<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>133-ThreadGroup API介绍之一</title>
      <link href="/2019/12/07/133-thread-group-api1/"/>
      <url>/2019/12/07/133-thread-group-api1/</url>
      
        <content type="html"><![CDATA[<p>通过<code>new Thread()</code>创建线程的时候，如果没有指定ThreadGroup，则默认使用创建线程的ThreadGroup。</p><p>ThreadGroup和Thread关系：</p><blockquote><p>线程组代表一组线程。此外，线程组还可以包括其他线程组。线程组形成一棵树，其中除初始线程组之外的每个线程组都有一个父级。</p><p>允许线程访问有关其自己的线程<em>组的信息，但不允许访问有关其线程组的</em>父线程组或任何其他线程组的信息。（测试结果：<strong>可以访问父线程组的只读信息，也可以访问其他线程组的只读信息</strong>）</p></blockquote><p>main是一个线程，其ThreadGroup为main</p><pre><code class="java">public static void main(String[] args) {    Thread.currentThread().getName()// main    Thread.currentThread().getThreadGroup().getName()// main}</code></pre><p>main线程的优先级为10（最高），StackSize也是比手动创建的线程大。</p><p>线程组的创建：</p><ol><li><p>use the name</p><blockquote><p><code>ThreadGroup(String name)</code></p></blockquote><pre><code class="java">ThreadGroup tg1 = new ThreadGroup(&quot;TG1&quot;);Thread t1 = new Thread(tg1, () -&gt; {    while (true) {        try {            ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();            System.out.println(threadGroup.getName());// TG1            // 访问线程父ThreadGroup的信息            System.out.println(threadGroup.getParent().getName());// main            System.out.println(threadGroup.getParent().activeCount());// 3            System.out.println(threadGroup.getParent().isDaemon());// false            // sleep不会放弃CPU执行权            Thread.sleep(10_000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}, &quot;T1&quot;);t1.start();System.out.println(&quot;t1&#39;s thread group name = &quot;+t1.getThreadGroup().getName());// TG1</code></pre></li><li><p>use the parent and group name</p><blockquote><p><code>ThreadGroup(ThreadGroup parent, String name)</code></p></blockquote><pre><code class="java">ThreadGroup tg2 = new ThreadGroup(tg1, &quot;TG2&quot;);System.out.println(&quot;tg2&#39;s name = &quot;+tg2.getName());System.out.println(&quot;tg2&#39;s parent name = &quot;+tg2.getParent().getName());</code></pre></li></ol><p>TG3与TG1为同一个父ThreadGroup-main，测试TG3能否访问TG1的一些信息</p><pre><code class="java">ThreadGroup tg3 = new ThreadGroup(&quot;TG3&quot;);Thread t3 = new Thread(tg3, () -&gt; {    System.out.println(&quot;&gt;&gt;&gt;&gt;&quot; + t1.getName());// TG1    Thread[] threads = new Thread[tg1.activeCount()];    tg1.enumerate(threads);    Stream.of(threads).forEach(System.out::println);// Thread[T1,5,TG1]}, &quot;T3&quot;);t3.start();</code></pre><p>测试结果：<strong>可以访问其他线程组的信息</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>132-如何捕获线程运行期间的异常</title>
      <link href="/2019/12/07/132-catch-thread-exception/"/>
      <url>/2019/12/07/132-catch-thread-exception/</url>
      
        <content type="html"><![CDATA[<p>捕获线程异常</p><pre><code class="java">public static void main(String[] args) {    Thread t = new Thread(() -&gt; {        try {            Thread.sleep(1_000L);            int result = 10 / 0;            System.out.println(&quot;result = &quot; + result);        } catch (InterruptedException e) {            e.printStackTrace();        }    });    t.start();    t.setUncaughtExceptionHandler((thread, e) -&gt; {        System.out.println(e);        System.out.println(thread.getName());    });}</code></pre><p>StackTrace。方法调用。</p><pre><code class="java">public class ThreadException {    public static void main(String[] args) {        new Test1().test();    }}</code></pre><pre><code class="java">public class Test1 {    private Test2 test2 = new Test2();    public void test() {        test2.test();    }}</code></pre><pre><code class="java">public class Test2 {    public void test() {        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();        Stream.of(stackTrace)                .filter(e -&gt; !e.isNativeMethod())                .forEach(e -&gt;                        Optional.of(e.getClassName() + &quot;.&quot; + e.getMethodName() + &quot;:&quot; + e.getLineNumber()).ifPresent(System.out::println)                );    }}</code></pre><Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/><Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131-如何给你的应用程序注入钩子程序，Linux下演示</title>
      <link href="/2019/12/07/131-hook-processor/"/>
      <url>/2019/12/07/131-hook-processor/</url>
      
        <content type="html"><![CDATA[<p>如何获取线程的Exception？</p><blockquote><p>我知道线程的<code>void run()</code>方法是不可以抛出异常的，如果线程死掉，调用者是不知道线程执行情况的。</p><p>如果没有捕获异常，在错误的情况下只是输出堆栈信息，调用者并不知道是什么异常导致。</p></blockquote><p>线程的栈可以跟踪到方法调用。</p><p>JDK模式：client、server</p><p>server模式会进行运行时优化。JIT，即Just In Time</p><p>Runtime可以调用一些系统命令</p><pre><code class="java">public class ExitCapture {    public static void main(String[] args) {        while (true) {            Thread.sleep(1_000L);            System.out.println(&quot;I am working...&quot;);        }    }}</code></pre><pre><code class="shell">javac ExitCapture.javajava -cp . ExitCapturenohup java -cp . ExitCapture &amp;tail -f nohup.outkill 2181</code></pre><p>如果程序占用了很多数据库连接或者是文件句柄，想要在kill程序的时候一并进行释放，或者在异常退出程序的情况下通知一下调用者程序知道它出错了，并不是调用者时时地去监控程序。（程序主动告诉，并不是被动发现）</p><pre><code class="java">public class ExitCapture {    public static void main(String[] args) {        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {            System.out.println(&quot;The application will be exit.&quot;);            notifyAndRelease();        }));        int i = 0;        while (true) {            Thread.sleep(1_000L);            System.out.println(&quot;I am working...&quot;);            i++;            if (i &gt; 20) {                throw new RuntimeException(&quot;Error&quot;);            }        }    }    private static void notifyAndRelease() {        System.out.println(&quot;notify to the admin.&quot;);        Thread.sleep(1_000L);        System.out.println(&quot;Will release resource(socket, file, connection.)&quot;);        Thread.sleep(1_000L);        System.out.println(&quot;Release and Notify Done!&quot;);    }}</code></pre><p>运行程序，在i&gt;20时程序抛出异常，被捕获到并执行<code>notifyAndRelease()</code>；通过<code>kill</code>杀死程序也可以被捕获并执行<code>notifyAndRelease()</code>，但是使用<code>kill -9</code>强制杀死程序则不会执行<code>notifyAndRelease()</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTF-8带BOM转UTF-8无BOM格式编码</title>
      <link href="/2019/12/04/utf8bom-to-utf8/"/>
      <url>/2019/12/04/utf8bom-to-utf8/</url>
      
        <content type="html"><![CDATA[<ol><li><p>保存的时候去掉BOM头（notepad++支持<strong>以UTF-8无BOM格式编码</strong>）</p></li><li><p>程序做兼容，兼容代码如下：</p><pre><code class="java">public static String deleteUTF8Bom(String fileStr) {    byte[] UTF8_BOM_BYTES = new byte[]{(byte) 0xEF, (byte) 0xBB, (byte) 0xBF};    byte[] bytes = fileStr.getBytes();    if (bytes[0] == UTF8_BOM_BYTES[0]            &amp;&amp; bytes[1] == UTF8_BOM_BYTES[1]            &amp;&amp; bytes[2] == UTF8_BOM_BYTES[2]) {        return new String(bytes, 3, bytes.length - 3);    }    return fileStr;}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中DO、BO、DTO、VO、AO、PO</title>
      <link href="/2019/12/02/code-rules-object-model/"/>
      <url>/2019/12/02/code-rules-object-model/</url>
      
        <content type="html"><![CDATA[<h2 id="1-DO（Domain-Object）领域对象"><a href="#1-DO（Domain-Object）领域对象" class="headerlink" title="1.DO（Domain Object）领域对象"></a>1.DO（Domain Object）领域对象</h2><p>​        就是从现实世界中抽象出来的有形或无形的业务实体。一般<strong>和数据中的表结构对应</strong>。</p><h2 id="2-BO-Business-Object-业务对象"><a href="#2-BO-Business-Object-业务对象" class="headerlink" title="2.BO(Business Object) 业务对象"></a>2.BO(Business Object) 业务对象</h2><p>​        主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 </p><p>​        比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。</p><h2 id="3-DTO（Data-Transfer-Object）数据传输对象"><a href="#3-DTO（Data-Transfer-Object）数据传输对象" class="headerlink" title="3.DTO（Data Transfer Object）数据传输对象"></a>3.DTO（Data Transfer Object）数据传输对象</h2><blockquote><p> 这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，</p></blockquote><p>​        但在这里，泛指用于展示层(Controller)与服务层(Service)之间的数据传输对象</p><p>​        DTO 的单向的？ 还是相互的？</p><h2 id="4-VO-View-Object-值对象"><a href="#4-VO-View-Object-值对象" class="headerlink" title="4.VO(View Object) 值对象"></a>4.VO(View Object) 值对象</h2><p>​        视图对象，用于展示层。它的作用是把某个指定页面（或组件）的所有数据封装起来，是Controller层返回给前端（浏览器端）的数据的类型</p><h2 id="5-PO-Persistant-Object-持久对象"><a href="#5-PO-Persistant-Object-持久对象" class="headerlink" title="5.PO(Persistant Object) 持久对象"></a>5.PO(Persistant Object) 持久对象</h2><p>​        在 O/R 映射的时候出现的概念，如果没有 O/R 映射，没有这个概念存在了。通常对应数据模型 ( 数据库 )，本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的 Java 对象。最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。</p><h2 id="6-TO-Transfer-Object-，数据传输对象"><a href="#6-TO-Transfer-Object-，数据传输对象" class="headerlink" title="6.TO(Transfer Object) ，数据传输对象"></a>6.TO(Transfer Object) ，数据传输对象</h2><p>​        在应用程序不同 tie( 关系 ) 之间传输的对象</p><h2 id="7-POJO-Plain-Ordinary-Java-Object-简单无规则-java-对象"><a href="#7-POJO-Plain-Ordinary-Java-Object-简单无规则-java-对象" class="headerlink" title="7.POJO(Plain Ordinary Java Object) 简单无规则 java 对象"></a>7.POJO(Plain Ordinary Java Object) 简单无规则 java 对象</h2><p>​        纯的传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。我的理解就是最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法。</p><h2 id="8-DAO-Data-Access-Object-数据访问对象"><a href="#8-DAO-Data-Access-Object-数据访问对象" class="headerlink" title="8.DAO(Data Access Object) 数据访问对象"></a>8.DAO(Data Access Object) 数据访问对象</h2><p>​        是一个 SUN 的一个标准 J2EE 设计模式， 这个模式中有个接口就是 DAO ，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作</p><p><strong>分层领域模型规约：</strong></p><ul><li>DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。</li><li>AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。</li><li>Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴代码规范考试试题</title>
      <link href="/2019/12/02/alibaba-p3c-exam/"/>
      <url>/2019/12/02/alibaba-p3c-exam/</url>
      
        <content type="html"><![CDATA[<ol><li><p>【多选 】关于索引的设计和使用，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.若查询条件中不包含索引的最左列，则无法使用索引。</li><li><input checked="" disabled="" type="checkbox"> B.对于范围查询，只能利用索引的最左列。</li><li><input checked="" disabled="" type="checkbox"> C.对于<code>order by A</code>或<code>group by A</code>语句，在<code>A</code>上建立索引，可以避免排序。</li><li><input checked="" disabled="" type="checkbox"> D.对于多列排序，需要所有列排序方向一致，才能利用索引。</li></ul></li><li><p>【多选 】关于explain执行计划，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>type</code>列显示了连接使用了何种类型，从最好到最差的连接类型为：<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>range</code>，<code>index</code>，<code>ALL</code>.</li><li><input checked="" disabled="" type="checkbox"> B.<code>possible_keys</code>显示可能在这张表中的索引，如果为空，表示没有可能的索引。</li><li><input checked="" disabled="" type="checkbox"> C.<code>key</code>列表示实际使用的索引。</li><li><input checked="" disabled="" type="checkbox"> D.<code>ref</code>列显示索引的哪一列被使用了。</li></ul></li><li><p>【多选 】关于数据库模糊检索的描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.绝对禁止左模糊。</li><li><input checked="" disabled="" type="checkbox"> B.绝对禁止全模糊。</li><li><input disabled="" type="checkbox"> C.绝对禁止右模糊。</li><li><input checked="" disabled="" type="checkbox"> D.全模糊或左模糊查询需求，优先使用搜索引擎。</li></ul></li><li><p>【多选 】数组使用<code>Arrays.asList</code>转化为集合，下列说法哪些正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>A.数组元素的修改，会影响到转化过来的集合。</strong></li><li><input disabled="" type="checkbox"> B.数组元素的修改，不会影响到转化过来的集合。</li><li><input checked="" disabled="" type="checkbox"> <strong>C.对于转换过来的集合，它的<code>add</code>/<code>remove</code>/<code>clear</code>方法会抛出：<code>UnsupportedOperationException</code>.</strong></li><li><input checked="" disabled="" type="checkbox"> D.<code>Arrays.asList</code>体现的是适配器模式，只是转换接口，后台的数据仍是数组。</li></ul></li><li><p>【多选 】关于捕获异常和抛异常，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.如果需要捕获不同类型异常，为了方便处理，可以使用<code>catch(Exception e){}</code>。</li><li><input checked="" disabled="" type="checkbox"> B.不要捕获异常后不处理，丢弃异常信息。</li><li><input checked="" disabled="" type="checkbox"> C.捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</li><li><input checked="" disabled="" type="checkbox"> D.异常定义时区分<code>unchecked</code>/<code>checked</code>异常，避免直接使用<code>RuntimeException</code>抛出。</li></ul></li><li><p>【单选】KV结构的集合，在处理null值的存储上有细微的区别，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> <p>A.<code>TreeMap</code>的key不可以为null</p></li><li><input disabled="" type="checkbox"> <p>B.<code>TreeMap</code>的key可以为null</p></li><li><input disabled="" type="checkbox"> <p>C.<code>ConcurrentHashMap</code>的key可以为null</p></li><li><input disabled="" type="checkbox"> <p>D.<code>ConcurrentHashMap</code>的value可以为null</p><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td><code>Hashtable</code></td><td>不允许为NULL</td><td>不允许为NULL</td><td>Dictionary</td><td>线程安全</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>不允许为NULL</td><td>不允许为NULL</td><td>AbstractMap</td><td>分段锁技术</td></tr><tr><td><code>TreeMap</code></td><td>不允许为NULL</td><td><em>允许为NULL</em></td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td><code>HashMap</code></td><td><em>允许为NULL</em></td><td><em>允许为NULL</em></td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table></li></ul></li><li><p>【多选】关于<code>Java</code>的接口描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.在接口类中的方法和属性使用<code>public</code>修饰符。</li><li><input checked="" disabled="" type="checkbox"> B.对于<code>Service</code>类，内部的实现类加<code>Imp</code>的后缀与接口区别。例如：<code>ProductServicelmpl</code>实现<code>ProductService</code>接口。</li><li><input checked="" disabled="" type="checkbox"> C.对于<code>Service</code>类，基于<code>SOA</code>的理念，是以接口方式暴露服务。</li><li><input checked="" disabled="" type="checkbox"> D.尽量不在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，而且是整个应用的基础常量。</li></ul></li><li><p>【多选】关于代码注释，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> <p>A.特殊注释标记，请注明标记人与标记时间。</p></li><li><input checked="" disabled="" type="checkbox"> <p>B.待办事宜（TODO）：（[标记人，标记时间，[预计处理时间]）</p></li><li><input disabled="" type="checkbox"> <p>C.在注释中用FIXME标记某代码虽然实现了功能，但是实现的方法有待商椎，希望将来能改进</p></li><li><input checked="" disabled="" type="checkbox"> <p>D.在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况 </p><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td>TODO</td><td>如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</td></tr><tr><td>FIXME</td><td>如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</td></tr><tr><td>XXX</td><td>如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</td></tr></tbody></table></li></ul></li><li><p>【多选】关于文件编码和格式的设定，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.IDE的<code>text file encoding</code>设置为<code>GBK</code>格式。</li><li><input checked="" disabled="" type="checkbox"> B.IDE的t<code>ext file encoding</code>设置为<code>UTF-8</code>格式。</li><li><input checked="" disabled="" type="checkbox"> C.IDE中文件的换行符使用<code>Unix</code>格式。</li><li><input disabled="" type="checkbox"> D.IDE中文件的换行符使用<code>Windows</code>格式。</li></ul></li><li><p>【多选】在《阿里巴巴Java开发手册》中，提到不要对单元测试存在哪些误解？</p><ul><li><input checked="" disabled="" type="checkbox"> A.那是测试同学干的事情。</li><li><input checked="" disabled="" type="checkbox"> B.单元测试代码是多余的。</li><li><input checked="" disabled="" type="checkbox"> C.单元测试代码不需要维护。</li><li><input checked="" disabled="" type="checkbox"> D.单元测试与线上故障没有辩证关系。</li></ul></li><li><p>【多选】对于索引<code>(a，b，c)</code>，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.查询语句<code>where a between 5 and 10</code>可以使用该索引。</li><li><input checked="" disabled="" type="checkbox"> B.查询语句<code>where a = 5 and b between 5 and 10</code>可以使用该索引。</li><li><input checked="" disabled="" type="checkbox"> C.查询语句<code>where a in（5, 6, 7, 8, 9）and b = 5</code>可以使用该索引。</li><li><input disabled="" type="checkbox"> D.查询语句<code>where b = 5 and c = 10</code>可以使用该索引。</li></ul></li><li><p>【多选】以下关于命名规约内容说明，正确的是：</p><ul><li><input disabled="" type="checkbox"> A.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，并且使用<del>复数形式</del>，例口：应用工具类包名为<code>com.alibaba.mpp.utils</code></li><li><input checked="" disabled="" type="checkbox"> B.类名使用<code>UperCamelCase</code>，必须通从验峰形式，但以下情形例外：（领域模型的相关命名）<code>DO</code>/<code>DTO</code>/<code>VO</code>/<code>DA0</code>等。</li><li><input checked="" disabled="" type="checkbox"> C.抽象类命名使用<code>Abstrac</code>或<code>Base</code>开头；异常类命名使用<code>Exepion</code>结尾；测试类命名以它要测式的类的名称开始，以<code>Test</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> D.枚举类名建议带上<code>Enum</code>后缀，枚举成员名称需要全大写，单词间用下划线隔开。</li></ul></li><li><p>【多选】关于类命名，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.抽象类命名使用<code>Abstract</code>或<code>Base</code>开头。</li><li><input checked="" disabled="" type="checkbox"> B.异常类命名使用<code>Excepion</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> C.测法类命名以它要测试的类的名称开始，以<code>Test</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> D.如果使用到了设计模式，建议在类名中体现出具体模式。例如代理模式的类命名：<code>LoginProxy</code>；观察者模式命名：<code>ResourceObserver</code>.</li></ul></li><li><p>【多选】下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</li><li><input disabled="" type="checkbox"> B.永久弃用的代码段注释掉即可，即不用加任何注释。</li><li><input checked="" disabled="" type="checkbox"> C.对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠（///）来说明注释掉代码的理由。</li><li><input checked="" disabled="" type="checkbox"> D.不要在视图模板中加入任何复杂的逻辑。</li></ul></li><li><p>【多选】关于日志级别的使用，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.<code>info</code>日志尽可能多输出，方便开发人员排查问题。</li><li><input checked="" disabled="" type="checkbox"> B.如果使用<code>warn</code>来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</li><li><input checked="" disabled="" type="checkbox"> C.生产环境禁止输出<code>debug</code>日志。</li><li><input checked="" disabled="" type="checkbox"> D.<code>error</code>级别只记录系统逻辑出错、异常或者重要的错误信息。</li></ul></li><li><p>【多选】以下关于格式规约的说法，正确的有哪些：</p><ul><li><input checked="" disabled="" type="checkbox"> A.左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格，如：<code>if (flag == 1) {System.out.println(&quot;world&quot;);}</code></li><li><input checked="" disabled="" type="checkbox"> B.<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/<code>do</code>等保留字与左右括号之间都必须加空格。</li><li><input disabled="" type="checkbox"> C.<code>while</code>这个保留字比较特殊，使用时左右括号之间可以不用加空格，例如：<code>while(true){...}</code></li><li><input checked="" disabled="" type="checkbox"> D.任何运算符左右必须加一个空格，运算符包括赋值运算符<code>=</code>、逻辑运算符<code>&amp;&amp;</code>、加减乘除符号、三目运行符等。</li></ul></li><li><p>【多选】关于用日志记录异常信息，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.日志尽量记录案发现场信息和异常堆栈信息。</li><li><input checked="" disabled="" type="checkbox"> B.如果日志中输出<code>POJO</code>类，<code>POJO</code>类需要重写<code>toString()</code>方法，避免只输出<code>hashCode</code>.</li><li><input disabled="" type="checkbox"> C.不建议输出任何日志，因为日志记录消耗性能。</li><li><input disabled="" type="checkbox"> D.捕获异常后，一律抛给调用者去处理。</li></ul></li><li><p>【多选】关于工具类二方库已经提供的，尽量不要在本应用中编程实现，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>JSON</code>操作使用<code>fasijson</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>MD5</code>操作使用<code>commons-codec</code>，</li><li><input disabled="" type="checkbox"> C.<code>ArrayUtils</code>、<code>NumberUtils</code>、<code>DateFormatUtils</code>、<code>DateUtils</code>等优先使用<code>org apache.commons.lang</code>包。</li><li><input checked="" disabled="" type="checkbox"> D.<code>CollectionUtils</code>优先使用<code>org.apache.commons.collections4</code>包。</li></ul></li><li><p>【多选】关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。</li><li><input disabled="" type="checkbox"> B.魔法值是指程序中随意定义并赋值的变量值，如果代码编写者明白变量值意义是可以任意使用的，例如在代码中写<code>if (status == 3) return error;</code>符合规范。</li><li><input checked="" disabled="" type="checkbox"> C.如果变量值仅在一个范围内变化推荐用<code>Enum</code>类。</li><li><input disabled="" type="checkbox"> D.在程序中，一律禁止使用枚举类型。</li></ul></li><li><p>【多选】下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</li><li><input checked="" disabled="" type="checkbox"> B.在<code>JDK8</code>中，针对统计时间等场景，推荐使用<code>Instant</code>类。</li><li><input checked="" disabled="" type="checkbox"> C.尽量不要在<code>VM</code>中加入变量声明、逻辑运算符，更不要在<code>VM</code>模板中加入任何复杂的逻辑。</li><li><input checked="" disabled="" type="checkbox"> D.后台输送给页面的变量必须加<code>$!{var}</code>——中间的感叹号。</li></ul></li><li><p>【多选】关于变量、方法名、包的命名，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>POJO</code>类中的任何布尔类型的变量，都不要加<code>is</code>，因为部分框架解析时有可能会出现序列化错误。</li><li><input checked="" disabled="" type="checkbox"> B.包名统一使用单数形式，如：<code>com.alibaba.mpp.util</code>。</li><li><input checked="" disabled="" type="checkbox"> C.中括号是数组类型的一部分，数组定义如下：<code>String[] args</code>；不要误写为<code>String args[]</code>;</li><li><input checked="" disabled="" type="checkbox"> D.<code>Service</code>/<code>DAO</code>层方法命名可以参考规约，例如：删除的方法推荐使用<code>remove</code>或<code>delete</code>做前缀。</li></ul></li><li><p>【多选】关于枚举类型，以下描述符合规范的是：</p><ul><li><input disabled="" type="checkbox"> A.只要是常量，就使用权举值。</li><li><input checked="" disabled="" type="checkbox"> B.如果变量值在一个范围内变化，而且还带有名称之外的延伸属性，必须使用<code>Enum</code>类，如：<code>pubic enum MonthEnum{ JANUARY(1), FEBRUARY(2), MARCH(3), APRIL(4), …, DECEMBER(12);}</code>。</li><li><input checked="" disabled="" type="checkbox"> C.枚举名命名建议带上<code>Enum</code>，枚举成员名称需要全大写，单词用<code>_</code>分割。</li><li><input disabled="" type="checkbox"> D.定义星期一至星期日这种范围固定的信息，不推荐使用枚举类型。</li></ul></li><li><p>【多选】关于使用<code>iBATIS</code>操作数据，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.如果表中字段和<code>DO</code>中的字段名完全一致，可直接用<code>DO</code>作为<code>resultClass</code>。</li><li><input disabled="" type="checkbox"> B.<code>iBATIS</code>中自带了<code>queryForList(String statementName, int start, int size)</code>的分页接口，可直接使用，无需再自行封装。</li><li><input checked="" disabled="" type="checkbox"> C.不要定义大而全的数据更新接口，对整个<code>DO</code>进行更新。必须按需更新。</li><li><input checked="" disabled="" type="checkbox"> D.<code>sqlmap</code>中写<code>update</code>语句时，必须包含对记录中<code>gmt_modified</code>字段的更新。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，以下哪些字段属于表的必备字段：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>id</code></li><li><input checked="" disabled="" type="checkbox"> B.<code>gmt_modified</code></li><li><input disabled="" type="checkbox"> C.<code>parent id</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>gmt_create</code></li></ul></li><li><p>【多选】防止<code>NPE</code>，是程序员的基本修养，对于可能产生<code>NPE</code>的场景，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.数据库的查询结果可能为<code>null</code></li><li><input disabled="" type="checkbox"> B.集合只需要判断<code>isNotEmpty</code>，对取出的数据元素不需要判断是否为<code>null</code></li><li><input checked="" disabled="" type="checkbox"> C.远程调用返回对象，一律要求进行<code>NPE</code>判断。</li><li><input checked="" disabled="" type="checkbox"> D.对于<code>Session</code>中获取的数据，建议<code>NPE</code>检查，避免空指针。</li></ul></li><li><p>【多选】<code>Hashtable</code>，<code>HashlMap</code>，<code>ConcurrentHashMap</code>都是Map的实现类，它们在处理mul值的存储上有细微的区别，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Hashtable</code>的<code>KV</code>都不可以为<code>null</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>HashlMap</code>的<code>KV</code>都可以为<code>null</code>。</li><li><input disabled="" type="checkbox"> C.<code>HashMap</code>的<code>K</code>不可以为<code>null</code>，<code>V</code>可以为<code>null</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>ConcurentHashlMap</code>的<code>KV</code>都不可以为<code>null</code></li></ul></li><li><p>【多选】关于数据库是与否概念的列的命名方式，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.对于是与否概念的列名，必须使用<code>can_abc</code>来表示。</li><li><input checked="" disabled="" type="checkbox"> B.对于是与否概念的列名，必须使用<code>is_abc</code>来表示。</li><li><input disabled="" type="checkbox"> C.数据类型是<code>varchar(1)</code>（<code>Y</code>表示是，<code>N</code>表示否）。</li><li><input checked="" disabled="" type="checkbox"> D.数据类型是<code>unsigned tiny int</code>.（<code>1</code>表示是，<code>0</code>表示否）。</li></ul></li><li><p>【多选】关于<code>count</code>相关的使用，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.不要使用<code>count(列名)</code>或<code>count(常量)</code>来替代<code>count(*)</code>。</li><li><input disabled="" type="checkbox"> B.<code>count(列名)</code>会统计值为<code>NULL</code>的行，而<code>count(*)</code>不会统计。</li><li><input checked="" disabled="" type="checkbox"> C.当某一列的值全是<code>NULL</code>时，<code>count(列名)</code>返回0。</li><li><input checked="" disabled="" type="checkbox"> D.在程序代码中写分页查询逻辑时，若<code>count</code>为<code>0</code>应直接返回，以避免执行后面的分页语句。</li></ul></li><li><p>【多选】关于二方库依赖的解析命令，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>mvn dependency:resolve</code>打印出已仲裁依赖的列表。</li><li><input checked="" disabled="" type="checkbox"> B.<code>mvn dependency.tree</code>打印工程整个的依赖树结构。</li><li><input checked="" disabled="" type="checkbox"> C.<code>mvn dependency:tree -Dverbose -Dincludes=commons-lang</code>打印出与<code>commons-lang</code>相关的详细依赖。</li><li><input disabled="" type="checkbox"> D.<code>mvn clean install</code>打印工程整个的依赖树结构，并部署到本地仓库中。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，数据库的表设计允许适当沉余，以提升SQL查询的性能，避免表的关联查询，下列哪些字段<strong>不允许沉余</strong>：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>text</code>类型的字段。</li><li><input disabled="" type="checkbox"> B.基本固定不变的类目名称。</li><li><input checked="" disabled="" type="checkbox"> C.<code>varchar(2500)</code>的段。</li><li><input checked="" disabled="" type="checkbox"> D.需要频繁修改的字段。</li></ul></li><li><p>【多选】为了更方便地进行单元测试，被测试的业务代码应避免以下哪些情况？</p><ul><li><input checked="" disabled="" type="checkbox"> A.构造方法中做的事情过多。</li><li><input checked="" disabled="" type="checkbox"> B.存在过多的全局变量和静态方法。</li><li><input checked="" disabled="" type="checkbox"> C.存在过多的外部依赖。</li><li><input checked="" disabled="" type="checkbox"> D.存在过多的条件语句。</li></ul></li><li><p>【多选】关于方法的返回值是否可以为null，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.方法的返回值可以为null，如果是集合，必须返回空集合。</li><li><input checked="" disabled="" type="checkbox"> B.方法的返回值可以为null，不强制返回空集合，或者空对象等。</li><li><input checked="" disabled="" type="checkbox"> C.方法实现者必须添加注释，充分说明什么情况下会返回null值。</li><li><input checked="" disabled="" type="checkbox"> D.防止NPE是调用者的责任。</li></ul></li><li><p>【多选】关于索引效率，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.使用索引的效率一定高于全表扫描的效率。</li><li><input disabled="" type="checkbox"> B.关于<code>explain</code>的结果，<code>type=index</code>的索引效率好于<code>type=ref</code>。</li><li><input checked="" disabled="" type="checkbox"> C.SQL查询条件<code>where a like &#39;%阿里%&#39;</code>，不会走索引。</li><li><input checked="" disabled="" type="checkbox"> D.SQL查询条件<code>where a like &#39;阿里%&#39;</code>，a列创建了索引，一般会使用索引进行检索。</li></ul></li><li><p>【多选】关于Integer值的比较，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Integer a = 3; Integer b = 3;</code>那么条件表达式<code>(a==b)</code>返回的结果是<code>true</code>。</li><li><input disabled="" type="checkbox"> B.<code>Integer a = 3; Integer b = 3;</code>那么条件表达式<code>(a==b)</code>返回的结果是<code>false</code>。</li><li><input disabled="" type="checkbox"> C.<code>Integer a = 273; Integer b = 273;</code>那么条件表达式<code>(a==b)</code>返回的结果是<code>true</code>。</li><li><input checked="" disabled="" type="checkbox"> D.<code>Integer a = 273; Integer b = 273;</code>那么条件表达式(a==b)返回的结果是<code>false</code>。</li></ul></li><li><p>【单选】关于测试代码的覆盖率，下列哪些说法是正确的？</p><ul><li><input disabled="" type="checkbox"> A.路径覆盖是最强覆盖，符合路径覆盖且测试全部通过，程序绝对没有问题。</li><li><input checked="" disabled="" type="checkbox"> B.语句覆盖度是最弱的覆盖度量方式。</li><li><input disabled="" type="checkbox"> C.分支覆盖与条件覆盖其实是一回事。</li><li><input disabled="" type="checkbox"> D.判定条件覆盖与路径覆盖其实是一回事。</li></ul></li><li><p>【多选】关于Java的方法使用，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Object#equals</code>方法容易抛空指针，使用常量或确定有值的对象来调用<code>.equals()</code>方法。</li><li><input checked="" disabled="" type="checkbox"> B.所有的相同类型的包装类对象之间值的比较，全部使用<code>.equals()</code>方法比较。</li><li><input disabled="" type="checkbox"> C.<code>DO / VO</code>等领域模型类不需要覆写<code>Object#toString()</code>方法，没啥用处。</li><li><input checked="" disabled="" type="checkbox"> D.慎用<code>Object#clone()</code>方法来拷贝对象。</li></ul></li><li><p>【多选】通过集合<code>A.subList()</code>获取子集合B，下列说法哪些是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.返回的集合B没有实现<code>Serializable</code>接口，不能被序列化，所以不能应用于<code>RPC</code>场景。</li><li><input checked="" disabled="" type="checkbox"> B.在B集合中添加某个元素，那么A集合也会添加进去此元素。</li><li><input disabled="" type="checkbox"> C.集合A中元素的修改不会影响到集合B的任何操作。</li><li><input checked="" disabled="" type="checkbox"> D.对A元素个数的修改，会导致集合B的遍历产生<code>ConcurrentModificationException</code>异常。</li></ul></li><li><p>【多选】对于索引的基本原理，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.索引的数据结构主要有<code>B-Tree</code>、<code>Hash</code>、<code>R-Tree</code>、<code>Full-Text</code>等。</li><li><input checked="" disabled="" type="checkbox"> B.从物理存储来看，主要分为聚集(clustered)和非聚集(non-clustered)索引。</li><li><input checked="" disabled="" type="checkbox"> C.MySQL的表是聚集索引组织表(index of table)。</li><li><input checked="" disabled="" type="checkbox"> D.聚簇索引的叶子节点存放的是数据，非聚簇索引的叶子节点存放的是非聚集索引的key和主键值。</li></ul></li><li><p>【单选】关于二方库升级，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.升级二方库只是改个版本号，不需要关联功能的回归。</li><li><input checked="" disabled="" type="checkbox"> B.升级二方库需要比对仲裁结果的差异，谨慎评估。</li><li><input disabled="" type="checkbox"> C.升级二方库，绝对不会影响到其它二方库的版本号。</li><li><input disabled="" type="checkbox"> D.只要此二方库负责人保证说不会有任何影响，即可大胆升级，直接发布上线。</li></ul></li><li><p>【多选】关于maven依赖、仲裁、规则，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>&lt;dependencies&gt;</code>的依赖会默认传递给子项目。</li><li><input disabled="" type="checkbox"> B.<code>&lt;dependencies&gt;</code>的依赖绝对不会传递给子项目。</li><li><input checked="" disabled="" type="checkbox"> C.在<code>&lt;dependencyManagement&gt;</code>中指定版本号。</li><li><input checked="" disabled="" type="checkbox"> D.避免在不同的子项目，声明同一个二方库的不同版本号。</li></ul></li><li><p>【多选】针对<code>TCP</code>协议，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.<code>TCP</code>链接主动关闭的一方，在完成四次挥手协议后，即会立即关闭并释放<code>socket</code>，</li><li><input disabled="" type="checkbox"> B.处于<code>time_wait</code>状态的<code>socket</code>，其实是已经关闭状态，当需要新建连接时，可以被马上复用。</li><li><input checked="" disabled="" type="checkbox"> C.当大量<code>socket</code>于<code>time_wait</code>状态时，会导致可用<code>socket</code>资源稀缺，从而导致服务器并发能力下降。</li><li><input checked="" disabled="" type="checkbox"> D.通过修改<code>/etc/sysctl.conf</code>配置文件，减小<code>time_wait</code>的超时时间，可以降低<code>time_wait</code>状态的<code>socket</code>数量，从而提升服务器并发能力。</li></ul></li><li><p>【多选】关于<code>try-catch</code>的使用方式，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.推荐用<code>try-catch</code>来做流程控制、条件控制。</li><li><input checked="" disabled="" type="checkbox"> B.捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</li><li><input disabled="" type="checkbox"> C.对大段代码进行<code>try-catch</code>，利用<code>Throwable</code>来捕捉，万无一失。</li><li><input checked="" disabled="" type="checkbox"> D.对大段代码进行<code>try-catch</code>，这是不负责任的表现，分清稳定代码和非稳定代码，对非稳定的代码做对应的异常处理。</li></ul></li><li><p>【多选】关于系统安全，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A非<code>SEO URL</code>必须配置为禁止爬虫访问。</li><li><input checked="" disabled="" type="checkbox"> B.用户生成内容的场景，如发帖评论等，必须实现防刷。</li><li><input checked="" disabled="" type="checkbox"> C.使用平台资源，比如短信、邮件等功能，避免被滥刷资损，同时防止对用户造成骚扰。</li><li><input checked="" disabled="" type="checkbox"> D.文本内容必须进行违禁词过滤。</li></ul></li><li><p>【多选】关于并发处理，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li><li><input checked="" disabled="" type="checkbox"> B.同步处理时，能锁部分代码区块的情况下不要锁整个方法；高并发时，同步调用应该考虑到性能损耗。</li><li><input checked="" disabled="" type="checkbox"> C.创建线程或线程池时，推荐给线程指定一个有意义的名称，方便出错时回溯。</li><li><input disabled="" type="checkbox"> D.推荐使用<code>Executors.newFixedThreadPool(int x)</code>生成指定大小的线程池。</li></ul></li><li><p>【单选】在定义<code>DO/DTO/V0/</code>等<code>POJO</code>类时，对属性默认值的设定，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.String类型的默认值设定为空字符串。</li><li><input disabled="" type="checkbox"> B.Date类型的默认值设定为<code>new Date()</code>。</li><li><input disabled="" type="checkbox"> C.集合类型的默认值设定为<code>Collections.EMPTY_LIST</code>。</li><li><input checked="" disabled="" type="checkbox"> D.不要设定任何属性默认值。</li></ul></li><li><p>【单选】集合在遍历过程中，有时需要对符合一定条件的元素进行删除，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.在<code>foreach</code>循环里进行元素的<code>remove</code>操作。</li><li><input checked="" disabled="" type="checkbox"> <strong>B.使用<code>Iterator</code>方式，如果有并发，需要对<code>iterator</code>对象加锁。</strong></li><li><input disabled="" type="checkbox"> C.<code>iterator</code>进行元素的删除操作，绝对是线程安全的。</li><li><input disabled="" type="checkbox"> D.Java无法实现在遍历时，进行册删除元素操作。</li></ul></li><li><p>【多选】关于二方库的<code>snapshot</code>与<code>release</code>的区别，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>snapshot</code>在本地编译时，都会到中央仓库下载最新的二方库。</li><li><input checked="" disabled="" type="checkbox"> B.<code>release</code>在本地编译时，如果已经存在相同的版本号，即使中央仓库有最新相同版本的二方库也不会拉取。</li><li><input disabled="" type="checkbox"> C.应用使用了A的<code>release</code>版本二方库，A依赖了B的<code>snapshot</code>二方库，应用本地编译时，并不会拉取B最新的<code>snapsho</code>二方库。</li><li><input checked="" disabled="" type="checkbox"> D.应用发布尽量使用<code>release</code>版本的二方库，此举是为了保证发布的幂等性。</li></ul></li><li><p>【多选】关于多线程并行处理定时任务的情况，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.推荐使用<code>Timer</code>方式处理。</li><li><input checked="" disabled="" type="checkbox"> B.推荐使用<code>ScheduledExecutorService</code>方式处理。</li><li><input checked="" disabled="" type="checkbox"> C.<code>Timer</code>运行多个<code>TimeTask</code>时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行。</li><li><input checked="" disabled="" type="checkbox"> D.<code>ScheduledExecutorService</code>并发运行多个定时任务时，其中某线程抛出异常，不会影响到其它线程的继续运行。</li></ul></li><li><p>【多选】关于构造方法，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在<code>init</code>方法中。</li><li><input checked="" disabled="" type="checkbox"> B.当一个类有多个构造方法，应该按顺序放置在一起，便于阅读。</li><li><input checked="" disabled="" type="checkbox"> C.如果不允许外部直接通过<code>new</code>来创建对象，那么构造方法必须是<code>private</code>。</li><li><input disabled="" type="checkbox"> D.构造方法中可以有业务实现代码，如对成员变量的简单运算、业务判断等。</li></ul></li><li><p>【多选】关于注释，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.方法内部单行注释，在被注释语句上方另起一行，使用<code>//</code>注释。</li><li><input checked="" disabled="" type="checkbox"> B.所有的类都必须添加创建者信息。</li><li><input checked="" disabled="" type="checkbox"> C.相比较使用“半吊子”英文来注释，用中文注释把问题说清楚更合适。</li><li><input checked="" disabled="" type="checkbox"> D.所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li></ul></li><li><p>【多选】关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.跨应用共享常量：放置在二方库中，通常是<code>client.jar</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> B.应用内共享常量：通常放置在一方库的<code>modules</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> C.子工程内部共享常量：即在当前子工程的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> D.类内常量：直接在类内部<code>private static final</code>定义。</li></ul></li><li><p>【多选】关于基本数据类型与包装数据类型的使用标准，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.所有的<code>POJO</code>类属性必须使用包装数据类型。</li><li><input checked="" disabled="" type="checkbox"> B.<code>RPC</code>方法的返回值和参数必须使用包装数据类型。</li><li><input disabled="" type="checkbox"> C.因为JAVA的自动装箱与拆箱机制，不需要根据场景来区分数据类型。</li><li><input checked="" disabled="" type="checkbox"> D.所有的局部变量推荐使用基本数据类型。</li></ul></li><li><p>【多选】关于线程池管理线程的好处，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.能够减少在创建和销毁线程上所花的时间以及系统资源的开销。</li><li><input disabled="" type="checkbox"> B.使用线程池一定能避免<code>OOM</code>问题。</li><li><input checked="" disabled="" type="checkbox"> C.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li><li><input disabled="" type="checkbox"> D.线程池能够根据资源等待情况，自动调整线程优先级并解决死锁问题。</li></ul></li><li><p>【多选】关于生产环境的日志文件，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.应用的日志文件统一保存在：<code>/home/admin/应用名/logs/路径下</code>，便于统一维护以及认知统一。</li><li><input checked="" disabled="" type="checkbox"> B.日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。</li><li><input checked="" disabled="" type="checkbox"> C.避免重复打印日志，浪费磁盘空间，务必在<code>log4j.xml</code>中设置<code>additivity=false</code>。</li><li><input checked="" disabled="" type="checkbox"> D.错误日志和业务日志尽量分开存放。</li></ul></li><li><p>【多选】关于二方库的依赖处理，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.依赖于一个二方库群时，必须定义一个统一版本变量，避免各子二方库版本号不一致。</li><li><input disabled="" type="checkbox"> B.可以允许子项目的<code>pom</code>依赖中出现相同的<code>Groupld</code>，相同的<code>Artifactld</code>，但是不同的<code>Version</code>。</li><li><input checked="" disabled="" type="checkbox"> C.所有<code>pom</code>文件中的依赖声明放在<code>&lt;dependencies&gt;</code>语句块中，所有版本仲裁放在<code>&lt;dependencyManagemet&gt;</code>语句块中。</li><li><input checked="" disabled="" type="checkbox"> D.线上应用不要依赖<code>SNAPSHOT</code>版本（安全包除外）。</li></ul></li><li><p>【多选】关于数据库中<code>NULL</code>的描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.<code>NULL=NULL</code>的返回结果为<code>true</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>NULL</code>与任何值的比较结果都为<code>NULL</code>。</li><li><input disabled="" type="checkbox"> C.<code>NULL&lt;&gt;1</code>的返回结果为<code>true</code>。</li><li><input checked="" disabled="" type="checkbox"> D.当某一列的值全是NULL时，<code>sum(col)</code>的返回结果为<code>NULL</code>。</li></ul></li><li><p>【多选】关于表字段和索引，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.表字段注释，如果修改字段含义或对字段表示的状态追加时，需要及时更新。</li><li><input checked="" disabled="" type="checkbox"> B.合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</li><li><input disabled="" type="checkbox"> C.针对表的每个字段都增加索引，加快查询速度。</li><li><input checked="" disabled="" type="checkbox"> D.字段的区分度越高，索引的查找速度越快。</li></ul></li><li><p>【多选】关于参数校验，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.批量处理接口必须做好接口入参保护。</li><li><input checked="" disabled="" type="checkbox"> B.需要极高稳定性和可用性的方法需要对参数进行校验。</li><li><input checked="" disabled="" type="checkbox"> C.底层的方法，在上层调用中参数多半已经被校验过，可以考虑不校验。</li><li><input checked="" disabled="" type="checkbox"> D.对外提供的开放接口，都要进行参数检验。</li></ul></li><li><p>【多选】关于二方库GroupID和ArtifactID格式，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.GroupID格式为：com.{公司/子公司}.业务线[.子业务]。</li><li><input disabled="" type="checkbox"> B.GroupID格式为：com.{公司/子公司}.业务线.子业务线.子模块。</li><li><input disabled="" type="checkbox"> C.ArtifactlD格式为：产品线名_模块名或者产品线.模块名。</li><li><input checked="" disabled="" type="checkbox"> D.ArtifactID格式为：产品线名-模块名。</li></ul></li><li><p>【多选】关于应用与数据库之间的操作，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.对外提供一个大而全的接口进行POJO的update更新，这样比较省事，省代码。</li><li><input checked="" disabled="" type="checkbox"> B.使用事务回滚的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li><li><input disabled="" type="checkbox"> C.应用服务器与数据库之间是短连接。</li><li><input checked="" disabled="" type="checkbox"> D.应用服务器与数据库之间是长连接。</li></ul></li><li><p>【多选】关于MySQL性能优化的描述，下列哪些说法是正确的</p><ul><li><input checked="" disabled="" type="checkbox"> A.主键查询优先于二级索引查询。</li><li><input checked="" disabled="" type="checkbox"> B.表连接有一定的代价，故表连接数量越少越好。</li><li><input checked="" disabled="" type="checkbox"> C.一般情况下，二级索引扫描优先于全表扫描。</li><li><input checked="" disabled="" type="checkbox"> D.可以使用通过索引避免排序代价。</li></ul></li><li><p>【多选】关于<code>checked/unchecked exception</code>，下列哪些说法是正确的</p><ul><li><input disabled="" type="checkbox"> A.继承<code>java.lang.Error</code>的类属于<code>checked exception</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>checked</code>异常继承<code>java.lang.Exception</code>类。</li><li><input checked="" disabled="" type="checkbox"> C.<code>unchecked</code>异常继承<code>java.lang.RuntimeException</code>类。</li><li><input checked="" disabled="" type="checkbox"> D.<code>NullPointerException</code>、<code>llegalArgumentException</code>属于<code>unchecked exception</code>。</li></ul></li><li><p>【多选】关于领域模型命名，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.数据对象命名：<code>xxxDO</code>，<code>xxx</code>即为数据表名，例如：<code>ResellerAccountDO</code>。</li><li><input checked="" disabled="" type="checkbox"> B.数据传输对象：<code>xxxDTO</code>，<code>xxx</code>为业务领域相关的名称，例如<code>ProductDTO</code>。</li><li><input checked="" disabled="" type="checkbox"> C.展示层对象：<code>xxxVO</code>，<code>xxx</code>一般为网页名称，例如<code>RecommendProductVO</code>。</li><li><input disabled="" type="checkbox"> D.<code>POJO</code>是<code>DO</code>/<code>DTO</code>/<code>BO</code>/<code>VO</code>的统称，命名成<code>xxxPOJO</code>。</li></ul></li><li><p>【多选】以下关于命名规约内容说明，正确的是：</p><ul><li><input disabled="" type="checkbox"> A.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，并且使用复数形式，例如：应用工具类包名为<code>com.albaba.mpp.utils</code></li><li><input checked="" disabled="" type="checkbox"> B.类名使用<code>UperCamelCase</code>，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）<code>DO</code>/<code>DTO</code>/<code>VO</code>/<code>DA0</code>等。</li><li><input checked="" disabled="" type="checkbox"> C.抽象类命名使用<code>Abstract</code>域<code>Base</code>开头；异常类命名使用<code>Exception</code>结尾；测试类命名以它要测试的类的名称开始，以<code>Test</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> D.枚举类名建议带上<code>Enum</code>后缀，枚举成员名称需要全大写，单词间用下划发隔开。</li></ul></li><li><p>【多选】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量，那么下列说法正确的是</p><ul><li><input checked="" disabled="" type="checkbox"> A.Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li><li><input checked="" disabled="" type="checkbox"> B.Correct，正确的输入，并得到预期的结果。</li><li><input checked="" disabled="" type="checkbox"> C.Design，与设计文档相结合，来编写单元测试。</li><li><input disabled="" type="checkbox"> D.Equal，单元测试环境必须与线上生产环境一致。「ERROR」</li></ul></li><li><p>【多选】在多线程并发读写的情况下，下列哪些处理方式能保证对象的线程安全：</p><ul><li><input disabled="" type="checkbox"> A.使用<code>volatile</code>关键字。「<code>volatile</code>解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题；但是如果多写，同样无法解决线程安全问题。」</li><li><input checked="" disabled="" type="checkbox"> B.使用<code>synchronized</code>关键字给对象的读写操作加锁。</li><li><input checked="" disabled="" type="checkbox"> C.如果是基本类型，推荐使用<code>java.util.concurent.atomic</code>包下面提供的线程安全的基本类型包装类，例如<code>Atomiclnteger</code>。</li><li><input checked="" disabled="" type="checkbox"> D.如果是集合，推荐使用<code>java.util.concurent</code>提供的并发集合类，例如：<code>ConcurrentHashMap</code>。</li></ul></li><li><p>【多选】关于接口使用抛异常还是返回错误码，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.向公司外提供的<code>http</code>/<code>api</code>接口，推荐使用<code>错误码</code>方式返回异常或者错误信息。</li><li><input checked="" disabled="" type="checkbox"> B.对于应用内部的方法调用，推荐使用<code>抛出异常</code>的方式处理异常或者错误信息。</li><li><input checked="" disabled="" type="checkbox"> C.跨应用的<code>RPC</code>调用，推荐使用将<code>错误码</code>和<code>错误简短信息</code>封装成<code>Result</code>的方式进行返回。</li><li><input checked="" disabled="" type="checkbox"> D.对外提供的接口，一定要保证逻辑健壮性：尽量避免空指针等技术类异常；对于业务类异常要做好错误码或者异常信息的封装。</li></ul></li><li><p>【多选】关于<code>join</code>的描述，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>join</code>的字段，数据类型须保持绝对一致。</li><li><input checked="" disabled="" type="checkbox"> B.<code>join</code>列必须有索引。</li><li><input checked="" disabled="" type="checkbox"> C.优先<code>where</code>过滤，其次再<code>join</code>关联。</li><li><input disabled="" type="checkbox"> D.只要满足业务需求和，<code>join</code>表的个数不受限制。</li></ul></li><li><p>【多选】关于参数有效性验证，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.防止<code>page size</code>过大导致内存溢出。</li><li><input checked="" disabled="" type="checkbox"> B.防止正则输入源串拒绝服务<code>ReDOS</code>。</li><li><input checked="" disabled="" type="checkbox"> C.防止任意重定向。</li><li><input checked="" disabled="" type="checkbox"> D.预防SQL注入。</li></ul></li><li><p>【单选】关于日志的打印，下列哪些写法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.<code>System.out(&quot;xxx&quot;+e.getMessage())</code>。</li><li><input disabled="" type="checkbox"> B.<code>System.err(&quot;xxx&quot;+e.getMessage())</code>。</li><li><input disabled="" type="checkbox"> C.<code>e.printStackTrace()</code>。</li><li><input checked="" disabled="" type="checkbox"> D.<code>logger.error(&quot;exception happens product info:&quot; + product.toString() + &quot;_&quot; + e.getMessage() e)</code>。</li></ul></li><li><p>【多选】关于异常的处理方式，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.为防止<code>obj</code>对象本身空指针异常，书写代码时应该注意加异常捕获处理，例1：<code>try{objmethod()} catcth(NullPointerException) {.…}</code>。</li><li><input checked="" disabled="" type="checkbox"> B.方法签名中，抛给调用者的关键字为<code>throws</code></li><li><input disabled="" type="checkbox"> C.方法内部，抛出异常实对象为<code>throws</code></li><li><input checked="" disabled="" type="checkbox"> D.自定义异常要做到“认知对等”，即：抛出者和接收者要保持对自定义异常的认知统一，接收方需要知道这种异常的含义和对应的处理方案。</li></ul></li><li><p>【单选】关于使用<code>explain</code>对数据库性能进行优化分析，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>SQL</code>性能优化的目标：至少要达到<code>range</code>级别，要求是<code>ref</code>级别，如果可以是<code>consts</code>最好。</li><li><input disabled="" type="checkbox"> B.<code>index</code>级别走的是扫描索引，所以速度会比<code>ref</code>快。</li><li><input disabled="" type="checkbox"> C.<code>range</code>级别是指对表进行范围索引。</li><li><input disabled="" type="checkbox"> D.<code>ref</code>级别是指使用主键或者唯一索引。</li></ul></li><li><p>【多选】关于异常处理，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>try</code>块放到了事务代码中，<code>catch</code>异常后，如果需要回滚事务，必须要手动回滚事务。</li><li><input checked="" disabled="" type="checkbox"> B.在<code>fnally</code>块必须对文件流进行关闭。</li><li><input checked="" disabled="" type="checkbox"> C.不能在<code>finaly</code>块使用<code>return</code>，<code>finally</code>块中的<code>return</code>返回后方法结束执行，不会再执行<code>try</code>块中的<code>return</code>语句。</li><li><input checked="" disabled="" type="checkbox"> D.循环体中避免不必要的<code>try-catch</code>操作。</li></ul></li><li><p>【多选】关于客户数据展示，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.客户的密码，密钥及密保问题答案等信息禁止展示。</li><li><input checked="" disabled="" type="checkbox"> B.客户的银行卡号只显示后四位。</li><li><input checked="" disabled="" type="checkbox"> C.客户的证件号码只显示第一位和最后一位，在必要业务场景下，经多因子强验证后可完整展示。</li><li><input checked="" disabled="" type="checkbox"> D.涉及有完整展示客户信息的页面均需要接入防爬系统。</li></ul></li><li><p>【多选】数组使用<code>Arrays.asList()</code>转化为集合，下列说法哪些正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.数组元素的修改，会影响到转化过来的集合。</li><li><input disabled="" type="checkbox"> B.数组元素的修改，不会影响到转化过来的集合。</li><li><input checked="" disabled="" type="checkbox"> C.对于转换过来的集合，它的<code>add</code>/<code>remove</code>/<code>clear</code> 方法会抛出：<code>UnsupportedOperationException</code>。</li><li><input checked="" disabled="" type="checkbox"> D.<code>Arrays.asList()</code>体现的是适配器模式，只是转换接口，后台的数据仍是数组。</li></ul></li><li><p>【多选】关于数据库查询的描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.当需要获取数据表所有字段的值映射到<code>DO</code>时，可使用<code>select *</code>来查询。</li><li><input checked="" disabled="" type="checkbox"> B.绝对禁止左模糊和全模糊查询；限制使用右模糊查询。全模糊或左模糊搜索的需求走搜索引擎实现。</li><li><input checked="" disabled="" type="checkbox"> C.禁止使用存储过程来查询返回数据。</li><li><input checked="" disabled="" type="checkbox"> D.在表查询中，需<code>order by</code>排序时，优先使用主键列，索引列。</li></ul></li><li><p>【多选】关于Java代码的设计和开发注意事项，下列哪些说法符合《集合开发规约》</p><ul><li><input checked="" disabled="" type="checkbox"> A.禁止将URL、文件名、系统参数、数据库连接地址、业务规则的可变参数，硬编码在工程中。</li><li><input checked="" disabled="" type="checkbox"> B.<code>long</code>或者<code>Long</code>初始赋值时，必须是大写<code>L</code>，不能小写。</li><li><input checked="" disabled="" type="checkbox"> C.当一个类有多个构造方法，或是多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</li><li><input checked="" disabled="" type="checkbox"> D.相同参数类型，同等业务含义，才可以使用Java的可变参数，参数的类型尽量避免使用<code>Object</code>。</li></ul></li><li><p>【多选】好的单元测试必须遵守<code>AlR</code>原则，那么<code>AlR</code>原则具体是指：</p><ul><li><input checked="" disabled="" type="checkbox"> A.单元测试应该是全自动执行的，并且非交互式的。</li><li><input disabled="" type="checkbox"> B.单元测试必须在线上环境能够全部被正确地编译。</li><li><input checked="" disabled="" type="checkbox"> C.为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</li><li><input checked="" disabled="" type="checkbox"> D.单元测试是可以重复执行的。</li></ul></li><li><p>【多选】关于数据库索引的命名，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.主键索引（<code>primary key</code>），字段类型为<code>unsigned bigint</code>、单表时推荐自增、步长为1。</li><li><input disabled="" type="checkbox"> B.主键索引（<code>primary key</code>），字段类型为<code>unsigned bigint</code>、单表时推荐自增、步长为2。</li><li><input checked="" disabled="" type="checkbox"> C.唯一索引（<code>unique key</code>），命名规则为<code>uk_</code>字段名（如果多个字段继续下划线）。</li><li><input checked="" disabled="" type="checkbox"> D.普通索引（<code>normal index</code>），标记成<code>idx_</code>字段名（如果多个继续下划线）。</li></ul></li><li><p>【多选】关于异常处理的注意事项，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.事务场景中，抛出异常被<code>catch</code>后，如果需要回滚，一定要手动回滚事务。</li><li><input checked="" disabled="" type="checkbox"> B.在<code>finally</code>块必须对文件流进行关闭。</li><li><input disabled="" type="checkbox"> C.推荐在<code>finally</code>块使用<code>return</code>语句。</li><li><input disabled="" type="checkbox"> D.在<code>try</code>块内，可以不用对可能为<code>null</code>的对象做非空判断，因为如果抛掷<code>NPE</code>，会被<code>catch</code>块捕获并处理。</li></ul></li><li><p>【多选】关于数据库中表相关的命名，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.表名、字段名禁止出现数字开头，禁止两个下划线中间只出现数字。</li><li><input checked="" disabled="" type="checkbox"> B.表名不使用复数名词。</li><li><input disabled="" type="checkbox"> C.表必备三字段命名：<code>id</code>，<code>gmt_create</code>，<code>gmt_modify</code>。</li><li><input checked="" disabled="" type="checkbox"> D.表必备三字段命名：<code>id</code>，<code>gmt_create</code>，<code>gmt_modified</code>。</li></ul></li><li><p>【多选】对于索引的基本原理，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.索引的数据结构主要有<code>B-Tree</code>、<code>Hash</code>、<code>R-Tree</code>、<code>Full-Text</code>等。</li><li><input checked="" disabled="" type="checkbox"> B.从物理存储来看，主要分为聚集（clustered）和非聚集（non-clustered）索引。</li><li><input checked="" disabled="" type="checkbox"> C.MySQL的表是聚集索引组织表（index of table）。</li><li><input checked="" disabled="" type="checkbox"> D.聚簇索引的叶子节点存放的是数据，非聚簇索引的叶子节点存放的是非聚集索引的key和主键值。</li></ul></li><li><p>【多选】关于应用中可以直接依赖的日志框架，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input disabled="" type="checkbox"> A.<code>Log4j</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>SLF4J</code>。</li><li><input checked="" disabled="" type="checkbox"> C.<code>JCL</code>（Jakarta Commons Logging）。</li><li><input disabled="" type="checkbox"> D.<code>Logback</code>。</li></ul></li><li><p>【多选】关于线程安全，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>SimpleDateFormat</code>是线程不安全的类。</li><li><input disabled="" type="checkbox"> B.<code>SimpleDateFormat</code>是线程安全的类。</li><li><input checked="" disabled="" type="checkbox"> C.一般不要定义<code>SimpleDateFormat</code>的static变量，如果定义为static，必须保证线程安全。</li><li><input checked="" disabled="" type="checkbox"> D.推荐使用Apache封装好的<code>DateUtils</code>和<code>DateFormatUtils</code>工具类，来处理时间日期转换问题。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，以下哪些字段属于表的必备字段：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>id</code></li><li><input checked="" disabled="" type="checkbox"> B.<code>gmt_modified</code></li><li><input disabled="" type="checkbox"> C.<code>parent_id</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>gmt_create</code></li></ul></li><li><p>【多选】下面的例子代码和描述，哪些是有不正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.单行字符数限制不超过140个，超出需要换行</li><li><input disabled="" type="checkbox"> B.IDE的<code>text file encoding</code>设置为<code>GBK</code>；IDE中文件的换行符使用Unix格式，不要使用windows格式。</li><li><input checked="" disabled="" type="checkbox"> C.大括号与<code>if</code>，<code>else</code>，<code>for</code>，<code>do</code>，<code>while</code>语句一起使用，即使只有一条语句（或是空），也应该把大括号写上。 </li><li><input checked="" disabled="" type="checkbox"> D.大括号的使用约定。如果是大括号内为空，则简洁地写成即可，不需要换行；</li></ul></li><li><p>【多选】关于分页查询，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.分页查询，当统计的count为0时，应该直接返回，不要再执行分页查询语句。</li><li><input checked="" disabled="" type="checkbox"> B.iBATIS自带的<code>queryForList(String statementName，int start，int size)</code>分页接口有性能隐患，不允许使用。</li><li><input checked="" disabled="" type="checkbox"> C.定义明确的SQL查询语句，通过传入参数<code>start</code>和<code>size</code>来实现分页逻辑。</li><li><input disabled="" type="checkbox"> D.可使用存储过程写分页逻辑，提高效率。</li></ul></li><li><p>【多选】关于类和方法，下列哪些符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.任何类、方法、严控访问范围。因为过宽泛的访问范围，不利于模块解耦。</li><li><input checked="" disabled="" type="checkbox"> B.对外暴露的接囗签名，原则上不允许修改，宁可新增，避免对依赖端产生影响。</li><li><input checked="" disabled="" type="checkbox"> C.如果新增一个功能完全相同的新接口，过时接口必须加<code>@deprecated</code>注释。</li><li><input checked="" disabled="" type="checkbox"> D.所有过时的类与方法不得使用。</li></ul></li><li><p>【多选】关于建表规约，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.字段为非负数，必须定义为<code>unsigned</code>。</li><li><input checked="" disabled="" type="checkbox"> B.存储的字符数几乎完全相等的字段，推荐定义为char类型存储。</li><li><input disabled="" type="checkbox"> C.varchar会预先分配存储空间。</li><li><input checked="" disabled="" type="checkbox"> D.不得使用级联与外键，一切外键概念必须在应用层解决。</li></ul></li><li><p>【多选】关于常量的命名，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.常量命名应该全部大写，单词间用下划线隔开。</li><li><input checked="" disabled="" type="checkbox"> B.常量的定义要力求语义表达完整清楚，让别人能从常量名称上大致了解含义，例如：<code>MAX STOCK_COUNT</code>。</li><li><input disabled="" type="checkbox"> C.常量命名，可以使用拼音与英文的混合方式。</li><li><input checked="" disabled="" type="checkbox"> D.在使用缩写时要注意：杜绝不规范的缩写。</li></ul></li><li><p>【多选】关于代码书写格式，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.换行时相对上一行缩进2个空格。</li><li><input checked="" disabled="" type="checkbox"> B.运算符与下文一起换行，方法调用的点符号与下文一起换行。</li><li><input checked="" disabled="" type="checkbox"> C.在多个参数超长，逗号后进行换行。</li><li><input checked="" disabled="" type="checkbox"> D.在括号前不要换行。</li></ul></li><li><p>【单选】<code>List</code>子类使用<code>toArray</code>方法实现集合向数组转换，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.<code>Vector</code>无法使用<code>toArray</code>转换成数组。</li><li><input checked="" disabled="" type="checkbox"> B.优先推荐：调用集合类的方法<code>toArray(T[] a)</code>，传入的是类型完全一样的数组，大小就是集合的<code>size()</code>。</li><li><input disabled="" type="checkbox"> C.集合的修改，会影响到数组元素的改变。</li><li><input disabled="" type="checkbox"> D.数组的修改，会影响到集合元素的改变。</li></ul></li><li><p>【单选】关于类的序列化，下列说法哪些是正确的：</p><ul><li><input disabled="" type="checkbox"> A.类的序列化与<code>serialVersionUID</code>毫无关系。</li><li><input disabled="" type="checkbox"> B.如果完全不兼容升级，不需要修改<code>serialVersionUID</code>值。</li><li><input disabled="" type="checkbox"> C.<code>POJO</code>类的<code>seriaVersionUID</code>不一致会编译出错。</li><li><input checked="" disabled="" type="checkbox"> D.<code>POJO</code>类的<code>serialVersionUID</code>不一致会抛出序列化运行时异常。</li></ul></li><li><p>【多选】关于<code>hashcode</code>和<code>equals</code>，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.<code>hashcode</code>是<code>Class</code>的方法，<code>equals</code>是<code>Object</code>的方法。</li><li><input checked="" disabled="" type="checkbox"> B.<code>hashcode</code>决定（如：<code>HashMap</code>）存储位置；<code>equals</code>决定是否需要覆盖（同一<code>hash</code>下）集合元素。</li><li><input checked="" disabled="" type="checkbox"> C.类重写<code>hashcode</code>，必须重写<code>equals</code>。</li><li><input disabled="" type="checkbox"> D.两者是否需要重写，没有必然联系。</li></ul></li><li><p>【多选】关于二方库版本号的命名方式，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.版本号命名格式：<code>主版本号.次版本号.修订号</code>。</li><li><input checked="" disabled="" type="checkbox"> B.主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。</li><li><input checked="" disabled="" type="checkbox"> C.次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。</li><li><input checked="" disabled="" type="checkbox"> D.修订号：保持完全兼容性，修复BUG、新增次要功能特性等。</li></ul></li><li><p>【单选】<code>sort</code>表示元素在存入集合时进行了排序，数据遍历的结果是按某个排序规则输出的；而<code>order</code>表示每次遍历的序列都是一样的，元素前后关系每次遍历都是确定的，那么下列哪些集合既是<code>sort</code>，又是<code>order</code>的：</p><ul><li><input disabled="" type="checkbox"> A.<code>HashSet</code></li><li><input disabled="" type="checkbox"> B.<code>LinkedList</code></li><li><input disabled="" type="checkbox"> C.<code>HashMap</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>Treset</code></li></ul></li><li><p>【多选】关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.跨应用共享常量：放置在二方库中，通常是<code>client.jar</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> B.应用内共享常量：通常放置在一方库的<code>modules</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> C.子工程内部共享常量：即在当前子工程的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> D.类内常量：直接在类内部<code>private static final</code>定义。</li></ul></li><li><p>【多选】关于注释，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.方法头定义签名上的注释可以使用<code>//</code>（双划线）简单说明，不必要遵守javadoc规范。</li><li><input checked="" disabled="" type="checkbox"> B.类定义开始部分，一般都用javadoc注释程序的总体描述以及作者信息。</li><li><input checked="" disabled="" type="checkbox"> C.方法头定义签名上的注释必须遵守javadoc规范，使用<code>/**</code>回车来生成，不得在方法定义上方使用<code>//</code>（双划线）简单说明。</li><li><input disabled="" type="checkbox"> D.方法头定义签名上的注释，可以使用<code>// XXX</code>的形式</li></ul></li><li><p>针对tcp协议，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.tcp链接主动关闭的一方，在完成四次挥手协议后，即会立即关闭并释放socket。</li><li><input disabled="" type="checkbox"> B.处于time_wait状态的socket，其实是已经关闭状态，当需要新建连接时，可以被马上复用。</li><li><input checked="" disabled="" type="checkbox"> C.当大量socket处于time_wait状态时，会导致可用socket资源稀缺，从而导致服务器并发能力下降。</li><li><input checked="" disabled="" type="checkbox"> D.通过修改<code>etc/sysctl.conf</code>配置文件，减小time_wait的超时时间，可以降低time_wait状态的socket数量，从而提升服务器并发能力。</li></ul></li><li><p>【多选】关于控制语句，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.推荐if-else的方式可以改写成卫语句的形式。</li><li><input checked="" disabled="" type="checkbox"> B.尽量减少try-catch块内的逻辑，定义对象、变量、获取数据库连接等操作可以移到try-catch块外处理</li><li><input disabled="" type="checkbox"> C.<code>if(condition) statements;</code>单行语句不需要使用大括号。</li><li><input checked="" disabled="" type="checkbox"> D.在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。</li></ul></li><li><p>【单选】关于Map类型集合的遍历方式，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.Map类型的实现类都同时实现了lterator接口。</li><li><input disabled="" type="checkbox"> B.使用foreach进行遍历。</li><li><input disabled="" type="checkbox"> C.推荐使用keySet进行遍历。</li><li><input checked="" disabled="" type="checkbox"> D.推荐使用entrySet进行遍历。</li></ul></li><li><p>【多选】关于数据库命名规则，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.数据库库名和表名没有规定，可任意取名，只要方便记忆即可。</li><li><input checked="" disabled="" type="checkbox"> B.库名应该尽量与应用名称保持一致，表的命名最好是<code>业务名称_表名</code>的方式。</li><li><input checked="" disabled="" type="checkbox"> C.无论是库名还是表名都禁用保留字，如desc、match、range等。</li><li><input checked="" disabled="" type="checkbox"> D.表名、字段名必须使用小写字母或数字。</li></ul></li><li><p>【单选】单元测试代码写在Java工程的哪个地方最为合适？</p><ul><li><input disabled="" type="checkbox"> A.写在业务代码体里边，方便调试。</li><li><input disabled="" type="checkbox"> B.写在业务代码同一个包下，方便归类查找。</li><li><input checked="" disabled="" type="checkbox"> C.写在<code>src/test/java</code>目录下。</li><li><input disabled="" type="checkbox"> D.写在<code>src/java</code>目录下。</li></ul></li><li><p>【多选】关于加锁，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.可以只锁代码区块的情况下，就不要锁整个方法体。</li><li><input checked="" disabled="" type="checkbox"> B.高并发的业务场景下，要考虑加锁及同步处理带来的性能损耗，能用无锁数据结构，就不要用锁。</li><li><input checked="" disabled="" type="checkbox"> C.能用对象锁的情况下，就不要用类锁。</li><li><input checked="" disabled="" type="checkbox"> D.加锁时需要保持一致的加锁顺序，否则可能会造成死锁。</li></ul></li><li><p>【多选】利用索引进行排序，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.查询语句<code>WHERE a = 10 ORDER BY b</code>，可以利用索引(a, b)来进行索引排序。</li><li><input checked="" disabled="" type="checkbox"> B.查询语句<code>WHERE a &gt; 10 ORDER BY b</code>，不可以利用索引(a, b)来进行索引排序。</li><li><input disabled="" type="checkbox"> C.查询语句<code>WHERE a lN（10, 11）ORDER BY b</code>，可以利用索引(a, b)来进行索引排序。</li><li><input checked="" disabled="" type="checkbox"> D.查询语句<code>WHERE a &gt; 10 AND b = 20 ORDER BY a</code>，可以利用索引(b, a)来进行索引排序。</li></ul></li><li><p>【多选】如何处理单元测试产生的数据，下列哪些说法是正确的？</p><ul><li><input checked="" disabled="" type="checkbox"> A.测试数据入库时加特殊前缀标识。</li><li><input checked="" disabled="" type="checkbox"> B.测试数据使用独立的测试库。</li><li><input checked="" disabled="" type="checkbox"> C.自动回滚单元测试产生的脏数据。</li><li><input disabled="" type="checkbox"> D.无须区别，统一在业务代码中进行判断和识别。</li></ul></li><li><p>【多选】关于Java代码的设计和开发注意事项，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.所有的覆写方法，必须是强制加<code>@Override</code>。</li><li><input checked="" disabled="" type="checkbox"> B.setter方法中，参数名称与类成员变量名称一致，<code>this.成员名 = 参数名</code>。</li><li><input checked="" disabled="" type="checkbox"> C.在getter方法中，尽量不要增加逻辑判断，因为添加了逻辑判断后，会增加排查问题难度。</li><li><input checked="" disabled="" type="checkbox"> D.避免用<code>BeanUtil</code>进行属性的copy。</li></ul></li><li><p>【多选】关于线程池的创建，下列哪些说法符合《阿里巴巴/ava开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式。</li><li><input checked="" disabled="" type="checkbox"> B.<code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li><li><input checked="" disabled="" type="checkbox"> C.<code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>的主要问题是线程数最大数是<code>Integer.MAX_VALUE</code>，可能会创建数量非常多的线程，甚至OOM。</li><li><input disabled="" type="checkbox"> D.我们的机器运算速度够快，所以线程池的创健并不需要特别的约定。</li></ul></li><li><p>【多选】使用<code>CountDownLatch</code>进行异步转同步操作时，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.每个线程退出前必须调用<code>countDown()</code>方法。</li><li><input checked="" disabled="" type="checkbox"> B.线程执行代码注意catch异常，确保<code>countDowm()</code>方法可以被执行。</li><li><input disabled="" type="checkbox"> C.子线程抛出异常堆钱，直接就可以在主线程catch到。</li><li><input checked="" disabled="" type="checkbox"> D.主线程必须在启动其他线程后调用<code>await()</code>方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</li></ul></li><li><p>【多选】关于索引的使用，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.查询语句<code>WHERE a+1 = 5</code>可以利用a索引。</li><li><input checked="" disabled="" type="checkbox"> B.查询语句<code>WHERE date_format(gmt_create, &#39;%Y-%m-%d&#39;) = &#39;2016-11-11&#39;</code>无法利用gmt_create索引。</li><li><input checked="" disabled="" type="checkbox"> C.当c列类型为char时，查询语句<code>WHERE c = 5</code>无法利用c索引。</li><li><input checked="" disabled="" type="checkbox"> D.索引字段使用时不能进行函数运算。</li></ul></li><li><p>【多选】关于代码注释，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.所有的抽象方法（包括接口中的方法）必须要用javadoc注释。</li><li><input disabled="" type="checkbox"> B.所有的方法，包括私有方法，最好都增加注释，有总比没有强。</li><li><input checked="" disabled="" type="checkbox"> C.过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</li><li><input checked="" disabled="" type="checkbox"> D.我的命名和代码结构非常好，可以减少注释的内容。</li></ul></li><li><p>【多选】关于日志的条件输出和占位符的方式，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。</li><li><input checked="" disabled="" type="checkbox"> B.条件输出方式可以避免log参数中字符串拼接的开销。</li><li><input checked="" disabled="" type="checkbox"> C.占位符输出格式可以和条件输出一样避免参数中字符串拼接开销。</li><li><input disabled="" type="checkbox"> D.因为设置了日志输出级别，所以无需使用条件输出方式。</li></ul></li><li><p>【多选】关于二方库使用枚举类型，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.二方库里可以定义枚举类型。</li><li><input checked="" disabled="" type="checkbox"> B.二方库里接口的入参可以使用枚举类型。</li><li><input disabled="" type="checkbox"> C.二方库里接口的返回值不能使用枚举类型，但可以包含枚举类型。</li><li><input checked="" disabled="" type="checkbox"> D.二方库里接口的返回值是枚举类型或包含枚举类型时，当二方库的枚举值升级（增加枚举值）时，可能会导致接口调用时出现枚举对象序列化异常。</li></ul></li><li><p>【多选】关于组合索引，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.查询条件<code>where a=&#39;0&#39; and b=&#39;1&#39;</code>，当组合索引为(b, a)的时候能进行索引扫描。</li><li><input disabled="" type="checkbox"> B.查询条件<code>where a=&#39;0&#39; and b=&#39;1&#39;</code>，当组合索引为(c, a, b)的时候能进行索引扫描。</li><li><input checked="" disabled="" type="checkbox"> C.查询<code>select b from table where a=&#39;0&#39;</code>，当组合索引为(a, b)的时候会进行索引扫描。</li><li><input disabled="" type="checkbox"> D.查询条件<code>where a&gt;0 order by b</code>，当组合索引为(a, b)时会利用索引进行排序。</li></ul></li><li><p>【多选】关于系统安全，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.表单、AJAX提交不需要进行CSRF安全过滤。</li><li><input checked="" disabled="" type="checkbox"> B.表单、AJAX提交必须执行CSRF安全过滤。</li><li><input checked="" disabled="" type="checkbox"> C.URL外部重定向传入的目标地址必须执行白名单过滤。</li><li><input checked="" disabled="" type="checkbox"> D.用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，以下功能必须进行水平权限控制校验的有：</p><ul><li><input checked="" disabled="" type="checkbox"> A.订单详情页面。</li><li><input checked="" disabled="" type="checkbox"> B.类目管理后台。</li><li><input checked="" disabled="" type="checkbox"> C.店铺装修后台。</li><li><input checked="" disabled="" type="checkbox"> D.订单付款页面。</li></ul></li><li><p>【多选】关于ORM的规则，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.数据库中，表达是与否概念的字段，必须使用<code>is_xxx</code>的方式命名。</li><li><input disabled="" type="checkbox"> B.推荐使用iBATIS自带的<code>queryForList(String statementName, int start, int size)</code>进行分页查询。</li><li><input disabled="" type="checkbox"> C.为避免写resultMap，可以直接拿HashMap与HashTable作为查询结果集的输出。</li><li><input checked="" disabled="" type="checkbox"> D.不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义。</li></ul></li><li><p>【多选】以下关于格式规约的说法，正确的有哪些：</p><ul><li><input checked="" disabled="" type="checkbox"> A.代码块缩进4个空格，如果使用tab缩进，请设置成1个tab为4个空格；</li><li><input disabled="" type="checkbox"> B.代码块缩进5个空格，如果使用tab缩进，请设置成1个tab为5个空格。</li><li><input disabled="" type="checkbox"> C.为了保特代码美观，《手册》强烈推荐增加若干空格，使某一行的变量与相邻对应位置的变量对齐。</li><li><input checked="" disabled="" type="checkbox"> D.方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间推荐插入一个空行；相同业务逻辑和语义之间不需要插入空行。</li></ul></li><li><p>【多选】以下关于格式规约的说法，正确的有哪些：</p><ul><li><input checked="" disabled="" type="checkbox"> A.左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格，例1：<code>if(f1ag == 1) {System.out.println(&quot;world&quot;);}</code></li><li><input checked="" disabled="" type="checkbox"> B.if / for / while / switch / do等保留字与左右括号之间都必须加空格；</li><li><input disabled="" type="checkbox"> C.while这个保留字比较特殊，使用时左右括号之间可以不用加空格，例1：<code>while(true){...}</code></li><li><input checked="" disabled="" type="checkbox"> D.任何运算符左右必须加一个空格，运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</li></ul></li><li><p>【多选】关于索引的设计，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.对varchar类型的字段建立索引，必须指定索引长度。</li><li><input disabled="" type="checkbox"> B.对varchar类型的字段建立索引，不需要指定索引长度，这样索引区分度最好。</li><li><input checked="" disabled="" type="checkbox"> C.业务上具有唯一特性的字段（含组合字段），必须指定唯一索引。</li><li><input checked="" disabled="" type="checkbox"> D.建复合索引时，一般选择区分度高的字段放在最左列。</li></ul></li><li><p>【多选】关于类和方法，下列哪些符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.任何类、方法、严控访问范围。因为过宽泛的访问范围，不利于模块解耦。</li><li><input checked="" disabled="" type="checkbox"> B.对外暴露的接口签名，原则上不允许修改，宁可新增，避免对依赖端产生影响。</li><li><input checked="" disabled="" type="checkbox"> C.如果新增一个功能完全相同的新接口，过时接口必须加@deprecated注释。</li><li><input checked="" disabled="" type="checkbox"> D.所有过时的类与方法不得使用。</li></ul></li><li><p>【多选】关于变量和常量定义，下列哪些符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Long a=2L</code>；//大写的L</li><li><input disabled="" type="checkbox"> B.<code>Long a=2l</code>; //小写的l</li><li><input disabled="" type="checkbox"> C.常量只定义一次，不再赋值，所以不需要命名规范。</li><li><input checked="" disabled="" type="checkbox"> D.不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>130-如何实现一个自己的显式锁Lock精讲下（让锁具备超时功能）</title>
      <link href="/2019/12/01/130-custom-lock-timedout/"/>
      <url>/2019/12/01/130-custom-lock-timedout/</url>
      
        <content type="html"><![CDATA[<h2 id="上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG"><a href="#上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG" class="headerlink" title="上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG"></a>上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG</h2><pre><code class="java">public static void main(String[] args) throws InterruptedException {    final BooleanLock booleanLock = new BooleanLock();    new Thread(() -&gt; {        try {            booleanLock.lock();            Optional.of(Thread.currentThread().getName() + &quot; have the lock Monitor.&quot;).ifPresent(System.out::println);            work();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            booleanLock.unlock();        }      }, &quot;T1&quot;);    // 问题：违规非法操作，导致运行混乱    Thread.sleep(100);    booleanLock.unlock();}</code></pre><p>锁booleanLock由线程T1中加锁<code>lock()</code>，就只能由T1解锁<code>unlock()</code>。</p><p>解决：</p><pre><code class="java">private Thread currentThread;@Overridepublic synchronized void lock() throws InterruptedException {    ...    this.currentThread = Thread.currentThread();}@Overridepublic synchronized void unlock() {    // 释放锁    if (Thread.currentThread() == currentThread) {        ...    }}</code></pre><p>synchronized机制导致的一个问题：synchronized不能被打断，导致其他线程抢不到锁。</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {    new Thread(SynchronizedProblem::run, &quot;T1&quot;).start();    Thread.sleep(1000);    Thread t2 = new Thread(SynchronizedProblem::run, &quot;T2&quot;);    t2.start();    Thread.sleep(2000);    t2.interrupt();    System.out.println(t2.isInterrupted());// true，但是并没有中断t2}private synchronized static void run() {    System.out.println(Thread.currentThread().getName());    while (true) { }}</code></pre><p><code>t2.isInterrupted()</code>返回值为true，但是并没有中断t2，此时就需要让锁具备超时功能，即<code>void lock(long mills)</code>，mills时间拿不到锁就会超时，同时抛出<code>TimeOutException</code>异常。</p><h2 id="让锁具备超时功能"><a href="#让锁具备超时功能" class="headerlink" title="让锁具备超时功能"></a>让锁具备超时功能</h2><p>调用的方法一直阻塞，但是还有其他工作需要执行，此时放弃调用方法需要使用<code>void lock(long mills)</code>。等待锁指定时间，一旦时间超过就抛出<code>TimeOutException</code></p><pre><code class="java">@Overridepublic synchronized void lock(long mills) throws InterruptedException, TimeOutException {    if (mills &lt;= 0) {        lock();    }    long hasRemaining = mills;    long endTime = System.currentTimeMillis() + mills;    while (initValue) {        if (hasRemaining &lt;= 0) {            throw new TimeOutException(&quot;Time Out&quot;);        }        blockedThreadCollection.add(Thread.currentThread());        this.wait(mills);        hasRemaining = endTime - System.currentTimeMillis();    }    this.initValue = true;    this.currentThread = Thread.currentThread();}</code></pre><p><code>void wait()</code>需要synchronized，需要添加一个Monitor锁</p><p>Java5之后JUC并发包提供了相同的功能。由大神Doug Lea开发，使Java性能更加接近于C/C++。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>129-如何实现一个自己的显式锁Lock精讲上</title>
      <link href="/2019/12/01/129-custom-lock/"/>
      <url>/2019/12/01/129-custom-lock/</url>
      
        <content type="html"><![CDATA[<p>synchronized的机制导致的一个问题：当线程A调用使用synchronized加锁的线程B时，如果线程B的运行时间很长，则调用者线程A将会进入阻塞状态，且不可打断，也不能立即返回。</p><h2 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h2><pre><code class="java">/** * 自定义显式锁 */public interface Lock {    class TimeOutException extends Exception {        public TimeOutException(String message) {            super(message);        }    }    void lock() throws InterruptedException;    void lock(long mills) throws InterruptedException, TimeOutException;    void unlock();    Collection&lt;Thread&gt; getBlockedThread();    int getBlockedSize();}</code></pre><h2 id="BooleanLock实现类"><a href="#BooleanLock实现类" class="headerlink" title="BooleanLock实现类"></a>BooleanLock实现类</h2><pre><code class="java">public class BooleanLock implements Lock {    /**     * The initValue is true indicated the lock has been get.     * The initValue is false indicated the lock is free (other thread can get this).     */    private boolean initValue;    private Collection&lt;Thread&gt; blockedThreadCollection = new ArrayList&lt;&gt;();    public BooleanLock() {        this.initValue = false;    }    @Override    public synchronized void lock() throws InterruptedException {        // 锁已经被其他线程使用        while (initValue) {            blockedThreadCollection.add(Thread.currentThread());            this.wait();        }        // 锁未被使用，抢到锁立即设置initValue的值        this.initValue = true;        blockedThreadCollection.remove(Thread.currentThread());    }    @Override    public void lock(long mills) throws InterruptedException, TimeOutException {}    @Override    public synchronized void unlock() {        // 释放锁        this.initValue = false;        Optional.of(Thread.currentThread().getName() + &quot; release the lock monitor.&quot;).ifPresent(System.out::println);        this.notifyAll();    }    @Override    public Collection&lt;Thread&gt; getBlockedThread() {        // 可以直接返回，但是不安全。此处返回的是一个实例，调用者可以随意更改（null，clear()等操作）。        return Collections.unmodifiableCollection(blockedThreadCollection);    }    @Override    public int getBlockedSize() {        return blockedThreadCollection.size();    }}</code></pre><h2 id="测试调用方法"><a href="#测试调用方法" class="headerlink" title="测试调用方法"></a>测试调用方法</h2><pre><code class="java">public static void main(String[] args) throws InterruptedException {    final BooleanLock booleanLock = new BooleanLock();    Stream.of(&quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;, &quot;T4&quot;).forEach(name -&gt; {        new Thread(() -&gt; {            try {                booleanLock.lock();                Optional.of(Thread.currentThread().getName() + &quot; have the lock Monitor.&quot;).ifPresent(System.out::println);                work();            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                booleanLock.unlock();            }        }, name).start();    });    // 问题：违规非法操作，导致运行混乱    Thread.sleep(100);    booleanLock.unlock();}private static void work() throws InterruptedException {    Optional.of(Thread.currentThread().getName() + &quot; is working...&quot;).ifPresent(System.out::println);    Thread.sleep(10_000);}</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>违规非法操作，导致运行混乱。巨大的BUG</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {    final BooleanLock booleanLock = new BooleanLock();    ...    // 问题：违规非法操作，导致运行混乱    Thread.sleep(100);    booleanLock.unlock();}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128-线程生产者消费者的综合实战结合Java8语法</title>
      <link href="/2019/12/01/128-prod-cons-case/"/>
      <url>/2019/12/01/128-prod-cons-case/</url>
      
        <content type="html"><![CDATA[<p>数据采集功能：利用多个线程采集多台服务器运行状态信息。当服务器数量较少时，可以采取一个线程采集一台服务器；但是服务器数量非常大时，将不可能采取这种方式，可以开启一定数量的线程采集完成后再采集其他服务器，即运行的线程始终保持着稳定数量。</p><p>操作系统可以支持一个应用开启的线程数量是有限制的，取决于stack size。多线程的性能是有一个峰值的，超过峰值性能反而会下降。这是因为线程数量过大时，应用的上下文切换会消耗很大一部分资源。</p><pre><code class="java">public class CaptureService {    private static final LinkedList&lt;Control&gt; CONTROLS = new LinkedList&lt;&gt;();    private static final int MAX_WORKER = 5;    public static void main(String[] args) {        List&lt;Thread&gt; worker = new ArrayList&lt;&gt;();        Stream.of(&quot;M1&quot;, &quot;M2&quot;, &quot;M3&quot;, &quot;M4&quot;, &quot;M5&quot;, &quot;M6&quot;, &quot;M7&quot;, &quot;M8&quot;, &quot;M9&quot;, &quot;M10&quot;)                .map(CaptureService::createCaptureService)                .forEach(t -&gt; {                    t.start();                    worker.add(t);                });        worker.forEach(t -&gt; {            t.join();        });        Optional.of(&quot;All of capture work finished.&quot;).ifPresent(System.out::println);    }    public static Thread createCaptureService(String name) {        return new Thread(() -&gt; {            Optional.of(&quot;The worker [&quot; + Thread.currentThread().getName() + &quot;] BEGIN capture data.&quot;).ifPresent(System.out::println);            synchronized (CONTROLS) {                while (CONTROLS.size() &gt; MAX_WORKER) {                    CONTROLS.wait();                }                CONTROLS.addLast(new Control());            }            Optional.of(&quot;The worker [&quot; + Thread.currentThread().getName() + &quot;] is WORKING...&quot;).ifPresent(System.out::println);            Thread.sleep(10_000);            synchronized (CONTROLS) {                Optional.of(&quot;The worker [&quot; + Thread.currentThread().getName() + &quot;] END capture data.&quot;).ifPresent(System.out::println);                CONTROLS.removeFirst();                CONTROLS.notifyAll();            }        }, name);    }    private static class Control {}}</code></pre><p>Optional可以防止NPE空指针异常</p><p>解决的问题：</p><ol><li>多个线程上下文切换带来的损耗问题</li><li>多个线程占多个资源，比如同时创建多个数据库连接、打开多个文件（文件句柄是有限的）。</li></ol><p>学习了线程池之后，可以不必这么麻烦啦。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>127-wait和sleep的本质区别是什么，深入分析（面试常见问题）</title>
      <link href="/2019/12/01/127-wait-sleep/"/>
      <url>/2019/12/01/127-wait-sleep/</url>
      
        <content type="html"><![CDATA[<p>The difference of sleep and wait:</p><ol><li>sleep is the method of Thread, but wait is the method of Object.</li><li>sleep will not release the Object monitor(LOCK), but the wait will be release the monitor and add to the Object monitor waiting queue.</li><li>Use sleep not depend on the monitor(synchronized), but wait need.</li><li>The sleep method not need be wakeup, but wait need. except wait(long timeout)</li></ol><p>验证不同点3：</p><pre><code class="java">public static void m1() {    Thread.sleep(2_000);}public static void m2() {    synchronized (LOCK) {        LOCK.wait();    }}</code></pre><p><code>LOCK.wait();</code>没有使用<code>synchronized</code>则会抛出<code>java.lang.IllegalMonitorStateException</code>异常</p><p>验证不同点2：</p><pre><code class="java">// 两个线程依次运行public static void m3() {    synchronized (LOCK) {        System.out.println(&quot;The Thread &quot; + Thread.currentThread().getName() + &quot; enter.&quot;);        Thread.sleep(20_000);    }}// 两个线程几乎同时运行，两个线程最终都加入到了LOCK的waiting queuepublic static void m4() {    synchronized (LOCK) {        System.out.println(&quot;The Thread &quot; + Thread.currentThread().getName() + &quot; enter.&quot;);        LOCK.wait();    }}</code></pre><pre><code class="java">public static void main(String[] args) {    Stream.of(&quot;T1&quot;, &quot;T2&quot;).forEach(name -&gt; new Thread(DifferenceOfWaitAndSleep::m4, name).start());}</code></pre><p>使用<code>sleep()</code>两个线程将会依次运行；使用<code>wait()</code>两个线程几乎同时运行，最终都加入到了LOCK的waiting queue</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>126-多线程下的生产者消费者模型，以及详细介绍notifyAll方法</title>
      <link href="/2019/11/30/126-multi-thread-notifyall/"/>
      <url>/2019/11/30/126-multi-thread-notifyall/</url>
      
        <content type="html"><![CDATA[<p><code>public final void wait()</code>方法</p><blockquote><p>使当前线程等待，直到另一个线程为此对象调用<code>notify()</code>方法或<code>notifyAll()</code>方法。此方法的行为就像完全执行调用<code>wait(0)</code>一样。</p><p>当前线程必须拥有该对象的监视器。线程释放此监视器的所有权，并等待直到另一个线程通过调用notify方法或notifyAll方法通知等待在此对象监视器上等待的线程唤醒。然后，线程等待，直到它可以重新获得监视器的所有权并恢复执行（即可运行状态）。</p></blockquote><p><code>public final void notify()</code>方法</p><blockquote><p>唤醒正在此对象的监视器上等待的单个线程。如果有任何线程在此对象上等待，则选择其中一个唤醒。选择是任意的，并且可以根据实现情况进行选择。线程通过调用其中一个wait方法在对象的监视器上等待。</p></blockquote><p><code>public final void notifyAll()</code>方法</p><blockquote><p>唤醒正在此对象的监视器上等待的所有线程。线程通过调用其中一个wait方法在对象的监视器上等待。</p></blockquote><p>改造多线程下的生产者-消费者模型：</p><pre><code class="java">public void produce() {    synchronized (LOCK) {        // 分析此处为什么使用while，而不是用if？        while (isProduced) {            LOCK.wait();        }        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + (++i));        LOCK.notifyAll();        isProduced = true;    }}</code></pre><pre><code class="java">public void consume() {    synchronized (LOCK) {        while (!isProduced) {            LOCK.wait();        }        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i);        LOCK.notifyAll();        isProduced = false;    }}</code></pre><pre><code class="java">public static void main(String[] args) {    ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();    Stream.of(&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;).forEach(n -&gt; new Thread(new Runnable() {        @Override        public void run() {            while (true) {                pc.produce();                Thread.sleep(10);            }        }    }, n).start());    Stream.of(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;).forEach(n -&gt; new Thread(() -&gt; {        while (true) {            pc.consume();            Thread.sleep(10);        }    }, n).start());}</code></pre><p>分析此处为什么使用while，而不是用if？</p><pre><code class="java">while (isProduced) {    LOCK.wait();}</code></pre><p><code>notifyAll()</code>方法将会唤醒所有的生产者线程。</p><p>如果使用<code>if()</code>：线程A先抢到锁，运行时判断有没有生产数据，无则生产数据并运行完成，当它再次抢锁运行时发现已经生产过数据则会进行<code>wait()</code>操作；线程B抢到锁运行时将<u>会跳过判断</u>直接生产数据，从而造成了消费者还没有消费完数据又重复生产。</p><p>例：生产两次消费一次，生产一次消费两次</p><pre><code>P2-&gt;2P3-&gt;3C3-&gt;3P1-&gt;4C4-&gt;4C2-&gt;4</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125-多Produce多Consume之间的通讯导致出现程序假死的原因分析</title>
      <link href="/2019/11/30/125-multi-prod-cons/"/>
      <url>/2019/11/30/125-multi-prod-cons/</url>
      
        <content type="html"><![CDATA[<p>多个生产者、消费者线程运行时，会产生一些问题</p><pre><code class="java">Stream.of(&quot;P1&quot;, &quot;P2&quot;).forEach(n -&gt;        new Thread(() -&gt; {            while (true) {                pc.produce();            }        }, n).start());Stream.of(&quot;C1&quot;, &quot;C2&quot;).forEach(n -&gt;        new Thread(() -&gt; {            while (true) {                pc.consume();            }        }, n).start());</code></pre><p>此时运行程序会先正常运行一段时间，然后卡住。使用<code>jstack</code>查看程序也并没有发生死锁。那么，产生的原因是什么？</p><p><strong>分析</strong>：在消费者1消费完成后进行<code>notify()</code>操作时，并没有指定唤醒哪个线程，此时有可能唤醒的是消费者2线程。然后消费者2唤醒后发现后并没有可以消费的数据，又自行wait，此时所有生产者线程也是处于wait状态，所有线程都BLOACKED,在等待被唤醒，进而造成了线程假死的情况。</p><p><code>notify()</code>唤醒的是持有同样MONITOR锁的线程，且只唤醒一个线程。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>124-线程间通信快速入门，使用wait和notify进行线程间的数据通信</title>
      <link href="/2019/11/30/124-wait-notify/"/>
      <url>/2019/11/30/124-wait-notify/</url>
      
        <content type="html"><![CDATA[<p>线程通信例子：线程A负责从数据库读取数据，线程B负责分析处理数据。当线程A获取到数据并放入内存后需要通知线程B去处理数据。线程A为<strong>生产者</strong>，线程B为<strong>消费者</strong>。</p><p>版本1：生产者一直负责生产，消费者一直负责消费。没有进行通信，生产者生产完毕没有通知消费者，消费者也不知道是否是最新数据、是否已经消费过。</p><pre><code class="java">public class ProduceConsumerVersion1 {    private int i = 1;    private final Object LOCK = new Object();    private void produce() {        synchronized (LOCK) {            System.out.println(&quot;P-&gt;&quot; + (i++));        }    }    private void consume() {        synchronized (LOCK) {            System.out.println(&quot;C-&gt;&quot; + (i));        }    }    public static void main(String[] args) {        ProduceConsumerVersion1 pc = new ProduceConsumerVersion1();        new Thread(() -&gt; {            while (true) {                pc.produce();            }        }, &quot;P&quot;).start();        new Thread(() -&gt; {            while (true) {                pc.consume();            }        }, &quot;C&quot;).start();    }}</code></pre><p>运行代码会发现，有些时候线程P不断生产数据，而线程C没有消费；而有些时候线程C只消费最新的数据，并且不断重复的消费最新数据。</p><p>造成这种情况的原因是：线程间没有进行通信。</p><p>版本2：生产者负责生产，生产完毕之后通知消费者，如果没有消费则不再进行生产。消费者负责消费，有数据则进行消费，没有数据则进行等待。</p><pre><code class="java">public class ProduceConsumerVersion2 {    private int i = 0;    private final Object LOCK = new Object();    // 是否已经消费    private volatile boolean isProduced = false;    public void produce() {        synchronized (LOCK) {            if (isProduced) {                LOCK.wait();            } else {                System.out.println(&quot;P-&gt;&quot; + (++i));                LOCK.notify();                isProduced = true;            }        }    }    public void consume() {        synchronized (LOCK) {            if (isProduced) {                System.out.println(&quot;C-&gt;&quot; + i);                LOCK.notify();                isProduced = false;            } else {                LOCK.wait();            }        }    }    public static void main(String[] args) {        ProduceConsumerVersion2 pc = new ProduceConsumerVersion2();        new Thread(() -&gt; {            while (true) {                pc.produce();            }        }, &quot;P&quot;).start();        new Thread(() -&gt; {            while (true) {                pc.consume();            }        }, &quot;C&quot;).start();    }}</code></pre><p>此代码实现了简单的生产者-消费者模型，但是在多个生产者、消费者线程运行时，会产生一些问题。思考问题是什么？欲知后事如何，且听下回分解。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123-多线程死锁分析，案例介绍</title>
      <link href="/2019/11/30/123-deadlock-case/"/>
      <url>/2019/11/30/123-deadlock-case/</url>
      
        <content type="html"><![CDATA[<p>死锁。多个锁相互交叉锁定代码</p><p>当线程T1持有资源A，线程T2持有资源B。此时线程T1想要获取资源B，并且线程T2想要获取资源A。两个线程都想要获取对方手中的资源，自己又不肯让出已有资源，一直僵持不下就形成了死锁。</p><p>程序在运行时什么事都没做（不输出日志、CPU内存等都没有发生变化），此时极有可能发生了死锁。需要查看程序运行情况。</p><ol><li><p>案例</p><p>线程T1：</p><pre><code class="java">public class DeadLock {    private OtherService otherService;    public void setOtherService(OtherService otherService) {        this.otherService = otherService;    }    // DeadLock的实例的锁-资源A    private final Object LOCK = new Object();    public void m1() {        synchronized (LOCK) {            System.out.println(&quot;********m1********&quot;);            otherService.s1();        }    }    public void m2() {        synchronized (LOCK) {            System.out.println(&quot;********m2********&quot;);        }    }}</code></pre><p>线程T2：</p><pre><code class="java">public class OtherService {    private DeadLock deadLock;    public void setDeadLock(DeadLock deadLock) {        this.deadLock = deadLock;    }    // OtherService的实例的锁-资源B    private final Object LOCK = new Object();    public void s1() {        synchronized (LOCK) {            System.out.println(&quot;========s1========&quot;);        }    }    public void s2() {        synchronized (LOCK) {            System.out.println(&quot;========s2========&quot;);            deadLock.m2();        }    }}</code></pre><p>测试调用方法：</p><pre><code class="java">public static void main(String[] args) {    DeadLock deadLock = new DeadLock();    OtherService otherService = new OtherService();    deadLock.setOtherService(otherService);    otherService.setDeadLock(deadLock);    new Thread(() -&gt; {        while (true) {            deadLock.m1();        }    }, &quot;T1&quot;).start();    new Thread(() -&gt; {        while (true) {            otherService.s2();        }    }, &quot;T2&quot;).start();}</code></pre></li><li><p>查看死锁</p><p>当程序运行时产生死锁，通过代码会很难分析出死锁在哪里产生。此时应通过工具jstack查看程序运行状态。</p><ol><li><p>获取程序进程id（pid）。<code>jps</code></p><pre><code>2086 DeadLockTest2007 KotlinCompileDaemon2106 Jps1194 1213 RemoteMavenServer36</code></pre></li><li><p>查看程序运行状态。<code>jstack 2086</code></p><pre><code>Found one Java-level deadlock:=============================&quot;T2&quot;:  waiting to lock monitor 0x00007fe848005758 (object 0x000000076adb9730, a java.lang.Object),  which is held by &quot;T1&quot;&quot;T1&quot;:  waiting to lock monitor 0x00007fe8480042b8 (object 0x000000076adbd6a0, a java.lang.Object),  which is held by &quot;T2&quot;Java stack information for the threads listed above:===================================================&quot;T2&quot;:    at com.tuyrk.chapter8.DeadLock.m2(DeadLock.java:28)    - waiting to lock &lt;0x000000076adb9730&gt; (a java.lang.Object)    at com.tuyrk.chapter8.OtherService.s2(OtherService.java:29)    - locked &lt;0x000000076adbd6a0&gt; (a java.lang.Object)    at com.tuyrk.chapter8.DeadLockTest.lambda$main$1(DeadLockTest.java:24)    at com.tuyrk.chapter8.DeadLockTest$$Lambda$2/2094548358.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;T1&quot;:    at com.tuyrk.chapter8.OtherService.s1(OtherService.java:22)    - waiting to lock &lt;0x000000076adbd6a0&gt; (a java.lang.Object)    at com.tuyrk.chapter8.DeadLock.m1(DeadLock.java:22)    - locked &lt;0x000000076adb9730&gt; (a java.lang.Object)    at com.tuyrk.chapter8.DeadLockTest.lambda$main$0(DeadLockTest.java:19)    at com.tuyrk.chapter8.DeadLockTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre><p>T2持有0x000000076adbd6a0，想要获取0x000000076adb9730；</p><p>而T1持有0x000000076adb9730，想要获取0x000000076adbd6a0。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcrun:error:invalid active developer path</title>
      <link href="/2019/11/28/macOS-update-git/"/>
      <url>/2019/11/28/macOS-update-git/</url>
      
        <content type="html"><![CDATA[<p>macOS更新系统后git出现错误：xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missingxcrun at: /Library/Developer /CommandLineTools /usr/bin/xcrun。如图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e747jombj30nu08ujt4.jpg" alt="Git异常" style="zoom:50%;" /><p>解决方法：</p><p>在终端运行：</p><pre><code class="shell">xcode-select --install</code></pre><p>出现：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e7bmvbjnj30po09smys.jpg" style="zoom:45%;" /><p>点击安装，然后点击同意协议。</p><p>等待安装，点击完成即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>122-通过实验分析Class锁的存在</title>
      <link href="/2019/11/27/122-class-lock/"/>
      <url>/2019/11/27/122-class-lock/</url>
      
        <content type="html"><![CDATA[<p>静态方法、静态代码块加锁，锁的MONITOR是什么东西？</p><ol><li><p>顺序访问。两个线程抢占同一个锁。（Class锁）</p><pre><code class="java">public synchronized static void m1() {}</code></pre><pre><code class="java">public synchronized static void m2() {}</code></pre><p>其到底是什么锁呢？</p><p><strong>静态方法加的锁其实是Class锁。</strong></p></li><li><p>增加静态代码块，判定锁MONITOR是什么。</p><ul><li><p>暂未添加静态代码块时：</p><pre><code class="java">public static void m3() {}</code></pre><p><code>m3()</code>为静态非加锁方法，启动程序会立即运行，此时<code>m1()</code>会同时运行。</p></li><li><p>添加静态代码块后：</p><pre><code class="java">static {    synchronized (SynchronizedStatic.class) {}}</code></pre><p>先进行一次实例化，运行静态代码块，运行完成才执行<code>m3()</code>和<code>m1()</code></p></li></ul><p><strong>静态代码块加的锁其实是Class锁。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121-通过实验分析This锁的存在</title>
      <link href="/2019/11/27/121-this-lock/"/>
      <url>/2019/11/27/121-this-lock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>this锁就是通过一个实例作为MONITOR，然后进行加锁。</p></blockquote><ol><li><p>同时访问。</p><pre><code class="java">public synchronized void m1() {}</code></pre><pre><code class="java">public void m2() {}</code></pre></li><li><p>顺序访问。两个线程运行方法时抢占同一个this锁。</p><p>一个线程必须等待另一个线程访问的方法执行完成才能访问。</p><pre><code class="java">public synchronized void m1() {}</code></pre><pre><code class="java">public synchronized void m2() {}</code></pre></li><li><p>同时访问。两个线程抢占的锁不一样。m1为this锁；m2为LOCK锁。</p><pre><code class="java">public synchronized void m1() {}</code></pre><pre><code class="java">private final Object LOCK = new Object();public void m2() {    synchronized (LOCK) {}}</code></pre></li><li><p>顺序访问。两个线程抢占同一个锁，即LOCK</p><pre><code class="java">private final Object LOCK = new Object();</code></pre><pre><code class="java">public void m1() {    synchronized (LOCK) {}}</code></pre><pre><code class="java">public void m2() {    synchronized (LOCK) {}}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>120-同步代码块以及同步方法之间的区别和关系</title>
      <link href="/2019/11/24/120-sync-codeblock-method/"/>
      <url>/2019/11/24/120-sync-codeblock-method/</url>
      
        <content type="html"><![CDATA[<p>synchronized关键字同步方法的使用</p><p>代码：</p><pre><code class="java">// 单线程运行synchronized方法里边的内容@Overridepublic synchronized void run() {    while (true) {        // 1        if (index &gt; MAX) {            break;        }        try {            Thread.sleep(5);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));        // 2    }}</code></pre><p><strong>运行结果：只有线程t1运行并输出信息。</strong></p><p>分析：三个线程同时去争抢synchronized的方法锁，此时线程t1争抢到锁然后进入同步方法运行程序，一直到运行完成；然后线程t2争抢到锁并进入同步方法，但是此时<code>index &gt; MAX</code>只能跳出程序。线程t3亦是如此。</p><p>注：同步代码块的锁为LOCK锁；同步方法的锁为this锁</p><p>此时，应该如何使用synchronized同步方法来实现同步运行呢？</p><pre><code class="java">@Overridepublic void run() {    while (true) {        if (ticket()) {            break;        }    }}private synchronized boolean ticket() {    // 1. getField    if (index &gt; MAX) {        return true;    }    Thread.sleep(5);        // index++; =&gt; index = index + 1;    // 1. get Field index.    // 2. index = index + 1;    // 3. put Field index.    System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));    return false;}private boolean ticket2() {    synchronized (this) {        if (index &gt; MAX) {            return true;        }        try {            Thread.sleep(5);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));        return false;    }}</code></pre><p>使用同步代码块的原则：使用synchronized关键字应尽量小地给共享数据加锁</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>119-结合jconsole,jstack以及汇编指令认识synchronized关键字</title>
      <link href="/2019/11/24/119-synchronized/"/>
      <url>/2019/11/24/119-synchronized/</url>
      
        <content type="html"><![CDATA[<p>上一节使用的synchronized到底是什么呢？</p><p>例子：在动物园检票的时候（前提：只有一台检票机，游客没有排队），每次只能有一位游客通过检票机进入动物园。游客类比多个线程，检票机类比synchronized。此时synchronized内部为单线程，<strong>串行化运行程序代码</strong></p><p>目的：让synchronized代码块里边的代码串行化运行，让共享数据串行被操作。</p><p>代码：</p><pre><code class="java">public class SynchronizedTest {    // 代码规范：final命名的变量需要使用大写    private static final Object LOCK = new Object();    public static void main(String[] args) {        // 任务        Runnable runnable = () -&gt; {            synchronized (LOCK) {                Thread.sleep(500_000);            }        };        // 创建并启动线程        Thread t1 = new Thread(runnable);        Thread t2 = new Thread(runnable);        Thread t3 = new Thread(runnable);        t1.start();t2.start();t3.start();    }}</code></pre><h2 id="jconsole工具"><a href="#jconsole工具" class="headerlink" title="jconsole工具"></a>jconsole工具</h2><ol><li><p>在终端输入命令：<code>jconsole</code>。打开Java监视和管理控制台，并选择名为SynchronizedTest的本地进程</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9996491lpj30z80u04am.jpg" alt="Java监视和管理控制台" style="zoom:40%;" /></li><li><p>点击线程，查看Thread0、Thread1、Thread2</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g999atar2vj30s40nyq8k.jpg" alt="线程Thread信息" style="zoom:50%;" /><p>Thread-0：状态: TIMED_WAITING</p><p>Thread-1：状态: java.lang.Object@20a5a1a4上的BLOCKED, 拥有者: Thread-0</p><p>Thread-2：状态: java.lang.Object@20a5a1a4上的BLOCKED, 拥有者: Thread-0</p></li></ol><h2 id="jstack工具"><a href="#jstack工具" class="headerlink" title="jstack工具"></a>jstack工具</h2><ol><li><p>在终端输入命令：<code>jps</code></p><pre><code class="shell">1488 Launcher1489 SynchronizedTest1491 Jps500 570 RemoteMavenServer36814 KotlinCompileDaemon</code></pre></li><li><p>在终端输入命令：<code>jstack 1489</code></p><pre><code class="shell">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):&quot;Thread-2&quot; #21 prio=5 os_prio=31 tid=0x00007f968c0aa800 nid=0x9f03 waiting for monitor entry [0x0000700008441000]   java.lang.Thread.State: BLOCKED (on object monitor)    at com.tuyrk.chapter07.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)    - waiting to lock &lt;0x000000076adb5948&gt; (a java.lang.Object)    at com.tuyrk.chapter07.SynchronizedTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;Thread-1&quot; #20 prio=5 os_prio=31 tid=0x00007f968c0a9800 nid=0x6a03 waiting for monitor entry [0x000070000833e000]   java.lang.Thread.State: BLOCKED (on object monitor)    at com.tuyrk.chapter07.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)    - waiting to lock &lt;0x000000076adb5948&gt; (a java.lang.Object)    at com.tuyrk.chapter07.SynchronizedTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;Thread-0&quot; #19 prio=5 os_prio=31 tid=0x00007f968c0a9000 nid=0x6903 waiting on condition [0x000070000823b000]   java.lang.Thread.State: TIMED_WAITING (sleeping)    at java.lang.Thread.sleep(Native Method)    at com.tuyrk.chapter07.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)    - locked &lt;0x000000076adb5948&gt; (a java.lang.Object)    at com.tuyrk.chapter07.SynchronizedTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;Monitor Ctrl-Break&quot; #5 daemon prio=5 os_prio=31 tid=0x00007f9690127000 nid=0x3c03 runnable [0x000070000730e000]   java.lang.Thread.State: RUNNABLE</code></pre><p>线程锁LOCK即为MONITOR（监视器）</p></li></ol><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><ol><li><p>在终端输入命令：<code>javap -c 01-thread-base/target/classes/com/tuyrk/chapter07/TicketWindowRunnable.class</code></p><pre><code class="shell">Compiled from &quot;TicketWindowRunnable.java&quot;public class com.tuyrk.chapter07.TicketWindowRunnable implements java.lang.Runnable {  public com.tuyrk.chapter07.TicketWindowRunnable();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: aload_0       5: iconst_1       6: putfield      #2                  // Field index:I       9: aload_0      10: new           #3                  // class java/lang/Object      13: dup      14: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      17: putfield      #4                  // Field MONITOR:Ljava/lang/Object;      20: return  public void run();    Code:       0: aload_0       1: getfield      #4                  // Field MONITOR:Ljava/lang/Object;       4: dup       5: astore_1       6: monitorenter       7: aload_0       8: getfield      #2                  // Field index:I      11: sipush        500      14: if_icmple     22      17: aload_1      18: monitorexit      19: goto          93      22: ldc2_w        #6                  // long 5l      25: invokestatic  #8                  // Method java/lang/Thread.sleep:(J)V      28: goto          36      31: astore_2      32: aload_2      33: invokevirtual #10                 // Method java/lang/InterruptedException.printStackTrace:()V      36: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;      39: new           #12                 // class java/lang/StringBuilder      42: dup      43: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V      46: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;      49: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;      52: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      55: ldc           #17                 // String  的号码是：      57: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      60: aload_0      61: dup      62: getfield      #2                  // Field index:I      65: dup_x1      66: iconst_1      67: iadd      68: putfield      #2                  // Field index:I      71: invokevirtual #18                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;      74: invokevirtual #19                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      77: invokevirtual #20                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V      80: aload_1      81: monitorexit      82: goto          90      85: astore_3      86: aload_1      87: monitorexit      88: aload_3      89: athrow      90: goto          0      93: return    Exception table:       from    to  target type          22    28    31   Class java/lang/InterruptedException           7    19    85   any          22    82    85   any          85    88    85   any}</code></pre><p>getfield、putfield</p><p>monitorenter、monitorexit</p></li></ol><pre><code class="shell">javap --help</code></pre><pre><code class="shell">用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括:  -help  --help  -?        输出此用法消息  -version                 版本信息  -v  -verbose             输出附加信息  -l                       输出行号和本地变量表  -public                  仅显示公共类和成员  -protected               显示受保护的/公共类和成员  -package                 显示程序包/受保护的/公共类                           和成员 (默认)  -p  -private             显示所有类和成员  -c                       对代码进行反汇编  -s                       输出内部类型签名  -sysinfo                 显示正在处理的类的                           系统信息 (路径, 大小, 日期, MD5 散列)  -constants               显示最终常量  -classpath &lt;path&gt;        指定查找用户类文件的位置  -cp &lt;path&gt;               指定查找用户类文件的位置  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>118-数据同步的引入与Synchronized的简单介绍</title>
      <link href="/2019/11/24/118-sync-base/"/>
      <url>/2019/11/24/118-sync-base/</url>
      
        <content type="html"><![CDATA[<p>逻辑执行单元-任务</p><pre><code class="java">private int index = 1;private static final int MAX = 500;@Overridepublic void run() {    while (true) {        if (index &gt; MAX) {            break;        }        Thread.sleep(5);        System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));    }}</code></pre><p>线程调用</p><pre><code class="java">// 一个runnable实例被多个线程共享TicketWindowRunnable ticketWindow = new TicketWindowRunnable();Thread windowThread1 = new Thread(ticketWindow, &quot;一号窗口&quot;);Thread windowThread2 = new Thread(ticketWindow, &quot;二号窗口&quot;);Thread windowThread3 = new Thread(ticketWindow, &quot;三号窗口&quot;);windowThread1.start();windowThread2.start();windowThread3.start();</code></pre><p>运行结果：</p><pre><code>...二号窗口 的号码是：501三号窗口 的号码是：502</code></pre><p>分析为什么会出现这种情况？</p><p>当index=499的时候，三个线程均不满足index &gt; MAX，同时三个线程均还未执行完成index++，三个线程都不会进入if，所以都可以执行后边的输出语句。</p><p>解决方法：使用synchronized同步方法。</p><pre><code class="java">synchronized (MONITOR) {    if (index &gt; MAX) {        break;    }    try {        Thread.sleep(5);    } catch (InterruptedException e) {        e.printStackTrace();    }    System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>117-Thread API综合实战，编写ThreadService实现暴力结束线程的综合实战</title>
      <link href="/2019/11/23/117-force-stop-thread/"/>
      <url>/2019/11/23/117-force-stop-thread/</url>
      
        <content type="html"><![CDATA[<p>思考：</p><p>在读操作的过程中线程被阻塞住blocked。此时没有机会打断或读flag，线程不能监听到打断操作。这种情况如何停止线程？暴力。</p><pre><code class="java">@Overridepublic void run() {    // connection or read file}</code></pre><p>此时，在JDK提供的方法中只有stop()可能通过暴力的方式关闭线程，但是stop()已经被官方不推荐使用。可以通过一些小技巧来实现，操作方法如下。</p><p>JDK提供的方法不能使用，此时自己封装一个Service。</p><p>思路：把任务线程设置为调用线程的守护线程，通过main来启动调用线程，从而执行任务线程。当需要停止线程的时候只需要中断调用线程即可，调用线程生命周期结束时，为守护线程的任务线程会自动停止。</p><pre><code class="java">public class ThreadService {    // 调用线程    private Thread executeThread;    private boolean finished = false;    /**     * 执行线程     * @param task 任务     */    public void execute(Runnable task) {        this.executeThread = new Thread(() -&gt; {            // 任务执行线程            Thread runner = new Thread(task);            runner.setDaemon(true);            runner.start();            try {                runner.join();                finished = true;            } catch (InterruptedException e) {}        });        this.executeThread.start();    }    /**     * 关闭线程     * @param mills 线程最长执行时间（单位：毫秒）     */    public void shutdown(long mills) {        long currentTime = System.currentTimeMillis();        // 当任务未完成执行。        while (!finished) {            // 如果超时。            if (System.currentTimeMillis() - currentTime &gt;= mills) {                System.out.println(&quot;任务超时，需要结束线程！&quot;);                executeThread.interrupt();                break;            }            // 既未完成任务，也没超时            try {                Thread.sleep(0, 1);            } catch (InterruptedException e) {                System.out.println(&quot;执行线程被打断！&quot;);                break;            }        }        finished = false;    }}</code></pre><p>通过main调用实现启动线程和中断线程。</p><pre><code class="java">public static void main(String[] args) {    ThreadService service = new ThreadService();    long startTime = System.currentTimeMillis();    service.execute(() -&gt; {        // 1. load a very heavy resource.        /*while (true) {        }*/        // 2. 线程执行5s后结束        try {            Thread.sleep(5_000);        } catch (InterruptedException e) {        }    });    service.shutdown(10_000);    long endTime = System.currentTimeMillis();    System.out.println(&quot;执行时间为：&quot; + (endTime - startTime));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>116-采用优雅的方式结束线程生命周期</title>
      <link href="/2019/11/23/116-graceful-stop-thread/"/>
      <url>/2019/11/23/116-graceful-stop-thread/</url>
      
        <content type="html"><![CDATA[<p>Graceful thread stop</p><ol><li><p>使用开关变量控制是否启动</p><pre><code class="java">private volatile boolean start = true;@Overridepublic void run() {    while (start) {        // ...    }}public void shutdown() {    this.start = false;}</code></pre><pre><code class="java">worker.start();Thread.sleep(3_000);worker.shutdown();</code></pre><p>实用场景：当程序需要批量获取数据的时候，可以开辟多个线程执行任务，每个线程获取一部分数据，当程序执行完成后需要释放资源，即关闭线程。但是某些线程可能会出现问题导致无法正常关闭，此时需要使用开关变量来控制线程关闭。JVM中的线程主要是放在栈内存中，但是栈空间并不是很大，如果线程一直存在并越来越多可能出现栈内存溢出的情况。</p></li><li><p>通过打断的方式实现</p><ul><li><p>打断sleep()</p><pre><code class="java">@Overridepublic void run() {    while (true) {        // 1. sleep()        try {            Thread.sleep(1);        } catch (InterruptedException e) {            break;// return;        }    }    // ... catch中使用break;可以在while()后执行其他操作    System.out.println(&quot;break-opera after while&quot;);}</code></pre></li><li><p>打断if</p><pre><code class="java">@Overridepublic void run() {    while (true) {        // 2. if        if (Thread.interrupted()) {            break;// return;        }    }    // ... catch中使用break;可以在while()后执行其他操作    System.out.println(&quot;break-opera after while&quot;);}</code></pre></li></ul><pre><code class="java">worker.start();Thread.sleep(3_000);worker.interrupt();</code></pre></li></ol><p>思考：</p><p>在读操作的过程中线程被阻塞住blocked。此时没有机会打断或读flag，线程不能监听到打断操作。这种情况如何停止线程？暴力。</p><pre><code class="java">@Overridepublic void run() {    // connection or read file}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1043-Kafka流处理平台</title>
      <link href="/2019/11/18/1043-Kafka/"/>
      <url>/2019/11/18/1043-Kafka/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1043" target="_blank" rel="noopener">https://www.imooc.com/learn/1043</a></p><p>简介：Kafka是目前主流的流处理平台，同时作为消息队列家族的一员，其高吞吐性作为很多场景下的主流选择。同时作为流处理平台，在大数据开发中，作为黏合剂串联各个系统。本课分为四大部分：第一部分介绍Kafka相关概念和基本信息；第二部分则从Kafka的结构出发，代领大家了解Kafka的设计与思想；第三部分则从实战出发，结合Kafka的应用场景，一步一步结合代码掌握Kafka的用法。最后，我们学习和探究Kafka的高级特性，融会贯通并争取可以在日常其他开发工作中使用Kafka给我们带来的技术能量。课程配套代码参考：<a href="https://github.com/AnAngryMan/KafkaSimpleExample" target="_blank" rel="noopener">https://github.com/AnAngryMan/KafkaSimpleExample</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>课程介绍</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92kvgdkiuj30vi0q2795.jpg" alt="Kafka数据流" style="zoom:30%;" /><p>课程安排：</p><ul><li>Kafka概念解析</li><li>Kafka结构设计</li><li>Kafka场景与应用</li><li>Kafka高级特性</li></ul><h2 id="第2章-什么是Kafka"><a href="#第2章-什么是Kafka" class="headerlink" title="第2章 什么是Kafka"></a>第2章 什么是Kafka</h2><blockquote><p>本章节讲解Kafka的由来，Kafka的定位和基本概念。</p></blockquote><h3 id="2-1-什么是kafka"><a href="#2-1-什么是kafka" class="headerlink" title="2-1 什么是kafka"></a>2-1 什么是kafka</h3><p>LinkedIn开源</p><ul><li>分布式数据同步系统 Databus</li><li>高性能计算引擎 Cubert</li><li>Java异步处理框架 ParSeq</li><li>Kafka流处理平台</li></ul><p>Kafka前世今生</p><ul><li>LinkedIn开发</li><li>2011年初开源，加入Apache基金会</li><li>2012年从Apache Incubator毕业</li><li>Apache顶级开源项目</li></ul><p>streaming platform has three key capabilities：</p><ul><li>Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system.</li><li>Store streams of records in a fault-tolerant durable way.</li><li>Process streams of records as they occur.</li></ul><p>Kafka is generally used for two broad classes of applications：</p><ul><li>Building real-time streaming data pipelines that reliably get data between systems or applications.</li><li>Building real-time streaming applications that transform or react to the streams of data.</li></ul><h2 id="第3章-Kafka的设计和结构"><a href="#第3章-Kafka的设计和结构" class="headerlink" title="第3章 Kafka的设计和结构"></a>第3章 Kafka的设计和结构</h2><blockquote><p>本章节讲解Kafka的部署结构、内部设计结构和设计，让你了解Kafka高效而可靠的原因</p></blockquote><h3 id="3-1-kafka基本概念"><a href="#3-1-kafka基本概念" class="headerlink" title="3-1 kafka基本概念"></a>3-1 kafka基本概念</h3><blockquote><p>物理概念</p><p>逻辑概念</p></blockquote><p>Producer：消息和数据的生产者，向Kafka的一个topic发布消息的进程/代码/服务</p><p>Consumer：消息和数据的消费者，订阅数据（Topic）并且处理其发布的消息的进程/代码/服务</p><p>Consumer Group：逻辑概念。对于同一个Topic，会广播给不同的group，一个group中，只有一个consumer可以消费该消息。</p><p>Broker：物理概念。Kafka集群中的每个Kafka节点</p><p>Topic：逻辑概念。Kafka消息的类别，对数据进行区分、隔离</p><p>Partition：物理概念。Kafka下数据存储的基本单元。一个Topic数据，会被分散存储到多个Partition，每一个Partition是有序的。</p><p>Replication：同一个Partition可能会有多个Replica，多个Replica之间的数据是一样的。</p><p>Replication Leader：一个Partition的多个Replica上，需要一个Leader负责该Partition上与Producer和Consumer交互</p><p>ReplicaManager：负责管理当前broker所有分区和副本的信息，处理KafkaController发起的一些请求，副本状态的切换、添加/读取消息等</p><h3 id="3-2-kafka概念延伸"><a href="#3-2-kafka概念延伸" class="headerlink" title="3-2 kafka概念延伸"></a>3-2 kafka概念延伸</h3><p>Partition：</p><ul><li>每一个Topic被切分为多个Partitions</li><li>消费者数目小于或等于Partition的数目</li><li>Broker Group中的每一个Broker保存Topic的一个或多个Partitions</li><li>Consumer Group中的仅有一个Consumer读取Topic的一个或多个Partitions，并且是唯一的Consumer</li></ul><p>Replication：</p><ul><li>当集群中有Broker挂掉的情况，系统可以主动地使Replicas提供服务</li><li>系统默认设置每一个Topic的Replication的系数为1，可以在创建Topic时单独设置。</li></ul><p>Replication特点：</p><ul><li>Replication的基本单位是Topic的Partition</li><li>所有的读和写都从Leader进，Followers只是作为备份</li><li>Followers必须能够及时复制Leader的数据</li><li>增加容错性与可扩展性</li></ul><h3 id="3-3-kafka基本结构"><a href="#3-3-kafka基本结构" class="headerlink" title="3-3 kafka基本结构"></a>3-3 kafka基本结构</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92ml4h2z8j30sm0ni0z0.jpg" alt="Kafka基本结构" style="zoom:35%;" /><ul><li>Producer API</li><li>Consumer API</li><li>Streams API</li><li>Connectors API</li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92mn3gn8uj31ka0r44oe.jpg" alt="Kafka基本结构" style="zoom:30%;" /><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92mo6igjyj31r805gwic.jpg" alt="Kafka消息结构" style="zoom:50%;" /><ul><li><p>Offset：</p></li><li><p>Length：</p></li><li><p>CRC32：</p></li><li><p>Magic：</p></li><li><p>attributes：</p></li><li><p>Timestamp：</p></li><li><p>Key Length：</p></li><li><p>Key：</p></li><li><p>Value Length：</p></li><li><p>Value：</p></li></ul><h3 id="3-4-kafka特点"><a href="#3-4-kafka特点" class="headerlink" title="3-4 kafka特点"></a>3-4 kafka特点</h3><blockquote><p>分布式</p></blockquote><ul><li>多分区</li><li>多副本</li><li>多订阅者</li><li>基于Zookeeper调度</li></ul><blockquote><p>高性能</p></blockquote><ul><li>高吞吐量</li><li>低延迟</li><li>高并发</li><li>时间复杂度为O(1)</li></ul><blockquote><p>持久性与扩展性</p></blockquote><ul><li>数据可持久化</li><li>容错性</li><li>支持在线水平扩展</li><li>消息自动平衡</li></ul><h2 id="第4章-Kafka的应用场景和实战"><a href="#第4章-Kafka的应用场景和实战" class="headerlink" title="第4章 Kafka的应用场景和实战"></a>第4章 Kafka的应用场景和实战</h2><blockquote><p>本章节带领大家了解Kafka的一些应用场景，然后从简单案例和复杂案例两个案例学习掌握Kafka的用法。</p></blockquote><h3 id="4-1-kafka应用场景"><a href="#4-1-kafka应用场景" class="headerlink" title="4-1 kafka应用场景"></a>4-1 kafka应用场景</h3><ul><li>消息队列</li><li>行为跟踪</li><li>元信息监控</li><li>日志收集</li><li>流处理</li><li>事件源</li><li>持久性日志（commit log）</li></ul><h3 id="4-2-kafka简单案例"><a href="#4-2-kafka简单案例" class="headerlink" title="4-2 kafka简单案例"></a>4-2 kafka简单案例</h3><ul><li>环境启动</li><li>简单生产者</li><li>简单消费者</li></ul><p>下载与安装</p><ul><li><p>Zookeeper下载</p><p><a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html#download</a></p></li><li><p>Kafka下载</p><p><a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a></p></li><li><p>安装：解压，配置环境变量</p></li><li><p>Mac便捷安装：<code>brew install kafka</code></p></li></ul><pre><code class="shell"># bash1 启动zookeeperzookeeper-server-start /usr/local/etc/kafka/zookeeper.properties# bash2 启动Kafkakafka-server-start /usr/local/etc/kafka/server.properties</code></pre><pre><code class="shell"># bash3 创建topickafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic tuyrk-kafka-topic# 查看Kafka topickafka-topics --list --zookeeper localhost:2181# 创建生产者kafka-console-producer --broker-list localhost:9092 --topic tuyrk-kafkatopic</code></pre><pre><code class="shell"># bash4 创建消费者kafka-console-consumer --bootstrap-server localhost:9092 --topic tuyrk-kafka-topic --from-beginnin</code></pre><ul><li><code>from-beginnin</code>：从开始重新接收消息</li></ul><h3 id="4-3-kafka代码案例"><a href="#4-3-kafka代码案例" class="headerlink" title="4-3 kafka代码案例"></a>4-3 kafka代码案例</h3><ul><li>工程结构</li><li>基础代码</li></ul><p>教师源码：<a href="https://github.com/AnAngryMan/KafkaSimpleExample" target="_blank" rel="noopener">https://github.com/AnAngryMan/KafkaSimpleExample</a></p><p>学习源码（springboot+kafka）：<a href="https://github.com/tuyrk/learn-imooc" target="_blank" rel="noopener">https://github.com/tuyrk/learn-imooc</a></p><h2 id="第5章-Kafka高级特性"><a href="#第5章-Kafka高级特性" class="headerlink" title="第5章 Kafka高级特性"></a>第5章 Kafka高级特性</h2><blockquote><p>本章节学习Kafka的消息事务和零拷贝，前者学习Kafka如何保证数据一致性，后者学习Kafka消息传递的高效性。</p></blockquote><h3 id="5-1-kafka高级特性之消息事务"><a href="#5-1-kafka高级特性之消息事务" class="headerlink" title="5-1 kafka高级特性之消息事务"></a>5-1 kafka高级特性之消息事务</h3><p>为什么要支持事务？</p><ul><li>满足“读取-处理-写入”模式</li><li>流处理需求的不断增强</li><li>不准确的数据处理的容忍度降低</li></ul><p>数据传输的事务定义</p><ul><li>最多一次：消息不会被重复发送，最多被传输一次，但也有可能一次不传输</li><li>最少一次：消息不会被漏发送，最少被传输一次，但也有可能被重复传输</li><li>精确的一次（Exactly once）：不会漏传输也不会重复传输，每个消息都被传输一次且仅仅传输一次。这是大家所期望的情况。</li></ul><p>事务保证</p><ul><li><p>内部重试问题：Procedure幂等处理</p></li><li><p>多分区原子写入</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g978niwdtvj31ac0gwgos.jpg" alt="多分区原子写入" style="zoom:30%;" /></li></ul><p>事务保证-避免僵尸实例</p><ul><li>每个事务Produce分配一个transaction.id，在进程重新启动时能够识别相同的Producer实例</li><li>Kafka增加了一个与transaction.id相关的epoch，存储每个transaction.id内部元数据</li><li>一旦epoch被触发，任何具有相同的transaction.id和更旧的epoch的Producer被视为僵尸，Kafka会拒绝来自这些Producer的后续事务性写入</li></ul><h3 id="5-2-kafka高级特性之零拷贝"><a href="#5-2-kafka高级特性之零拷贝" class="headerlink" title="5-2 kafka高级特性之零拷贝"></a>5-2 kafka高级特性之零拷贝</h3><p>零拷贝简介：</p><ul><li>网络传输持久性日志块</li><li>Java NIO <code>channel.transforTo()</code>方法</li><li>Linux sendfile系统调用</li></ul><p>文件传输到网络的公共数据路径</p><ul><li>操作系统将数据从磁盘读入到内核空间的页缓存</li><li>应用程序将数据从内核空间读入到用户空间缓存中</li><li>应用程序将数据写回到内核空间的socket缓存中</li><li>操作系统将数据从socket缓冲区复制到网卡缓冲区，以便将数据经网络发出</li></ul><p>零拷贝过程</p><ul><li>操作系统将数据从磁盘读入到内核空间的页缓存</li><li>将数据的位置和长度的信息的描述符增加至内核空间（socket缓冲区）</li><li>操作系统将数据从内核拷贝到网卡缓冲区，以便将数据经网络发出</li></ul><p>文件传输到网络的公共数据路径演变</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g979vkbrulj31u00lutb5.jpg" alt="文件传输到网络的公共数据路径演变" style="zoom:50%;" /><h2 id="第6章-课程总结"><a href="#第6章-课程总结" class="headerlink" title="第6章 课程总结"></a>第6章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="6-1-课程总结"><a href="#6-1-课程总结" class="headerlink" title="6-1 课程总结"></a>6-1 课程总结</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g979ws24pej31ke0u0nka.jpg" alt="Kafka课程总结" style="zoom:25%;" /><ol><li>基础概念与结构</li><li>三维特点</li><li>应用场景</li><li>应用案例</li><li>高级特性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1193-前端面试加分福音--node基础</title>
      <link href="/2019/11/16/1193-node-base/"/>
      <url>/2019/11/16/1193-node-base/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1193" target="_blank" rel="noopener">https://www.imooc.com/learn/1193</a></p><p>简介：系统的学习NodeJS的基础，熟练使用Node的核心API，了解node的运行过程，学会搭建自己的服务器，并实现我们常见的登录、注册功能，揭开后端开发的神秘面纱。</p></blockquote><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><h3 id="1-1-课程简介-08-47"><a href="#1-1-课程简介-08-47" class="headerlink" title="1-1 课程简介 (08:47)"></a>1-1 课程简介 (08:47)</h3><p>为什么要学node</p><ul><li>使自己更全面，有大局观</li><li>提升话语权</li><li>升职加薪的筹码</li></ul><p>Node的作用和应用</p><ul><li>脱离浏览器运行JS</li><li>后台API编写</li><li>Webpack、Gulp、Npm等等</li><li>中间层：服务器中负责IO读写的中间层服务器</li></ul><p>Node的优点：</p><ul><li>性能、异步IO、处理数据、安全性</li></ul><h3 id="1-2-学习目标-03-35"><a href="#1-2-学习目标-03-35" class="headerlink" title="1-2 学习目标 (03:35)"></a>1-2 学习目标 (03:35)</h3><p>登陆、注册案例</p><p>前置知识：HTML+CSS、JavaScript</p><h2 id="第2章-Node介绍"><a href="#第2章-Node介绍" class="headerlink" title="第2章 Node介绍"></a>第2章 Node介绍</h2><h3 id="2-1-Node的优势-05-36"><a href="#2-1-Node的优势-05-36" class="headerlink" title="2-1 Node的优势 (05:36)"></a>2-1 Node的优势 (05:36)</h3><ul><li>便于前端开发入门</li><li>性能高</li><li>利于前端代码的整合</li></ul><h3 id="2-2-Node环境搭建和运行-06-35"><a href="#2-2-Node环境搭建和运行-06-35" class="headerlink" title="2-2 Node环境搭建和运行 (06:35)"></a>2-2 Node环境搭建和运行 (06:35)</h3><p>Node官网：<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></p><p>Node环境搭建</p><ul><li>官网上下载node-v-xx.msi傻瓜式的安装包。一路下一步安装完成。</li><li>检测是否安装成功：<code>node -v</code></li><li>运行程序：<code>node xxx.js</code></li></ul><h3 id="2-3-npm和包-13-20"><a href="#2-3-npm和包-13-20" class="headerlink" title="2-3 npm和包 (13:20)"></a>2-3 npm和包 (13:20)</h3><p>NPM包管理器：</p><blockquote><p>NPM：node package management</p></blockquote><ul><li>package.json</li><li>NPM、CNPM</li><li>npm常用命令</li></ul><p>没有包管理器的时候：</p><pre><code class="html">&lt;script src=&quot;js/jquery.js&quot;/&gt;&lt;script src=&quot;js/swiper.js&quot;/&gt;&lt;script src=&quot;js/fastclick.js&quot;/&gt;</code></pre><p>CNPM安装</p><pre><code class="shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>NPM常用命令：</p><pre><code class="shell">npm init # 初始化npm install xxx # 安装npm i xxxnpm uninstall xxx # 删除npm un xxxnpm update xxx # 更新npm install # 安装npm i</code></pre><h2 id="第3章-Node的模块"><a href="#第3章-Node的模块" class="headerlink" title="第3章 Node的模块"></a>第3章 Node的模块</h2><blockquote><ol><li>全局模块（对象）process</li><li>系统模块</li><li>自定义模块</li></ol></blockquote><h3 id="3-1-Node中的模块：全局模块-10-34"><a href="#3-1-Node中的模块：全局模块-10-34" class="headerlink" title="3-1 Node中的模块：全局模块 (10:34)"></a>3-1 Node中的模块：全局模块 (10:34)</h3><blockquote><p>定义：何时何地都能访问，不需要引用</p></blockquote><ol><li><p><strong>process.env：环境变量</strong></p><ul><li><p>代码</p><pre><code class="javascript">console.log(process.env);</code></pre></li><li><p>命令</p><pre><code class="shell">node index.js</code></pre></li><li><p>结果</p><pre><code class="json">{  TERM: &#39;xterm-256color&#39;,  SHELL: &#39;/bin/bash&#39;,  CLICOLOR: &#39;1&#39;,  TMPDIR: &#39;/var/folders/jd/4db9g3vs0c57f0_fwtj6nkfc0000gn/T/&#39;,  Apple_PubSub_Socket_Render: &#39;/private/tmp/com.apple.launchd.gNREVjs4ne/Render&#39;,  USER: &#39;tuyuankun&#39;,  SSH_AUTH_SOCK: &#39;/private/tmp/com.apple.launchd.rYrS6hZYR9/Listeners&#39;,  __CF_USER_TEXT_ENCODING: &#39;0x1F5:0x19:0x34&#39;,  LSCOLORS: &#39;gxfxaxdxcxegedabagacad&#39;,  PATH: &#39;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Develop/applications/apache-maven-3.6.2/bin:/Develop/applications/elasticsearch-7.3.1/bin:/Develop/applications/elasticsearch-head&#39;,  TERMINAL_EMULATOR: &#39;JetBrains-JediTerm&#39;,  PWD: &#39;/Develop/learn-imooc/1193-node-base&#39;,  XPC_FLAGS: &#39;0x0&#39;,  XPC_SERVICE_NAME: &#39;0&#39;,  M2_HOME: &#39;/Develop/applications/apache-maven-3.6.2&#39;,  SHLVL: &#39;1&#39;,  HOME: &#39;/Users/tuyuankun&#39;,  LOGNAME: &#39;tuyuankun&#39;,  LC_CTYPE: &#39;zh_CN.UTF-8&#39;,  OLDPWD: &#39;/Develop/learn-imooc/1193-node-base/js&#39;,  _: &#39;/usr/local/bin/node&#39;}</code></pre></li></ul></li><li><p><strong>process.argv：运行参数</strong></p><ul><li><p>代码</p><pre><code class="javascript">console.log(process.argv);</code></pre></li><li><p>命令</p><pre><code class="shell">node index.js a b c</code></pre></li><li><p>结果</p><pre><code class="json">[  &#39;/usr/local/Cellar/node/12.10.0/bin/node&#39;,  &#39;/Develop/learn-imooc/1193-node-base/index.js&#39;,  &#39;a&#39;,  &#39;b&#39;,  &#39;c&#39;]</code></pre></li></ul><p>简易计算器：</p><pre><code class="javascript">let num1 = parseInt(process.argv[2]);let num2 = parseInt(process.argv[3]);console.log(num1 + num2);</code></pre><pre><code class="shell">node index.js 34 43</code></pre><pre><code class="shell">77</code></pre></li><li><p><strong>__dirname：当前目录名称</strong></p></li></ol><h3 id="3-2-Node中的模块：系统模块-13-54"><a href="#3-2-Node中的模块：系统模块-13-54" class="headerlink" title="3-2 Node中的模块：系统模块 (13:54)"></a>3-2 Node中的模块：系统模块 (13:54)</h3><blockquote><p>定义：需要require()，但不需要单独下载</p></blockquote><ol><li><p><strong>path：用于处理文件路径和目录路径的实用工具</strong></p><pre><code class="javascript">var path = require(&#39;path&#39;);</code></pre><pre><code class="javascript">path.dirname(&quot;/node/a/c/c/1.jpg&quot;)// 文件夹名称path.basename(&quot;/node/a/c/c/1.jpg&quot;)// 文件名称path.extname(&quot;/node/a/c/c/1.jpg&quot;)// 文件后缀名称path.resolve(&quot;/node/a/b/c&quot;, &quot;../../&quot;, &quot;d&quot;)// /node/a/dpath.resolve(__dirname, &quot;index.js&quot;)// index.js的绝对路径</code></pre></li><li><p>f s：用于文件读写操作</p><pre><code class="javascript">var fs = require(&quot;fs&quot;);</code></pre><ul><li><p>写操作：</p><pre><code class="javascript">fs.writeFile(&quot;fs.write.txt&quot;, &quot;刚下飞机&quot;, function (err) {    if (err) {        throw err;    }});// 同步fs.writeFileSync(&quot;fs.writeSync.txt&quot;, &quot;分割线&quot;);</code></pre></li><li><p>读操作：</p><pre><code class="javascript">fs.readFile(&quot;js/helloworld.js&quot;, function (err, data) {        if (err) {            console.log(err);        } else {            console.log(data.toString());        }    });// 同步var data = fs.readFileSync(&quot;js/helloworld.js&quot;);</code></pre></li><li><p>追加文件</p><pre><code class="javascript">fs.writeFile(&quot;fs.write.txt&quot;, &quot;年入百万&quot;, {flag: &quot;a&quot;}, function (err) {    if (err) {        throw err;    }});</code></pre><pre><code class="javascript">fs.appendFile(&quot;fs.write.txt&quot;, &quot;泻药&quot;, function (err) {    if (err) {        throw err;    }});</code></pre></li></ul></li></ol><h3 id="3-3-Node中的模块：自定义模块-07-23"><a href="#3-3-Node中的模块：自定义模块-07-23" class="headerlink" title="3-3 Node中的模块：自定义模块 (07:23)"></a>3-3 Node中的模块：自定义模块 (07:23)</h3><blockquote><p>定义：require自己封装的模块</p></blockquote><ul><li>exports</li><li>module</li><li>require</li></ul><pre><code class="javascript">/* mod.js */// 1. 参数/*exports.a = 1;exports.b = 2;var c = 3;*/// 2. 对象/*module.exports = {    a: 1,    b: 2};*/// 3. 方法/*module.exports = function () {    console.log(&quot;module.exports function&quot;);};*/// 4. 类module.exports = class {    constructor(name) {        this.name = name;    }    show() {        console.log(this.name);    }};</code></pre><pre><code class="javascript">/* exports.js */const mod = require(&quot;./mod&quot;);/*console.log(mod.a);// 1console.log(mod.b);// 2console.log(mod.c);// undefined*//*mod();*/let tuyrk = new mod(&quot;tuyrk&quot;);tuyrk.show();</code></pre><p><code>require()</code></p><ol><li>如果有路径，就去路径里面找</li><li>没有的话就去node_modules里面找</li><li>路径下没有模块，就去node的安装目录里面找。</li></ol><h3 id="3-4-核心：http模块-11-21"><a href="#3-4-核心：http模块-11-21" class="headerlink" title="3-4 核心：http模块 (11:21)"></a>3-4 核心：http模块 (11:21)</h3><blockquote><p>服务器对象：<code>http.createServer()</code></p></blockquote><pre><code class="javascript">let fs = require(&quot;fs&quot;);let path = require(&quot;path&quot;);let http = require(&quot;http&quot;);http.createServer((req, res) =&gt; {    /*console.log(&quot;我来了。&quot;);*/    /*res.write(&quot;index&quot;);    res.end();*/    console.log(req.url);    fs.readFile(`./${req.url}`, (err, data) =&gt; {        if (err) {            console.log(err);            res.writeHead(404);            res.end(&quot;404 not found&quot;);        } else {            res.writeHead(200);            res.end(data);        }    });}).listen(8888);</code></pre><pre><code class="html">&lt;p&gt;我是http.html&lt;/p&gt;&lt;img src=&quot;../imgs/avatar.jpeg&quot; alt=&quot;avatar.jpeg&quot;&gt;</code></pre><h2 id="第4章-Node中的数据交互"><a href="#第4章-Node中的数据交互" class="headerlink" title="第4章 Node中的数据交互"></a>第4章 Node中的数据交互</h2><h3 id="4-1-GET请求-13-32"><a href="#4-1-GET请求-13-32" class="headerlink" title="4-1 GET请求 (13:32)"></a>4-1 GET请求 (13:32)</h3><p>客户端与服务器交互的东西称为报文。</p><p>报文分为：报文头（信息，&lt;=32K）、报文体（数据&lt;2G）。</p><p>请求方式：GET、POST、PUT、DELETE</p><p>GET请求</p><ul><li>什么是GET请求？主要是获取数据。一次性传输数据</li><li>数据是放在URL里面进行传输。报文头。</li><li>容量小：&lt;32K</li></ul><pre><code class="javascript">let http = require(&quot;http&quot;);let url = require(&quot;url&quot;);http.createServer(((req, res) =&gt; {    console.log(req.url);    // 1. 无url模块，原始处理方法    /*let [url, query] = req.url.split(&#39;?&#39;);    console.log(url, query);*/    // 2. 使用url模块处理路径与参数    let {pathname, query} = url.parse(req.url, true);    console.log(pathname, query);})).listen(8888);</code></pre><pre><code class="html">&lt;form action=&quot;http://localhost:8888/aaa&quot; method=&quot;get&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre><h3 id="4-2-POST请求-12-34"><a href="#4-2-POST请求-12-34" class="headerlink" title="4-2 POST请求 (12:34)"></a>4-2 POST请求 (12:34)</h3><p>POST请求</p><ul><li><p>分段传输数据</p></li><li><p>数据是放在body里边进行传输。报文体</p></li><li><p>容量大：2G</p></li></ul><pre><code class="javascript">let http = require(&quot;http&quot;);let querystring = require(&quot;querystring&quot;);http.createServer(((req, res) =&gt; {    let result = [];    req.on(&quot;data&quot;, buffer =&gt; {        result.push(buffer);// 分段传输数据，多次执行添加    });    req.on(&quot;end&quot;, () =&gt; {// 数据处理完成        let data = Buffer.concat(result).toString();// 数组转buffer        console.log(querystring.parse(data));// 处理queryString    })})).listen(8888);</code></pre><pre><code class="html">&lt;form action=&quot;http://localhost:8888/aaa&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre><p>总结：</p><ol><li>GET<ul><li>url?username=xxx&amp;password=xxx</li><li>32K</li><li>url模块</li><li><code>url.parse(req.url, true)</code></li></ul></li><li>POST<ul><li>放在请求体</li><li>2G</li><li>querystring模块</li><li><code>querystring.parse(data)</code></li></ul></li></ol><h2 id="第5章-案例"><a href="#第5章-案例" class="headerlink" title="第5章 案例"></a>第5章 案例</h2><h3 id="5-1-接口（API）-05-59"><a href="#5-1-接口（API）-05-59" class="headerlink" title="5-1 接口（API） (05:59)"></a>5-1 接口（API） (05:59)</h3><p>登录框：登陆、注册</p><p>接口设计</p><ul><li>什么是接口（API）：不同功能层之间的通信规则称为接口</li><li>参数、返回值</li></ul><p>登陆：</p><pre><code class="shell">GET &#39;/login&#39;username, password</code></pre><pre><code class="json">{  err: 1,  msg: &quot;密码错误&quot;}</code></pre><p>注册：</p><pre><code class="shell">POST &#39;/reg&#39;</code></pre><h3 id="5-2-项目：实现登录和注册-30-08"><a href="#5-2-项目：实现登录和注册-30-08" class="headerlink" title="5-2 项目：实现登录和注册 (30:08)"></a>5-2 项目：实现登录和注册 (30:08)</h3><p>后台：</p><pre><code class="javascript">/*login.js*/const http = require(&quot;http&quot;);const url = require(&quot;url&quot;);const querystring = require(&quot;querystring&quot;);const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);let user = {    admin: &quot;123456&quot;};http.createServer(((req, res) =&gt; {    // 获取数据    let uri, get, post;    if (req.method === &quot;GET&quot;) {        let {pathname, query} = url.parse(req.url, true);        uri = pathname, get = query;        complete();    } else if (req.method === &quot;POST&quot;) {        let arr = [];        uri = req.url;        req.on(&quot;data&quot;, buffer =&gt; {            arr.push(buffer);        });        req.on(&quot;end&quot;, () =&gt; {            post = querystring.parse(Buffer.concat(arr).toString());            complete();        });    }    // 业务操作    // function complete() {}    // 设置状态码、编码    function setHead() {        res.writeHead(200, {            &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;        });    }})).listen(8888);</code></pre><p>页面：</p><pre><code class="html">&lt;!--login.html--&gt;&lt;form&gt;    用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; id=&quot;password&quot;&gt;&lt;br&gt;    &lt;button id=&quot;login&quot;&gt;登陆&lt;/button&gt;    &lt;button id=&quot;reg&quot;&gt;注册&lt;/button&gt;&lt;/form&gt;</code></pre><h2 id="第6章-课程回顾与总结"><a href="#第6章-课程回顾与总结" class="headerlink" title="第6章 课程回顾与总结"></a>第6章 课程回顾与总结</h2><h3 id="6-1-总结扩展-11-45"><a href="#6-1-总结扩展-11-45" class="headerlink" title="6-1 总结扩展 (11:45)"></a>6-1 总结扩展 (11:45)</h3><p>作用：</p><ol><li>写Web API</li><li>中间层</li><li>前端工程化的一些工具（webpack、gulp）</li></ol><p>优势：</p><ol><li>性能高</li><li>便于前端入手</li></ol><p>npm命令：</p><blockquote><p>package.json</p></blockquote><pre><code class="shell">npm i xxxnpm un xxx</code></pre><p>三大模块</p><ol><li>全剧模块</li><li>系统模块 require引入</li><li>自定义模块 自己封装 module.export</li></ol><p><strong>重点：http模块</strong></p><pre><code class="javascript">http.createServer((req, res) =&gt; {    // ...})</code></pre><p>数据通信：</p><ol><li><p>GET请求</p><ul><li><p>url模块</p><pre><code class="javascript">url.parse(req.url, true);</code></pre></li></ul></li><li><p>POST请求</p></li></ol><ul><li><pre><code class="javascript">let arr = [];req.on(&quot;data&quot;, buffer =&gt; {    arr.push(buffer);   // ...});req.on(&quot;end&quot;, () =&gt; {    Buffer.concat(arr).toString();});querystring.parse(req.url); // username=tuyrk&amp;password=123</code></pre></li></ul><p><strong>登陆、注册</strong></p><p>接口API、设计API</p><ul><li><p>GET ‘/login’</p></li><li><p>参数：username,password string object</p></li><li><p>返回值：</p><pre><code class="json">{  err: 0,  msg: &quot;xxx&quot;}</code></pre></li></ul><p>深入学习：express/koa2、MongoDB</p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115-Thread中断Interrupt方法详细讲解</title>
      <link href="/2019/11/14/115-thread-interrupt/"/>
      <url>/2019/11/14/115-thread-interrupt/</url>
      
        <content type="html"><![CDATA[<ul><li><p>interrupt()</p><p>中断此线程</p></li><li><p>interrupted()</p><p>测试<strong>当前线程</strong>是否已被中断。</p></li><li><p>isInterrupted()</p><p>测试<strong>此线程</strong>是否已被中断。</p></li></ul><p><code>interrupt()</code>仅仅是修改interrupt的状态。必须是<code>wait()</code>、<code>join()</code>、<code>sleep()</code>的时候才会抛出异常中断线程。</p><pre><code class="java">Thread t1 = new Thread(&quot;t1&quot;) {    @Override    public void run() {        while (true) {            //// todo.        }    }};t1.start();// start之后处于runnable，并不一定马上就会running。所以设置短暂休眠等待t1启动Thread.sleep(100);System.out.println(t1.isInterrupted());t1.interrupt();System.out.println(t1.isInterrupted());</code></pre><ol><li><p>线程状态改变，不会捕获到打断信号</p><pre><code class="java">System.out.println(&quot;&gt;&gt;&quot; + this.isInterrupted());</code></pre></li><li><p><code>sleep()</code>。线程状态改变，且捕获到打断信号</p><pre><code class="java">try {    Thread.sleep(1_000);} catch (InterruptedException e) {    System.out.println(&quot;收到打断信号。&quot;);    e.printStackTrace();}</code></pre></li><li><p><code>wait()</code>。线程状态改变，且捕获到打断信号</p><p>使用<code>wait()</code>必须给一个monitor，monitor需使用synchronized包裹。</p><pre><code class="java">private static final Object MONITOR = new Object();</code></pre><pre><code class="java">synchronized (MONITOR) {    try {        MONITOR.wait(1_000);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre></li><li><p><code>join()</code>。线程状态改变，且捕获到打断信号</p><p>注意：<code>t3.join();</code>这里join的不是t3线程，而是main线程。所以需要对main线程进行<code>interrupt()</code></p><pre><code class="java">Thread t3 = new Thread(() -&gt; {    while (true) {}}, &quot;t3&quot;);t3.start();Thread main = Thread.currentThread();Thread t31 = new Thread(() -&gt; {    try {        Thread.sleep(100);    } catch (InterruptedException e) {        e.printStackTrace();    }    main.interrupt();});t31.start();try {    // 这里join的不是t3线程，而是main线程    t3.join();} catch (InterruptedException e) {    e.printStackTrace();}</code></pre></li></ol><p>非静态<code>isInterrupted()</code>和静态<code>interrupted()</code>区别：</p><ul><li><p>在实现Runnable接口创建任务实例时，<code>isInterrupted()</code>将不能被获取</p><pre><code class="java">Thread t2 = new Thread(() -&gt; {    while (true) {        synchronized (MONITOR) {            try {                MONITOR.wait(1_000);            } catch (InterruptedException e) {                // 获取不到isInterrupted()                // System.out.println(&quot;wait()-&gt;&quot; + isInterrupted());                System.out.println(&quot;wait()-&gt;&quot; + Thread.interrupted());                e.printStackTrace();            }        }    }}, &quot;t2&quot;);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>114-Thread的join方法详细介绍，结合一个典型案例</title>
      <link href="/2019/11/13/114-thread-join/"/>
      <url>/2019/11/13/114-thread-join/</url>
      
        <content type="html"><![CDATA[<p><code>join()</code>方法</p><blockquote><p>调用线程一直等待被调用线程的执行，直到被调用线程死亡。</p></blockquote><pre><code class="java">Thread t1 = new Thread(() -&gt; {    IntStream.range(1, 1000).forEach(i -&gt;            System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i)    );}, &quot;t1&quot;);t1.start();t1.join();IntStream.range(1, 1000).forEach(i -&gt;        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</code></pre><p>注：<code>join()</code>必须放在<code>start()</code>之后。</p><pre><code class="java">Thread t1 = new Thread(() -&gt; {    IntStream.range(1, 9000).forEach(i -&gt;            System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i)    );}, &quot;t1&quot;);Thread t2 = new Thread(() -&gt; {    IntStream.range(1, 9000).forEach(i -&gt;            System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i)    );}, &quot;t2&quot;);t1.start();t2.start();t1.join();t2.join();Optional.of(&quot;All of tasks finish done.&quot;).ifPresent(System.out::println);IntStream.range(1, 1000).forEach(i -&gt;        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</code></pre><p>注意：</p><ul><li><p>t1、t2交替执行</p><pre><code class="java">t1.start();t2.start();t1.join();t2.join();</code></pre></li><li><p>先执行t1，在执行t2。此时t1加入join，t2还没启动。</p><pre><code class="java">t1.start();t1.join();t2.start();t2.join();</code></pre></li></ul><p>问题：一些嵌入式的HTTP Server，比如jetty，为什么把任务启动，一会之后会自动挂掉？<br>原因：在主线程退出之后会把http server挂掉（守护线程），避免占用端口、浪费资源。<br>解决：使用<code>Thread.currentThread().join();</code>。让当前线程执行，直到当前线程死掉</p><pre><code class="java">public static void main(String[] args) {    // 一直等待main线程结束,直到main线程结束。    // 结果main线程一直运行。    Thread.currentThread().join();}</code></pre><p>例：采集服务器节点的信息的例子。</p><p>问题：多个线程如何得到唯一的采集结束时间？</p><p>提示：使用<code>join()</code>方法</p><pre><code class="java">public class ThreadJoin3 {    public static void main(String[] args) throws InterruptedException {        long startTimestamp = System.currentTimeMillis();        // 假设有三台机器，开启三个线程。        Thread m1 = new Thread(new CaptureRunnable(&quot;M1&quot;, 10_000L));        Thread m2 = new Thread(new CaptureRunnable(&quot;M2&quot;, 30_000L));        Thread m3 = new Thread(new CaptureRunnable(&quot;M3&quot;, 15_000L));        m1.start();m2.start();m3.start();        m1.join();m2.join();m3.join();        long endTimestamp = System.currentTimeMillis();        System.out.printf(&quot;Save data begin timestamp is %s, end timestamp is %s\n&quot;, startTimestamp, endTimestamp);        System.out.printf(&quot;Spend time is %s&quot;, endTimestamp - startTimestamp);    }}/** * 采集服务器节点的任务。 */@Dataclass CaptureRunnable implements Runnable {    // 机器节点的名称    private String machineName;    // 采集花费时间    private long spendTime;    public CaptureRunnable(String machineName, long spendTime) {        this.machineName = machineName;        this.spendTime = spendTime;    }    @Override    public void run() {        // do the really capture data.        Thread.sleep(spendTime);        System.out.printf(machineName + &quot; completed data capture at timestamp [%s] and successful.\n&quot;, System.currentTimeMillis());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>113-线程ID，优先级讲解</title>
      <link href="/2019/11/13/113-thread-id-priority/"/>
      <url>/2019/11/13/113-thread-id-priority/</url>
      
        <content type="html"><![CDATA[<p>Thread中一些简单的API</p><pre><code class="java">Thread t1 = new Thread(() -&gt; {    Optional.of(&quot;Hello&quot;).ifPresent(System.out::println);    try {        Thread.sleep(1_000);    } catch (InterruptedException e) {        e.printStackTrace();    }}, &quot;t1&quot;);</code></pre><pre><code class="java">// 线程名称。Optional.of(t1.getName()).ifPresent(System.out::println);// 线程ID。++threadSeqNumberOptional.of(t1.getId()).ifPresent(System.out::println);// 线程优先级，默认为5.Optional.of(t1.getPriority()).ifPresent(System.out::println);</code></pre><p>线程优先级范围是1-10，默认为5，通过修改线程优先级可以企图改变线程的执行顺序。</p><p>线程不一定会按照指定的优先级执行。</p><pre><code class="java">Thread.MAX_PRIORITY// 最高优先级，10Thread.NORM_PRIORITY// 默认优先级，5Thread.MIN_PRIORITY// 最低优先级，1</code></pre><p>线程t1、t2、t3交替运行。</p><pre><code class="java">Thread t1 = new Thread(() -&gt; {    for (int i = 0; i &lt; 1000; i++) {        Optional.of(Thread.currentThread().getName() + &quot;-Index-&quot; + i).ifPresent(System.out::println);    }}, &quot;t1&quot;);t1.setPriority(Thread.MAX_PRIORITY);Thread t2 = new Thread(() -&gt; {    for (int i = 0; i &lt; 1000; i++) {        Optional.of(Thread.currentThread().getName() + &quot;-Index-&quot; + i).ifPresent(System.out::println);    }}, &quot;t2&quot;);t2.setPriority(Thread.NORM_PRIORITY);Thread t3 = new Thread(() -&gt; {    for (int i = 0; i &lt; 1000; i++) {        Optional.of(Thread.currentThread().getName() + &quot;-Index-&quot; + i).ifPresent(System.out::println);    }}, &quot;t3&quot;);t3.setPriority(Thread.MIN_PRIORITY);t1.start();t2.start();t3.start();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112-Daemon线程的创建以及使用场景分析</title>
      <link href="/2019/11/13/112-daemon/"/>
      <url>/2019/11/13/112-daemon/</url>
      
        <content type="html"><![CDATA[<p>Runnable不是线程，它只是一个接口，只是一个任务执行单元。它的作用是把线程控制和业务逻辑分开。真正代表线程的只有Thread。</p><p>ThreadGroup的好处：可以统一管理Thread线程。</p><p>在JDK1.7之后可以将数据<code>10000</code>写为<code>10_000</code></p><ol><li><p>main线程此时逻辑单元已经结束，为什么还没有退出程序呢？</p><p>因为此时ThreadGroup中还有线程Thread-0处于active状态。</p><pre><code class="java">public class DeamonThread {    public static void main(String[] args) throws InterruptedException {        // new        Thread t = new Thread() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName() + &quot; running&quot;);                Thread.sleep(1_000_000);                System.out.println(Thread.currentThread().getName() + &quot; done&quot;);            }        };        // runnable -&gt; running| -&gt; blocked -&gt; dead        t.start();        System.out.println(Thread.currentThread().getName());    }}</code></pre></li><li><p><code>t.setDaemon(true);</code>在main结束后自动结束所有线程</p><p>守护线程Daemon有什么作用呢？</p><blockquote><p>例：建立网络连接。<br>从A到B建立了一个长连接，长连接在一定间隔时间会发送心跳包以证明连接是可用的。比如A为客户端，B为服务器，A不断向B发送心跳包，B向A返回心跳响应。<br>当前工作线程创建了一个连接后，要维护这个长连接，但是当前工作线程的业务逻辑、发送数据等操作与维护连接并没有关系，此时就可以创建一个守护线程daemonThread来进行心跳检测工作。<br>当工作线程已经结束工作而死亡，非守护线程并不会自动死亡，而此时再去进行长连接心跳检测并没有任何意义，所以将其设置为守护线程可以在工作线程死亡时自动死亡。</p></blockquote></li></ol><p>思考：</p><ol><li><p>在非守护线程A里创建守护线程B，当线程A结束后，线程B会自动结束么？</p><p>线程B会自动结束</p></li><li><p>在非守护线程A里创建非守护线程B，当线程A结束后，线程B会自动结束么，JVM可以正常退出么？</p><p>线程B不会自动结束，仍然在运行。</p></li><li><p>在守护线程A里创建守护线程B，当线程A结束后，线程B会自动结束么？</p><p>会。</p></li><li><p>在守护线程A里创建非守护线程B，当线程A结束后，线程B会自动结束么，JVM可以正常退出么？</p><p>会。</p><pre><code class="java">Thread thread = new Thread(() -&gt; {    Thread innerThread = new Thread(() -&gt; {        while (true) {            System.out.println(&quot;innerThread do something for health check.&quot;);            Thread.sleep(1_000);        }    }, &quot;innerThread&quot;);    // innerThread.setDaemon(true);    innerThread.start();    Thread.sleep(1_000);    System.out.println(&quot;thread finish done.&quot;);}, &quot;thread&quot;);// innerThread.setDaemon(true);thread.start();</code></pre></li></ol><p>总结：</p><ol><li>线程默认为非守护线程。其实main线程也就是非守护线程。</li><li>当仅运行的所有线程都是守护程序线程时，Java虚拟机将退出。 </li></ol><p>注意：必须在线程<code>start()</code>启动之前调用<code>setDaemon()</code>方法。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111-Thread构造函数StackSize详细讲解-续</title>
      <link href="/2019/11/13/111-thread-stacksize2/"/>
      <url>/2019/11/13/111-thread-stacksize2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</p></blockquote><p>默认的stackSize是多大呢？</p><ul><li>JDK源码中stackSize默认为0，代表该变量值被忽略。把传入的stackSize赋值给类变量，然后在代码中未找到引用，可能是在JVM中被引用了。</li></ul><p>构造Thread的时候传入stackSize代表着该线程占用的stack的大小。如果没有指定stackSize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI函数去使用。需要注意：该参数在某些平台（操作系统）可能无效。通过JVM参数显式设置：<code>-Xss10M</code></p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110-Thread构造函数StackSize详细讲解</title>
      <link href="/2019/11/12/110-thread-stacksize1/"/>
      <url>/2019/11/12/110-thread-stacksize1/</url>
      
        <content type="html"><![CDATA[<p>不要过分压榨应用的性能，应用服务压力建议最大达到应用性能峰值的80%。超过80%可以通过横向扩展应用以减缓压力。现在分布式应用那么普遍。</p><p>验证：JVM启动时创建的栈空间不变，由于线程的栈空间占用了很大虚拟机栈内存，所以在main主线程里，JVM能允许创建的线程数也会相应减少。</p><pre><code class="java">public class CreateThread5 {    private static int counter = 0;    public static void main(String[] args) {        try {            // 不断循环创建Thread            for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {                counter++;                // 1. 默认stackSize。                /*new Thread(() -&gt; {                    // 增大栈针的宽度                    byte[] data = new byte[1024 * 1024 * 2];                    while (true) {}                }).start();*/                // 2. 修改stackSize。                new Thread(null, () -&gt; {                    // 增大栈针的宽度                    byte[] data = new byte[1024 * 1024 * 2];                    while (true) {}                }, &quot;stackSizeTest&quot;, 1 &lt;&lt; 32).start();            }        } catch (Error e) {            e.printStackTrace();        }        System.out.println(&quot;Total create thread nums =&gt; &quot; + counter);    }}</code></pre><p>输出结果：</p><ol><li><p>默认stackSize。</p><pre><code class="shell">java.lang.OutOfMemoryError: unable to create new native thread    at java.lang.Thread.start0(Native Method)    at java.lang.Thread.start(Thread.java:717)    at com.tuyrk.chapter03.CreateThread5.main(CreateThread5.java:28)Total create thread nums =&gt; 4060</code></pre></li><li><p>stackSize = 1 &lt;&lt; 32</p><pre><code class="shell">java.lang.OutOfMemoryError: unable to create new native thread    at java.lang.Thread.start0(Native Method)    at java.lang.Thread.start(Thread.java:717)    at com.tuyrk.chapter03.CreateThread5.main(CreateThread5.java:28)Total create thread nums =&gt; 4060</code></pre></li></ol><p>结论：<strong>有待考证。暂认不成立</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>109-多线程与JVM内存结构的关系，虚拟机栈实验</title>
      <link href="/2019/11/12/109-thread-with-memory/"/>
      <url>/2019/11/12/109-thread-with-memory/</url>
      
        <content type="html"><![CDATA[<p>Java内存结构-简：</p><ul><li>栈（非堆）</li><li>堆</li></ul><p>栈存储基本数据类型，引用类型</p><p>堆存储对象</p><p>Java内存结构</p><p>栈：</p><ul><li>方法区（线程共享）</li><li>虚拟机栈（线程私有）<ul><li>栈针（若干）：局部变量表、操作栈、动态链接库、方法出口/入口</li></ul></li><li>本地方法区C++：执行引擎、本地库接口<code>.so</code>、本地方法</li><li>程序计数器</li></ul><p>堆内存</p><ul><li>对象实体（栈只保存变量的引用）</li></ul><p>不断压栈操作将会导致栈溢出，从而程序崩溃并抛出<code>java.lang.StackOverflowError</code></p><ul><li><p>main主线程</p><pre><code class="java">/** * Java多线程与内存堆栈关系。虚拟机栈 */public class CreateThread3 {    private static int counter = 0;    // JVM will create a thread named &quot;main&quot;    public static void main(String[] args) {        // create a JVM stack        try {            add(0);        } catch (Error e) {            e.printStackTrace();// java.lang.StackOverflowError            System.out.println(counter);// 21325        }    }    private static void add(int i) {        counter++;        add(i + 1);    }}</code></pre></li><li><p>用户子线程</p><pre><code class="java">public class CreateThread4 {    private static int counter = 0;    public static void main(String[] args) {        Thread t = new Thread(new Runnable() {            @Override            public void run() {                try {                    add(0);                } catch (Error e) {                    e.printStackTrace();// java.lang.StackOverflowError                    System.out.println(counter);// 18455                }            }            private void add(int i) {                counter++;                add(i + 1);            }        });        t.start();    }}</code></pre></li></ul><p>通过stackSize构造方法改变线程的栈内存大小，避免抛出<code>java.lang.StackOverflowError</code>。<del>但是JVM启动时创建的栈空间不变，由于线程的栈空间占用了很大虚拟机栈内存，所以在main主线程里，JVM能允许创建的线程数也会相应减少。</del></p><pre><code class="java">public class CreateThread4 {    private static int counter = 0;    public static void main(String[] args) {        Thread t = new Thread(null, new Runnable() {            @Override            public void run() {                try {                    add(0);                } catch (Error e) {                    e.printStackTrace();                    System.out.println(counter);                }            }            private void add(int i) {                counter++;                add(i + 1);            }        }, &quot;stackSizeTest&quot;, 1 &lt;&lt; 24);        t.start();    }}</code></pre><p>扩展：</p><ol><li><p>编写一个抛出<code>java.lang.StackOverflowError</code>的例子</p></li><li><p>编写一个抛出<code>java.lang.OutOfMemoryError</code>的例子</p></li><li><p>JVM之–Java内存结构</p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/9747207" target="_blank" rel="noopener">JVM之–Java内存结构（第一篇）</a></p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/9751487" target="_blank" rel="noopener">JVM之—Java内存结构（第二篇）</a></p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/9774579" target="_blank" rel="noopener">JVM之—Java内存结构（第三篇）</a></p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/10044575" target="_blank" rel="noopener">JVM之—Java内存分配参数（第四篇）</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108-构造Thread对象你也许不知道的几件事</title>
      <link href="/2019/11/12/108-construct-thread/"/>
      <url>/2019/11/12/108-construct-thread/</url>
      
        <content type="html"><![CDATA[<p>构造函数：</p><ul><li>构造方法没有传入ThreadGroup，是否会创建默认的ThreadGroup</li><li>如果传入ThreadGroup为null，是否会使用其他默认的ThreadGroup</li><li>ThreadGroup和Thread之间的关系是什么</li><li>线程和栈的关系</li></ul><pre><code class="java">Thread()Thread(String name)Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name)Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></pre><ul><li><p>Thread()</p><p>创建线程对象Thread，默认有一个线程名，以Thread-开头，从0开始计数</p><pre><code class="java">Thread t1 = new Thread();</code></pre><p>如果在构造Thread的时候没有传递Runnable或者没有复写Thread的<code>run()</code>方法，该Thread将不会调用任何东西，如果传递了Runnable的实例，或者复写了Thread的<code>run()</code>方法，则会执行该方法的逻辑单元（逻辑代码）</p><pre><code class="java">Thread t2 = new Thread() {    @Override    public void run() {        System.out.println(&quot;================&quot;);    }};</code></pre><p>如果构造线程对象时未传入ThreadGroup，Thread会默认获取父线程的ThreadGroup作为该线程的ThreadGroup。此时子线程和父线程将会在同一个ThreadGroup中。</p><pre><code class="java">System.out.println(t1.getThreadGroup()); // mainSystem.out.println(Thread.currentThread().getName()); // mainSystem.out.println(Thread.currentThread().getThreadGroup().getName()); // main</code></pre><p>通过ThreadGroup对象可以获得该线程组中有多少个线程</p><pre><code class="java">ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();Thread[] threads = new Thread[threadGroup.activeCount()];threadGroup.enumerate(threads);Arrays.stream(threads).forEach(System.out::println);// main,Thread-0,Monitor</code></pre></li><li><p>Thread(String name)</p><pre><code class="java">Thread t3 = new Thread(&quot;MyName&quot;);</code></pre></li><li><p>Thread(Runnable target)</p><pre><code class="java">Thread t4 = new Thread(() -&gt; {    System.out.println(&quot;Runnable...&quot;);});</code></pre></li><li><p>Thread(Runnable target, String name)</p><pre><code class="java">Thread t5 = new Thread(() -&gt; {    System.out.println(&quot;Runnable...&quot; + Thread.currentThread().getName());}, &quot;RunnableThread&quot;);</code></pre></li><li><p>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</p><p>stackSize：The stack size is the approximate number of bytes of address space that the virtual machine is to allocate for this thread’s stack.<strong>The effect of the <code>stackSize</code> parameter, if any, is highly platform dependent.On some platforms, the value of the <code>stackSize</code> parameter may have no effect whatsoever.</strong></p><p>构造Thread的时候传入stackSize代表着该线程占用的stack的大小。如果没有指定stackSize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI函数去使用。需要注意：该参数在某些平台（操作系统）可能无效。通过JVM参数显式设置：<code>-Xss10M</code></p><pre><code class="java">Thread t = new Thread(null, new Runnable() {    @Override    public void run() {        try {            add(0);        } catch (Error e) {            e.printStackTrace();            System.out.println(counter);        }    }    private void add(int i) {        counter++;        add(i + 1);    }}, &quot;stackSizeTest&quot;, 1 &lt;&lt; 24);</code></pre></li></ul><p><strong>总结</strong>：</p><ol><li>创建线程对象Thread，默认有一个线程名，以Thread-开头，从0开始计数</li><li>如果在构造Thread的时候没有传递Runnable或者没有复写Thread的<code>run()</code>方法，该Thread将不会调用任何东西，如果传递了Runnable的实例，或者复写了Thread的<code>run()</code>方法，则会执行该方法的逻辑单元（逻辑代码）</li><li>如果构造线程对象时未传入ThreadGroup，Thread会默认获取父线程的ThreadGroup作为该线程的ThreadGroup。此时子线程和父线程将会在同一个ThreadGroup中。</li><li>构造Thread的时候传入stackSize代表着该线程占用的stack的大小。如果没有指定stackSize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI函数去使用。需要注意：该参数在某些平台（操作系统）可能无效。通过JVM参数显式设置：<code>-Xss10M</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>107-策略模式在Thread和Runnable中的应用分析</title>
      <link href="/2019/11/12/107-Strategy-in-thread/"/>
      <url>/2019/11/12/107-Strategy-in-thread/</url>
      
        <content type="html"><![CDATA[<p>Runnable接口与多线程中的哪种设计模式比较接近？</p><ul><li>策略模式</li></ul><p>举例：税收计算器。需多看代码示例，深入理解策略模式。</p><pre><code class="java">@FunctionalInterfacepublic interface CalculatorStrategy {    /**     * @param salary 薪水     * @param bonus 奖金     * @return 税收     */    double calculate(double salary, double bonus);}</code></pre><pre><code class="java">/** * 计算税率：工资*0.1 + 奖金*0.15 */public class SimpleCalculatorStrategy implements CalculatorStrategy {    private final static double SALARY_RATE = 0.1;    private final static double BONUS_RATE = 0.15;    @Override    public double calculate(double salary, double bonus) {        return salary * SALARY_RATE + bonus * BONUS_RATE;    }}</code></pre><pre><code class="java">/** * 税务计算器。Runnable与多线程设计模式 */@Datapublic class TaxCalculator {    // 薪水    private final double salary;    // 奖金    private final double bonus;    private CalculatorStrategy calculatorStrategy;    public TaxCalculator(double salary, double bonus) {        this.salary = salary;        this.bonus = bonus;    }    public TaxCalculator(double salary, double bonus, CalculatorStrategy calculatorStrategy) {        this.salary = salary;        this.bonus = bonus;        this.calculatorStrategy = calculatorStrategy;    }    // 计算税率    protected double calcTax() {        return calculatorStrategy.calculate(salary, bonus);    }    // 计算    public double calculate() {        return this.calcTax();    }}</code></pre><pre><code class="java">/** * 计算税率：工资*0.1 + 奖金*0.15 */public class TaxCalculatorMain {    public static void main(String[] args) {        // 1. 模版方法        /*TaxCalculator calculator = new TaxCalculator(10000d, 2000d) {            @Override            protected double calcTax() {                return getSalary() * 0.1 + getBonus() * 0.15;            }        };        System.out.println(calculator.calculate());*/        // 2.1 策略模式        /*TaxCalculator calculator = new TaxCalculator(10000d, 2000d);        CalculatorStrategy strategy = new SimpleCalculatorStrategy();        calculator.setCalculatorStrategy(strategy);        System.out.println(calculator.calculate());*/        // 2.2 策略模式-Java8Lambda        /*TaxCalculator calculator = new TaxCalculator(10000d, 2000d);        calculator.setCalculatorStrategy((s, b) -&gt; s * 0.1 + b * 0.15);        System.out.println(calculator.calculate());*/        TaxCalculator calculator = new TaxCalculator(10000d, 2000d, (s, b) -&gt; s * 0.1 + b * 0.15);        System.out.println(calculator.calculate());    }}</code></pre><p>通过策略模式的思想改造<code>BankRunnable.java</code></p><pre><code class="java">/** * 银行大厅 */public class BankRunnable {    private final static int MAX = 50;    private int index = 1;    public static void main(String[] args) {        // 1. 一个runnable实例被多个线程共享        /*TicketWindowRunnable ticketWindow = new TicketWindowRunnable();*/        // 2. 策略模式思想改造runnable实例线程        Runnable ticketWindow = new BankRunnable().getTicketWindow();        Thread windowThread1 = new Thread(ticketWindow, &quot;一号窗口&quot;);        Thread windowThread2 = new Thread(ticketWindow, &quot;二号窗口&quot;);        Thread windowThread3 = new Thread(ticketWindow, &quot;三号窗口&quot;);        windowThread1.start();        windowThread2.start();        windowThread3.start();    }    private Runnable getTicketWindow() {        return () -&gt; {            while (index &lt;= MAX) {                System.out.println(Thread.currentThread() + &quot; 的号码是:&quot; + (index++));                Thread.sleep(100);            }        };    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>106-用Runnable接口将线程的逻辑执行单元从控制中抽取出来</title>
      <link href="/2019/11/12/106-runnable-bank-queue/"/>
      <url>/2019/11/12/106-runnable-bank-queue/</url>
      
        <content type="html"><![CDATA[<p>课程目标：</p><ul><li><p><strong>让业务数据和线程逻辑分离</strong>。Runnable。@FunctionalInterface</p><p><code>run()</code>方法为线程的逻辑代码块</p></li></ul><pre><code class="java">/** * 叫号机。继承Runnable接口 */public class TicketWindowRunnable implements Runnable {    private int index = 1;    private static final int MAX = 50;    @Override    public void run() {        while (index &lt;= MAX) {            System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));        }    }}</code></pre><pre><code class="java">/** * 银行大厅，柜台，业务处理窗口。 */public class BankRunnable {    public static void main(String[] args) {        TicketWindowRunnable ticketWindow1 = new TicketWindowRunnable();        Thread windowThread1 = new Thread(ticketWindow1, &quot;一号窗口&quot;);        Thread windowThread2 = new Thread(ticketWindow1, &quot;二号窗口&quot;);        Thread windowThread3 = new Thread(ticketWindow1, &quot;三号窗口&quot;);        windowThread1.start();        windowThread2.start();        windowThread3.start();    }}</code></pre><p>不管定义多少个线程，业务逻辑的数据实例只有一个，不像Thread类中业务逻辑数据和线程混淆在一起，每一次<code>new Thread()</code>就会新创建一份业务逻辑数据。</p><p>三个线程使用同一份业务数据实例，此时很有可能发生数据安全问题。比如，将MAX=1，可能有以下输出：</p><pre><code class="shell">一号窗口 的号码是：1二号窗口 的号码是：2</code></pre><p>想一想Runnable接口与多线程中的哪种设计模式比较接近？</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105-采用多线程方式模拟银行排队叫号</title>
      <link href="/2019/11/12/105-thread-bank-queue/"/>
      <url>/2019/11/12/105-thread-bank-queue/</url>
      
        <content type="html"><![CDATA[<p>课程目标：</p><ul><li>通过继承Thread类实现线程的创建</li><li>并且知道使用Runnable的必要性，使用它的原因是什么。</li></ul><p>案例：</p><blockquote><p>实现银行排队叫号功能（粗糙版）。银行有多个柜台，当一个人需要去办理业务的时候，先到叫号机上领取一个号码。当银行柜员处理完成当前客户就会使用叫号器呼叫下一位客户到窗口办理业务。</p></blockquote><pre><code class="java">/** * 叫号机。实现Thread类 */public class TicketWindowThread extends Thread {    private final String name;    private static final int MAX = 50;    private static int index = 1;    public TicketWindowThread(String name) {        this.name = name;    }    @Override    public void run() {        // 当当前号码数小于最大号码时，进行售票操作        while (index &lt;= MAX) {            System.out.println(&quot;柜台：&quot; + name + &quot;，当前的号码是：&quot; + (index++));        }    }}</code></pre><pre><code class="java">/** * 银行大厅，柜台，业务处理窗口 */public class BankThread {    public static void main(String[] args) {        TicketWindowThread ticketWindow1 = new TicketWindowThread(&quot;一号柜台&quot;);        ticketWindow1.start();        TicketWindowThread ticketWindow2 = new TicketWindowThread(&quot;二号柜台&quot;);        ticketWindow2.start();        TicketWindowThread ticketWindow3 = new TicketWindowThread(&quot;三号柜台&quot;);        ticketWindow3.start();    }}</code></pre><p>此时三个线程出现的结果是：线程线程分别执行0-50号，拥有独立的index，并没有达到三个线程共同使用一个index的效果。</p><p>怎们达到共享index变量，使用同一份资源的效果呢？</p><ol><li><p>给index设置为静态变量static。此时始终只会实例化一次。</p><p>使用static实现了共享变量的效果，但是static也有一个问题。就是static生命周期较长，伴随JVM的启动，一直到销毁；从类加载就会开始存在，即使是类实例销毁之后也不会销毁，static不是在类中堆栈空间的信息，它有自己独立的一份存储空间。<a href="https://www.cnblogs.com/hf-cherish/p/4970267.html" target="_blank" rel="noopener">java 静态变量生命周期（类生命周期）</a></p></li></ol><p>本节通过继承Thread类实现了多线程方式模拟银行排队叫号的粗糙版，接下来将会实现比较友好的银行排队叫号功能，<strong>把业务和线程分离出来</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104-线程生命周期以及start方法源码剖析</title>
      <link href="/2019/11/11/104-thread-lifecycle/"/>
      <url>/2019/11/11/104-thread-lifecycle/</url>
      
        <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8u9nc9l7qj30y20fewgo.jpg" alt="线程生命周期简图" style="zoom:50%;" /><p>线程生命周期共有6种状态：</p><ol><li><p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</p></li><li><p>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br> 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p></li><li><p>阻塞(BLOCKED)：表示线程阻塞于锁。</p></li><li><p>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p></li><li><p>终止(TERMINATED)：表示该线程已经执行完毕。</p> <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8uagny1khj30w30lf0tx.jpg" alt="线程状态图" style="zoom:80%;" /> <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8uafgd9wbj30sx0eejrw.jpg" alt="线程生命周期" style="zoom:80%;" /></li></ol><p><code>start()</code></p><blockquote><pre><code class="java">public void start()</code></pre><p>Causes this thread to begin execution; the Java Virtual Machine calls the <code>run</code> method of this thread.</p><p>The result is that two threads are running concurrently: the current thread (which returns from the call to the <code>start</code> method) and the other thread (which executes its <code>run</code> method).</p><p><strong>It is never legal to start a thread more than once.</strong> In particular, a thread may not be restarted once it has completed execution.</p></blockquote><ul><li>程序启动会创建两个线程：main主线程、run用户子线程</li><li><code>start()</code>不能被执行两次：IllegalThreadStateException</li></ul><p>不执行<code>start()</code>方法，而直接执行<code>run()</code>方法，此时没有启动线程，只是调用了一个实例方法而已。这是使用了模版方法的技巧。</p><pre><code class="java">Thread t1 = new Thread(&quot;READ-Thread&quot;) {  @Override  public void run() {    println(Thread.currentThread().getName());    readFromDataBase();  }};t1.run();</code></pre><p>此时输出的线程名称为：<code>main</code></p><p>模版方法：</p><p>例：在实际程序中，算法已经基本固定，但是其中有一些逻辑可能是多变的，此时将其抽象出去并让子类去实现。</p><pre><code class="java">public abstract class BaseTemplateMethod {    public static void main(String[] args) {        BaseTemplateMethod t1 = new BaseTemplateMethod() {            @Override            protected void wrapPrint(String message) {                System.out.println(&quot;*&quot; + message + &quot;*&quot;);            }        };        t1.print(&quot;Hello Thread&quot;);        BaseTemplateMethod t2 = new BaseTemplateMethod() {            @Override            protected void wrapPrint(String message) {                System.out.println(&quot;+&quot; + message + &quot;+&quot;);            }        };        t2.print(&quot;Hello Thread&quot;);    }    public final void print(String message) {        System.out.println(&quot;#####################&quot;);        wrapPrint(message);        System.out.println(&quot;#####################&quot;);    }    protected abstract void wrapPrint(String message);}</code></pre><p>注：真正的Template方法需要写成抽象类，并把<code>print()</code>方法写成<code>final</code>方法（必须为<code>final</code>方法），<code>wrapPrint()</code>方法写成抽象方法。</p><p>总结：</p><ol><li>Java应用程序的main函数是一个线程，是被JVM启动的时候调用，线程的名字叫main</li><li>实现一个线程必须创建Thread实例，override重写<code>run()</code>方法，并且调用<code>start()</code>方法</li><li>在JVM启动后，实际上有多个线程，但是至少有一个非守护线程（main线程）</li><li>当你调用一个线程的<code>start()</code>方法的时候，此时至少有两个线程，一个是调用你的线程（main方法），还有一个是执行<code>run()</code>方法的线程</li><li>线程的生命周期分为：New、Runnable、Running、Block、Terminate</li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103-创建并启动线程</title>
      <link href="/2019/11/11/103-create-thread/"/>
      <url>/2019/11/11/103-create-thread/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * 读数据 */private static void readFromDataBase() {    // read data from database and handle it    try {        println(&quot;Begin read data from db.&quot;);        Thread.sleep(1000 * 5L);        println(&quot;Read data done and start handle it.&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }    println(&quot;The data handle finish and successfully.&quot;);}</code></pre><pre><code class="java">/** * 写数据 */private static void writeDataToFile() {    // write data to file    try {        println(&quot;Begin write data to file.&quot;);        Thread.sleep(1000 * 10L);        println(&quot;Write data done and start handle it.&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }    println(&quot;The data handle finish and successfully.&quot;);}</code></pre><ol><li><p>顺序执行，而非交替执行</p><pre><code class="java">// 例1readFromDataBase();writeDataToFile();// 例2for (int i = 0; i &lt; 100; i++) {    println(&quot;Task i=&gt;&quot; + i);}for (int j = 0; j &lt; 100; j++) {    println(&quot;Task j=&gt;&quot; + j);}</code></pre></li><li><p>交替执行</p><pre><code class="java">Thread t1 = new Thread(&quot;Custom-Thread&quot;) {    @Override    public void run() {        for (int i = 0; i &lt; 100; i++) {            println(&quot;Task i=&gt;&quot; + i);            try {                Thread.sleep(1000 * 1L);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }};t1.start();for (int j = 0; j &lt; 100; j++) {    println(&quot;Task j=&gt;&quot; + j);}</code></pre><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8u68chvj9j30p00kwgnk.jpg" alt="Custom-Thread线程情况" style="zoom:50%;" /></li><li><p>交替执行读写操作</p><pre><code class="java">new Thread(&quot;READ-Thread&quot;) {    @Override    public void run() {        readFromDataBase();    }}.start();new Thread(&quot;WRITE-Thread&quot;) {    @Override    public void run() {        writeDataToFile();    }}.start();</code></pre></li></ol><ul><li><p>创建线程后不调用<code>start()</code>方法，此时他是一个线程么？</p><p>不是。涉及到线程的生命周期。Thread被new出来之后只是一个Java实例，和其他普通Java实例一模一样。只有<code>.start()</code>启动之后才会变为一个线程，而且启动是立即返回的，不是BLOCKED阻塞。</p></li></ul><p>JDK文档：<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p><p>查看<code>java.lang.Thread</code></p><p>A <em>thread</em> is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</p><p>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon.</p><p>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named <code>main</code> of some designated class).</p><p>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of <code>Thread</code>. This subclass should override the <code>run</code> method of class <code>Thread</code>. An instance of the subclass can then be allocated and started. </p><p>验证启动程序后JVM会自动创建main线程：</p><ol><li><p>编写程序并运行</p><pre><code class="java">public static void main(String[] args) {    try {        Thread.sleep(1000 * 100L);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre></li><li><p>显示当前所有Java进程pid</p><pre><code class="shell">jps</code></pre></li><li><p>基于JMX的可视化监视、管理工具。实时的监控Java程序在运行过程中的内存、CPU、线程的使用情况，并可以对加载的相关类进行分析</p><pre><code class="shell">jconsole &lt;thread_pid&gt;</code></pre><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8u5g8s2ucj30p00kumz4.jpg" a lt="jconsole查看线程" style="zoom:50%;" /></li><li><p>总结：</p><p>JVM启动时：</p><ul><li>非守护线程：<code>main()</code>整个程序的入口。</li><li>守护线程：<code>Finalizer()</code>垃圾回收器、<code>Reference Handler</code>引用具柄、<code>Signal Dispatcher</code>接收系统信号命令、JMX、RMI</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102-简单介绍什么是线程</title>
      <link href="/2019/11/11/102-what-is-thread/"/>
      <url>/2019/11/11/102-what-is-thread/</url>
      
        <content type="html"><![CDATA[<p>课程大纲：</p><ol><li>线程介绍</li><li>创建并启动线程</li><li>线程的生命周期</li><li>Runnable接口介绍</li><li>Thread API详细介绍</li><li>线程同步，锁技术</li><li>如何优雅的停止线程</li><li>线程间通讯</li><li>线程组详细介绍</li><li>线程池原理以及实现一个简单的线程池</li><li>线程异常捕获以及线程堆栈信息详细讲解</li><li>FIFO队列以及多线程环境下的运行</li><li>BoolenLock锁实现</li><li>常用设计模式在多线程环境下的使用</li><li>查缺补漏</li></ol><p>其他课程：</p><ol><li>PowerMock实战视频（10集）</li><li>Concordion实战视频（10集）</li><li>Apache Sqoop实战视频（12集）</li><li>Apache Flume实战视频（42集）</li><li>Java 8 实战视频（40集）</li><li>Scala实战视频（160集）</li></ol><p>进程-线程-协程</p><p>线程（Thread）是操作系统能够进行运算调度的最小单位，是独立调度和分派的基本单位。它被包含在进程之中，是进程中的实际运作单位。</p><p>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在单个程序中同时运行多个线程完成不同的工作，成为多线程。</p><p>并行：多核操作系统中，一个CPU执行一个线程</p><p>并发：程序同时（时间段非时间点）执行多个线程，有线程上下文切换</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101-课程大纲及主要内容介绍</title>
      <link href="/2019/11/11/101-syllabus/"/>
      <url>/2019/11/11/101-syllabus/</url>
      
        <content type="html"><![CDATA[<ol><li>Java多线程介绍</li><li>多线程编程入门</li><li>线程创建与启动以及线程状态</li><li>Runnable接口详细详解</li><li>线程优先级以及守护线程详解</li><li>线程同步</li><li>线程间通讯</li><li>线程组详解</li><li>自运行对象详解</li><li>线程异常回调</li><li>线程池详解</li><li>等待线程完成任务</li><li>阻塞IO和多线程详解</li><li>如何优雅的结束线程</li><li>自定义线程锁详解</li><li>FIFO队列与线程</li><li>多线程API查漏补缺</li></ol><p>例子：</p><ol><li><p>需求：一个系统去采集其他所有服务器节点的IO、磁盘等连接情况。</p><p>分析：这里不可能去一个一个地采集，应该用到多线程。每一个线程采集一个服务器节点。每一轮采集完成都需要将数据写入到DB数据库。</p><p>总表：批次、采集开始时间，采集结束时间</p><p>详情表：节点ID，CPU、内存、IO、应用进程数等，关联ID</p><p>思考：</p><ul><li><p>多个线程如何得到唯一的采集结束时间？</p></li><li><p>如果服务器节点数目达到100台，那么则需要100个线程？此时系统会因为线程过多出现CPU、内存、系统资源分配不足而崩溃</p><p>始终保持20个线程去执行任务，每当一个线程执行完成任务，则新开启一个任务再去采集其他服务器节点</p></li><li><p>启动主线程如何知道子线程是否调用成功，回调。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100-Java多线程基础知识目录</title>
      <link href="/2019/11/11/100-catalog/"/>
      <url>/2019/11/11/100-catalog/</url>
      
        <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8szj5cfvoj31600sd11b.jpg" alt="Java并发编程" style="zoom:100%;" /><ol><li>课程大纲及主要内容介绍</li><li>简单介绍什么是线程</li><li>创建并启动线程</li><li>线程生命周期以及start方法源码剖析</li><li>采用多线程方式模拟银行排队叫号</li><li>用Runnable接口将线程的逻辑执行单元从控制中抽取出来</li><li>策略模式在Thread和Runnable中的应用分析</li><li>构造Thread对象你也许不知道的几件事</li><li>多线程与JVM内存结构的关系，虚拟机栈实验</li><li>Thread构造函数StackSize详细讲解</li><li>Thread构造函数StackSize详细讲解-续</li><li>Daemon线程的创建以及使用场景分析</li><li>线程ID，优先级讲解</li><li>Thread的join方法详细介绍，结合一个典型案例</li><li>Thread中断Interrupt方法详细讲解</li><li>采用优雅的方式结束线程生命周期</li><li>Thread API综合实战，编写ThreadService实现暴力结束线程的综合实战</li><li>数据同步的引入与Synchronized的简单介绍</li><li>结合jconsole,jstack以及汇编指令认识synchronized关键字</li><li>同步代码块以及同步方法之间的区别和关系</li><li>通过实验分析This锁的存在</li><li>通过实验分析Class锁的存在</li><li>多线程死锁分析，案例介绍</li><li>线程间通信快速入门，使用wait和notify进行线程间的数据通信</li><li>多Produce多Consume之间的通讯导致出现程序假死的原因分析</li><li>多线程下的生产者消费者模型，以及详细介绍notifyAll方法</li><li>wait和sleep的本质区别是什么，深入分析（面试常见问题）</li><li>线程生产者消费者的综合实战结合Java8语法</li><li>如何实现一个自己的显式锁Lock精讲上</li><li>如何实现一个自己的显式锁Lock精讲下（让锁具备超时功能）</li><li>如何给你的应用程序注入钩子程序，Linux下演示</li><li>如何捕获线程运行期间的异常</li><li>ThreadGroup API介绍之一</li><li>ThreadGroup API介绍之二</li><li>线程池原理与自定义线程池</li><li>自定义个简单的线程池并且测试</li><li>给线程池增加拒绝策略以及停止方法</li><li>给线程池增加自动扩充线程数量，以及闲时自动回收的功能</li><li>课程结束，内容回顾，下季内容预告</li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1186-Java并发编程的“基石”——多线程概念初识</title>
      <link href="/2019/11/09/1186-thread-base/"/>
      <url>/2019/11/09/1186-thread-base/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1186" target="_blank" rel="noopener">https://www.imooc.com/learn/1186</a></p><p>简介：并发是程序员永恒的命题。并发易学难精，没有稳扎稳打的第一步，前路坎坷易弃坑。本课程邀请慕课广受好评的《Java并发核心知识体系精讲》课程的悟空老师带领小伙伴构建清晰的理论基石，涵盖线程、进程、多线程、并发、高并发、同步、异步、阻塞、非阻塞等，还有高频面试点拨。一句话：浓缩2小时的高质精品并发入门课，你绝对值得拥有~</p></blockquote><p>@[TOC]</p><h2 id="第1章-踏上Java并发征途"><a href="#第1章-踏上Java并发征途" class="headerlink" title="第1章 踏上Java并发征途"></a>第1章 踏上Java并发征途</h2><blockquote><p>理清本课程学习目的，构建知识脉络，纵览全局。</p></blockquote><h3 id="1-1-序-本课综述-05-11"><a href="#1-1-序-本课综述-05-11" class="headerlink" title="1-1 序-本课综述 (05:11)"></a>1-1 序-本课综述 (05:11)</h3><p>并发编程的“基石”——多线程概念建立</p><p>晦涩难懂的概念：</p><ul><li>线程、进程</li><li>串行、并行、并发</li><li>多线程、高并发</li><li>同步异步、阻塞非阻塞</li></ul><p>问题：</p><ol><li>线程和进程的相同和不同？</li><li>并行和并发有什么区别？</li><li>多线程就是高并发么？相反，高并发就是多线程么？</li><li>同步阻塞和异步非阻塞的关系？</li></ol><h3 id="1-2-从思维导图看并发脉络-08-13"><a href="#1-2-从思维导图看并发脉络-08-13" class="headerlink" title="1-2 从思维导图看并发脉络 (08:13)"></a>1-2 从思维导图看并发脉络 (08:13)</h3><p><a href="https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd" target="_blank" rel="noopener">https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd</a></p><p>附：</p><ul><li><p>并发编程的“基石”——多线程概念建立：</p><p><a href="http://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd" target="_blank" rel="noopener">http://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd</a></p></li><li><p>线程8大核心基础：</p><p><a href="http://naotu.baidu.com/file/07f437ff6bc3fa7939e171b00f133e17" target="_blank" rel="noopener">http://naotu.baidu.com/file/07f437ff6bc3fa7939e171b00f133e17</a></p></li><li><p>Java内存模型——底层原理：</p><p><a href="http://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9" target="_blank" rel="noopener">http://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9</a></p></li><li><p>死锁——从产生到消除：</p><p><a href="http://naotu.baidu.com/file/ec7748c253f4fc9d88ac1cc1e47814f3" target="_blank" rel="noopener">http://naotu.baidu.com/file/ec7748c253f4fc9d88ac1cc1e47814f3</a> </p></li><li><p>二级大纲（复习用） 成体系的Java并发多线程核心+内存模型+死锁——从用法到原理，面试必考：</p><p><a href="http://naotu.baidu.com/file/29942292cd032adfae23c09783676004" target="_blank" rel="noopener">http://naotu.baidu.com/file/29942292cd032adfae23c09783676004</a></p></li><li><p>并发工具类分类（本导图对应的课程正在录制中，20年上线）：</p><p><a href="http://naotu.baidu.com/file/3902a010470d7c1cf76fe719be124797" target="_blank" rel="noopener">http://naotu.baidu.com/file/3902a010470d7c1cf76fe719be124797</a></p></li></ul><h2 id="第2章-孪生兄弟：进程和线程"><a href="#第2章-孪生兄弟：进程和线程" class="headerlink" title="第2章 孪生兄弟：进程和线程"></a>第2章 孪生兄弟：进程和线程</h2><blockquote><p>用比喻和实操彻底理解进程和线程的联系和不同，并讲解Java语言和多线程的渊源。</p></blockquote><h3 id="2-1-什么是进程？实操案例：用活动监视器看正在运行的各进程-07-24"><a href="#2-1-什么是进程？实操案例：用活动监视器看正在运行的各进程-07-24" class="headerlink" title="2-1 什么是进程？实操案例：用活动监视器看正在运行的各进程 (07:24)"></a>2-1 什么是进程？实操案例：用活动监视器看正在运行的各进程 (07:24)</h3><p>操作系统、进程、线程的包含关系：</p><blockquote><p>操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8s3qksku6j313i0hqtbj.jpg" alt="操作系统、进程、线程的包含关系" style="zoom:30%;" /><p>Oracle文档的官方定义：</p><blockquote><p><a href="https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html" target="_blank" rel="noopener">https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html</a></p></blockquote><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Process</td><td>The UNIX environment (such as file descriptors, user ID, and so on) created with the <code>fork(2)</code> system call, which is set up to run a program.</td></tr><tr><td>Thread</td><td>A sequence of instructions executed within the context of a process.</td></tr></tbody></table><ul><li>进程：使用fork(2)系统调用创建的UNIX环境（例如文件描述符、用户ID等），它被设置为运行程序。</li><li>线程：在进程上下文中执行的一系列指令</li></ul><p>什么是进程</p><ul><li>进程的英文是Process，指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程</li></ul><p>活动监视器演示</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8s3zh26atj313x0u0nc4.jpg" alt="活动监视器" style="zoom:40%;" /><p><strong>总结</strong>：进程就是程序(代码)的真正运行实例，<strong>是资源分配的基本单位</strong></p><h3 id="2-2-什么是线程？实操案例：用代码演示线程数量的实时变化-05-05"><a href="#2-2-什么是线程？实操案例：用代码演示线程数量的实时变化-05-05" class="headerlink" title="2-2 什么是线程？实操案例：用代码演示线程数量的实时变化 (05:05)"></a>2-2 什么是线程？实操案例：用代码演示线程数量的实时变化 (05:05)</h3><p>什么是线程</p><ul><li>线程是<strong>CPU的基本调度单位</strong>，每个线程执行的都是进程代码的某个片段</li></ul><p>实例演示：利用活动监视器的CPU栏目查看Java进程的线程数量的变化</p><pre><code class="java">/** * 创建100个线程，用活动监视器的CPU栏目查看Java进程的线程数量的变化，10秒后线程消失了 */public class Create100Threads {    public static void main(String[] args) {        for (int i = 0; i &lt; 100; i++) {            new Thread(new Runnable() {                @Override                public void run() {                    try {                        Thread.sleep(10 * 1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }).start();        }    }}</code></pre><p>用房子作比喻</p><h3 id="2-3-线程和进程有哪6个不同？生活案例：房子与住户-04-58"><a href="#2-3-线程和进程有哪6个不同？生活案例：房子与住户-04-58" class="headerlink" title="2-3 线程和进程有哪6个不同？生活案例：房子与住户 (04:58)"></a>2-3 线程和进程有哪6个不同？生活案例：房子与住户 (04:58)</h3><ol><li>起源不同：先有进程，后有线程</li><li>概念不同：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位；线程是CPU调度单位</li><li>内存共享方式不同：默认情况下，内存无法与其他进程共享；线程共享由操作系统分配给其父进程的相同内存块</li><li>拥有资源不同：进程拥有独立内存，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<ul><li>线程共享的内容包括：<ol><li><strong>进程代码段</strong></li><li>进程的公有数据(利用这些共享的数据，线程很容易实现相互的通讯)</li><li>进程打开的文件描述符</li><li>信号的处理器</li><li>进程的当前目录</li><li>进程用户ID与进程组ID</li></ol></li><li>线程独有的内容包括：<ol><li>线程ID</li><li>寄存器组的值</li><li><strong>线程的堆栈</strong></li><li>错误返回码</li><li>线程的信号屏蔽码</li></ol></li></ul></li><li>数量不同：一个程序至少有一个进程,一个进程至少有一个线程</li><li>开销不同：<ol><li>线程的创建、终止时间比进程短</li><li>同一进程内的线程切换时间比进程切换短</li><li>同一进程的各个线程间共享文件和文件资源，可以不通过内核进行通信</li></ol></li><li>相似点：生命周期（就绪、等待、运行等状态）</li></ol><h3 id="2-4-Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用-05-42"><a href="#2-4-Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用-05-42" class="headerlink" title="2-4 Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用 (05:42)"></a>2-4 Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用 (05:42)</h3><ul><li><p>Java天生支持多线程、语言排名高</p></li><li><p>Java线程会一对一映射到操作系统</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tvvmls2pj31ai0lon38.jpg" alt="Java虚拟机与操作系统线程关系图" style="zoom:35%;" /></li></ul><p>JVM自动启动线程：</p><blockquote><p>即使代码中不显示创建线程，在运行main时，JVM也会自动启动其他的线程</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8s60yzc0rj30l80gkmzu.jpg" alt="JVM自动启动线程" style="zoom:50%;" /><ul><li><code>Signal Dispatcher</code>：把操作系统发来的信号分发给适当的处理程序。连接操作系统和应用程序</li><li><code>Finalizer</code>：负责对象的<del>finalize()</del>方法</li><li><code>Reference Handler</code>：和GC、引用相关的线程</li><li><code>main</code>：主线程，用户程序的入口</li></ul><h2 id="第3章-多线程比线程复杂在哪里？"><a href="#第3章-多线程比线程复杂在哪里？" class="headerlink" title="第3章 多线程比线程复杂在哪里？"></a>第3章 多线程比线程复杂在哪里？</h2><blockquote><p>讲解什么是多线程，并讲解需要多线程的原因、局限。</p></blockquote><h3 id="3-1-什么是多线程？生活案例：“合租室友”和“吃火锅”-09-02"><a href="#3-1-什么是多线程？生活案例：“合租室友”和“吃火锅”-09-02" class="headerlink" title="3-1 什么是多线程？生活案例：“合租室友”和“吃火锅” (09:02)"></a>3-1 什么是多线程？生活案例：“合租室友”和“吃火锅” (09:02)</h3><p>多线程的概念</p><blockquote><p>多线程是指在单个进程中运行多个线程。如果一个程序允许允许两个或以上的线程，那么它就是多线程程序。</p></blockquote><p>比喻：</p><ol><li>老友记的比喻<ul><li>客厅：公共空间</li><li>厕所：锁</li><li>独立房间：线程独享空间</li><li>花园浇花：线程合作</li></ul></li><li>火锅的比喻<ul><li>大火锅一个人吃：就是单进程单线程</li><li>大火锅多人吃：就是单进程多线程</li><li>分开吃小火锅：就是多进程多线程</li><li>我吃火锅，别人吃火锅底料：那就是我拥有锁，别人拿不到锁</li></ul></li></ol><p>多线程实例：抢火车票</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t0no9wyrj314q0k243y.jpg" alt="多线程实例：抢火车票" style="zoom:25%;" /><table><thead><tr><th>相互独立的任务</th><th>资源共享的任务</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t0p5x9wsj314q0p2gtl.jpg" style="zoom:25%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t0qiwv02j30xe0tegv5.jpg" style="zoom:25%;" /></td></tr></tbody></table><h3 id="3-2-为什么需要多线程？3大原因-06-54"><a href="#3-2-为什么需要多线程？3大原因-06-54" class="headerlink" title="3-2 为什么需要多线程？3大原因 (06:54)"></a>3-2 为什么需要多线程？3大原因 (06:54)</h3><ol><li><p>最主要的目的就是提高CPU利用率</p><ul><li><p>提高处理速度</p></li><li><p>避免无效等待（IO的时候可以做别的事）</p></li><li><p>提高用户体验：避免卡顿、缩短等待时间</p><ol><li><p>并行处理，提高性能。通常是服务器领域（例如Tomcat），用多个线程去接收进来的HTTP请求，而不是排队等待单一的线程处理</p></li><li><p>在Android开发中，主线程的重要任务之一是绘制屏幕界面，该线程中不允许进行IO操作或网络请求，目的就是避免卡顿，影响用户的交互</p></li></ol></li></ul></li><li><p>便于编程建模</p><p>把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p></li><li><p>计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台</p><ul><li><p>摩尔定律</p><blockquote><p>当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。</p></blockquote></li><li><p>阿姆达尔定律</p><blockquote><p>一般情况下，处理器越多，程序执行的速度就会越快，但是会有一个上限，上限取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t15hbqmqj310o0twtji.jpg" alt="阿姆达尔定律" style="zoom:40%;" /></li></ul></li></ol><h3 id="3-3-什么场景需要多线程？有哪些局限？-04-07"><a href="#3-3-什么场景需要多线程？有哪些局限？-04-07" class="headerlink" title="3-3 什么场景需要多线程？有哪些局限？ (04:07)"></a>3-3 什么场景需要多线程？有哪些局限？ (04:07)</h3><p>什么场景中会用到多线程?</p><ol><li><p>什么时候需要新开线程</p><p>通常在需要进行耗时任务的时候，例如执行磁盘IO读写，或者从网络获取信息的时候。</p></li><li><p>为了同时做多件不同的事</p><p>开网页同时听音乐</p><p>后台线程：比如执行定时任务quartz</p></li><li><p>为了提高工作效率、处理能力</p><p>tomcat：每次有一个新的请求过来的时候，tomcat会把这个请求交给一个新的线程去处理，。</p><p>多线程后台并行下载文件</p><p>NIO和AIO</p></li><li><p>需要同时有很大并发量的时候</p><p>压测</p></li></ol><p>多线程的局限</p><ol><li><p>性能问题：上下文切换带来的消耗</p></li><li><p>异构化任务（任务结构不一样）很难高效并行</p></li><li><p>带来线程安全问题</p><p>数据安全问题。a++数据错误</p><p>线程带来的活跃性问题。线程饥饿、死锁</p></li></ol><h2 id="第4章-并行和并发傻傻分不清楚？"><a href="#第4章-并行和并发傻傻分不清楚？" class="headerlink" title="第4章 并行和并发傻傻分不清楚？"></a>第4章 并行和并发傻傻分不清楚？</h2><blockquote><p>讲解并行、串行、并发的含义，并说明操作系统、处理器、编程语言的发展使得并发“飞入寻常百姓家”。</p></blockquote><h3 id="4-1-并行和并发傻傻分不清楚？一图胜千言-10-07"><a href="#4-1-并行和并发傻傻分不清楚？一图胜千言-10-07" class="headerlink" title="4-1 并行和并发傻傻分不清楚？一图胜千言 (10:07)"></a>4-1 并行和并发傻傻分不清楚？一图胜千言 (10:07)</h3><p>串行和并行</p><blockquote><p>串行是大家排队一个个来，并行是大家一起来</p></blockquote><p>一图胜千言</p><table><thead><tr><th>线程的串行并行</th><th>通讯的串行并行</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1jyy0nej30z70u048c.jpg" style="zoom:25%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1lt89b4j30se0w2n9q.jpg" style="zoom:25%;" /></td></tr></tbody></table><p>并发和并行</p><p>一图胜千言</p><ul><li><p>并发：同一时刻仅有一个线程</p><p>Concurrency：</p><ol><li>Single Processor</li></ol></li></ul><ol start="2"><li>Logically simultaneous processing</li></ol><ul><li><p>并行：同一时刻可以有多个线程</p><p>Parallelism：</p><ol><li>Multiprocessores,Multicore</li><li>Physically simultaneous processing</li></ol><table><thead><tr><th>并发</th><th>并行</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1ukp6jbj30ta0kqgun.jpg" style="zoom:25%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1w7tzf6j30t20iyq9i.jpg" style="zoom:25%;" /></td></tr></tbody></table></li></ul><ul><li><p>实例：排队买咖啡</p><ol><li><p>并发（Concurrent），一台咖啡机，两个等待队列</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t22yj3eaj312w08k0zm.jpg" alt="一台咖啡机，两个等待队列" style="zoom:40%;" /></li><li><p>并行（Parallel），两台咖啡机，两个等待队列</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t242hyojj310q08s45z.jpg" alt="两台咖啡机，两个等待队列" style="zoom:40%;" /></li></ol></li></ul><p>并行的概念：</p><blockquote><p>在<strong>同一时刻</strong>，有多个任务同时执行</p></blockquote><ul><li>真正的“同时”运行——在<strong>同一时刻</strong>，有多个任务同时执行</li><li>例如，在多核处理器上，有两个线程同时执行一段代码</li><li>可见，单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务</li></ul><p>并发的概念：</p><blockquote><ol><li>两个或多个任务可以在重叠的<strong>时间段内</strong>启动、运行和完成</li><li>对“并发性”的简称</li></ol></blockquote><ol><li><p>形容多个任务的执行状态</p><ul><li><p>两个或多个任务可以在重叠的<strong>时间段内</strong>启动、运行和完成</p></li><li><p>并行(两个线程同时执行)一定是并发，并发不一定是并行</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2gpqwa9j30pa0p2qa7.jpg" alt="并发并行的包含关系" style="zoom:25%;" /></li></ul><table><thead><tr><th>并发<br />Concurrency<br />（Single-Core CPU）</th><th>并行且并发<br />Concurrency+Parallelism<br />（Multi-Core CPU）</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2iw85hij30y80dmq6a.jpg" style="zoom:35%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2m40uzyj30zg0jiwgn.jpg" style="zoom:35%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2ptq9fzj308w0ncmxv.jpg" style="zoom:30%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2qusdalj308w0nq3zy.jpg" style="zoom:30%;" /></td></tr></tbody></table><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2wbimw3j319u0u0djb.jpg" alt="并行与并发的关系" style="zoom:30%;" /></li><li><p>程序的不同部分具有可以同时执行的性质</p><ul><li>“并发性”是一种程序的性质。如果一个程序具有并发性，说明这个程序的不同的部分可以无序或同时执行，且不影响最终的执行结果。</li><li>在不同核心数的计算机上的不同表现。此时，并行和并发的概念不在同一维度上</li></ul><p>并发性是并发执行或并行执行的前提条件和必要条件</p></li></ol><h3 id="4-2-并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗-06-56"><a href="#4-2-并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗-06-56" class="headerlink" title="4-2 并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗 (06:56)"></a>4-2 并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗 (06:56)</h3><ol><li><p>打游戏时，女朋友来电话</p><p>同时打游戏和接电话。并发</p><p>关掉游戏，专心接电话。串行</p></li><li><p>单核CPU</p><p>程序具备并发性，但不并行执行。单核并发程序</p><p>程序具备并发性，且并行执行：多核并发程序</p><p>既不并行执行，也不具备并发性：单核串行程序</p><p>并行执行，但程序不具备并发性：不可能</p></li></ol><h3 id="4-3-是什么让并发和并行成为了可能？-03-48"><a href="#4-3-是什么让并发和并行成为了可能？-03-48" class="headerlink" title="4-3 是什么让并发和并行成为了可能？ (03:48)"></a>4-3 是什么让并发和并行成为了可能？ (03:48)</h3><ul><li><p>操作系统</p></li><li><p>多核CPU</p></li><li><p>编程语言</p></li></ul><h2 id="第5章-高并发只是并发的升级版吗？"><a href="#第5章-高并发只是并发的升级版吗？" class="headerlink" title="第5章 高并发只是并发的升级版吗？"></a>第5章 高并发只是并发的升级版吗？</h2><blockquote><p>用业界场景说明高并发不仅仅是并发的升级版，也不能简单地理解为就是多线程。高并发和多线程相互成就</p></blockquote><h3 id="5-1-什么是高并发？企业案例：双11、春晚-04-21"><a href="#5-1-什么是高并发？企业案例：双11、春晚-04-21" class="headerlink" title="5-1 什么是高并发？企业案例：双11、春晚 (04:21)"></a>5-1 什么是高并发？企业案例：双11、春晚 (04:21)</h3><p>高并发</p><blockquote><p>同时有很多个请求发送给服务器系统，因此服务器就会并行处理</p></blockquote><ul><li><p>双11天猫</p></li><li><p>春晚微信摇一摇</p></li></ul><h3 id="5-2-高并发和多线程的关系？相互成就-04-47"><a href="#5-2-高并发和多线程的关系？相互成就-04-47" class="headerlink" title="5-2 高并发和多线程的关系？相互成就 (04:47)"></a>5-2 高并发和多线程的关系？相互成就 (04:47)</h3><p>多线程和高并发是什么：解决方案、状态</p><p>多线程和高并发的关系：多线程是对应高并发场景的一种解决方案。为了解决高并发带来的问题，如数据错乱、程序访问慢、服务器死机，从而使用多线程编程提高硬件利用率，获取到更多资源。</p><p>高并发并不意味着是多线程：Redis缓存层</p><h3 id="5-3-高并发有哪些重要指标？-03-58"><a href="#5-3-高并发有哪些重要指标？-03-58" class="headerlink" title="5-3 高并发有哪些重要指标？ (03:58)"></a>5-3 高并发有哪些重要指标？ (03:58)</h3><ul><li>QPS（Queries Per Second）：每秒请求数</li><li>带宽：峰值流量和页面的平均大小</li><li>PV（Page View）：24小时的页面浏览量</li><li>UV（Unique Visitor）：独立用户访问量</li><li>吞吐率（Requests per second）</li><li>并发连接数（The number of concurrent connections）：某个时刻服务器接受请求的数目</li><li>服务器平均请求等待时间（Time per request: across all concurrent requests）：服务器处理一个请求需要花费的时间</li></ul><p>IP和UV的区别</p><ul><li>UV是用户cookies数量</li><li>IP与UV数量关系不确定</li></ul><h2 id="第6章-你真的懂同步与异步？阻塞与非阻塞？"><a href="#第6章-你真的懂同步与异步？阻塞与非阻塞？" class="headerlink" title="第6章 你真的懂同步与异步？阻塞与非阻塞？"></a>第6章 你真的懂同步与异步？阻塞与非阻塞？</h2><blockquote><p>把同步异步、阻塞和非阻塞用烧水壶和买书的例子讲解清楚</p></blockquote><h3 id="6-1-一图胜千言：同步、异步是什么含义？-08-47"><a href="#6-1-一图胜千言：同步、异步是什么含义？-08-47" class="headerlink" title="6-1 一图胜千言：同步、异步是什么含义？ (08:47)"></a>6-1 一图胜千言：同步、异步是什么含义？ (08:47)</h3><ul><li>同步与异步：被调用者，调用结束后是否主动返回结果</li><li>阻塞和非阻塞：调用者，调用后是否可以去做别的事</li></ul><p>一图胜千言</p><table><thead><tr><th>Synchronous Execution</th><th>Asynchronous Execution</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ttuwc30pj313s0lyn67.jpg" style="zoom:40%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ttwcrqrvj313o0n6dpx.jpg" style="zoom:40%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu00xrw8j30py0v4n0w.jpg" style="zoom: 30%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu1xfumij30q00v2gqh.jpg" style="zoom:30%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu3zcjy1j30ic0o6418.jpg" style="zoom:40%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu6enri2j30iw0o40vx.jpg" style="zoom: 40%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu7z769oj30m80nw0xl.jpg" style="zoom:40%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu92dappj30lm0na797.jpg" style="zoom:40%;" /></td></tr></tbody></table><p>同步</p><ul><li><p>同步指的是，客户端发出一个请求后，在没有得到结果之前，服务端就不返回任何结果。但是一旦服务端返回，那返回的就是客户端想要的结果（而不是告诉客户端再等等之类的内容）。</p></li><li><p>被调用者主动告诉调用者结果</p></li><li><p>被调用者（也就是服务器）的行为，而不是请求方的行为。</p></li></ul><p>异步</p><ul><li><p>不实时处理</p></li><li><p>调用在发出之后，服务端会立刻返回，告诉调用方“我收到你的请求了，我会处理的”</p></li><li><p>调用发出后，等服务端计算完毕后，服务端会通过发消息等途径来通知调用者，或通过回调函数处理这个调用。</p></li></ul><p>同步与异步的例子</p><ul><li><p>烧水壶</p><p>同步：盯着水壶</p><p>异步：声音提醒</p></li><li><p>买书，打电话问书店老板</p><p>同步：现场查询</p><p>异步：后续回电</p></li></ul><p>阻塞和非阻塞</p><ul><li><p>我是调用者，我调用一个东西的后，结果返回前，是否还能做别的事</p></li><li><p>站在<strong>线程状态</strong>的角度</p></li><li><p>站在<strong>线程发出请求</strong>(通常是HTTP请求)的角度</p></li></ul><p>阻塞非阻塞的例子</p><ul><li><p>烧水壶</p><p>阻塞：坐在水壶面前不能动</p><p>非阻塞：等的时候去客厅看电视</p></li><li><p>打电话问书店老板</p><p>阻塞式调用：你会一直把自己“挂起”，直到得到这本书有没有的结果；</p><p>非阻塞式调用：你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p><p>在这里<strong>阻塞与非阻塞与是否同步异步无关</strong>。<strong>跟老板通过什么方式回答你无关</strong>。</p></li></ul><h3 id="6-2-4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞-05-38"><a href="#6-2-4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞-05-38" class="headerlink" title="6-2 4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 (05:38)"></a>6-2 4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 (05:38)</h3><p>同步异步、阻塞非阻塞的综合例子</p><ul><li>同步阻塞：坐在普通水壶前</li><li>同步非阻塞：水烧开之前我们先去客厅看电视了，但是水壶不会主动通知我们，需要我们时不时的去厨房看一下水有没有烧开</li><li>异步阻塞：带有提醒功能的水壶烧水，我们坐着等</li><li>异步非阻塞：带有提醒功能的水壶烧水。在水烧发出提醒之前我们先去客厅看电视了，等水壶发出声音提醒我们。</li></ul><h2 id="第7章-面试问题检验学习成果"><a href="#第7章-面试问题检验学习成果" class="headerlink" title="第7章 面试问题检验学习成果"></a>第7章 面试问题检验学习成果</h2><blockquote><p>面试常见问题，用和本课息息相关的8个常见面试问题来检验同学们的学习收获。</p></blockquote><h3 id="7-1-常见面试问题-04-33"><a href="#7-1-常见面试问题-04-33" class="headerlink" title="7-1 常见面试问题 (04:33)"></a>7-1 常见面试问题 (04:33)</h3><ol><li><p>进程和线程的相同和不同？</p><p>起源不同、概念不同（进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位；线程是CPU调度单位）、内存共享方式不同、拥有资源不同、数量不同、开销不同</p><p>生命周期（就绪、等待、运行等状态）相似</p></li><li><p>并行和并发的异同？</p><p>并发：同一时刻仅有一个线程；</p><p>并行：同一时刻可以有多个线程</p><p>并行(两个线程同时执行)一定是并发，并发不一定是并行</p></li><li><p>高并发是不是就意味着多线程？有什么反例？</p><p>多线程是对应高并发场景的一种解决方案。为了解决高并发带来的问题，如数据错乱、程序访问慢、服务器死机，从而使用多线程编程提高硬件利用率，获取到更多资源，迅速化解高并发带来的压力</p><p>解决高并发不仅只有多线程，比如系统整体架构、Redis缓存层、MQ</p></li><li><p>多线程可以提高程序执行效率，你知不知道有有哪些弊端？</p><ul><li><p>上下文切换带来的消耗</p></li><li><p>异构化任务（任务结构不一样）很难高效并行</p></li><li><p>带来线程安全问题</p><p>数据安全问题。a++数据错误</p><p>线程带来的活跃性问题。线程饥饿、死锁</p></li></ul></li><li><p>什么是同步，什么是异步，什么是阻塞，什么是非阻塞？</p><p>同步与异步：被调用者，调用结束后是否主动返回结果</p><p>阻塞和非阻塞：调用者，调用后是否可以去做别的事</p></li><li><p>在单核CPU上运行多线程程序有意义吗？</p><p>有意义。单CPU多线程，是尽力在压榨CPU的使用率，如果有IO操作，很多线程会休息，如果单线程，那么CPU就休息。如果CPU已经被挤满，那么并不是说在单核CPU上运行多线程程序没有意义，而是说，线程的数量设置不合理，应该减少线程的数量。</p></li></ol><h2 id="第8章-全程回顾"><a href="#第8章-全程回顾" class="headerlink" title="第8章 全程回顾"></a>第8章 全程回顾</h2><blockquote><p>用思维导图进行全课总结，温故知新，更上一层。</p></blockquote><h3 id="8-1-思维导图总结、实战课展望-16-11"><a href="#8-1-思维导图总结、实战课展望-16-11" class="headerlink" title="8-1 思维导图总结、实战课展望 (16:11)"></a>8-1 思维导图总结、实战课展望 (16:11)</h3><p><a href="https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd" target="_blank" rel="noopener">https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd</a></p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1129-玩转Vim 从放弃到爱不释手</title>
      <link href="/2019/11/05/1129-vim/"/>
      <url>/2019/11/05/1129-vim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1129" target="_blank" rel="noopener">https://www.imooc.com/learn/1129</a></p><p>简介：Vim作为一个强大的编辑器，是很多巨佬的不二之选，但因为其较高的入门学习门槛劝退了很多人。中文的系统教程少之又少，讲vim插件使用的更是屈指可数，本课程从vim最基础的操作和概念开始讲起，带领大家学会使用和配置 vim，安装强大的 vim 插件，真正掌握编辑器之神 vim 的使用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-玩转vim-从放弃到爱不释手"><a href="#第1章-玩转vim-从放弃到爱不释手" class="headerlink" title="第1章 玩转vim 从放弃到爱不释手"></a>第1章 玩转vim 从放弃到爱不释手</h2><blockquote><p>课程导学</p></blockquote><h3 id="1-1-玩转vim-从放弃到爱不释手-课程导学-09-43"><a href="#1-1-玩转vim-从放弃到爱不释手-课程导学-09-43" class="headerlink" title="1-1 玩转vim 从放弃到爱不释手-课程导学 (09:43)"></a>1-1 玩转vim 从放弃到爱不释手-课程导学 (09:43)</h3><p>什么是Vim？</p><blockquote><p>Linux下两大编辑神器之一：Vim</p></blockquote><ul><li>Linux/Unix下使用最多的编辑器</li><li>Vi的改进版</li><li>可能是最难上手的编辑器之一</li></ul><p>为什么要学习Vim？</p><blockquote><p>都21世纪了，为什么还要学习Vim？</p></blockquote><ul><li>只要你用服务器，Vim就是一个必备技能</li><li>后端和运维工程师必须掌握的编辑器，不然服务器上操作很尴尬</li><li>可以纯键盘⌨️编辑，提升编辑效率</li></ul><p>痛点</p><blockquote><p>Vim难上手，学习曲线陡</p></blockquote><ul><li>Vim视频学习资料很少，网上很多博客讲解零散、不够直观</li><li>缺少系统的教程。Vim命令众多，难以学习和记忆</li><li>Vim学习曲线比较陡，需要较长时间才能上手，劝退很多初学者</li></ul><p>课程目的</p><blockquote><p>帮你驯服Vim</p></blockquote><ul><li>了解和掌握Vim中的基本概念</li><li>熟悉Vim基本使用方法，能够做到日常编辑（纯键盘编辑）</li><li>知道如何自定义Vim，安装插件无限扩充Vim的功能</li></ul><p>课程内容</p><blockquote><p>如何学习Vim？Vim经常被诟病难易上手和使用</p></blockquote><ul><li>Vim的概念和基本操作，比如移动和增删改查</li><li>如何配置Vim，编写自己的vimrc文件</li><li>如何安装和使用插件，无限扩充Vim的功能</li></ul><p>受众</p><blockquote><p>哪些人可以从本门课程受益呢？</p></blockquote><ul><li>运维工程师、后端工程师等</li><li>Linux用户</li><li>对Vim感兴趣，想要提升开发效率的开发者,甚至普通用户</li></ul><p>预备知识</p><blockquote><p>不要求掌握Vim的基础知识，但最好使用Linux/Unix系统</p></blockquote><ul><li>熟悉基本的命令行操作（一般Vim多在Linux服务器上使用）</li><li>知道如何安装Vim</li><li>有其他编辑器使用经验。几乎所有流行IDE和编辑器都有Vim扩展</li></ul><p>课程特色</p><blockquote><p>学习Vim非一日之功，得靠肌肉记忆</p></blockquote><ul><li>由浅入深，循序渐进。从基本的概念和操作讲起</li><li>授人以🐟，同时授人以渔。学会了插件自己扩充Vim功能</li><li>大量实践技巧（所有演示均使用按键回显工具，让你看得更明白）</li></ul><h2 id="第2章-初识-Vim，想说爱你不容易"><a href="#第2章-初识-Vim，想说爱你不容易" class="headerlink" title="第2章 初识 Vim，想说爱你不容易"></a>第2章 初识 Vim，想说爱你不容易</h2><blockquote><p>从基础的 Vim 操作讲起，学习 Vim 操作和涉及到的 Vim 概念。</p></blockquote><h3 id="2-1-初识-Vim，想说爱你不容易-11-50"><a href="#2-1-初识-Vim，想说爱你不容易-11-50" class="headerlink" title="2-1 初识 Vim，想说爱你不容易 (11:50)"></a>2-1 初识 Vim，想说爱你不容易 (11:50)</h3><p>下载与安装</p><blockquote><p>作为开发者的你，安装Vim应该很简单</p></blockquote><ul><li>Linux/Unix(Mac)自带Vim，直接终端里输入<code>vim</code>即可进入</li><li>Windows用户可以下载安装Gvim等体验</li><li>建议Windows用户可以尝试使用虚拟机来体验Linux下的Vim</li></ul><p>初识Vim</p><blockquote><p>据说StackOverflow帮助过上百万开发者退出过Vim！</p></blockquote><ul><li><p>输入<code>vim</code>命令进入Vim</p><pre><code>~                              VIM - Vi IMproved                                ~                                                                               ~                               version 8.0.1283                                ~                           by Bram Moolenaar et al.                            ~                 Vim is open source and freely distributable                   ~                                                                               ~                        Become a registered Vim user!                          ~                type  :help register&lt;Enter&gt;   for information                  ~                                                                          ~                type  :q&lt;Enter&gt;               to exit~                type  :help&lt;Enter&gt;  or  &lt;F1&gt;  for on-line help~                type  :help version8&lt;Enter&gt;   for version info</code></pre></li><li><p>进去之后似乎没法输入东西，起始默认进去是普通(normal)模式</p></li><li><p>使用<code>:q</code>可以退出Vim</p></li></ul><p>开始编辑</p><blockquote><p>进入编辑模式就可以像其他编辑器一样编辑了</p></blockquote><ul><li><p>使用<code>i</code>进入编辑模式，开始输入文字</p></li><li><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>insert before character</td></tr><tr><td><code>a</code></td><td>append after character</td></tr><tr><td><code>o</code></td><td>open a line below</td></tr><tr><td><code>I</code></td><td>insert before line</td></tr><tr><td><code>A</code></td><td>append after line</td></tr><tr><td><code>O</code></td><td>open a line above</td></tr></tbody></table></li><li><p>使用<code>Esc</code>又可以回到普通(normal)模式。使用<code>:wq</code>保存退出</p><p>insert -&gt; normal：<code>Esc</code></p></li></ul><p>课后练习</p><blockquote><p>用Vim靠的是肌肉记忆，赶紧自己操作练习一下吧</p></blockquote><ul><li>通过搜索引擎学习如何安装，并在你的操作系统中安装好Vim</li><li>进入Vim，使用<code>i</code>/<code>a</code>/<code>o</code>进入编辑(insert)模式输入文本</li><li>退回到默认的普通(normal)模式，保存并退出Vim</li></ul><h3 id="2-2-Vim，为什么你有这么多模式-09-15"><a href="#2-2-Vim，为什么你有这么多模式-09-15" class="headerlink" title="2-2 Vim，为什么你有这么多模式 (09:15)"></a>2-2 Vim，为什么你有这么多模式 (09:15)</h3><p>“怪异的Vim模式”</p><blockquote><p>Vim和其他很多编辑器的区别在于多种模式</p></blockquote><ul><li><p>进入Vim默认是普通(normal)模式？为什么不是编辑模式呢？</p><p>答：在日常开发中更多的是浏览代码，而不是编辑代码</p></li><li><p>使用<code>i</code>(insert)/<code>a</code>(append)等进入编辑模式</p></li><li><p>还有<code>:cmd</code>命令模式和<code>v</code>(visual)可视化模式</p></li></ul><ol><li>为什么进入Vim不能插入—普通(Normal)模式</li></ol><blockquote><p>奇怪的是，为什么Vim进入之后不能像其他编辑器一样直接插入？</p></blockquote><ul><li>进入Vim默认是普通(normal)模式。使用<code>Esc</code>从插入模式回到普通模式</li><li>普通模式下可以进行各种命令操作和移动</li><li>大部分情况下，你是在浏览而不是编辑。所以Vim默认是普通(normal)模式</li></ul><ol start="2"><li>插入(Insert)模式</li></ol><blockquote><p>插入模式下Vim可以直接编辑，和其他编辑器一样</p></blockquote><ul><li>使用<code>i</code>(insert)/<code>a</code>(append)/<code>o</code>(open a line below)进入插入模式</li><li>使用<code>Esc</code>退出插入模式到普通(normal)模式</li><li>你来试试<code>I</code>/<code>A</code>/<code>O</code>如何进入插入模式的？</li></ul><ol start="3"><li>命令(Command)模式</li></ol><blockquote><p>普通(Normal)模式下输入<code>:</code>之后执行命令，比如保存退出<code>:wq</code>，一气呵成</p></blockquote><ul><li>顾名思义，执行Vim命令。比如保存<code>:w</code>、退出<code>:q</code></li><li>比如分屏：<code>:vs</code>(vertical split)、<code>:sp</code>(split)</li><li>比如使用<code>:% s/java/python/g</code>全局替换，将<code>java</code>替换为<code>python</code></li></ul><ol start="4"><li>可视化(Visual)模式</li></ol><blockquote><p>可视化(Visual)模式一般用来块状选择文本</p></blockquote><ul><li>普通模式下，使用<code>v</code>进入字符选择</li><li>使用<code>V</code>选择行</li><li>使用<code>Ctrl+v</code>进入方块♦️选择</li></ul><p>课后练习</p><blockquote><p>理解和使用Vim常用的4种模式</p></blockquote><ul><li>找一个文件编辑，在插入模式和普通模式之间切换</li><li>使用命令模式替换单词</li><li>尝试使用可视化(Visual)模式，想想它的使用场景是？</li></ul><h3 id="2-3-Vim-插入模式小技巧-08-08"><a href="#2-3-Vim-插入模式小技巧-08-08" class="headerlink" title="2-3 Vim 插入模式小技巧 (08:08)"></a>2-3 Vim 插入模式小技巧 (08:08)</h3><p>如何快速纠错？</p><blockquote><p>代码就像人生，总是经常出错，需要我们快速修正</p></blockquote><ul><li><p>进入Vim之后，首先使用<code>i</code>/<code>a</code>/<code>o</code>进入插入模式</p></li><li><p>尝试抛弃退格键，使用<code>Ctrl</code>快捷键来完成编辑删除工作</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+h</code></td><td>删除上一个字符</td></tr><tr><td><code>Ctrl+w</code></td><td>删除上一个单词</td></tr><tr><td><code>Ctrl+u</code></td><td>删除当前行</td></tr></tbody></table></li><li><p>以上几个快捷键可以用在很多地方，比如<strong><em>终端</em></strong></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+a</code></td><td>快速移动到开头</td></tr><tr><td><code>Ctrl+e</code></td><td>快速移动到结尾</td></tr><tr><td><code>Ctrl+b</code></td><td>前移动</td></tr><tr><td><code>Ctrl+f</code></td><td>后移动</td></tr></tbody></table></li></ul><p>快速切换普通(Normal)模式和编辑(Insert)模式</p><blockquote><p>很多键盘的键位设置，<code>Esc</code>按起来不方便，不方便切换到普通模式</p></blockquote><ul><li>使用<code>Ctrl+c</code>代替<code>Esc</code>（但是可能会中断某些插件）、<code>Ctrl+[</code></li><li><strong><code>gi</code>快速跳转到最后一次编辑的地方，并进入插入模式</strong></li><li>在配置章节，我们会讲解如何映射方便的快捷键来代替<code>Esc</code></li></ul><p>让键盘适应工具</p><blockquote><p>键盘的选择会影响你的编辑速度</p></blockquote><ul><li>选择<code>Esc</code>和<code>Ctrl</code>比较容易触碰到的键盘</li><li>使用Vim，你可以使用HHKB或者Poker2这种迷你键盘</li><li>使用软件修改键位，比如<code>CapsLock</code>改成频繁使用到的<code>Ctrl</code></li></ul><ul><li><p>码农神器之HHKB—专为Linux下Vim/Emacs设计</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg8zp9kyj31jw0kojwp.jpg" alt="码农神器之HHKB" style="zoom:50%;" /></li><li><p>发烧之选—Poker2</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg90lb5nj31gi0i0dis.jpg" alt="发烧之选---Poker2" style="zoom:50%;" /></li></ul><h3 id="2-4-Vim-快速移动大法-15-11"><a href="#2-4-Vim-快速移动大法-15-11" class="headerlink" title="2-4 Vim 快速移动大法 (15:11)"></a>2-4 Vim 快速移动大法 (15:11)</h3><p>众所周知，vim normal模式使用了反人类的hjkl来移动</p><ul><li>编辑器作者在编写vim的时候，键盘还没流行上下左右按键</li><li>左（<code>h</code>），下（<code>j</code>），上（<code>k</code>），右（<code>l</code>）。移动也不会让手指脱离主键盘区</li><li>逼着自己使用hjkl一段时间之后，便会体会到它非常有效率</li></ul><p>在单词之间「飞舞」</p><blockquote><p>在单词之间移动是我们浏览操作中最常使用的命令</p></blockquote><ul><li><code>w</code>/<code>W</code>移动到下一个word/WORD开头。<code>e</code>/<code>E</code>移动到下一个word/WORD结尾</li><li><code>b</code>/<code>B</code>回到上一个word/WORD开头，可以理解为backword</li><li>word指的是以非空白符分割的单词，WORD指的是以空白符分割的单词</li></ul><p><code>synyax on</code>：打开高亮显示</p><p>行间搜索移动</p><blockquote><p>同一行快速移动的方式其实是：搜索一个字符并且移动到该字符</p></blockquote><ul><li>使用<code>f{char}</code>可以移动到char字符上，<code>t{char}</code>移动到char的前一个字符</li><li>如果第一次没搜到，可以用分号<code>;</code>/逗号<code>,</code>继续搜索该行的下一个/上一个</li><li>大写的<code>F</code>表示反过来搜索前面的字符</li></ul><p>如何快速移动到一行的行首或者行尾呢？</p><ul><li><code>0</code>移动到行首第一个字符，<code>^</code>移动到行首第一个非空白字符</li><li><code>$</code>移动到行尾，<code>_g</code>移动到行尾非空白字符</li><li>记住常用的<code>0</code>和<code>$</code>就可以满足日常需求了。</li></ul><p>Vim垂直移动</p><blockquote><p>在句子（sentence）和段落（paragraph）间移动。（不常用）</p></blockquote><ul><li>使用小括号<code>()</code>在句子间移动，可以使用<code>:help (</code>来查看帮助文档</li><li>使用大括号<code>{}</code>在段落间移动</li><li>插件章节会讲到如何使用easy-motion插件移动，这些命令就都不用记忆了</li></ul><p>Vim页面移动</p><ul><li><code>gg</code>/<code>G</code>移动到文件开头和结尾，可以使用<code>ctrl+o</code>快速返回</li><li><code>H</code>/<code>M</code>/<code>L</code>跳转到屏幕的开头（Head）、中间（Middle）、结尾（Lower）</li><li><code>ctrl+u</code>、<code>ctrl+f</code>上下翻页（upward/forward）。<code>zz</code>把光标当前行置为屏幕中间</li></ul><h3 id="2-5-Vim快速增删改查-13-29"><a href="#2-5-Vim快速增删改查-13-29" class="headerlink" title="2-5 Vim快速增删改查 (13:29)"></a>2-5 Vim快速增删改查 (13:29)</h3><p>Vim增加字符</p><ul><li>进入插入模式编辑文本</li><li><code>a</code>/<code>i</code>/<code>o</code>、<code>A</code>/<code>I</code>/<code>O</code></li></ul><p>Vim快速删除</p><ul><li>Vim在normal模式下使用<code>x</code>快速删除一个字符</li><li>使用<code>d</code>（delete）配合文本对象快速删除一个单词<code>daw</code>（d around word）</li><li><code>d</code>和<code>x</code>都可以搭配数字来执行多次</li></ul><p>Vim快速修改</p><ul><li><p><code>r{char}</code>（replace）、<code>c</code>（change）、<code>s</code>（substitute）</p></li><li><p>normal模式下使用<code>r{char}</code>可以替换一个字符char。<code>s</code>替换并进入插入模式</p><p><code>R</code>进入插入模式，将光标所在的字符直接替换为输入的字符。<code>S</code>删除整行，进入插入模式</p></li><li><p>使用<code>c</code>配合文本对象可以快速进行修改。例如：<code>ciw</code>、<code>caw</code>、<code>ct&quot;</code></p><p><code>C</code>删除整行，进入插入模式（不包含行首的非空白字符）</p></li></ul><p>Vim查询</p><ul><li>使用<code>/</code>或者<code>?</code>进行前向或者反向搜索</li><li>使用<code>n</code>/<code>N</code>跳转到下一个或者上一个匹配</li><li>使用<code>*</code>或者<code>#</code>进行当前光标所在单词的前向或者后向匹配</li></ul><h3 id="2-6-Vim-如何搜索替换-07-15"><a href="#2-6-Vim-如何搜索替换-07-15" class="headerlink" title="2-6 Vim 如何搜索替换 (07:15)"></a>2-6 Vim 如何搜索替换 (07:15)</h3><p>Vim替换命令：</p><blockquote><p>substitute命令允许查找并且替换文本，并且支持正则表达式</p></blockquote><ul><li><code>:[range] s[ubstitute]/{pattern}/{string}/[flags]</code></li><li><code>range</code>表示范围。 比如：<code>10,20</code>表示10-20行，<code>%</code>表示全部</li><li><code>pattern</code>是要替换的模式，<code>string</code>是替换后的文本，<code>flags</code>是替换标志位</li></ul><p>替换标志位</p><ul><li><code>g</code>(flobal)表示全局范围内执行</li><li><code>c</code>(confirm)表示确认，可以确认或者拒绝修改</li><li><code>n</code>(number)报告匹配到的次数而不替换，可以用来查询匹配次数</li></ul><p>例：</p><pre><code class="shell"># 在全局范围内将self替换为this:% s/self/this/g# 在1-6行将self替换为this:1,6 s/self/this/g# 统计1-6行匹配到self的次数:1,6 s/self//n# 利用正则，将quack替换为jiao，而不替换do_quack:% s/\&lt;quack\&gt;/jiao/g</code></pre><p><code>u</code>：撤销操作</p><p><code>Ctrl+r</code>：反向撤销</p><p>课后练习：</p><ul><li>如何批量替换多个文件中的匹配呢？</li><li>延伸：使用插件来批量搜索替换多个文件中的匹配</li></ul><h3 id="2-7-Vim-多文件操作-15-01"><a href="#2-7-Vim-多文件操作-15-01" class="headerlink" title="2-7 Vim 多文件操作 (15:01)"></a>2-7 Vim 多文件操作 (15:01)</h3><p>Buffer Window Tab：</p><ul><li><p>Buffer是指打开的一个文件的内存缓冲区</p></li><li><p>Window是Buffer可视化的分割区域</p></li><li><p>Tab可以组织Window为一个工作区</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg91qg8bj31dh0u0qag.jpg" alt="Buffer Window Tab" style="zoom:40%;" /></li></ul><p>Buffer（缓冲区）</p><ul><li>Vim打开一个文件后会加载文件内容到缓冲区</li><li>之后的修改都是针对内存中的缓冲区，并不会直接保存到文件</li><li>直到执行<code>:w</code>（write）的时候才会把修改的内容写入到文件里</li></ul><p>Buffer切换</p><ul><li>使用<code>:ls</code>会列举出当前缓冲区，然后使用<code>:b n</code>跳转到第n个缓冲区</li><li><code>bpre</code>、<code>bnext</code>、<code>bfirst</code>、<code>blast</code></li><li><code>:b buffer_name</code>、<code>:b filename</code>，<code>tab</code>会自动补全<code>buffer_name</code></li></ul><p><code>:e b.txt</code>：编辑(edit)b.txt</p><p>Window窗口：</p><ul><li>一个缓冲区可以分割成多个窗口，每个窗口也可以打开不同的缓冲区</li><li><code>&lt;Ctrl+w&gt;s</code>水平分割，<code>&lt;Ctrl+w&gt;v</code>垂直分割。或者<code>:sp</code>、<code>:vs</code></li><li>每个窗口可以继续被无限分割（屏幕是否足够大）</li></ul><p>分割窗口示例：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg933wfnj30vi0lqwfr.jpg" alt="Window分割窗口示例" style="zoom:40%;" /><p>如何切换窗口：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Ctrl+w&gt;w</code></td><td>在窗口间循环切换</td></tr><tr><td><code>&lt;Ctrl+w&gt;h</code></td><td>切换到左边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;j</code></td><td>切换到下边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;k</code></td><td>切换到上边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;l</code></td><td>切换到右边的窗口</td></tr></tbody></table><p><code>&lt;Ctrl+w&gt;L</code>：将当前窗口移动到右边</p><p><code>&lt;Ctrl+w&gt;H</code>：将当前窗口移动到左边</p><p>如何重排窗口？</p><blockquote><p>重排窗口可以改变窗口的大小<code>:h window-resize</code>查看文档</p></blockquote><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Ctrl+w&gt;=</code></td><td>使所有窗口等宽、等高</td></tr><tr><td><code>&lt;Ctrl+w&gt;_</code></td><td>最大化活动窗口的高度</td></tr><tr><td>`&lt;Ctrl+w&gt;</td><td>`</td></tr><tr><td><code>[n] &lt;Ctrl+w&gt;_</code></td><td>把活动窗口的高度设为[n]行</td></tr><tr><td>`[n] &lt;Ctrl+w&gt;</td><td>`</td></tr></tbody></table><p>Tab（标签页）将窗口分组</p><blockquote><p>Tab是可以容纳一系列窗口的容器<code>:h tabpage</code></p></blockquote><ul><li>Vim的Tab和其他编辑器有所不同，可以将其想象为Linux的虚拟桌面</li><li>比如一个Tab全用来编辑Python文件，一个Tab全是HTML文件</li><li>相比窗口，Tab一般使用较少，Tab太多管理起来也比较麻烦</li></ul><p>Tab操作</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:tabnew {filename}</code></td><td>在新标签中打开{filename}</td></tr><tr><td><code>:tabe[dit] {filename}</code></td><td>在新标签中打开{filename}</td></tr><tr><td><code>&lt;Ctrl+w&gt;T</code></td><td>把当前窗口移动到一个新标签页</td></tr><tr><td><code>:tabc[lose]</code></td><td>关闭当前标签页及其中的所有窗口</td></tr><tr><td><code>tabo[nly]</code></td><td>只保留活动标签页，关闭其他所有标签页</td></tr></tbody></table><p>Tab切换操作</p><table><thead><tr><th>Ex命令</th><th>普通模式命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:tabn[ext] {N}</code></td><td><code>{N} gt</code></td><td>切换到标签为{N}的标签页</td></tr><tr><td><code>:tabn[ext]</code></td><td><code>gt</code></td><td>切换到下一个标签页</td></tr><tr><td><code>tabp[revious]</code></td><td><code>gT</code></td><td>切换到上一个标签页</td></tr></tbody></table><p><code>:vs c.txt</code>：垂直分割打开c.txt</p><p><code>:tabnew duck.py</code>：在新的标签页打开duck.py</p><p>课后练习</p><ul><li>尝试打开Vim一次操作多个文件</li><li>窗口分割可以非常方便的查看代码，比如查看整个调用链</li><li>延伸：插件篇会配合<code>ctrlp</code>插件和<code>nerdtree</code>快速操作多个文件</li></ul><h3 id="2-8-什么是-Vim-的-text-object-06-49"><a href="#2-8-什么是-Vim-的-text-object-06-49" class="headerlink" title="2-8 什么是 Vim 的 text object (06:49)"></a>2-8 什么是 Vim 的 text object (06:49)</h3><p>Text Object（文本对象）</p><ul><li>Vim里文本也有对象的概念，比如一个单词、一段句子、一个段落</li><li>很多其他编辑器经常只能操作单个字符来修改文本，比较低效</li><li>通过操作文本对象来修改要比只操作单个字符高效</li></ul><p>文本对象操作方式</p><blockquote><p>之前已经使用过文本对象了，比如<code>dw</code>删除一个单词</p></blockquote><ul><li><code>[number] &lt;command&gt; [text object]</code>。次数+命令+文本对象</li><li><code>number</code>表示次数，<code>command</code>表示命令：<code>d</code>(delete)、<code>c</code>(chage)、<code>y</code>(yank)</li><li><code>text object</code>是要操作的文本对象，比如单词<code>w</code>、句子<code>s</code>、段落<code>p</code></li></ul><p><code>iw</code>：表示inner word。<code>viw</code>命令首先<code>v</code>进入选择模式，<code>iw</code>将选中当前单词</p><p><code>aw</code>：表示around word。它不但会选中当前单词，还会包含单词之后的空格</p><p><code>ci&quot;</code>：删除<code>&quot;&quot;</code>中的内容，并进入插入模式。另外还有<code>()</code>、<code>{}</code>、<code>[]</code>等。</p><p>课后练习</p><blockquote><p>摆脱低效的字符操作，使用文本对象提升效率</p></blockquote><ul><li>如何删除一个单词？</li><li>在Vim中尝试使用文本对象快速增、删、改一个单词</li><li>延伸：有些插件扩展了文本对象。比如<code>vim-go</code>可以使用<code>f</code>表示一个函数</li></ul><h3 id="2-9-Vim复制粘贴与寄存器的使用-16-51"><a href="#2-9-Vim复制粘贴与寄存器的使用-16-51" class="headerlink" title="2-9 Vim复制粘贴与寄存器的使用 (16:51)"></a>2-9 Vim复制粘贴与寄存器的使用 (16:51)</h3><p>Normal模式复制粘贴</p><ul><li><p>normal模式下复制粘贴分别使用<code>y</code>(yank)和<code>p</code>(put)，剪贴<code>d</code>和<code>p</code></p></li><li><p>可以使用<code>v</code>(visual)命令选中所要复制的地方，然后使用<code>p</code>粘贴</p></li><li><p>配合文本对象。比如使用<code>viw</code>复制一个单词，<code>yy</code>复制一行</p><p>Vim里的<strong>剪贴</strong>(cut)<strong>复制</strong>(copy)<strong>粘贴</strong>(paste)分别是<strong>delete</strong>/<strong>yank</strong>/<strong>put</strong></p></li></ul><p>Insert模式下的复制粘贴</p><ul><li>和其他文本编辑器一样，使用<code>Ctrl+v</code>或者<code>cmd+v</code>粘贴，但是粘贴代码有个坑</li><li>很多人在<code>.vimrc</code>中设置了<code>autoindent</code>，粘贴Python代码缩进错乱</li><li>这个时候需要在粘贴前后使用<code>:set paste</code>和<code>:set nopaste</code>解决、使用系统剪贴板寄存器<code>:&quot;</code>也可以解决</li></ul><p>什么是Vim的寄存器？</p><ul><li>Vim里操作的是寄存器而不是系统剪贴板。</li><li>默认使用<code>d</code>删除或者<code>y</code>复制的内容都放到了“无名寄存器”</li><li>用<code>x</code>删除一个字符放到无名寄存器，然后<code>p</code>粘贴，可以调换两字符</li></ul><p>深入寄存器（register）</p><blockquote><p>Vim不使用单一剪贴板进行剪贴、复制与粘贴，而是多组寄存器</p></blockquote><ul><li>通过<code>&quot;{register}</code>前缀可以指定寄存器，不指定则默认使用无名寄存器</li><li>比如使用<code>&quot;ayiw</code>复制一个单词到寄存器<code>a</code>中，<code>&quot;bdd</code>删除当前行到寄存器<code>b</code>中</li><li>Vim中，<code>&quot;&quot;</code>表示无名寄存器,缺省使用，<code>&quot;&quot;p</code>其实就等同于<code>p</code>。<code>&quot;+</code>系统剪贴板。</li></ul><p><code>:reg a</code>：查看寄存器<code>a</code></p><p>其他常见寄存器</p><blockquote><p>除了有名寄存器a-Z，Vim中还有一些其他常见寄存器</p></blockquote><ul><li><p>复制专用寄存器<code>&quot;0</code>，使用<code>y</code>复制文本同时会被拷贝到复制寄存器<code>0</code></p></li><li><p>系统剪贴板<code>&quot;+</code>，可以在复制前加上<code>&quot;+</code>复制到系统剪贴板。</p><p>查看是否开启系统剪贴板：<code>:echo has(&#39;clipboard&#39;)</code></p><p>设置<code>:set clipboard=unnamed</code></p></li><li><p>其他寄存器，比如<code>&quot;%</code>当前文件名，<code>&quot;.</code>上次插入的文本</p></li></ul><p><code>:e!</code>：舍弃当前修改并重新加载文本内容</p><p>课后练习</p><blockquote><p>了解normal/insert模式复制粘贴的方法，常见寄存器的用法</p></blockquote><ul><li>找一段Python代码，尝试在Vim里粘贴进入</li><li>试试将Vim中的内容复制到系统粘贴板</li><li>尝试在服务器的Vim里粘贴系统剪贴板的内容</li></ul><h3 id="2-10-Vim-如何用宏完成强大的批量操作-10-23"><a href="#2-10-Vim-如何用宏完成强大的批量操作-10-23" class="headerlink" title="2-10 Vim 如何用宏完成强大的批量操作 (10:23)"></a>2-10 Vim 如何用宏完成强大的批量操作 (10:23)</h3><p>从需求说起</p><blockquote><p>从一个需求说起，给多行URL链接加上双引号</p></blockquote><pre><code>https://www.zhihu.com/question/54919485https://www.zhihu.com/explorehttps://www.zhihu.com/topichttps://www.zhihu.com/topic/19601308https://www.zhihu.com/topic/19607351https://www.zhihu.com/topic/19630716https://www.zhihu.com/topic/19637932https://www.zhihu.com/people/weikexin-67https://www.zhihu.com/questton/267339149/answer/325252706https://www.zhihu.com/question/267339149/answer/523371968https://www.zhihu.com/people/zhang-jia-hao-15https://www.zhihu.com/question/48510028https://www.zhihu.com/question/267339149/answer/323414411https://www.zhihu.com/people/ming-ming 0701https://www.zhihu.com/question/267339149/answer/519709724https://www.zhihu.com/question/answer/519709724https://www.zhihu.com/question/22897152https://www.zhihu.com/question/22130215https://www.zhihu.com/question/19823813</code></pre><p>什么是Vim宏（macro）</p><ul><li>宏可以看成是一系列命令的集合</li><li>可以使用宏「录制」一系列操作，然后用于「回放」</li><li>宏可以非常方便地把一系列命令用在多行文本上</li></ul><p>如何使用宏</p><blockquote><p>宏的使用分为录制和回放，与拍电影类似。</p></blockquote><ul><li>Vim使用<code>q</code>来录制，同时也是使用<code>q</code>结束录制</li><li>使用<code>q{register}</code>选择要保存的寄存器，把录制的命令保存其中</li><li>使用<code>@{register}</code>回放寄存器中保存的一系列命令</li></ul><p>使用宏解决提出的问题</p><ul><li><p>先给一行加上双引号，然后再回放到其他所有行</p></li><li><p>先使用<code>q</code>开始录制，给一行加上双引号，之后使用<code>q</code>退出</p></li><li><p>在剩下所有行中回放录制的宏</p><p>录制：</p><pre><code class="shell">qaI&quot;&lt;Esc&gt;A&quot;&lt;Esc&gt;jq</code></pre><p>调用方式一：</p><pre><code>10@a</code></pre><p>调用方式二：</p><pre><code>VGG:normal @a</code></pre></li></ul><p>课后练习</p><blockquote><p>知道什么是宏，如何使用宏完成日常需求</p></blockquote><ul><li>想象一下编辑代码或者文本什么时候会使用到宏？</li><li>想一下还有没有其他方式来完成这个批量加引号的编辑需求</li><li>尝试亲自操作一下宏命令编辑。</li></ul><h3 id="2-11-Vim-补全大法-07-33"><a href="#2-11-Vim-补全大法-07-33" class="headerlink" title="2-11 Vim 补全大法 (07:33)"></a>2-11 Vim 补全大法 (07:33)</h3><p>什么是补全？</p><blockquote><p>只要手速快，补全什么的都是浮云。</p></blockquote><ul><li>补全是根据当前环境上下文由编辑器「猜」用户想要输入的内容</li><li>比如补全一个单词、文件名，或者代码中的函数名、变量名等</li><li>Vim中提供了多种补全功能，还可以由插件扩展功能实现代码补全</li></ul><p>Vim中常见的补全：</p><table><thead><tr><th>命令</th><th>补全类型</th></tr></thead><tbody><tr><td><code>&lt;C-n&gt;</code></td><td>普通关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-n&gt;</code></td><td><strong>当前缓冲区关键字</strong></td></tr><tr><td><code>&lt;C-x&gt;&lt;C-i&gt;</code></td><td>包含文件关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-]&gt;</code></td><td>标签文件关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-k&gt;</code></td><td>字典查找</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-l&gt;</code></td><td>整行补全</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-f&gt;</code></td><td><strong>文件名补全</strong></td></tr><tr><td><code>&lt;C-x&gt;&lt;C-o&gt;</code></td><td><strong>全能（Omni）补全</strong></td></tr></tbody></table><p><strong>常见的三种补全类型：</strong></p><ul><li><p>使用<code>&lt;Ctrl+n&gt;</code>和<code>&lt;Ctrl+p&gt;</code>补全单词</p><p><code>Ctrl+n</code>：n(next)代表下一个补全的选项</p><p><code>Ctrl+p</code>：p(previous)代表上一个补全的选项</p></li><li><p>使用<code>&lt;Ctrl+x&gt;</code>+<code>&lt;Ctrl+f&gt;</code>补全文件名</p><p><code>Ctrl+w</code>：回删一个单词</p></li><li><p>使用<code>&lt;Ctrl+x&gt;</code>和<code>&lt;Ctrl+o&gt;</code>补全代码，需要开启文件类型检查，安装插件</p><p><code>:filetype on</code>：开启文件类型检查</p><p><code>:set filetype</code>：查看当前文件类型</p></li></ul><p><code>:r! echo %</code>：当前文件名（文件名）。<code>&quot;%p</code>也可输出文件名</p><p><code>:r! echo %:p</code>：当前文件名称（文件路径+文件名）</p><p>For more info：</p><pre><code>:help read:help filename-modifiers</code></pre><p>课后练习：</p><blockquote><p>知道如何在Vim中使用补全，补全的几种常见类型</p></blockquote><ul><li>尝试使用Vim中的补全方式来补全单词</li><li>在Vim中输入文件名的时候尝试补全，想想如何输入现有的文件名？</li><li>延伸：目前补全都是基于文本匹配的，插件可是实现代码补全。</li></ul><h3 id="2-12-给-Vim-换个配色-06-32"><a href="#2-12-给-Vim-换个配色-06-32" class="headerlink" title="2-12 给 Vim 换个配色 (06:32)"></a>2-12 给 Vim 换个配色 (06:32)</h3><p>Vim更换颜色</p><ul><li>使用<code>:colorscheme</code>显示当前的主题配色，默认是<code>default</code></li><li>使用<code>:colorscheme &lt;Ctrl+d&gt;</code>可以显示所有的配色</li><li>有中意的配色后，使用<code>:colorscheme 配色名</code>就可以修改颜色</li></ul><p><code>vim duck.go duck.py -O</code>：打开两个文件并垂直分割。在一个窗口的一个Tab页中</p><p>从网上下载配色</p><blockquote><p>默认的配色没有喜欢的怎们办？</p></blockquote><ul><li><p>从网络上寻找更好看的配色</p></li><li><p><a href="http://github.com/flazz/vim-colorschemes" target="_blank" rel="noopener">http://github.com/flazz/vim-colorschemes</a></p><p><a href="http://github.com/w0ng/vim-hybrid" target="_blank" rel="noopener">http://github.com/w0ng/vim-hybrid</a></p></li><li><p>安装之后就有大量的主题可以更换了</p><pre><code>git clone https://github.com/w0ng/vim-hybrid.gitmkdir -p ~/.vim/colorscp vim-hybrid/colors/hybrid.vim ~/.vim/colors</code></pre></li></ul><p>课后练习</p><ul><li>尝试更改Vim的配色方案，想要持久化配置需要写到<code>.vimrc</code>中</li><li>在网上选一个喜欢的配色方案，下载并使用它，比如<code>hybird</code></li><li>下载多个配色方案到<code>.vim/colors</code>并且随时更换</li></ul><h3 id="2-13-本章小结：裸-Vim-也很强-02-37"><a href="#2-13-本章小结：裸-Vim-也很强-02-37" class="headerlink" title="2-13 本章小结：裸 Vim 也很强 (02:37)"></a>2-13 本章小结：裸 Vim 也很强 (02:37)</h3><p>裸的Vim</p><blockquote><p>本节没使用配置过的Vim，而是用裸的Vim演示，目的何在？</p></blockquote><ul><li>很多初学者Vim基本命令都不熟练就开始找一些复杂的强大配置</li><li>不利于熟悉Vim，一旦出问题了还不知道怎们修复</li><li>建议初学者从裸的Vim开始学习。有些场景，比如服务器或者容器上无法配置Vim</li></ul><p>裸的Vim也很强</p><blockquote><p>学习Vim之前，先用正确打字指法和盲打</p></blockquote><ul><li>编辑代码，脑子🧠一般比手👋快，盲打有利于跟上你的大脑速度</li><li>裸的Vim也有很多强大的功能和使用方式</li><li>学会了使用Vim，可以在任何IDE上安装Vim插件，几乎所有流行的编辑器和IDE工具都支持Vim插件</li></ul><p>下一步该学习什么？</p><blockquote><p>前提是已经无障碍使用Vim，并且没有那么痛苦纠结了。</p></blockquote><ul><li>学习<strong>Vim配置</strong>，我的Vim我做主</li><li>Vim也在与时俱进，探索学习各种炫酷和方便的<strong>插件</strong></li><li>用中学，学中用。慢慢就有了肌肉记忆</li></ul><h2 id="第3章-编写-Vim-配置，我的-Vim-我做主"><a href="#第3章-编写-Vim-配置，我的-Vim-我做主" class="headerlink" title="第3章 编写 Vim 配置，我的 Vim 我做主"></a>第3章 编写 Vim 配置，我的 Vim 我做主</h2><blockquote><p>学习如何编写Vim 的配置文件，自定义 Vim。</p></blockquote><h3 id="3-1-编写-vim-配置，我的-vim-我做主-17-09"><a href="#3-1-编写-vim-配置，我的-vim-我做主-17-09" class="headerlink" title="3-1 编写 vim 配置，我的 vim 我做主 (17:09)"></a>3-1 编写 vim 配置，我的 vim 我做主 (17:09)</h3><p>什么是Vim配置</p><blockquote><p>什么是Vim的配置，为什么要使用它呢？</p></blockquote><ul><li>Vim里有非常多常用的设置，比如<code>:set number</code>设置行号</li><li>之前的使用都是在Vim里临时设置，没法持久化，每次打开文件都需要设置</li><li><code>.vimrc</code>提供了一种持久化配置的方式，让用户自定义配置</li></ul><p>如何编写Vim配置文件</p><ul><li>Linux/Unix下新建一个隐藏文件<code>vim ~/.vimrc</code></li><li>Windows系统<code>vim $MYVIMRC</code>，通过环境变量编辑配置文件</li><li>接着就可以开始自定义配置</li></ul><p>Vim配置都包含什么？</p><ul><li>常用设置。比如：<code>set number</code>设置行号、<code>colorscheme hybrid</code>设置主题</li><li>常用的Vim映射。比如：<code>noremap &lt;leader&gt;w :w&lt;cr&gt;</code>保存文件</li><li>自定义的<code>vimscript</code>函数(vim高手)和插件的配置(插件篇)</li></ul><p>常用设置：</p><ul><li>可以把常用的设置写到<code>.vimrc</code>里，避免每次打开Vim重新设置</li><li>比如设置行号<code>set number</code>、设置主题<code>colorscheme hybrid</code></li><li>Vim里有非常多的配置，可以参考大佬的配置</li></ul><p>Vim中的映射</p><blockquote><p>Vim中的映射比较复杂，源于Vim有多种模式</p></blockquote><ul><li>设置一下<code>&lt;leader&gt;</code>键，<code>let mapleader = &#39;,&#39;</code>，常用的是逗号<code>,</code>或者空格<code>&lt;Space&gt;</code></li><li>比如用<code>inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;</code>在插入模式保存</li><li>Vim中的映射概念稍微复杂，但是非常强大</li></ul><p>Tmux使用<code>Ctrl+B+%</code>实现垂直分割屏幕</p><p>​    <code>zt</code>：将光标所在行定位于屏幕顶部</p><p>​    <code>zz</code>：将光标所在行定位于屏幕中部</p><p>​    <code>jj</code>：映射<code>&lt;Esc&gt;</code>键，退到普通normal模式</p><p>​    <code>:FormatJSON</code>：格式化JSON代码</p><p>​    <code>Ctrl+h/j/k/l</code>：映射<code>&lt;Ctrl-w&gt;+h/j/k/l</code>，光标在分屏窗口中移动</p><p>​    <code>xp</code>：普通模式下，对调字符</p><p>​    <code>:h option-list</code>：查看指令列表</p><p>Vim插件</p><blockquote><p>现代化的Vim可以通过Vim插件管理器安装插件</p></blockquote><ul><li>通过插件用户可以无限扩充Vim的功能</li><li>想要使用插件需要具备一定的Vim配置知识</li></ul><p>Vim脚本</p><blockquote><p>Vim有自己的脚本语言<code>Vimscript</code></p></blockquote><ul><li>Vim脚本对于Vim高级玩家来说可以实现强大的Vim插件</li><li>初学者知道有这个概念就好，Vim脚本是一种简单的脚本语言</li><li>可以通过<code>vimscript</code>实现更多Vim的控制，开发自己的插件</li></ul><p>课后练习</p><blockquote><p>掌握Vim配置需要对Vim本身很熟悉</p></blockquote><ul><li><p>尝试自己建立一个<code>~/.vimrc</code>文件，加入常见的设置选项</p></li><li><p>研究一下GitHub上<code>vim-go</code>教程<code>vim-go-tutoial</code>的<code>.vimrc</code>文件</p><p><a href="https://github.com/fatih/vim-go-tutorial/blob/master/vimrc" target="_blank" rel="noopener">https://github.com/fatih/vim-go-tutorial/blob/master/vimrc</a></p></li><li><p>拿来主义、网上、很多人开源了自己的配置(dotfiles)可参考学习</p><p><strong>通过把<code>.vimrc</code>配置文件放到git版本库可以同步到其他电脑或者服务器上</strong></p></li></ul><p>课程讲师的<code>.vimrc</code>文件：</p><pre><code class="shell">&quot; 常用设置&quot; 设置行号set numbercolorscheme hybrid&quot; 按F2进入粘贴模式set pastetoggle=&lt;F2&gt;&quot; 高亮搜索set hlsearch&quot; 设置折叠方式set foldmethod=indent&quot; 一些方便的映射let mapleader=&#39;,&#39;let g:mapleader=&#39;,&#39;&quot; 使用 jj 进入 normal模式inoremap jj &lt;Esc&gt;`^&quot; 使用 &lt;leader&gt;+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;noremap &lt;leader&gt;w :w&lt;cr&gt;&quot; 切换 buffernnoremap &lt;silent&gt; [p :bprevious&lt;cr&gt;nnoremap &lt;silent&gt; [n :bnext&lt;cr&gt;&quot; use ctrl+h/j/k/l switch windownoremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l&quot; Sudo to writecnoremap w!! w !sudo tee % &gt;/dev/null&quot; json 格式化com! FormatJSON %!python3 -m json.tool&quot; 插件设置，这里使用了 vim-plugcall plug#begin(&#39;~/.vim/plugged&#39;)&quot; 安装插件只需要把 github 地址放到这里重启后执行 :PlugInstall 就好了Plug &#39;mhinz/vim-startify&#39;Plug &#39;scrooloose/nerdtree&#39;call plug#end()&quot; 插件相关配置&quot; 禁止 stratify 自动切换目录let g:startify_change_to_dir = 0&quot; nerdtreenmap ,v :NERDTreeFind&lt;cr&gt;nmap ,g :NERDTreeToggle&lt;cr&gt;&quot; 定义函数SetTitle，自动插入文件头func SetTitle()    if &amp;filetype == &#39;python&#39;        call setline(1, &quot;\#!/usr/bin/env python&quot;)        call setline(2, &quot;\# -*- coding:utf-8 -*-&quot;)        normal G        normal o        normal o        call setline(5, &quot;if __name__ == &#39;__main__&#39;:&quot;)        call setline(6, &quot;    pass&quot;)    endifendfunc</code></pre><h3 id="3-2-Vim-映射迷人眼-14-53"><a href="#3-2-Vim-映射迷人眼-14-53" class="headerlink" title="3-2 Vim 映射迷人眼 (14:53)"></a>3-2 Vim 映射迷人眼 (14:53)</h3><p>什么是Vim映射</p><blockquote><p>Vim映射就是把「一个操作」映射到「另一个操作」</p></blockquote><ul><li>如果你不满意现在的按键设置，比如Vim本来的命令</li><li>或者想要映射一些方便的快捷键</li><li>按照用户意愿定制Vim</li></ul><p>基本映射</p><blockquote><p>基本映射指的是在普通normal模式下的映射，当然还有其他模式的映射</p></blockquote><ul><li><p>使用<code>map</code>就可以实现映射。比如：<code>:map - x</code>按<code>-</code>就会删除字符</p><p>取消<code>map</code>映射使用<code>:unmap -</code></p></li><li><p><strong><code>:map &lt;space&gt; viw</code>按空格键<code>&lt;space&gt;</code>就会选中光标所在的整个单词</strong></p></li><li><p><code>:map &lt;C-d&gt; dd</code>按<code>Ctrl+d</code>执行<code>dd</code>删除一行</p></li></ul><p>模式映射</p><blockquote><p>Vim常用模式normal/visual/insert都可以定义映射</p></blockquote><ul><li><p>用<code>nmap</code>/<code>vmap</code>/<code>imap</code>定义映射,只在normal/visual/insert分别有效</p></li><li><p><code>:vmap \ U</code>：把在visual模式下选中的文本大小写(u(小写)/U(大写)转化大小写)</p></li><li><p>想想如何在insert模式下映射<code>Ctrl+d</code>来删除一行</p><p><code>:imap &lt;C-d&gt; &lt;Esc&gt;ddi</code></p></li></ul><p><strong>现有映射的问题？</strong></p><blockquote><pre><code>:nmap - dd:nmap \ -</code></pre><p>当按下<code>\</code>时，Vim会解析<code>\</code>为<code>-</code>；因为又映射了<code>-</code>，Vim会继续解析<code>-</code>为<code>dd</code>，即最终按下<code>\</code>会删除整行。（类似于递归解析映射）</p></blockquote><p>递归映射和非递归映射</p><blockquote><p><strong><code>*map</code>系列命令有递归的风险</strong></p></blockquote><ul><li>如果用户安装了一个插件，插件映射了同一个按键的不同行为，有冲突就会有一个失效</li><li>想要保证插件映射没有冲突会非常痛苦</li><li>解决方案就是使用非递归映射</li></ul><p>非递归映射</p><blockquote><p>Vim提供了非递归映射，这些命令不会递归解析</p></blockquote><ul><li>使用<code>*map</code>对应的<code>nnoremap</code>/<code>vnoremap</code>/<code>inoremap</code></li><li>何时使用递归映射<code>*map</code>？何时使用非递归映射<code>*noremap</code>呢？</li><li>「任何」时候都应该使用非递归映射，拯救自己同时也拯救了插件作者</li></ul><p><strong>``^<code>：光标回到最后一次插入模式停止时光标的位置。</code>:help <code>^</code>查看帮助。</strong></p><p>课后练习</p><ul><li><p>尝试在<code>.vimrc</code>文件中定义一些映射，提升工作效率</p></li><li><p>参考一些开源的Vim配置，看看哪些映射可以拿来使用</p></li><li><p>阅读《笨方法学Vimscript》书中关于映射的章节。</p><p><a href="http://learnvimscriptthehardway.onefloweroneworld.com/" target="_blank" rel="noopener">http://learnvimscriptthehardway.onefloweroneworld.com/</a></p></li></ul><h3 id="3-3-本章小结：配置-Vim，让她更顺手-01-16"><a href="#3-3-本章小结：配置-Vim，让她更顺手-01-16" class="headerlink" title="3-3 本章小结：配置 Vim，让她更顺手 (01:16)"></a>3-3 本章小结：配置 Vim，让她更顺手 (01:16)</h3><p>学习和使用配置</p><blockquote><p>学习和使用Vim配置是Vim玩家进阶的必修之路</p></blockquote><ul><li>了解常见的配置选项</li><li>学习和使用Vim映射，用得不爽我就改</li><li>Vim进阶需要学习Vimscript。《笨发放学Vimscript》</li></ul><p>下一步该学什么？</p><blockquote><p>强大的Vim插件</p></blockquote><ul><li>Vim也在与时俱进，发布了Vim8，还有Neovim</li><li>知道如何配置Vim之后，开始探索各种强大的Vim插件</li><li>打好<strong>Vim配置</strong>和<strong>映射</strong>的基础，开始学习如何安装和使用插件</li></ul><h2 id="第4章-Vim-安装和使用插件"><a href="#第4章-Vim-安装和使用插件" class="headerlink" title="第4章 Vim 安装和使用插件"></a>第4章 Vim 安装和使用插件</h2><blockquote><p>学会如何安装和使用常见的 Vim 插件，增强 Vim 的功能。</p></blockquote><h3 id="4-1-Vim-安装插件，竟如此简单-08-40"><a href="#4-1-Vim-安装插件，竟如此简单-08-40" class="headerlink" title="4-1 Vim 安装插件，竟如此简单 (08:40)"></a>4-1 Vim 安装插件，竟如此简单 (08:40)</h3><p>什么是插件？</p><blockquote><p>和其他现代流行编辑器一样，Vim同样支持强大的插件扩展</p></blockquote><ul><li>Vim插件是使用vimscript或者其他语言编写的vim功能扩展</li><li>编辑器自带的功能有限，有了插件之后几乎可以无限扩充其功能</li><li>网络上比如GitHub.com等有很多开源的Vim插件可以使用</li></ul><p>如何安装插件？</p><blockquote><p>原始的方式是直接clone插件代码，如今Vim有很多插件管理器</p></blockquote><ul><li><p>目前Vim有很多插件管理器可供选择</p></li><li><p>常见的有：<code>vim-plug</code>、<code>Vundle</code>、<code>Pathogen</code>、<code>Dein.Vim</code>、<code>volt</code>等</p></li><li><p>综合性能、易用性、文档等几个方面，推荐使用<code>vim-plug</code></p><p><a href="https://www.slant.co/topics/1224/~best-plugin-managers-for-vim" target="_blank" rel="noopener">https://www.slant.co/topics/1224/~best-plugin-managers-for-vim</a></p></li></ul><p>使用<code>vim-plug</code>安装插件</p><ul><li><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">https://github.com/junegunn/vim-plug</a></p></li><li><p>学习一个新东西的最好方式就是看官方文档</p></li><li><p>按照官方的教程，就可以非常容易地了解它的使用方式</p><pre><code class="shell">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre></li></ul><p>安装第一个插件<code>vim-startify</code></p><blockquote><p>一个好用的vim开屏插件</p></blockquote><ul><li><p><a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">https://github.com/mhinz/vim-startify</a></p></li><li><p>修改<code>.vimrc</code>配置文件，增加该插件的名称</p></li><li><p>重新启动vim或者执行<code>:source ~/.vimrc</code>，执行<code>:PlugInstall</code></p><pre><code class="shell">call plug#begin(&#39;~/.vim/plugged&#39;)Plug &#39;mhinz/vim-startify&#39;call plug#end()</code></pre><p><code>:source ~/.vimrc</code></p><p><code>:PlugInstall</code></p></li><li><p>如果已经安装完成，退出并重新打开Vim查看效果</p></li></ul><p>课后练习</p><blockquote><p>打开Vim操练起来，首先下载vim-plug并浏览其文档</p></blockquote><ul><li>安装vim-plug插件管理器</li><li>安装vim插件vim-startify、nerdtree，看看能否生效</li></ul><h3 id="4-2-如何寻找自己需要的插件-06-42"><a href="#4-2-如何寻找自己需要的插件-06-42" class="headerlink" title="4-2 如何寻找自己需要的插件 (06:42)"></a>4-2 如何寻找自己需要的插件 (06:42)</h3><ul><li><p>Google关键词搜索</p></li><li><p><a href="https://github.com/vim-awesome/vim-awesome" target="_blank" rel="noopener">https://github.com/vim-awesome/vim-awesome</a></p><p><a href="https://vimawesome.com/" target="_blank" rel="noopener">https://vimawesome.com/</a></p></li><li><p>浏览网上开源的vim配置，借鉴想要的插件</p></li></ul><h3 id="4-3-vim美化插件，让你的-vim-与众不同-09-57"><a href="#4-3-vim美化插件，让你的-vim-与众不同-09-57" class="headerlink" title="4-3 vim美化插件，让你的 vim 与众不同 (09:57)"></a>4-3 vim美化插件，让你的 vim 与众不同 (09:57)</h3><p>vim美化插件</p><blockquote><p>更改vim的外观</p></blockquote><ul><li><p>修改启动界面：<a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">https://github.com/mhinz/vim-startify</a></p><p><code>:Startify</code></p></li><li><p>状态栏美化：<a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">https://github.com/vim-airline/vim-airline</a></p><p><a href="https://github.com/vim-airline/vim-airline-themes" target="_blank" rel="noopener">https://github.com/vim-airline/vim-airline-themes</a></p></li><li><p>增加代码缩进线条：<a href="https://github.com/Yggdroot/indentLine" target="_blank" rel="noopener">https://github.com/Yggdroot/indentLine</a></p></li></ul><p>vim配色方案</p><ul><li>vim-hybrid配色：<a href="https://github.com/w0ng/vim-hybrid" target="_blank" rel="noopener">https://github.com/w0ng/vim-hybrid</a></li><li>solarized配色：<a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="noopener">https://github.com/altercation/vim-colors-solarized</a></li><li>gruvbox配色：<a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener">https://github.com/morhetz/gruvbox</a></li></ul><p>课后练习</p><ul><li>尝试使用vim-stratify快速打开最近使用的文件</li><li>安装vim-airline美化状态栏</li><li>安装indentline给vim增加代码缩进线</li></ul><h3 id="4-4-Vim文件目录和搜索插件，跳转文件so-easy-12-20"><a href="#4-4-Vim文件目录和搜索插件，跳转文件so-easy-12-20" class="headerlink" title="4-4 Vim文件目录和搜索插件，跳转文件so easy (12:20)"></a>4-4 Vim文件目录和搜索插件，跳转文件so easy (12:20)</h3><p><strong>文件目录树</strong>：</p><blockquote><p>默认的文件目录管理比较简陋，nerdtree弥补了这个问题</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gj3vo85oj311w0o87le.jpg" alt="文件目录树" style="zoom:45%;" /><p>文件管理器nerdtree</p><blockquote><p>使用nerdtree插件进行文件目录树管理</p></blockquote><ul><li><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree</a></p><p><code>:NERDTree</code></p><p><code>:NERDTreeFind</code></p><p><code>:NERDTreeToggle</code></p></li><li><p><code>autocmd vimenter * NERDTree</code>可以在启动vim的时候打开NERDTree‘</p></li><li><p><code>map &lt;leader&gt;v :NERDTreeFind&lt;CR&gt;</code>查找文件位置</p></li></ul><p><strong>快速搜索文件</strong>：</p><blockquote><p>如何根据文件名快速查找打开一个文件</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gk4xgm5mj316e0m0137.jpg" alt="快速搜索文件" style="zoom:45%;" /><p>模糊搜索器</p><blockquote><p>使用ctrlp插件快速查找并且打开文件</p></blockquote><ul><li><a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="noopener">https://github.com/ctrlpvim/ctrlp.vim</a></li><li><code>let g:ctrlp_map = &#39;&lt;c-p&gt;&#39;</code></li><li>使用<Ctrl-p>，然后输入少量字符就可以开始搜索</li></ul><p>课后练习</p><blockquote><p>快速定位文件是常用操作，需牢牢掌握提升效率</p></blockquote><ul><li>安装nerdtree插件，加入快捷键映射</li><li>安装ctrlp插件，然后使用快速定位文件</li><li>改变自己之前低效的操作方式，适应新的操作方式</li></ul><h3 id="4-5-Vim快速定位插件，文件位置任我行-05-58"><a href="#4-5-Vim快速定位插件，文件位置任我行-05-58" class="headerlink" title="4-5 Vim快速定位插件，文件位置任我行 (05:58)"></a>4-5 Vim快速定位插件，文件位置任我行 (05:58)</h3><p>Vim移动命令：</p><blockquote><p>在基础篇学习了很多Vim移动的命令</p></blockquote><ul><li>比如，<code>w</code>/<code>e</code>基于单词移动，<code>gg</code>/<code>G</code>文件首尾，<code>0</code>/<code>$</code>行首尾，<code>f{char}</code>查询字符</li><li><code>Ctrl+f</code>、<code>Ctrl+u</code>前后翻屏</li><li>如果需要快速跳转到当前窗口显示区的任意位置需要怎们做？</li></ul><p>如何快速移动到任意位置</p><blockquote><p>可以使用vim的搜索/加上n跳转，但是使用easymotion更方便</p></blockquote><ul><li><a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">https://github.com/easymotion/vim-easymotion</a></li><li>官方文档较长，其实一个映射就能应付</li><li><code>nmap ss &lt;Plug&gt;(easymotion-s2)</code></li></ul><p>课后练习</p><blockquote><p>安装并使用easymotion插件</p></blockquote><ul><li>回忆一下vim里常用的移动操作</li><li>安装easymotion插件</li><li>使用easymotion练习在文件窗口的任意位置跳转</li></ul><h3 id="4-6-Vim-surround，编辑也要成双成对-05-27"><a href="#4-6-Vim-surround，编辑也要成双成对-05-27" class="headerlink" title="4-6 Vim-surround，编辑也要成双成对 (05:27)"></a>4-6 Vim-surround，编辑也要成双成对 (05:27)</h3><p>vim-surround</p><blockquote><p> 如何快速更换一对单引号为双引号?</p></blockquote><ul><li><p>一个一个查找然后替换</p></li><li><p><a href="https://github.com/tpope/vim-surround" target="_blank" rel="noopener">https://github.com/tpope/vim-surround</a></p></li></ul><p>vim-surround使用</p><blockquote><p>normal模式下增加、删除、修改成对内容</p></blockquote><ul><li><code>ds</code>（delete a surrounding）</li><li><code>cs</code>（change a surrounding）</li><li><code>ys</code>（you add a surrounding）</li></ul><p>例子：</p><ul><li><code>ysiw&quot;</code>：给单词增加<code>&quot;</code></li><li><code>cs&quot;&#39;</code>：修改<code>&quot;</code>为<code>&#39;</code></li><li><code>cs(]</code>：修改<code>(</code>为<code>]</code>，替换后的括号需要使用后括号，前括号会产生空格</li><li><code>ds&#39;</code>：删除<code>&#39;</code></li><li><code>ds(</code>：删除<code>(</code></li></ul><p>课后练习</p><blockquote><p>vim-surround大法好</p></blockquote><ul><li>使用vim-plug安装vim-surround插件</li><li>使用练习修改成对的内容，比如修改单引号为双引号</li><li>多练习几次，使用插件提升编辑效率</li></ul><h3 id="4-7-强大的Vim模糊搜索与替换插件-08-26"><a href="#4-7-强大的Vim模糊搜索与替换插件-08-26" class="headerlink" title="4-7 强大的Vim模糊搜索与替换插件 (08:26)"></a>4-7 强大的Vim模糊搜索与替换插件 (08:26)</h3><p>模糊搜索</p><blockquote><p>经常需要在一个代码项目中模糊搜索一些文本，怎们办？</p></blockquote><ul><li>vim自带的搜索可以搜索当前文件，但是项目有很多个文件</li><li>需要使用插件来模糊搜索多个文件内容</li><li>使用Ag.vim或者fzf.vim，都可以很好的支持模糊搜索</li></ul><p>fzf与fzf.vim</p><blockquote><p>fzf是一个强大的命令行模糊搜索工具，fzf.vim集成到了vim里</p></blockquote><ul><li><p><a href="https://github.com/junegunn/fzf.vim" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim</a></p></li><li><p>安装</p><pre><code class="shell">Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;</code></pre></li><li><p>使用<code>Ag [PATTERN]</code>模糊搜索字符串</p></li><li><p>使用<code>Files [PATH]</code>模糊搜索目录</p></li><li><p>更多命令：<a href="https://github.com/junegunn/fzf.vim#commands" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim#commands</a></p></li></ul><p>例子：</p><p><code>:Files .</code>：查看当前目录下的所有文件，再输入文件名实现搜索</p><p><code>:Ag {PATTERN}</code>：查找文本内容。</p><p>此处遇到了一个问题：ag is not found</p><p>解决方法参考：<a href="https://github.com/junegunn/fzf.vim/issues/440" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim/issues/440</a></p><p>搜索替换插件far.vim</p><blockquote><p>如果想要批量搜索替换，可以使用far.vim</p></blockquote><ul><li><p><a href="https://github.com/brooth/far.vim" target="_blank" rel="noopener">https://github.com/brooth/far.vim</a></p></li><li><p>使用</p><pre><code class="shell">:Far foo bar **/*.py:Fardo</code></pre></li><li><p>比如在代码重构的时候会经常使用到</p></li><li><p><code>:Far foo bar **/*.py</code></p></li></ul><p>课后练习</p><blockquote><p>模糊搜索和替换是一个非常常用的操作</p></blockquote><ul><li>使用vim-plug安装fzf.vim和far.vim</li><li>使用fzf.vim在一个项目中搜索想要的文本</li><li>使用far.vim批量替换一个项目下的文本</li></ul><h3 id="4-8-愉快写-golang-之vim-go插件-10-19"><a href="#4-8-愉快写-golang-之vim-go插件-10-19" class="headerlink" title="4-8 愉快写 golang 之vim-go插件 (10:19)"></a>4-8 愉快写 golang 之vim-go插件 (10:19)</h3><p>编辑器 VS IDE</p><blockquote><p>IDE一代又一代，经典的编辑器却长久不衰</p></blockquote><ul><li>除了Java，很多人用vim编写shell/php/golang/python/ruby</li><li>前端很多人使用VSCode，sublime/Atom有没落之势</li><li>很多后端和运维工程师使用vim，微信后台和阿里飞天系统很多代码出自在服务器上使用vim的工程师</li></ul><p>vim-go</p><blockquote><p>功能强大的golang插件vim-go</p></blockquote><ul><li><p><a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">https://github.com/fatih/vim-go</a></p></li><li><p>代码补全、重构、跳转、自动格式化、自动导入等功能</p></li><li><p>基本可以满足golang日常开发</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;Ctrl-x&gt;&lt;Ctrl-o&gt;</code></td><td>打开补全列表</td></tr><tr><td><code>&lt;Ctrl-p&gt;</code></td><td>向上选择补全</td></tr><tr><td><code>&lt;Ctrl-n&gt;</code></td><td>向下选择补全</td></tr><tr><td><code>&lt;Ctrl-]&gt;</code></td><td>跳转到定义的方法</td></tr><tr><td><code>&lt;Ctrl-o&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-i&gt;</code></td><td>跳转到上一次的地方</td></tr></tbody></table><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:GoFmt</code></td><td>格式化代码</td></tr><tr><td><code>:GoRename</code></td><td>重构名称</td></tr><tr><td><code>:GoImports</code></td><td>自动带入包</td></tr><tr><td><code>:GoRun</code></td><td>运行代码</td></tr><tr><td><code>:w</code></td><td>保存文件自动格式化代码</td></tr></tbody></table></li><li><p>vimrc配置：</p><pre><code class="shell">autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4</code></pre></li></ul><p>课后练习</p><ul><li>安装vim-go插件，阅读vim-go-tutorial教程</li><li>使用vim-go编写Go语言代码</li><li>如果遇到了问题，请查看vim-go-tutorial教程或者vim-go文档</li></ul><h3 id="4-9-python-mode把-vim-打造成轻量-Python-IDE-07-11"><a href="#4-9-python-mode把-vim-打造成轻量-Python-IDE-07-11" class="headerlink" title="4-9 python-mode把 vim 打造成轻量 Python IDE (07:11)"></a>4-9 python-mode把 vim 打造成轻量 Python IDE (07:11)</h3><p>Python-mode</p><blockquote><p>Python插件使用比较多的是jedi-vim和Python-mode</p></blockquote><ul><li><a href="https://github.com/python-mode/python-mode" target="_blank" rel="noopener">https://github.com/python-mode/python-mode</a></li><li>Python-mode具备基本的补全、跳转、重构、格式化功能</li><li>即使是在服务器上也能方便的调试Python代码</li></ul><ul><li><p>查看是否支持python：<code>vim --version | grep python</code>：</p></li><li><p>vimrc配置</p><pre><code class="shell">let g:pymode_python = &#39;python3&#39;let g:pymode_trim_whitespaces = 1let g:pymode_doc = 1let g:pymode_doc_bind = &#39;K&#39;let g:pymode_rope_goto_definition_bind = &#39;&lt;C-]&gt;&#39;let g:pymode_lint = 1let g:pymode_lint_checkers = [&#39;pyflakes&#39;, &#39;pep8&#39;, &#39;mccabe&#39;, &#39;pylint&#39;]let g:pymode_options_max_line_length = 120</code></pre></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;Ctrl-x&gt;&lt;Ctrl-o&gt;</code></td><td>打开补全列表</td></tr><tr><td><code>&lt;Ctrl-p&gt;</code></td><td>向上选择补全</td></tr><tr><td><code>&lt;Ctrl-n&gt;</code></td><td>向下选择补全</td></tr><tr><td><code>&lt;Ctrl-]&gt;</code></td><td>跳转到定义的方法</td></tr><tr><td><code>&lt;Ctrl-o&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-i&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-C&gt;ro</code></td><td>整理导入包的顺序</td></tr></tbody></table><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:PymodeLintAuto</code></td><td>自动Lint整理格式代码</td></tr><tr><td><code>:w</code></td><td>保存文件时做文件静态检查，并提示相应错误</td></tr></tbody></table><p>课后练习：</p><ul><li>安装python-mode插件</li><li>使用python-mode编写Python代码</li><li>如果遇到了问题，尝试查询python-mode文档解决</li></ul><h3 id="4-10-Vim-tagbar，更愉快地浏览代码-11-14"><a href="#4-10-Vim-tagbar，更愉快地浏览代码-11-14" class="headerlink" title="4-10 Vim tagbar，更愉快地浏览代码 (11:14)"></a>4-10 Vim tagbar，更愉快地浏览代码 (11:14)</h3><p>tagbar</p><blockquote><p>代码大纲，支持多种编程语言</p></blockquote><ul><li><p><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a></p></li><li><p>需要安装Universal Ctags生成对应的tag文件</p></li><li><p>快速浏览当前文件代码结构，并且搜索跳转到对应代码块</p></li><li><p>vimrc配置</p><pre><code class="shell">nnoremap &lt;leader&gt;t :TagbarToggle&lt;CR&gt;</code></pre></li></ul><p>安装ctags：</p><ul><li><p>Universal Ctags：<a href="https://ctags.io/" target="_blank" rel="noopener">https://ctags.io/</a></p></li><li><p><a href="https://docs.ctags.io/en/latest/osx.html#building-with-homebrew" target="_blank" rel="noopener">https://docs.ctags.io/en/latest/osx.html#building-with-homebrew</a></p><pre><code class="shell">brew tap universal-ctags/universal-ctagsbrew install --HEAD universal-ctags</code></pre></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:Tagbar</code></td><td>显示Tagbar</td></tr><tr><td><code>:TagbarToggle</code></td><td>显示Tagbar并定位到当前方法的目录</td></tr><tr><td><code>:ls</code></td><td>查看buffer</td></tr><tr><td><code>:b duck.py</code></td><td>跳转到duck.py的buffer</td></tr></tbody></table><p>vim-interestingwords</p><blockquote><p>高亮感兴趣的单词，浏览代码很有用</p></blockquote><ul><li><a href="https://github.com/lfv89/vim-interestingwords" target="_blank" rel="noopener">https://github.com/lfv89/vim-interestingwords</a></li><li>浏览代码的时候经常需要知道一个变量的使用方式</li><li>可以使用这个插件同时高亮多个单词</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;leader&gt;k</code></td><td>高亮单词</td></tr><tr><td><code>u</code>/<code>U</code></td><td>下/上一个高亮</td></tr><tr><td><code>&lt;leader&gt;K</code></td><td>取消所有高亮</td></tr></tbody></table><p>课后练习</p><ul><li>安装tagbar，开启文件代码大纲</li><li>安装interestingwords，高亮感兴趣的单词</li><li>如果遇到了问题，尝试查询插件的官方文档/Google搜索/vim help解决</li></ul><h3 id="4-11-强大的-vim-代码补全插件-07-16"><a href="#4-11-强大的-vim-代码补全插件-07-16" class="headerlink" title="4-11 强大的 vim 代码补全插件 (07:16)"></a>4-11 强大的 vim 代码补全插件 (07:16)</h3><p>deoplete.nvim</p><blockquote><p>一个强大的neovim/vim8异步补全插件</p></blockquote><ul><li><a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">https://github.com/Shougo/deoplete.nvim</a></li><li>多编程语言的支持，支持模糊匹配</li><li>需要安装对应编程语言的扩展</li></ul><p>安装：</p><pre><code class="shell">if has(&#39;nvim&#39;)  Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }else  Plug &#39;Shougo/deoplete.nvim&#39;  Plug &#39;roxma/nvim-yarp&#39;  Plug &#39;roxma/vim-hug-neovim-rpc&#39;endif</code></pre><p>如若报错请安装依赖：</p><pre><code class="shell">pip3 install --user pynvim</code></pre><p>配置：</p><pre><code class="shell">let g:deoplete#enable_at_startup = 1</code></pre><p>其他代码补全插件</p><ol><li><p>deoplete-jedi：</p><blockquote><p>Python语言代码补全，可以补全自己所写的库</p><p><a href="https://github.com/deoplete-plugins/deoplete-jedi" target="_blank" rel="noopener">https://github.com/deoplete-plugins/deoplete-jedi</a></p></blockquote></li><li><p>deoplete-go：</p><blockquote><p>Go语言代码补全</p><p><a href="https://github.com/deoplete-plugins/deoplete-go" target="_blank" rel="noopener">https://github.com/deoplete-plugins/deoplete-go</a></p></blockquote></li></ol><p>coc.nvim</p><blockquote><p>一个强大的neovim/vim8补全插件。LSP支持</p><p>LSP（Language-Server-Protocol）</p></blockquote><ul><li><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">https://github.com/neoclide/coc.nvim</a></li><li>full language server protocol support as VSCode</li><li>多语言插件支持</li></ul><p>课后练习</p><ul><li>安装deoplete.nvim和coc.nvim</li><li>安装对应的编程语言扩展</li><li>vim/neovim补全插件很多，有些支持异步。</li></ul><h3 id="4-12-Vim代码格式化与静态检查-09-43"><a href="#4-12-Vim代码格式化与静态检查-09-43" class="headerlink" title="4-12 Vim代码格式化与静态检查 (09:43)"></a>4-12 Vim代码格式化与静态检查 (09:43)</h3><p>格式化与静态检查</p><blockquote><p>为什么需要这些工具呢？能让工具做的就不用让人去费心</p></blockquote><ul><li>把精力集中在代码逻辑本身，而不是整理格式这些浪费精力的事情上</li><li>静态检查是为了让编写的代码更加规范。golint/pylint/eslint等</li><li>无论编写何种编程语言，最好都加上自动格式化和静态检查</li></ul><p>Neoformat</p><blockquote><p>vim-autoformat和Neoformat是两种使用较多的格式化插件，这里使用neoformat</p></blockquote><ul><li><a href="https://github.com/sbdchd/neoformat" target="_blank" rel="noopener">https://github.com/sbdchd/neoformat</a></li><li>需要安装对应语言的格式化库。python的autopep8、javascript的prettier等</li></ul><p>安装依赖：</p><pre><code class="shell">pip3 install autopep8</code></pre><p><code>:Neoformat</code>：格式化Python代码</p><p>静态检查Lint</p><blockquote><p>neomake和ale是两种常见的lint插件，这里使用ale</p></blockquote><ul><li><a href="https://github.com/dense-analysis/ale" target="_blank" rel="noopener">https://github.com/dense-analysis/ale</a></li><li>需要安装对应语言的lint库。比如golint/pylint/eslint等</li><li>vim8/neovim支持异步检查，不会影响vim编辑，推荐使用</li></ul><p>安装依赖：</p><pre><code class="shell">pip3 install pylint</code></pre><p>课后练习</p><blockquote><p>让插件帮助完成代码的格式化和静态检查吧。</p></blockquote><ul><li>安装noeformat插件和相关的格式化库，格式化代码</li><li>安装ale和对应语言的lint库，修复代码的缺陷</li><li>需要自定义检查功能（比如忽略某些检查错误），参考官方文档</li></ul><h3 id="4-13-Vim快速注释代码-03-06"><a href="#4-13-Vim快速注释代码-03-06" class="headerlink" title="4-13 Vim快速注释代码 (03:06)"></a>4-13 Vim快速注释代码 (03:06)</h3><p>vim-commentary</p><blockquote><p>vim注释插件有很多，推荐使用轻量的vim-commentary</p></blockquote><ul><li><a href="https://github.com/tpope/vim-commentary" target="_blank" rel="noopener">https://github.com/tpope/vim-commentary</a></li><li>记住常用的命令：gc注释和取消注释</li><li>插件会根据不同的文件类型使用不同注释。python(#)、golang(//)</li></ul><p>行注释：</p><ul><li><code>gcc</code>：注释代码</li><li><code>gcgc</code>：取消注释代码</li></ul><p>块注释：</p><ul><li><code>gc</code>：注释/取消注释代码</li></ul><p>课后练习</p><ul><li>安装vim-commentary插件</li><li>尝试打开Python文件并快速注释一段代码</li><li>打开不同类型的文件，比如go文件，试试注释一段代码或文字</li></ul><h3 id="4-14-vim和git，强强联手-07-11"><a href="#4-14-vim和git，强强联手-07-11" class="headerlink" title="4-14 vim和git，强强联手 (07:11)"></a>4-14 vim和git，强强联手 (07:11)</h3><p>Fugitive</p><blockquote><p>在vim里使用git</p></blockquote><ul><li><a href="https://github.com/tpope/vim-fugitive" target="_blank" rel="noopener">https://github.com/tpope/vim-fugitive</a></li><li>Gedit、Gdiff、Gblame、Gcommit等</li><li>使用tmux新开一个窗口来使用git</li></ul><p>vim-gitgutter</p><blockquote><p>在vim里显示文件变动</p></blockquote><ul><li><a href="https://github.com/airblade/vim-gitgutter" target="_blank" rel="noopener">https://github.com/airblade/vim-gitgutter</a></li><li>当修改文件之后可以显示当前文件的变动</li><li>哪些行新增，哪些行修改，哪些行删除</li></ul><p>配置：</p><pre><code class="shell">set updatetime = 100</code></pre><p>gv.vim</p><blockquote><p>在命令行查看提交记录，命令行工具tig</p></blockquote><ul><li><p><a href="https://github.com/junegunn/gv.vim" target="_blank" rel="noopener">https://github.com/junegunn/gv.vim</a></p></li><li><p>使用<code>:GV</code>命令调用</p></li><li><p>可以浏览代码提交变更</p></li></ul><p>tig</p><ul><li><p><a href="https://github.com/jonas/tig" target="_blank" rel="noopener">https://github.com/jonas/tig</a></p></li><li><p><a href="https://www.jianshu.com/p/d9f60c0abbf7" target="_blank" rel="noopener">tig — 让 git 命令行可视化</a></p></li></ul><p>课后练习</p><ul><li>安装三个git插件</li><li>使用<code>:Gblame</code>等命令</li><li>vim和tmux配合使用</li></ul><h3 id="4-15-本章小结：授人以渔，寻找自己需要的插件-02-29"><a href="#4-15-本章小结：授人以渔，寻找自己需要的插件-02-29" class="headerlink" title="4-15 本章小结：授人以渔，寻找自己需要的插件 (02:29)"></a>4-15 本章小结：授人以渔，寻找自己需要的插件 (02:29)</h3><p>Vim插件千千万</p><blockquote><p>本章介绍了如何安装使用常用的插件</p></blockquote><ul><li>Vim插件很多，不可能都全部介绍。学会自己寻找个安装</li><li>通过搜索引擎Google关键词、vimawesome、参考开源配置寻找插件</li><li>学会阅读插件的README文件和doc里的帮助文件，学习插件使用</li></ul><p>缺什么就找什么插件吧！</p><h2 id="第5章-与时俱进的-Vim"><a href="#第5章-与时俱进的-Vim" class="headerlink" title="第5章 与时俱进的 Vim"></a>第5章 与时俱进的 Vim</h2><blockquote><p>介绍如何安装和使用现有的开源配置，什么是 Neovim 等，站在巨人的肩膀上。</p></blockquote><h3 id="5-1-Vim和Tmux-天作之合-08-27"><a href="#5-1-Vim和Tmux-天作之合-08-27" class="headerlink" title="5-1 Vim和Tmux,天作之合 (08:27)"></a>5-1 Vim和Tmux,天作之合 (08:27)</h3><p>Tmux</p><blockquote><p>强大的终端复用工具。通过brew(Mac)、apt-get(ubuntu)安装</p></blockquote><ul><li>可以复用终端、分屏、托管进程等</li><li>在服务器上即使退出服务器也不会被kill，托管进程也很方便</li><li>可以方便地分割屏幕，实现多个进程公用屏幕</li></ul><p>Tmux使用文章：<a href="https://zhuanlan.zhihu.com/p/43687973" target="_blank" rel="noopener">手把手教你使用终端复用神器 Tmux，丢掉鼠标不是梦</a></p><p><code>&lt;Ctrl-b&gt;%</code>：垂直分屏</p><p><code>&lt;Ctrl-b&gt;&quot;</code>：水平分屏</p><p><code>&lt;Ctrl-b&gt;c</code>：创建新tmux窗口</p><p><code>&lt;Ctrl-b&gt;n</code>：跳转到下一个tmux窗口</p><p><code>&lt;Ctrl-b&gt;p</code>：跳转到上一个tmux窗口</p><p><code>&lt;Ctrl-b&gt;h</code>：向左切换分屏</p><p><code>&lt;Ctrl-b&gt;l</code>：向右切换分屏</p><p><code>&lt;Ctrl-b&gt;s</code>：查看所有会话</p><p><code>&lt;Ctrl-b&gt;d</code>：脱离当前会话。d(etach）</p><p><code>tmux ls</code>：查看会话列表</p><p><code>tmux new -s &lt;session_name&gt;</code>：创建会话</p><p><code>tmux att -t &lt;session_name&gt;</code>：链接会话。att(ach)</p><p>课后练习</p><blockquote><p>在系统或者服务器上安装tmux</p></blockquote><ul><li>使用tmux分割屏幕</li><li>尝试一个窗口编写代码，另一个窗口使用shell命令</li><li>尝试退出和重新attach到一个tmux的会话</li></ul><h3 id="5-2-无处不在的-vim，让-vim-嵌入你的开发工具-01-42"><a href="#5-2-无处不在的-vim，让-vim-嵌入你的开发工具-01-42" class="headerlink" title="5-2 无处不在的 vim，让 vim 嵌入你的开发工具 (01:42)"></a>5-2 无处不在的 vim，让 vim 嵌入你的开发工具 (01:42)</h3><p>几乎流行的编辑器和IDE都支持VIM插件</p><blockquote><p>让vim嵌入开发工具，甚至Chrome都有vimium插件</p></blockquote><ul><li>即使不用vim作为主力编辑器，依然可以使用它的编辑方式</li><li>几乎流行的开发工具都支持vim插件，以vim的方式编辑</li><li>比如VSCode/Atom/PyCharm等都支持安装vim插件</li></ul><p>课后练习</p><ul><li>搜索相应开发工具的vim插件</li><li>安装vim插件到开发工具里</li><li>尝试在各种开发工具中使用vim的方式编辑提升效率</li></ul><h3 id="5-3-与时俱进的-vim-之-neovim-02-07"><a href="#5-3-与时俱进的-vim-之-neovim-02-07" class="headerlink" title="5-3 与时俱进的 vim 之 neovim (02:07)"></a>5-3 与时俱进的 vim 之 neovim (02:07)</h3><p>Neovim</p><blockquote><p>一个新的vim版本，支持异步特性（vim8也支持）</p></blockquote><ul><li><a href="https://neovim.io/" target="_blank" rel="noopener">https://neovim.io/</a></li><li><a href="https://github.com/neovim/neovim" target="_blank" rel="noopener">https://github.com/neovim/neovim</a></li><li>开发更活跃，更丰富的特性和扩展异步支持</li><li>neovim的设计可以嵌入到很多GUI里，加上好看的外壳</li></ul><p>感兴趣的同学可以使用neovim代替vim啦！</p><h3 id="5-4-站在巨人的肩膀上，使用强大的开源配置-03-37"><a href="#5-4-站在巨人的肩膀上，使用强大的开源配置-03-37" class="headerlink" title="5-4 站在巨人的肩膀上，使用强大的开源配置 (03:37)"></a>5-4 站在巨人的肩膀上，使用强大的开源配置 (03:37)</h3><p>开箱即用</p><blockquote><p>如果你已经熟悉了vim配置，可以从网上直接使用一些开源配置</p></blockquote><ul><li><a href="https://github.com/SpaceVim/SpaceVim" target="_blank" rel="noopener">https://github.com/SpaceVim/SpaceVim</a></li><li><a href="https://github.com/pegasuswang/vim-config" target="_blank" rel="noopener">https://github.com/pegasuswang/vim-config</a></li><li>其他开源配置。不推荐新手直接使用，越复杂的配置上手成本越高</li></ul><p>课后练习</p><ul><li>找到一个合适的开源配置，尝试安装它</li><li>阅读其他文档，了解使用方式。一般开源配置都安装了很多插件</li><li>对于新手来说，配置太复杂太强大有时候可能会出现很多小问题</li></ul><h2 id="第6章-Vim虐我千百遍，我待Vim如初恋"><a href="#第6章-Vim虐我千百遍，我待Vim如初恋" class="headerlink" title="第6章 Vim虐我千百遍，我待Vim如初恋~"></a>第6章 Vim虐我千百遍，我待Vim如初恋~</h2><blockquote><p>Vim虐我千百遍，我待Vim如初恋~</p></blockquote><h3 id="6-1-课程总结-vim虐我千百遍，我待-vim-如初恋-03-17"><a href="#6-1-课程总结-vim虐我千百遍，我待-vim-如初恋-03-17" class="headerlink" title="6-1 课程总结-vim虐我千百遍，我待 vim 如初恋 (03:17)"></a>6-1 课程总结-vim虐我千百遍，我待 vim 如初恋 (03:17)</h3><p>可以用一生的编辑器</p><blockquote><p>vim从诞生到现在已经走过了快30个年头</p></blockquote><ul><li>几十年之间，无数的编辑器或者开发工具昙花一现</li><li>但是vim一直到现在依然有很多人在使用，甚至嵌入到各种开发工具</li><li>如今vim/neovim依然在活跃开发，很多开发者贡献插件</li></ul><p>学习方法</p><blockquote><p>熟悉vim靠的是肌肉记忆。脱离鼠标编辑能提升编辑效率</p></blockquote><ul><li>讲了很多，但是vim中依然有很多东西没有讲到，时不时发现一些使用技巧</li><li>在学中练，在练中学。熟能生巧，肌肉记忆</li><li>衡量投入产出比，是点到为止还是继续深入</li></ul><p>继续练级</p><blockquote><p>网络上有很多vim的资源，甚至练习的小游戏</p></blockquote><ul><li>《Practical vim》、中文版《Vim实用技巧》</li><li>《笨方法学vimscript》</li><li>学习和开发自己的插件</li></ul><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><pre><code class="shell">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;                                 Sample vimrc                                 &quot;&quot;                                                                              &quot;&quot;                                 Provided by:                                 &quot;&quot;                                     Tuyk                                     &quot;&quot;                                                                              &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax on &quot; 自动语法高亮&quot; colorscheme xcode-default &quot; 更换主题配色&quot; ======================...Basic Start...====================== &quot;&quot; Turn on line numbering &quot; 显示行号set number&quot; Save 1,000 items in history &quot; 设置历史行号set history=1000&quot; Show the line and column number of the cursor position &quot; 设置光标的位置值set ruler&quot; Display the incomplete commands in the bottom right-hand side of your screen.  set showcmd&quot; Display completion matches on your status lineset wildmenu&quot; Show a few lines of context around the cursorset scrolloff=5&quot; Highlight search matches &quot; 设置查找的值高亮显示set hlsearch&quot; Enable incremental searching &quot; 设置边搜索边高亮set incsearch&quot; Ignore case when searching &quot; 设置忽略查找选项的大小写set ignorecase&quot; Override the &#39;ignorecase&#39; option if the search pattern contains upper case characters.set smartcase&quot; Turn on file backupsset backup&quot; Don&#39;t line wrap mid-word.set lbr&quot; Copy the indentation from the current line. &quot; 设置自动复制上一行的缩进到下一行set autoindent&quot; Enable smart autoindenting. &quot; 设置自动识别“{}”缩进，写代码非常有用set smartindent&quot; Use spaces instead of tabs &quot; 使用空格替换tabset expandtab&quot; Enable smart tabsset smarttab&quot; Make a tab equal to 4 spacesset shiftwidth=4 &quot; 默认缩进4个空格set tabstop=4 &quot; tab 代表4个空格set softtabstop=4 &quot; 使用tab时 tab空格数&quot; 按F2进入粘贴模式set pastetoggle=&lt;F2&gt;&quot; 设置折叠方式&quot; set foldmethod=indent&quot; 开启系统剪贴板set clipboard=unnamed&quot; 解决中文乱码set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8&quot; Tell vim what background you are using &quot; 设置背景颜色&quot; set bg=light&quot; set bg=dark&quot; 退格删除键不能用set backspace=indent,eol,start&quot; ======================...Basic End...====================== &quot;&quot; ======================...Mapping Start...====================== &quot;&quot; Map Y to act like D and C, i.e. yank until EOL, rather than act like yy &quot; Map 映射&quot; map Y y$&quot; Remap VIM 0 to first non-blank character&quot; map 0 ^noremap &lt;space&gt; viw&quot; change the mapleader from \ to , &quot; 一些方便的映射&quot; NOTE: This has to be set before &lt;leader&gt; is used.let mapleader=&#39;,&#39;let g:mapleader=&#39;,&#39;&quot; 使用 jj 进入 normal模式inoremap jj &lt;Esc&gt;`^&quot; 使用 &lt;leader&gt;+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w!&lt;cr&gt;noremap &lt;leader&gt;w :w!&lt;cr&gt;&quot; 切换 buffernnoremap &lt;silent&gt; [p :bprevious&lt;cr&gt;nnoremap &lt;silent&gt; [n :bnext&lt;cr&gt;&quot; use ctrl+h/j/k/l switch windownoremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l&quot; Sudo to writecnoremap w!! w !sudo tee % &gt;/dev/null&quot; NERDTreemap &lt;leader&gt;v :NERDTreeFind&lt;CR&gt;map &lt;leader&gt;g :NERDTreeToggle&lt;CR&gt;&quot; ctrlp.vimlet g:ctrlp_map = &#39;&lt;c-p&gt;&#39;&quot; vim-easymotionnmap ss &lt;Plug&gt;(easymotion-s2)&quot; vim-goautocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4&quot; python-modelet g:pymode_python = &#39;python3&#39;let g:pymode_trim_whitespaces = 1let g:pymode_doc = 1let g:pymode_doc_bind = &#39;K&#39;let g:pymode_rope_goto_definition_bind = &#39;&lt;C-]&gt;&#39;let g:pymode_lint = 1let g:pymode_lint_checkers = [&#39;pyflakes&#39;, &#39;pep8&#39;, &#39;mccabe&#39;, &#39;pylint&#39;]let g:pymode_options_max_line_length = 120&quot; tagbarnnoremap &lt;leader&gt;t :TagbarToggle&lt;CR&gt;&quot; deoplete.nvimlet g:deoplete#enable_at_startup = 1set completeopt -=preview &quot; 关闭预览窗口&quot; vim-gitgutterset updatetime =100&quot; ======================...Mapping End...====================== &quot;&quot; ============================================================================== &quot;&quot; json 格式化com! FormatJSON %!python3 -m json.tool&quot; ============================================================================== &quot;&quot; ======================...Plugins Start...====================== &quot;&quot; 插件设置，这里使用了 vim-plugcall plug#begin(&#39;~/.vim/plugged&#39;)&quot; 安装插件只需要把 github 地址放到这里重启后执行 :PlugInstall 就好了Plug &#39;mhinz/vim-startify&#39;Plug &#39;vim-airline/vim-airline&#39;Plug &#39;vim-airline/vim-airline-themes&#39;Plug &#39;Yggdroot/indentLine&#39;Plug &#39;scrooloose/nerdtree&#39;Plug &#39;ctrlpvim/ctrlp.vim&#39;Plug &#39;easymotion/vim-easymotion&#39;Plug &#39;tpope/vim-surround&#39;Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;Plug &#39;ggreer/the_silver_searcher&#39;Plug &#39;brooth/far.vim&#39;Plug &#39;fatih/vim-go&#39;, { &#39;do&#39;: &#39;:GoUpdateBinaries&#39; }Plug &#39;python-mode/python-mode&#39;, { &#39;for&#39;: &#39;python&#39;, &#39;branch&#39;: &#39;develop&#39; }Plug &#39;majutsushi/tagbar&#39;Plug &#39;lfv89/vim-interestingwords&#39;if has(&#39;nvim&#39;)  Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }else  Plug &#39;Shougo/deoplete.nvim&#39;  Plug &#39;roxma/nvim-yarp&#39;  Plug &#39;roxma/vim-hug-neovim-rpc&#39;endifPlug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}Plug &#39;sbdchd/neoformat&#39;Plug &#39;dense-analysis/ale&#39;Plug &#39;tpope/vim-commentary&#39;Plug &#39;tpope/vim-fugitive&#39;Plug &#39;airblade/vim-gitgutter&#39;Plug &#39;junegunn/gv.vim&#39;call plug#end()&quot; 插件相关配置&quot; 禁止 stratify 自动切换目录let g:startify_change_to_dir = 0&quot; 启动时自动打开NERDTree&quot; autocmd vimenter * NERDTree&quot; ======================...Plugins End...====================== &quot;&quot; ======================...Function Start...====================== &quot;&quot; 定义函数SetTitle，自动插入文件头func SetTitle()    if &amp;filetype == &#39;python&#39;        call setline(1, &quot;\#!/usr/bin/env python&quot;)        call setline(2, &quot;\# -*- coding:utf-8 -*-&quot;)        normal G        normal o        normal o        call setline(5, &quot;if __name__ == &#39;__main__&#39;:&quot;)        call setline(6, &quot;    pass&quot;)    endifendfunc&quot; ======================...Function End...====================== &quot;&quot; For more options see &quot;:help option-list&quot; and &quot;:options&quot;.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1049-优雅玩转Vim</title>
      <link href="/2019/11/04/1049-vim/"/>
      <url>/2019/11/04/1049-vim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1049" target="_blank" rel="noopener">https://www.imooc.com/learn/1049</a></p><p>简介：Vim作为Linux 平台首选编辑器，无论是运维还是开发等IT人员都应该系统地学习下这款优秀经典的上古神器。本课程系统提炼vim 的精华、通过抛砖引玉把它展现到你的面前，更能让你的工作如虎添翼、事半功倍。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>Vim课程介绍。</p></blockquote><h3 id="1-1-课程简介-04-34"><a href="#1-1-课程简介-04-34" class="headerlink" title="1-1 课程简介 (04:34)"></a>1-1 课程简介 (04:34)</h3><p>在所有的类Unix操作系统中都会默认内置Vi/Vim文本编辑器</p><ol><li><p>Vim简介</p><ul><li>Vim和Vi的区别</li><li>Vimrc配置</li><li>Vim四种模式</li></ul></li><li><p>基础入门</p><ul><li>Vim寄存器（类似于Windows的粘贴板）</li><li>增查删改等常规操作（快捷键、按键）</li><li>Vim组合规律</li></ul></li><li><p>高级功能</p><ul><li>缓冲区与多文件编辑</li><li>多窗口与标签分组</li><li>文本对象和宏</li><li>Visual模式</li></ul></li></ol><h2 id="第2章-Vim简介"><a href="#第2章-Vim简介" class="headerlink" title="第2章 Vim简介"></a>第2章 Vim简介</h2><blockquote><p>为什么选择Vim作为编辑器，Vim安装与简洁Vimrc配置</p></blockquote><h3 id="2-1-vim介绍及Vimrc-18-02"><a href="#2-1-vim介绍及Vimrc-18-02" class="headerlink" title="2-1 vim介绍及Vimrc (18:02)"></a>2-1 vim介绍及Vimrc (18:02)</h3><p>Vim介绍：</p><ul><li>Vim是一个Unix以及类Unix文本编辑器</li><li>特点：功能强大、高度可定制(Vimrc、插件等)</li></ul><p>Vim vs Vi：</p><blockquote><p>Vim = Vi + IMproved</p></blockquote><ul><li>多级撤销</li><li>语法加亮和自动补全</li><li>支持多种插件</li><li>通过网络协议（HTTP/SSH）编辑文件</li><li>多文件编辑</li><li>Vim可以编辑压缩格式文件（gzip、zip等）</li></ul><p>Vimrc概述：</p><ul><li>rc = run command</li><li>系统级vimrc和用户级vimrc</li><li>每一行作为一个命令执行</li></ul><p>Vimrc使用：</p><blockquote><p>默认.Vimrc是没有得。需要用户自己手动创建。Vim 会自动搜索到。</p></blockquote><ul><li><p><code>:h vimrc</code> 查看Vimrc文档</p></li><li><p><code>:version</code> 查看vim版本</p></li><li><p><code>vim &lt;filename&gt;</code> 或 <code>:e &lt;filename&gt;</code> 打开文件📃</p></li><li><p><code>“</code> 注释</p></li><li><p>Vimrc-Sample：<a href="https://raw.githubusercontent.com/yangvipguang/vimrc-sample/master/vimrc-sample" target="_blank" rel="noopener">https://raw.githubusercontent.com/yangvipguang/vimrc-sample/master/vimrc-sample</a></p></li></ul><pre><code class="shell">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;                                 Sample vimrc                                 &quot;&quot;                                                                              &quot;&quot;                                 Provided by:                                 &quot;&quot;                                     Tuyk                                     &quot;&quot;                                                                              &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax on &quot; 自动语法高亮&quot; Save 1,000 items in history &quot; 设置历史行号set history=1000&quot; Show the line and column number of the cursor position &quot; 设置光标的位置值set ruler&quot; Display the incomplete commands in the bottom right-hand side of your screen.  set showcmd&quot; Display completion matches on your status lineset wildmenu&quot; Show a few lines of context around the cursorset scrolloff=5&quot; Highlight search matches &quot; 设置查找的值高亮显示set hlsearch&quot; Enable incremental searching &quot; 设置边搜索边高亮set incsearch&quot; Ignore case when searching &quot; 设置忽略查找选项的大小写set ignorecase&quot; Override the &#39;ignorecase&#39; option if the search pattern contains upper case characters.set smartcase&quot; Turn on line numbering &quot; 显示行号set number&quot; Turn on file backupsset backup&quot; Don&#39;t line wrap mid-word.set lbr&quot; Copy the indentation from the current line. &quot; 设置自动复制上一行的缩进到下一行set autoindent&quot; Enable smart autoindenting. &quot; 设置自动识别“{}”缩进，写代码非常有用set smartindent&quot; Use spaces instead of tabs &quot; 使用空格替换tabset expandtab&quot; Enable smart tabsset smarttab&quot; Make a tab equal to 4 spacesset shiftwidth=4 &quot; 默认缩进4个空格set tabstop=4 &quot; tab 代表4个空格set softtabstop=4 &quot; 使用tab时 tab空格数&quot; Specifiy a color scheme.colorscheme slate&quot; Tell vim what background you are using &quot; 设置背景颜色&quot; set bg=light&quot; set bg=dark&quot; Map Y to act like D and C, i.e. yank until EOL, rather than act like yy &quot; Map 映射&quot; map Y y$&quot; Remap VIM 0 to first non-blank character&quot; map 0 ^&quot; Easily create HTML unorded lists. &quot; map &lt;F3&gt; i&lt;ul&gt;&lt;CR&gt;&lt;Space&gt;&lt;Space&gt;&lt;li&gt;&lt;/li&gt;&lt;CR&gt;&lt;Esc&gt;I&lt;/ul&gt;&lt;Esc&gt;kcit&quot; map &lt;F4&gt; &lt;Esc&gt;o&lt;li&gt;&lt;/li&gt;&lt;Esc&gt;cit&quot; change the mapleader from \ to ,&quot; NOTE: This has to be set before &lt;leader&gt; is used.&quot; let mapleader=&quot;,&quot;&quot; Quickly save your file.&quot; map &lt;leader&gt;w :w!&lt;cr&gt;&quot; For more options see &quot;:help option-list&quot; and &quot;:options&quot;.</code></pre><h3 id="2-2-vim的四种模式-05-22"><a href="#2-2-vim的四种模式-05-22" class="headerlink" title="2-2 vim的四种模式 (05:22)"></a>2-2 vim的四种模式 (05:22)</h3><ol><li>普通模式<ul><li>打开的默认模式</li><li>移查删改</li></ul></li><li>可视化模式<ul><li>对一块区域操作</li></ul></li><li>插入模式<ul><li>添加文本</li></ul></li><li>命令模式<ul><li>和普通模式类似</li></ul></li></ol><p><code>v</code>：进入可视化模式</p><p><code>i</code>：进入插入模式</p><p><code>:</code>：使用命令模式</p><p><code>dd</code>：删除</p><p><code>Esc</code>：返回普通模式</p><p><code>:h vim-modes-intro</code>：查看vim模式文档（7种）</p><h2 id="第3章-Vim基础入门"><a href="#第3章-Vim基础入门" class="headerlink" title="第3章 Vim基础入门"></a>第3章 Vim基础入门</h2><blockquote><p>本章主要讲解移动、跳转与缩进，删除、复制与粘贴，修改、查找与替换相关内容。</p></blockquote><h3 id="3-1-移动、跳转与缩进-07-55"><a href="#3-1-移动、跳转与缩进-07-55" class="headerlink" title="3-1 移动、跳转与缩进 (07:55)"></a>3-1 移动、跳转与缩进 (07:55)</h3><p>Vim布局起源</p><ul><li><p>Vim最初的作者Bill Joy使用的机器ADM-3A终端机</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbdnjipj31bs0fmgod.jpg" alt="ADM-3A终端机" style="zoom:30%;" /><p>注意看上下左右键的位置</p></li></ul><p><strong>光标移动：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code></td><td>左移</td></tr><tr><td><code>l</code></td><td>右移</td></tr><tr><td><code>j</code></td><td>下移</td></tr><tr><td><code>k</code></td><td>上移</td></tr><tr><td><code>shift+6</code>/<code>0</code></td><td>移动到行首<code>^</code>/包含缩进空格</td></tr><tr><td><code>shift+4</code></td><td>移动到行尾<code>$</code></td></tr></tbody></table><p><strong>单词和字符移动：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>w/W</td><td>正向移动到下一个单词开头(小写识别特殊字符)</td></tr><tr><td>e/E</td><td>正向移动到下一个单词结尾</td></tr><tr><td>b/B</td><td>反向移动到上一个单词开头</td></tr><tr><td>ge</td><td>反向移动到上一个单词结尾</td></tr></tbody></table><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbf4b5oj30ja0asmxt.jpg" alt="单词和字符移动" style="zoom:50%;" /><p><strong>跳转：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>control+b/B</code></td><td>上一页</td></tr><tr><td><code>control+f/F</code></td><td>下一页</td></tr><tr><td><code>control+u/d</code></td><td>向上/下翻半页</td></tr><tr><td><code>gg</code></td><td>跳转到文件📁首行</td></tr><tr><td><code>G</code></td><td>跳转到文件📁尾行</td></tr><tr><td><code>&lt;line_number&gt;gg/G</code></td><td>跳转到指定行</td></tr><tr><td><code>{g}+control+g/G</code></td><td>查看文件信息/{g}更加详细</td></tr></tbody></table><p><strong>缩进：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;&gt;</code>===<code>:&gt;</code></td><td>右缩进(普通模式)</td></tr><tr><td><code>&lt;&lt;</code>===<code>:&lt;</code></td><td>左缩进(普通模式)</td></tr><tr><td><code>:m,n&gt;</code>===<code>:m&gt;(n-m+1)</code></td><td>m到n行缩进(命令行模式)</td></tr><tr><td><code>:m&gt;n</code>===<code>:m,m+n-1&gt;</code></td><td>m行开始,共n行缩进一次(命令行模式)</td></tr></tbody></table><h3 id="3-2-删除、复制与粘贴-25-41"><a href="#3-2-删除、复制与粘贴-25-41" class="headerlink" title="3-2 删除、复制与粘贴 (25:41)"></a>3-2 删除、复制与粘贴 (25:41)</h3><table><thead><tr><th>Windows</th><th>Vim</th><th>不同处</th></tr></thead><tbody><tr><td>cut</td><td>delete</td><td>和剪切相同，而不是直接删除</td></tr><tr><td>copy</td><td>yank</td><td>等同于复制,由于c用于(change)被迫选了yank</td></tr><tr><td>paste</td><td>put</td><td>粘贴完全相同</td></tr></tbody></table><p>Vim特性</p><ul><li><p>寄存器（保存临时数据）</p><table><thead><tr><th align="left">类型</th><th align="center">含义</th><th>表示方式</th><th>举例</th><th>特点</th></tr></thead><tbody><tr><td align="left">无名寄存器</td><td align="center">默认寄存器</td><td>“”</td><td>“” p=p</td><td>会被最后一条覆盖</td></tr><tr><td align="left">数字寄存器</td><td align="center">“+{0-9}缓存最近10次操作</td><td>“0”{1-9}</td><td>“0P<br />“1P</td><td>0用于复制专用<br />1-9用于最近9次行删除或者修改记录</td></tr><tr><td align="left">有名寄存器</td><td align="center">26英文字母命名有名寄存器</td><td>“[a-z]/[A-Z]”</td><td>“ayw</td><td>“A会通过^J追加到”a寄存器中</td></tr><tr><td align="left">黑洞寄存器</td><td align="center">有去无回</td><td>“-</td><td>“_dw</td><td>只想删除而不想覆盖无名寄存器</td></tr></tbody></table><p><code>:register</code>/<code>:reg</code>：进入寄存器</p><p><code>:h reg</code>：查看寄存器文档</p></li></ul><p>基础操作</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td>d = delete = cut</td><td>剪切</td></tr><tr><td>y = yank ≈ copy</td><td>类似于复制</td></tr><tr><td>P/p = put ≈ paste</td><td>粘贴到光标后/前</td></tr><tr><td>u = undo</td><td>撤销之前操作</td></tr><tr><td>Control+r = redo</td><td>重做/恢复之前操作(反撤销)</td></tr></tbody></table><p><code>yy</code>：复制整行。记录到<code>&quot;&quot;</code>默认寄存器/无名寄存器、<code>&quot;0</code>寄存器/复制专用寄存器</p><p><code>dd</code>：剪切整行。记录到<code>&quot;&quot;</code>默认寄存器/无名寄存器、<code>&quot;1</code>寄存器/剪切寄存器</p><p><code>p</code>：粘贴</p><p><code>u</code>：撤销</p><p><code>Control+r</code>：重做(反撤销)</p><p><code>&quot;ayy</code>：复制整行到<code>&quot;a</code>寄存器。记录到默认寄存器，不会记录到复制专用寄存器</p><p><code>&quot;_dd</code>：删除整行。不会记录到任何寄存器。黑洞寄存器</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td>yw</td><td>复制当前光标单词(从光标后开始截取)</td></tr><tr><td>y2w</td><td>复制正向倆个单词(从光标后开始截取)</td></tr></tbody></table><p>调换字符</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Practical vim</td></tr><tr><td>F{space}</td><td>Practical vim</td></tr><tr><td>x</td><td>Practical vim</td></tr><tr><td>p</td><td>Practical vim</td></tr></tbody></table><p><code>x</code>：剪切单个字符。记录到默认寄存器、<code>-</code>寄存器</p><p>行剪切粘贴</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Line1   Line2</td></tr><tr><td>dd</td><td>Line2</td></tr><tr><td>p</td><td>Line2   Line1</td></tr></tbody></table><p>行复制</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Line1   Line2</td></tr><tr><td>yy</td><td>Line1   Line2</td></tr><tr><td>p</td><td>Line1   Line2   Line1</td></tr></tbody></table><p>组合删除([count] operation [count] {motion})</p><table><thead><tr><th>操作按键</th><th>定义</th></tr></thead><tbody><tr><td><code>x</code>/<code>X</code></td><td>删除光标下/前单个字符</td></tr><tr><td><code>dw</code>(d = delete,w = word)</td><td>删除一个单词(必须在词首👋)(删除光标处到单词末尾🔚)</td></tr><tr><td><code>d{hjkl}</code></td><td>删除到上下左右一个操作前的字符</td></tr><tr><td><code>d$</code>===<code>D</code></td><td>删除光标到行尾的字符</td></tr><tr><td><code>d^</code></td><td>删除光标到行首的字符</td></tr><tr><td><code>dd</code></td><td>删除当前整行</td></tr><tr><td><code>{n}dd</code></td><td>向下删除n行（包括当前行）</td></tr><tr><td><code>5dw</code></td><td>删除正向单词5次</td></tr><tr><td><code>d3w</code></td><td>正向删除3w 动作</td></tr><tr><td><code>3w</code></td><td>正向移动单词3次</td></tr><tr><td><code>2d3w</code></td><td>正向删除3w 动作 2次</td></tr></tbody></table><h3 id="3-3-修改、查找与替换-15-59"><a href="#3-3-修改、查找与替换-15-59" class="headerlink" title="3-3 修改、查找与替换 (15:59)"></a>3-3 修改、查找与替换 (15:59)</h3><p>插入</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>Shift+i</code>/<code>Shift+a</code></td><td>插入模式并移动到行首/尾</td></tr><tr><td><code>i</code>/<code>a</code></td><td>光标前/后插入</td></tr><tr><td>[n]+<code>O</code>/<code>o</code></td><td>行前/后插入n次</td></tr><tr><td>[n]+<code>i</code></td><td>插入模式重复n次</td></tr></tbody></table><p>转换</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>~</code></td><td>单个字符大小写转换</td></tr><tr><td><code>g ~ w</code></td><td>单词大小写转换</td></tr><tr><td><code>g ~ $</code>/<code>g ~ ~</code></td><td>整行大小写转换(<code>^</code>光标处到行首大小写反转,<code>$</code>光标处到行尾大小写反转)</td></tr><tr><td><code>gUw</code>/<code>guw</code></td><td>单词转换成大小写</td></tr></tbody></table><p><code>.</code>：对上一个操作的重🐛复</p><p>查找</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>f{char}</code>/<code>F{char}</code></td><td>正向/反向查找某个单词(适用于查找某一行)</td></tr><tr><td><code>t{char}</code></td><td>查找字符前一个字符</td></tr><tr><td><code>dt{char}</code>/<code>df{char}</code></td><td>删除光标到查找字符间的字符</td></tr><tr><td><code>/{char}</code></td><td>命令行查找</td></tr></tbody></table><p><code>/{char}</code>：</p><ul><li><code>n</code>：向下⬇️查找🔎</li><li><code>N</code>：向上⬆️查找🔎</li></ul><p>替换(substitute)</p><p>语法：<code>[range]s[ubstitute]/{pattern}/{string}/[flags]</code></p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>:s/going/rolling/g</code></td><td>当前行所有going替换成rolling</td></tr><tr><td><code>:%s/going/rolling/g</code></td><td>%匹配所有范围</td></tr><tr><td><code>⇧+r</code>/<code>R</code></td><td>替换模式</td></tr><tr><td><code>r</code></td><td>单个字符替换</td></tr><tr><td><code>cw</code>、<code>c2w</code></td><td>修改单个单词</td></tr><tr><td><code>c$</code>/<code>C</code>类似于<code>d</code>操作符</td><td>修改光标之后行内内容</td></tr></tbody></table><h2 id="第4章-Vim高级功能"><a href="#第4章-Vim高级功能" class="headerlink" title="第4章 Vim高级功能"></a>第4章 Vim高级功能</h2><blockquote><p>本章主要讲解缓冲区与多文件编辑、多窗口操作（分屏）与标签分组、宏和文本对象以及Visual模式。</p></blockquote><h3 id="4-1-缓冲区与多文件编辑-13-25"><a href="#4-1-缓冲区与多文件编辑-13-25" class="headerlink" title="4-1 缓冲区与多文件编辑 (13:25)"></a>4-1 缓冲区与多文件编辑 (13:25)</h3><blockquote><p>缓冲区、标签、窗口</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbe71ptj31340hcmyi.jpg" alt="缓冲区与多文件编辑" style="zoom:45%;" /><p>编辑操作并不是真正的编辑文件，而是编辑文件在内存中的映射或快照或缓冲区</p><p>缓冲区：就是内容缓存区域。</p><ul><li>Buffer是内存中的一块缓冲区，用于临时存放Vim打开过的文件</li></ul><p>查看缓冲区列表：</p><ul><li><code>:files</code></li><li><code>:buffers</code></li><li><code>:ls</code><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbeqzfdj31kg0cwgoo.jpg" alt="缓冲区列表" style="zoom:30%;" /></li></ul><p>缓冲区列表指示状态</p><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>激活缓冲区，缓冲区被加载且显示</td></tr><tr><td>h</td><td>隐藏缓冲区，缓冲区被加载但🥚不显示</td></tr><tr><td>%</td><td>当前缓冲区</td></tr><tr><td>#</td><td>交换缓冲区</td></tr><tr><td>=</td><td>只读缓冲区</td></tr><tr><td>+</td><td>已经更改缓冲区</td></tr><tr><td>-</td><td>不可更改缓冲区，’modifiable’选项不置位</td></tr></tbody></table><p>缓冲区列表操作</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>:bp[revious]</code></td><td>上一个缓冲区</td></tr><tr><td><code>:bn[ext]</code></td><td>下一个缓冲区</td></tr><tr><td><code>:bf[irst]</code></td><td>到第一个缓冲区</td></tr><tr><td><code>:bl[ast]</code></td><td>到最后一个缓冲区</td></tr><tr><td><code>:buffer Number/File_name</code></td><td>指定缓冲区</td></tr><tr><td><code>:ball</code></td><td>编辑所有缓冲区</td></tr><tr><td><code>⌃+^</code>/<code>b#</code></td><td>切换到前一个buffer（交换buffer）</td></tr><tr><td><code>:qall!</code></td><td>退出全部缓冲区</td></tr><tr><td><code>:wall!</code></td><td>写入全部缓冲区</td></tr><tr><td><code>:badd</code></td><td>添加一个新缓冲区，但不设置为当前缓冲区</td></tr><tr><td><code>:bd[elete]</code></td><td>删除缓冲区</td></tr><tr><td><code>:m,nbd</code>/<code>:%db</code></td><td>删除m到n编号/所有的缓冲区文件</td></tr><tr><td><code>:bufdo {CMD}</code></td><td>bufdo set number</td></tr><tr><td><code>:E /:bd</code></td><td>打开文件目录列表/返回到🔙最初的buffer</td></tr></tbody></table><h3 id="4-2-多窗口操作与标签分组-16-57"><a href="#4-2-多窗口操作与标签分组-16-57" class="headerlink" title="4-2 多窗口操作与标签分组 (16:57)"></a>4-2 多窗口操作与标签分组 (16:57)</h3><ul><li>多窗口（分屏）</li></ul><p>分屏操作</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>vim -On</code>/<code>vim -on</code></td><td>垂直/水平分屏（n：数字，o：Open）</td></tr><tr><td><code>⌃+w c/q</code></td><td>关闭当前窗口/最后一个窗口时退</td></tr><tr><td><code>⌃+w s</code></td><td>上下分割当前打开的文件</td></tr><tr><td><code>⌃+w v</code></td><td>左右分割当前打开的文件</td></tr><tr><td><code>:sp filename</code></td><td>上下分割并打开一个新的文件</td></tr><tr><td><code>:vsp filename</code></td><td>左右分割并打开一个新的文件</td></tr></tbody></table><p>移动分屏和尺寸变动</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>⌃+w H</code></td><td>向左⬅️移动</td></tr><tr><td><code>⌃+w J</code></td><td>向下⬇️移动</td></tr><tr><td><code>⌃+w K</code></td><td>向上⬆️移动</td></tr><tr><td><code>⌃+w L</code></td><td>向右➡️移动</td></tr><tr><td><code>⌃+w +</code></td><td>增加高度</td></tr><tr><td><code>⌃+w -</code></td><td>减少高度</td></tr><tr><td><code>⌃+w _</code></td><td>减小到最低高度</td></tr><tr><td><code>⌃+w =</code></td><td>让所有屏的高度一致</td></tr></tbody></table><ul><li><p>标签</p><p>标签就是容纳一系列窗口的容器</p></li></ul><p>标签操作</p><table><thead><tr><th>指令</th><th><code>含义</code></th></tr></thead><tbody><tr><td><code>:tabnew [tab_name]</code></td><td><code>新建标签页</code></td></tr><tr><td><code>:tabfind</code></td><td><code>查找并在新标签中打开文件</code></td></tr><tr><td><code>:tabs</code></td><td>显示已打开标签页的列表</td></tr><tr><td><code>:tabclose</code></td><td>关闭当前标签页</td></tr><tr><td><code>:tabonly</code></td><td>仅保留当前标签页打开</td></tr><tr><td><code>:tabn/p/first/last</code></td><td>跳转到下/上/第一/最后一个标签页</td></tr><tr><td><code>:tabm</code></td><td>将当前标签页放置到指定位置</td></tr></tbody></table><p>标签操作和命令键</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>gt/T</code></td><td>移动到下/上一个标签</td></tr><tr><td><code>{i}gt</code></td><td><strong>跳转到i位置的标签</strong></td></tr><tr><td><code>noremap &lt;C-L&gt; &lt;Esc&gt; :tabnext &lt;CR&gt;</code></td><td>Vimrc中自定义快捷键</td></tr><tr><td><code>noremap &lt;C-H&gt; &lt;Esc&gt; :tabprevious &lt;CR&gt;</code></td><td>Vimrc中自定义快捷键</td></tr><tr><td><code>:tabe</code></td><td>编辑标签中的某个文件</td></tr><tr><td><code>:tabm 0/tabm</code></td><td>移动当前tab到第一个/最后一个</td></tr><tr><td><code>t:abm {i}</code></td><td><strong>移动当前tab到第i+1位置</strong></td></tr></tbody></table><h3 id="4-3-文本对象与宏-18-40"><a href="#4-3-文本对象与宏-18-40" class="headerlink" title="4-3 文本对象与宏 (18:40)"></a>4-3 文本对象与宏 (18:40)</h3><ul><li>文本对象</li></ul><pre><code>{operator} {a} {object}{operator} {i} {object}</code></pre><p>例：</p><ul><li><p>daw = Delete A Word</p><p><code>==a==n object</code>：包含尾部间隔空格</p></li><li><p>ciw = Change Inner Word</p><p><code>==i==nner object</code>：只是内容本身，不包含尾部单词间隔🈳️格</p></li></ul><p>Word/Sentence/Paragraph</p><table><thead><tr><th>textobject</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>word</td></tr><tr><td>s</td><td>sentence</td></tr><tr><td>p</td><td>paragraph</td></tr></tbody></table><p>块对象</p><table><thead><tr><th>textobject</th><th>说明</th></tr></thead><tbody><tr><td>]/[</td><td><code>[]</code> block</td></tr><tr><td>)/(、b</td><td><code>()</code> block</td></tr><tr><td>&gt;/&lt;、&gt;/&lt;</td><td><code>&lt;&gt;</code> block</td></tr><tr><td>}/{、B</td><td><code>()</code> block</td></tr><tr><td>t</td><td>tag block: <code>&lt;&gt; &lt;/&gt;</code></td></tr></tbody></table><p>Visual mode</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>viw</code></td><td>选中单词</td></tr><tr><td><code>vis</code></td><td>选中句子🍊</td></tr><tr><td><code>vip</code></td><td>选中段落</td></tr><tr><td>vi<code>(</code></td><td>选中<code>()</code>圆括号中的内容</td></tr><tr><td><code>vi[</code></td><td>选中<code>[]</code>中括号中的内容</td></tr><tr><td><code>vit</code></td><td>选中标签中的内容</td></tr></tbody></table><table>    <tr>        <th>指令</th>        <th>说明</th>    </tr>    <tr>        <td>v2i{</td>        <td>          选中两层`{}`大括号之间的所有内容<br/>          数字限制选择的嵌套层数        </td>    </tr>    <tr>        <td>v3aw</td>        <td>选择3⃣️个单词（3个单词➕2个间隔空格）</td>    </tr>    <tr>        <td>v3iw</td>        <td>选择3⃣️个单词（2个单词➕1个间隔空格）</td>    </tr>    <tr>        <td colspan="2" align="center">可将v选择操作指令替换为c(change), x, d(delete), y(yank)等操作符(operator)，来针对文本对象操作</td>    </tr>·</table><ul><li>宏</li></ul><blockquote><p>If you write a thing once, it is okay. However if you’re writing twice or more times, then you should find a better way to do it.</p><p>Vim的Micro就是用来解决重复的问题</p></blockquote><p>宏就是批处理，类似于命令行脚本或者编程中的函数</p><p><code>h: operator</code>：查看操作符文档</p><p>简单操作</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>qa</code></td><td>开始录制⏺️宏到寄存器a🀄️</td></tr><tr><td><code>qA</code></td><td>追加宏，在寄存器a🀄️追加</td></tr><tr><td><code>n@a</code></td><td>执行n遍a寄存器中的操作</td></tr><tr><td><code>@@</code></td><td>再执行一遍上一次操作</td></tr><tr><td><code>:n,mnormal @a</code></td><td>n到m行执行寄存器a宏操作</td></tr><tr><td><code>:let @a= &#39;</code></td><td>编辑宏a寄存器</td></tr></tbody></table><p>宏最佳操作</p><ul><li>规范光标位置：0</li><li>执行编辑和操作</li><li>移动光标到容易回放的位置：j</li></ul><p><code>Ctrl+a</code>：当前数字递增1</p><p>示例步骤：</p><ol><li><p>循环递增插入数字</p><pre><code class="shell"># 添加数字1i1Esc# 开始录制宏,此时光标在数字1行qa # 开始yy # 复制p # 粘贴q # 结束# 执行宏操作10@a</code></pre><pre><code></code></pre></li><li><p>为多行添加注释</p><pre><code class="shell"># 开始录制宏,此时光标在需注释行首qb # 开始i # 进入编辑模式`# ` # 添加注释Esc # 退出编辑模式^ # 移动到行首j # 光标下行移动q # 结束</code></pre></li></ol><p>宏保存</p><ul><li><code>viminfo</code>/<code>vimrc file</code></li><li>保存历史和非空寄存器</li><li>vim启动时读取</li><li>容易被覆盖</li></ul><h3 id="4-4-Visual-模式-15-51"><a href="#4-4-Visual-模式-15-51" class="headerlink" title="4-4 Visual 模式 (15:51)"></a>4-4 Visual 模式 (15:51)</h3><blockquote><p>在可视化模式下，可以对一个文本块的整体进行操作</p></blockquote><p>三种子模式</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>v</code></td><td>激活面向字符的可视化模式</td></tr><tr><td><code>V</code>/<code>shift+v</code></td><td>激活面向行的可视化模式</td></tr><tr><td><code>command+v</code></td><td>激活面向列块的可视化模式</td></tr></tbody></table><p>字符可视化模式=&gt;行可视化模式=&gt;块可视化模式</p><p>可视化模式操作</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>gv</td><td>重选上次的高亮选区</td></tr><tr><td>o</td><td>切换选取边界</td></tr></tbody></table><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="5-1-课程总结-03-18"><a href="#5-1-课程总结-03-18" class="headerlink" title="5-1 课程总结 (03:18)"></a>5-1 课程总结 (03:18)</h3><ol><li><p>Vim模式（四种）</p><p>普通模式、编辑模式、可视化模式、命令行模式</p></li><li><p>Vim组合 {operation}{motion}</p><p>增查删改</p></li><li><p>Vim配置多样性</p><p>配置文件.vimrc、Vim插件</p></li><li><p>Vim视图多样性</p><p>缓冲区、多文件编辑、多窗口、标签分组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1052-Git入门</title>
      <link href="/2019/11/01/1052-Git/"/>
      <url>/2019/11/01/1052-Git/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1052" target="_blank" rel="noopener">https://www.imooc.com/learn/1052</a></p><p>简介：本课程主要通过命令行和图形界面工具来介绍Git的安装、仓库创建、工作流、远程仓库、克隆仓库、标签管理和分支管理等Git的主要内容。</p></blockquote><p>@[TOC]</p><h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h2><blockquote><p>主要介绍Git的作用以及安装过程。</p></blockquote><h3 id="1-1-为什么学习git"><a href="#1-1-为什么学习git" class="headerlink" title="1-1 为什么学习git"></a>1-1 为什么学习git</h3><blockquote><p>作者：Linus Torvalds，同时也是Linux的作者。</p><p>版本控制：记录所有文件的所有版本，可以有效地追踪文件的变化。同时很容易回到之前的状态</p></blockquote><p>为什么学习Git：</p><ul><li>牛通的互联网、牛逼的大神们都在用</li><li>完整的版本控制功能，解决多人协作的问题</li><li>提高开发效率</li><li>如果你是程序猿,请务必学Git，井习惯把日己的代码同步到GitHub上</li></ul><p>注：Git不等于 GitHub大家注意了! Git和GitHub就是球和球场的关系!</p><p>课程安排：</p><blockquote><p>Git介绍<br>Git安装（命令行、图形化界面）<br>Git工作流<br>本地与远程仓库<br>分支管理<br>标签管理</p></blockquote><h3 id="1-2-Git安装"><a href="#1-2-Git安装" class="headerlink" title="1-2 Git安装"></a>1-2 Git安装</h3><p>命令行：</p><ul><li><p>下载Window Git</p></li><li><p>Msysgit <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p></li><li><p>配置用户信息</p><pre><code class="shell"># git bashgit config --global user.name &quot;tyk&quot;git config --global user.email &quot;tyk@163.com&quot;</code></pre></li><li><p>查看用户名邮箱是否配置成功</p><pre><code class="shell">git config --list</code></pre></li></ul><p>图形化界面：</p><ul><li>下载安装SourceTree <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">https://www.sourcetreeapp.com/</a></li><li>注册登录</li></ul><h2 id="第2章-Git仓库创建及工作量"><a href="#第2章-Git仓库创建及工作量" class="headerlink" title="第2章 Git仓库创建及工作量"></a>第2章 Git仓库创建及工作量</h2><blockquote><p>主要介绍Git如何创建仓库以及工作流的内容。</p></blockquote><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2-1 创建仓库"></a>2-1 创建仓库</h3><ul><li><p>初始化版本库</p><pre><code class="shell">git init</code></pre></li><li><p>添加文件到版本库</p><pre><code class="shell">git addgit commit</code></pre></li><li><p>查看仓库状态</p><pre><code class="shell">git status</code></pre></li></ul><p>创建Git仓库：</p><pre><code class="shell">mkdir democd demogit init # 初始化版本库ls -a # 查看所有文件（包含隐藏文件）echo &quot;git repo&quot; &gt;&gt; test.txt # 创建文件并追加输入内容git add test.txt # 添加文件到版本库git commit -m &quot;repo first commit&quot; # 提交文件到本地仓库git status # 查看仓库状态git push -f origin master # 将本地仓库内容同步到远程仓库</code></pre><h3 id="2-2-工作流"><a href="#2-2-工作流" class="headerlink" title="2-2 工作流"></a>2-2 工作流</h3><pre><code class="shell">git add &lt;file&gt;   # 将文件从本地工作区上传到暂存区git commit -m &quot;说明操作内容&quot;  # 将暂存区的文件上传到本地仓库git reset HEAD &lt;file&gt; # 将本地仓库的内容返回到暂存区git checkout -- 文件名 # 清除工作区git log # 查询提交记录的commit号git reset --hard &lt;commit_id&gt; # 将本地仓库和暂存区的内容全部回滚到commit号提交时的内容git rm &lt;file&gt; # 清空文件git rm --cached # 清除工作区里暂存区没有的文件git checkout HEAD &lt;file&gt; # 用最终仓库的文件替换掉暂存区和工作区的</code></pre><p>Git工作流：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigfvzdzj30pk0bzta6.jpg" width="600" alt="Git工作流"/><h2 id="第3章-Git主要功能"><a href="#第3章-Git主要功能" class="headerlink" title="第3章 Git主要功能"></a>第3章 Git主要功能</h2><blockquote><p>主要介绍Git远程仓库、克隆仓库、标签管理和分支管理的主要内容。</p></blockquote><h3 id="3-1-远程仓库"><a href="#3-1-远程仓库" class="headerlink" title="3-1 远程仓库"></a>3-1 远程仓库</h3><p>创建SSH Key</p><pre><code class="shell">ssh-keygen -t rsa -C &quot;github_registry_mail@github.com&quot;cd .ssh/cat id_rsa.pub</code></pre><p>GitHub设置：</p><p>​    [GitHub首页]-[个人头像]-[Settings]-[SSH and GPG keys]-[New SSH key]</p><p>查看本地是否与Github关联</p><pre><code class="shell">ssh -T git@github.com</code></pre><p>添加远程仓库</p><pre><code class="shell">git remote add origin git@github.com:tuyrk/demo.gitgit pull origin master --allow-unrelated-historiesgit push -u origin master</code></pre><p>在GitHub创建新仓库：</p><p>​    [GitHub首页]-[加号]-[New repository]-[Create repository]</p><p>将本地仓库提交到远程</p><pre><code class="shell">echo &quot;# demo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:tuyrk/demo.gitgit push -u origin master</code></pre><p>将远程仓库克隆到本地</p><pre><code class="shell">git remote add origin git@github.com:tuyrk/demo.gitgit push -u origin master</code></pre><h3 id="3-2-克隆仓库"><a href="#3-2-克隆仓库" class="headerlink" title="3-2 克隆仓库"></a>3-2 克隆仓库</h3><pre><code class="shell">git clone git@github.com:tuyrk/demo.git # 路径为GitHub中SSH路径</code></pre><p>流程：</p><ol><li>将远程仓库GitHub中的代码克隆一份到本地</li><li>在本地进行开发</li><li>开发完之后将代码推送到远程仓库</li></ol><h3 id="3-3-标签管理"><a href="#3-3-标签管理" class="headerlink" title="3-3 标签管理"></a>3-3 标签管理</h3><pre><code class="shell">git tag # 查看所有标签git tag &lt;name&gt; # 创建标签git tag -a &lt;name&gt; -m &quot;comment&quot; # 指定提交信息git tag -d &lt;name&gt; # 删除标签git push origin &lt;name&gt; # 标签发布git checkout &lt;name&gt; # 切换标签-快照git checkout -b &lt;分支名称&gt; &lt;tag标签名称&gt; # 切换标签-编辑</code></pre><h3 id="3-4-分支管理"><a href="#3-4-分支管理" class="headerlink" title="3-4 分支管理"></a>3-4 分支管理</h3><pre><code class="shell">git branch # 查看所有分支，“*”代表当前所在分支git branch &lt;分支名称&gt; # 创建分支git checkout &lt;分支名称&gt; # 切换分支git merge &lt;分支名称&gt; # 合并到master分支。首先需切换到master分支，然后进行合并git branch -d &lt;分支名称&gt; # 删除分支</code></pre><h2 id="第4章-课程总结"><a href="#第4章-课程总结" class="headerlink" title="第4章 课程总结"></a>第4章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="4-1-课程总结"><a href="#4-1-课程总结" class="headerlink" title="4-1 课程总结"></a>4-1 课程总结</h3><ul><li><p>介绍与安装</p></li><li><p>工作流</p><p>[工作区]=&gt;[暂存区]=&gt;[版本库]</p></li><li><p>初始化</p><pre><code class="shell">git initgit addgit commit</code></pre></li><li><p>远程仓库</p><pre><code class="shell">git remote addgit pullgit pushgit clone</code></pre></li><li><p>分支管理</p><pre><code class="shell">git branchgit checkoutgit merge</code></pre></li><li><p>标签管理</p><pre><code class="shell">git taggit push</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>390-版本控制入门 – 搬进 Github</title>
      <link href="/2019/11/01/390-Github/"/>
      <url>/2019/11/01/390-Github/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/390" target="_blank" rel="noopener">https://www.imooc.com/learn/390</a></p><p>简介：版本控制能够大大提高程序员的工作效率，但是通常会涉及到命令行操作，学习曲线陡峭。本课程中使用 Github 网站和图形化客户端来完成版本控制工作，提供一套简单实用的流程，配合图解方式的原理讲解，让大家以最短的时间上手 Git 和 Github 。</p></blockquote><p><a href="https://gitbeijing.com/" target="_blank" rel="noopener">https://gitbeijing.com/</a></p><p>@[TOC]</p><h2 id="第1章-Github课程介绍"><a href="#第1章-Github课程介绍" class="headerlink" title="第1章 Github课程介绍"></a>第1章 Github课程介绍</h2><blockquote><p>阐述本课程的覆盖内容，适合观众。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>Git和Linux之父，Linus</p><blockquote><p>我是个自负的混蛋，所有我的项目都以我自己的名字命名，先有Linux，现在是Git.<br>–Linus</p></blockquote><p>Global Information Tracker：全局信息跟踪器</p><p>Git：版本控制工具</p><p><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><h2 id="第2章-浏览器中使用-Github"><a href="#第2章-浏览器中使用-Github" class="headerlink" title="第2章 浏览器中使用 Github"></a>第2章 浏览器中使用 Github</h2><blockquote><p>不会用 Git，其实也可以直接使用 Github 来进行基本的版本控制操作的。</p></blockquote><h3 id="2-1-浏览器中使用Github"><a href="#2-1-浏览器中使用Github" class="headerlink" title="2-1 浏览器中使用Github"></a>2-1 浏览器中使用Github</h3><h2 id="第3章-Github-客户端的使用"><a href="#第3章-Github-客户端的使用" class="headerlink" title="第3章 Github 客户端的使用"></a>第3章 Github 客户端的使用</h2><blockquote><p>以 Mac 系统的客户端 Github For Mac 为例子来讲解，不过 Windows 系统上也有类似的客户端。</p></blockquote><h3 id="3-1-Github客户端的使用"><a href="#3-1-Github客户端的使用" class="headerlink" title="3-1 Github客户端的使用"></a>3-1 Github客户端的使用</h3><h2 id="第4章-简单分支操作"><a href="#第4章-简单分支操作" class="headerlink" title="第4章 简单分支操作"></a>第4章 简单分支操作</h2><blockquote><p>分支操作几乎是所有的 Git 高级操作的基础，本章来学会使用分支。</p></blockquote><h3 id="4-1-Github-简单分支操作"><a href="#4-1-Github-简单分支操作" class="headerlink" title="4-1 Github-简单分支操作"></a>4-1 Github-简单分支操作</h3><h2 id="第5章-分支合并"><a href="#第5章-分支合并" class="headerlink" title="第5章 分支合并"></a>第5章 分支合并</h2><blockquote><p>分支合并过程其实就是代码融合过程，会涉及到处理代码冲突的问题。</p></blockquote><h3 id="5-1-Github-合并分支（上）"><a href="#5-1-Github-合并分支（上）" class="headerlink" title="5-1 Github-合并分支（上）"></a>5-1 Github-合并分支（上）</h3><h3 id="5-2-Github-合并分支（下）"><a href="#5-2-Github-合并分支（下）" class="headerlink" title="5-2 Github-合并分支（下）"></a>5-2 Github-合并分支（下）</h3><h2 id="第6章-团队协作流程"><a href="#第6章-团队协作流程" class="headerlink" title="第6章 团队协作流程"></a>第6章 团队协作流程</h2><blockquote><p>Github 公司内部使用的工作流程 Github Flow，是 Git 多种协作流程中，最简单也是最流行的一套思路。本章来看看在团队内部如何应用这套流程。</p></blockquote><h3 id="6-1-Github-团队协作流程（上）"><a href="#6-1-Github-团队协作流程（上）" class="headerlink" title="6-1 Github-团队协作流程（上）"></a>6-1 Github-团队协作流程（上）</h3><h3 id="6-2-Github-团队协作流程（下）"><a href="#6-2-Github-团队协作流程（下）" class="headerlink" title="6-2 Github-团队协作流程（下）"></a>6-2 Github-团队协作流程（下）</h3><h2 id="第7章-开源项目贡献流程"><a href="#第7章-开源项目贡献流程" class="headerlink" title="第7章 开源项目贡献流程"></a>第7章 开源项目贡献流程</h2><blockquote><p>开源项目由于贡献者互相不认识，所以流程上必然是区别于团队流程的，但是本质上依然是基于 Pull Request 的 Github Flow。</p></blockquote><h3 id="7-1-开源项目贡献流程"><a href="#7-1-开源项目贡献流程" class="headerlink" title="7-1 开源项目贡献流程"></a>7-1 开源项目贡献流程</h3><h2 id="第8章-Github-Issues"><a href="#第8章-Github-Issues" class="headerlink" title="第8章 Github Issues"></a>第8章 Github Issues</h2><blockquote><p>Issues 相当于项目论坛，集中讨论项目新功能，bug 修复以及任何项目相关的事情。会涉及到 Markdown 使用和多种技巧。</p></blockquote><h3 id="8-1-Github-Issues"><a href="#8-1-Github-Issues" class="headerlink" title="8-1 Github Issues"></a>8-1 Github Issues</h3><h2 id="第9章-Github-Pages-搭建网站"><a href="#第9章-Github-Pages-搭建网站" class="headerlink" title="第9章 Github Pages 搭建网站"></a>第9章 Github Pages 搭建网站</h2><blockquote><p>Github 提供了自己搭建项目网站的一套框架，非常的简单实用。</p></blockquote><h3 id="9-1-Github-Pages-搭建网站"><a href="#9-1-Github-Pages-搭建网站" class="headerlink" title="9-1 Github Pages 搭建网站"></a>9-1 Github Pages 搭建网站</h3><p><a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></p><h2 id="第10章-Github-的秘密机关"><a href="#第10章-Github-的秘密机关" class="headerlink" title="第10章 Github 的秘密机关"></a>第10章 Github 的秘密机关</h2><blockquote><p>为了保证界面的简约美观，Github 的很多功能其实是隐藏的，例如一些非常能够提高工作效率的快捷键。</p></blockquote><h3 id="10-1-Github的秘密机关"><a href="#10-1-Github的秘密机关" class="headerlink" title="10-1 Github的秘密机关"></a>10-1 Github的秘密机关</h3><p>GitHub官网中搜索文件快捷键：T</p><p>GitHub社交化编程</p><p>怎么筛选学习内容？：可以追星</p><h2 id="第11章-Until-Next-Time-Goodbye"><a href="#第11章-Until-Next-Time-Goodbye" class="headerlink" title="第11章 Until Next Time, Goodbye!"></a>第11章 Until Next Time, Goodbye!</h2><blockquote><p>总结和下一步的学习建议。</p></blockquote><h3 id="11-1-Until-Next-Time-Goodbye-01-10"><a href="#11-1-Until-Next-Time-Goodbye-01-10" class="headerlink" title="11-1 Until Next Time, Goodbye! (01:10)"></a>11-1 Until Next Time, Goodbye! (01:10)</h3>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208-版本管理工具介绍—Git篇</title>
      <link href="/2019/11/01/208-Git/"/>
      <url>/2019/11/01/208-Git/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/208" target="_blank" rel="noopener">https://www.imooc.com/learn/208</a></p><p>简介：本课程主要讲解了git在各平台的安装和基本使用，Git能够帮助我们解决文件的提交、检出、回溯历史、冲突解决、多人协作模式等问题，并且大大提升我们的工作效率。</p></blockquote><p>@[TOC]</p><h2 id="第1章-版本管理工具初探"><a href="#第1章-版本管理工具初探" class="headerlink" title="第1章 版本管理工具初探"></a>第1章 版本管理工具初探</h2><blockquote><p>聊聊版本管理工具是什么，它能为我们做什么。</p></blockquote><h3 id="1-1-版本管理工具简介"><a href="#1-1-版本管理工具简介" class="headerlink" title="1-1 版本管理工具简介"></a>1-1 版本管理工具简介</h3><p>版本管理工具是干什么用的？</p><ul><li>备份文件（类似U盘，网盘）</li><li>记录历史（有各个阶段的代码历史版本）</li><li>回到过去（恢复历史版本）</li><li>多端协作（可以在家工作，也可以在公司）</li><li>团队协作（代码整合，多人共同完成一个项目）</li></ul><h2 id="第2章-工具的历史"><a href="#第2章-工具的历史" class="headerlink" title="第2章 工具的历史"></a>第2章 工具的历史</h2><blockquote><p>聊聊cvs、svn、git、github这些工具的发展历史。</p></blockquote><h3 id="2-1-版本管理工具发展历史"><a href="#2-1-版本管理工具发展历史" class="headerlink" title="2-1 版本管理工具发展历史"></a>2-1 版本管理工具发展历史</h3><ol><li><p>CVS 1985，集中式，始祖（网络环境）</p><p>最早期的版本控制软件，是把文件集中保存到中心服务器</p></li><li><p>SVN 2000，集中式，集大成者（网络环境）</p><p>在CVS的基础上的加强版，可以还原到某个时间点</p></li><li><p>Git 2005，分布式，geek主流（无网环境）</p><p>分布式的版本控制软件</p></li><li><p>GitHub 2008，托管网站，geek社区（程序员托管网站）</p><p>网站托管，基于Git</p></li></ol><p>集中式：服务器。需要联网</p><p>分布式：效率高。拥有版本库即可（Git）</p><h2 id="第3章-如何做个英雄"><a href="#第3章-如何做个英雄" class="headerlink" title="第3章 如何做个英雄"></a>第3章 如何做个英雄</h2><blockquote><p>演示git和github的基本使用，提升工作效率，让我们在独立工作中成为英雄</p></blockquote><h3 id="3-1-Git下载和安装"><a href="#3-1-Git下载和安装" class="headerlink" title="3-1 Git下载和安装"></a>3-1 Git下载和安装</h3><p>安装Git环境一Windows：</p><ul><li>下载Github for Windows：<a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a></li></ul><h3 id="3-2-linux下安装Git环境"><a href="#3-2-linux下安装Git环境" class="headerlink" title="3-2 linux下安装Git环境"></a>3-2 linux下安装Git环境</h3><p>安装Git环境一Linux：</p><pre><code class="shell">yum install gitgit --help</code></pre><h3 id="3-3-github注册"><a href="#3-3-github注册" class="headerlink" title="3-3 github注册"></a>3-3 github注册</h3><p><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><h3 id="3-4-创建一个新的项目"><a href="#3-4-创建一个新的项目" class="headerlink" title="3-4 创建一个新的项目"></a>3-4 创建一个新的项目</h3><p><a href="https://github.com/new" target="_blank" rel="noopener">https://github.com/new</a></p><h3 id="3-5-Linux环境下检出项目到本地"><a href="#3-5-Linux环境下检出项目到本地" class="headerlink" title="3-5 Linux环境下检出项目到本地"></a>3-5 Linux环境下检出项目到本地</h3><pre><code class="shell">git clone https://github.com/tuyrk/demo.git</code></pre><h3 id="3-6-Linux环境下第一次提交项目"><a href="#3-6-Linux环境下第一次提交项目" class="headerlink" title="3-6 Linux环境下第一次提交项目"></a>3-6 Linux环境下第一次提交项目</h3><pre><code class="shell">vi log.txtgit add log.txtgit commit -m &quot;comment&quot;git pushgit config</code></pre><p>忽略修改：</p><ol><li>gitignore添加需要忽略的文件</li></ol><h3 id="3-7-windows下检出项目和提交项目"><a href="#3-7-windows下检出项目和提交项目" class="headerlink" title="3-7 windows下检出项目和提交项目"></a>3-7 windows下检出项目和提交项目</h3><h2 id="第4章-和其他英雄一起工作"><a href="#第4章-和其他英雄一起工作" class="headerlink" title="第4章 和其他英雄一起工作"></a>第4章 和其他英雄一起工作</h2><blockquote><p>演示如何通过git和github，让我们和其他英雄一起工作，减少和解决合作中出现的冲突</p></blockquote><h3 id="4-1-关于代码冲突"><a href="#4-1-关于代码冲突" class="headerlink" title="4-1 关于代码冲突"></a>4-1 关于代码冲突</h3><h3 id="4-2-Linux下如何解决冲突"><a href="#4-2-Linux下如何解决冲突" class="headerlink" title="4-2 Linux下如何解决冲突"></a>4-2 Linux下如何解决冲突</h3><p>解决冲突步骤：</p><ol><li>git pull拉取最新代码</li><li>git diff查看</li><li>手动修改提交哪次冲突</li><li>再次提交</li></ol><pre><code class="shell">git pullgit diffgit add log.txtgit commit -m &quot;解决冲突后提交&quot;git push origin master</code></pre><h3 id="4-3-windows下如何解决冲突"><a href="#4-3-windows下如何解决冲突" class="headerlink" title="4-3 windows下如何解决冲突"></a>4-3 windows下如何解决冲突</h3><h3 id="4-4-如何回到过去"><a href="#4-4-如何回到过去" class="headerlink" title="4-4 如何回到过去"></a>4-4 如何回到过去</h3><p>版本回滚操作步骤：</p><pre><code class="shell">git log # 显示所有提交记录.git reset --hard &lt;提交ID&gt; # 完成回滚操作git pushgit log # 显示新的提交记录</code></pre><p>版本跳转操作步骤：</p><pre><code class="shell">git reflog # 查看该用户的所有操作git reset --hard &lt;提交ID&gt; # 完成跳转到现在</code></pre><h3 id="4-5-建立里程碑"><a href="#4-5-建立里程碑" class="headerlink" title="4-5 建立里程碑"></a>4-5 建立里程碑</h3><p>里程碑，即版本号。标签</p><pre><code class="shell">git tag -a &lt;name&gt; -m &quot;comment&quot; # 创建标签git push origin &lt;name&gt;git checkout &lt;name&gt; # 切换标签git checkout -b &lt;分支名称&gt; &lt;name&gt; # 切换标签git tag -d &lt;name&gt; # 删除标签</code></pre><h3 id="4-6-分支开发之分支合并"><a href="#4-6-分支开发之分支合并" class="headerlink" title="4-6 分支开发之分支合并"></a>4-6 分支开发之分支合并</h3><pre><code class="shell">git branch &lt;分支名称&gt; # 创建分支git checkout &lt;分支名称&gt; # 切换分支git merge &lt;分支名称&gt; # 合并到master分支。首先需切换到master分支，然后进行合并git branch -d &lt;分支名称&gt; # 删除分支</code></pre><h3 id="4-7-分支开发之合并到master"><a href="#4-7-分支开发之合并到master" class="headerlink" title="4-7 分支开发之合并到master"></a>4-7 分支开发之合并到master</h3><p>通过Github网页合并分支</p><h3 id="4-8-关于多人合作的一些经验"><a href="#4-8-关于多人合作的一些经验" class="headerlink" title="4-8 关于多人合作的一些经验"></a>4-8 关于多人合作的一些经验</h3><p><strong>利用工具提升工作效率，而不是去学习工具本身</strong></p><ol><li>多用客户端和工具，少用命令行，除非在linux服务器上直接开发</li><li>每次提交前，diff自己的代码，以免提交错误的代码</li><li>下班回家前，整理好自己的工作区</li><li>并行的项目，使用分支开发</li><li>遇到冲突时，搞明白冲突的原因，千万不要随意丢弃别人的代码</li><li>产品发布后，记得打tag，方便将来拉分支修bug</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo重新发布后GitPages自定义域名失效</title>
      <link href="/2019/10/29/hexo-gitpages-invalid/"/>
      <url>/2019/10/29/hexo-gitpages-invalid/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 <code>Github Pages</code> 功能将博客托管在了 Github 上，并配置 <code>CNAME</code> 将自己的域名解析了过去，在 <code>Github</code> 的仓库设置中开始 <code>Custom domain</code> 的功能，这时候就可以直接使用自己的域名访问啦。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8felp76szj311g0u00u4.jpg" alt="GitHub Pages" style="zoom:40%;" /><p>但是发现一个问题是，每次配置 <code>Custom domain</code> 之后，再次 <code>hexo deploy</code> 之后，<code>Custom domain</code> 会被重置失效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 <code>hexo</code> 生成的博客的 <code>source</code> 目录下新建一个 <code>CNAME</code> 文件，然后在这个文件中填入你的域名，最后重新部署hexo。这样就不会每次发布之后，<code>Github pages</code> 里的 <code>Custom domain</code> 都被重置掉啦。</p><pre><code class="shell">vim ource/CNAME</code></pre><pre><code class="shell">www.tuyrk.cn</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 同时管理Github和Gitee</title>
      <link href="/2019/10/29/git-manage-github-gitee/"/>
      <url>/2019/10/29/git-manage-github-gitee/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="1-取消git全局配置"><a href="#1-取消git全局配置" class="headerlink" title="1.取消git全局配置"></a>1.取消git全局配置</h2><blockquote><p>取消全局的user.name和user.email</p></blockquote><pre><code class="shell">git config --global --unset user.name &quot;xxx&quot;git config --global --unset user.email &quot;xxx&quot;</code></pre><p>其中<code>xxx</code>是以前配置的信息，可以通过 下边命令查看</p><pre><code class="shell">git config --global --list</code></pre><h2 id="2-生成new的ssh-keys"><a href="#2-生成new的ssh-keys" class="headerlink" title="2.生成new的ssh keys"></a>2.生成new的ssh keys</h2><blockquote><p>如果需要github和gitee都能存在，那么就需要生成github和gitee的id_rsa， 然后放在一起</p></blockquote><ol><li><p>生成Github 和 Gitee的keys</p><pre><code class="shell">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;xxx&quot;</code></pre><p>注：其中<code>xxx</code>是github平台的注册邮箱</p><pre><code class="shell">ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C &quot;...&quot;</code></pre><p>注：其中<code>...</code>是你gitee平台的注邮箱</p></li><li><p>将生成的新keys添加到ssh agent</p><pre><code class="shell">ssh-agent bash</code></pre><pre><code class="shell">ssh-add ~/.ssh/id_rsa.githubssh-add ~/.ssh/id_rsa.giteeexit</code></pre></li><li><p>配置config文件</p><blockquote><p>在.ssh文件夹下面配置config文件</p></blockquote><pre><code class="shell">vim ~/.ssh/config</code></pre><pre><code class="shell"># githubHost github.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.githubPort 443# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.gitee</code></pre></li></ol><h2 id="3-平台设置SSH"><a href="#3-平台设置SSH" class="headerlink" title="3.平台设置SSH"></a>3.平台设置SSH</h2><blockquote><p>钥匙和配置文件搞定后，就需要将我们的公钥放入到我们的平台中了</p></blockquote><ol><li><p>Github：复制<code>~/.ssh/id_rsa.github.pub</code>的内容到Github公钥</p><p>Settings &gt; SSH and GPG keys &gt; New SSH key</p></li><li><p>Gitee：复制<code>~/.ssh/id_rsa.gitee.pub</code>的内容到Gitee公钥</p><p>设置 &gt; 安全设置 &gt; SSH公钥</p></li></ol><h2 id="4-测试是否成功"><a href="#4-测试是否成功" class="headerlink" title="4.测试是否成功"></a>4.测试是否成功</h2><ol><li><p>Github</p><pre><code class="shell">ssh -T git@github.com</code></pre><p>结果：</p><pre><code>Hi 766564616! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></li><li><p>Gitee</p><pre><code class="shell">ssh -T git@gitee.com</code></pre><p>结果：</p><pre><code>Hi 神秘的小岛岛! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.</code></pre></li></ol><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol><li><p>Bad owner or permissions on /Users/tuyuankun/.ssh/config</p><pre><code class="shell">sudo chmod 600 config ~/.ssh/config</code></pre></li><li><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>@     WARNING: UNPROTECTED PRIVATE KEY FILE!     @</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>Permissions 0777 for ‘/Users/tuyuankun/.ssh/id_rsa.gitee’ are too open.</p><p>It is required that your private key files are NOT accessible by others.</p><p>This private key will be ignored.</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>@     WARNING: UNPROTECTED PRIVATE KEY FILE!     @</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>Permissions 0777 for ‘/Users/tuyuankun/.ssh/id_rsa.github’ are too open.</p><p>It is required that your private key files are NOT accessible by others.</p><p>This private key will be ignored.</p><pre><code class="shell">sudo chmod 700 ~/.ssh/id_rsa.gitee ~/.ssh/id_rsa.github</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-hexo快捷键说明</title>
      <link href="/2019/10/29/3-hexo-shortcuts/"/>
      <url>/2019/10/29/3-hexo-shortcuts/</url>
      
        <content type="html"><![CDATA[<p>快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可</p><p>如果有比较好的建议，欢迎骚扰。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><table><thead><tr><th align="left">Key</th><th align="left">Descption</th></tr></thead><tbody><tr><td align="left">ESC</td><td align="left">1.如果输入框有内容，清除内容 2.如果输入框无内容，失去焦点</td></tr><tr><td align="left">i/I</td><td align="left">获取焦点</td></tr><tr><td align="left">下</td><td align="left">向下选择文章</td></tr><tr><td align="left">上</td><td align="left">向上选择文章</td></tr><tr><td align="left">回车</td><td align="left">打开当前选中的文章，若没有，则默认打开第一个</td></tr></tbody></table><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><table><thead><tr><th align="left">Key</th><th align="left">Descption</th></tr></thead><tbody><tr><td align="left">s/S</td><td align="left">全屏/取消全屏</td></tr><tr><td align="left">w/W</td><td align="left">打开/关闭文章目录</td></tr><tr><td align="left">j/J</td><td align="left">向下滑动</td></tr><tr><td align="left">k/K</td><td align="left">向上滑动</td></tr><tr><td align="left">gg/GG</td><td align="left">到最顶端</td></tr><tr><td align="left">shift+G/g</td><td align="left">到最下端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS配置OpenVPN之Tunnelblick</title>
      <link href="/2019/10/10/MacOS-OpenVPN/"/>
      <url>/2019/10/10/MacOS-OpenVPN/</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接公司内网需要使用到OpenVPN，之前在Windows系统直接使用公司提供的<a href="https://openvpn.net/community-downloads/" target="_blank" rel="noopener">OpenVPN客户端</a>，但是似乎没有Mac版，所以使用了<a href="https://tunnelblick.net/index.html" target="_blank" rel="noopener">Tunnelblick工具</a>，下边记录一下在使用中遇到的一些问题。</p></blockquote><ol><li><p>下载⏬<a href="https://tunnelblick.net/index.html" target="_blank" rel="noopener">Tunnelblick工具</a>，安装</p></li><li><p>准备<code>*.ovpn</code>、<code>*.key</code>、<code>*.crt</code>在同一目录下</p><ul><li><p>问题一：<code>“comp-lzo” 在openvpn 2.4 中已弃用,将会在未来的版本中移除。</code></p><p>解决：<a href="https://github.com/Nyr/openvpn-install/issues/430" target="_blank" rel="noopener">https://github.com/Nyr/openvpn-install/issues/430</a></p><p>在<code>*.ovpn</code>使用<code>compress lzo</code>代替<code>comp-lzo</code> </p></li><li><p>问题二：<code>• &#39;ns-cert-type&#39; 这个选项在 OpenVPN 2.4 版本的配置中是过时的，已经在 OpenVPN 2.5 版本中移除。</code></p><p>解决：在<code>*.ovpn</code>使用<code>remote-cert-tls server</code>代替<code>ns-cert-type server</code></p></li><li><p>问题三：<code>unrecognized option or missing or extra parameter(s) ip-win32 (2.4.7)</code></p><p>解决：由于脚本是公司为Windows系统提供的，所以我在这里直接注释这个。</p><pre><code class="shell"># ip-win32 dynamic -1# route-method exe</code></pre></li></ul></li><li><p>点击<code>*.ovpn</code>、连接</p></li></ol><p><strong>==OpenVPN中不推荐使用的选项==</strong>：<a href="https://community.openvpn.net/openvpn/wiki/DeprecatedOptions" target="_blank" rel="noopener">https://community.openvpn.net/openvpn/wiki/DeprecatedOptions</a></p><p>OpenVPN客户端配置文件详解：<a href="https://blog.faystar.com/openvpn_client/" target="_blank" rel="noopener">https://blog.faystar.com/openvpn_client/</a></p><pre><code class="shell"># 定义是一个客户端client# 定义使用设备类型，与服务端一致;dev tapdev tun# 定义Windows下使用的网卡名称,linux不需要;dev-node 我的连接# 定义使用的协议，与服务端一致;proto tcpproto udp# 指定服务端地址和端口,可以用多行指定多台服务器# 实现负载均衡（从上往下尝试）remote 118.112.188.108 1194;remote my-server-2 1194# 若上面配置了多台服务器，让客户端随机连接;remote-random# 解析服务器域名# Keep trying indefinitely to resolve the# host name of the OpenVPN server.  Very useful# on machines which are not permanently connected# to the internet such as laptops.resolv-retry infinite# 客户端不需要绑定端口# Most clients do not need to bind to# a specific local port number.nobind# 也是为了让Openvpn也nobody运行（安全）# 注意：Windows不能设置;user nobody;group nobody# Try to preserve some state across restarts.persist-keypersist-tun# 若客户端通过HTTP Proxy，在这里设置# 要使用Proxy，不能使用UDP为VPN的通讯协议;http-proxy-retry # retry on connection failures;http-proxy [proxy server] [proxy port #]# 无线网络有很多多余的头文件，设置忽略它;mute-replay-warnings# 重点，就是指定ca和客户端的证书# 注意，下面的两个号是连在一起的，之间没有空格.需同时存在/注释ca &quot;ca.crt&quot;# cert &quot;test-1.crt&quot;# key &quot;test-1.key&quot;# 如果服务端打开了PAM认证模块，如mysql，LDAP数据库验证，客户端需要另其有效;auth-user-pass# 一些安全措施# Verify server certificate by checking# that the certicate has the nsCertType# field set to “server”.  This is an# important precaution to protect against# a potential attack discussed here:# http://openvpn.net/howto.html#mitm## To use this feature, you will need to generate# your server certificates with the nsCertType# field set to “server”.  The build-key-server# script in the easy-rsa folder will do this.remote-cert-tls server# 增强验证加密，如果你在服务器端生成了ta.key，那么这里就需要加上# then every client must also have the key.tls-auth ta.key 1# Select a cryptographic cipher.# If the cipher option is used on the server# then you must also specify it here.;cipher x# 使用lzo压缩，与服务端一致compress lzo# Set log file verbosity.verb 3# Silence repeating messages;mute 20#采用用户名密码方式验证,若不用证书的话,可以考虑这种方式,可以结合LDAP或者mysql;auth-user-pass#windows7上会报错,建议加上此行# route-method exe#强行指定添加路由前的延时route-delay 2#不存储验证缓存auth-nocache#设置IP地址过期时间# ip-win32 dynamic 0 7200</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>714-性能测试之LoadRunner</title>
      <link href="/2019/09/29/714-LoadRunner/"/>
      <url>/2019/09/29/714-LoadRunner/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/714" target="_blank" rel="noopener">https://www.imooc.com/learn/714</a></p><p>简介：性能测试的实施不仅仅是掌握LoadRunner即可，还需要进行性能测试设计与性能测试构建实施等。本课程的目标就是帮助各位朋友提高实战能力，让性能测试落地，接地气，课程中会拿实际案例作为分析手段进行演练，增强动手操作技能。 项目实战进阶推荐课程！！！ 性能测试 LoadRunner 工具实战-慕课网实战 <a href="http://coding.imooc.com/class/127.html" target="_blank" rel="noopener">http://coding.imooc.com/class/127.html</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>通过详细的细分教学，让学生理解什么是性能测试，性能测试的流程，使用Loadrunner做性能测试的步骤</p></blockquote><h3 id="1-1-性能测试学习内容指南-03-52"><a href="#1-1-性能测试学习内容指南-03-52" class="headerlink" title="1-1 性能测试学习内容指南 (03:52)"></a>1-1 性能测试学习内容指南 (03:52)</h3><p>目录：</p><ul><li>第一章 性能测试理论</li><li>第二章 LoadRunner的基本操作</li><li>第三章 系统的监控、分析与调优</li></ul><p>第一章 性能测试理论</p><ul><li>性能测试的<strong>常用术语</strong></li><li>性能测试的<strong>应用领域</strong></li><li>性能测试常用<strong>工具的原理</strong></li></ul><p>第二章 LoadRunner的基本操作</p><ul><li><p>LoadRunner的原理分析</p></li><li><p>LoadRunner脚本的开发流程</p><p>LoadRunner的<strong>三个组件</strong>：</p><ul><li>VuGen：基本设置、检查点、参数化、关联、调试、事务</li><li>Controller：场景设置、场景执行、资源监控、集合点、IP欺骗、负载均衡</li><li>Analysis：摘要报告、常见图分析、结果分析实践</li></ul></li></ul><p>第三章 系统的监控、分析、调优</p><ul><li>Windows/Linux的监控、分析、调优</li><li>数据库的监控、分析、调优</li><li>中间件的监控、分析、调优</li></ul><h2 id="第2章-主要概念介绍"><a href="#第2章-主要概念介绍" class="headerlink" title="第2章 主要概念介绍"></a>第2章 主要概念介绍</h2><blockquote><p>介绍性能测试的衍生史以及特点等。</p></blockquote><h3 id="2-1-性能测试理论-09-17"><a href="#2-1-性能测试理论-09-17" class="headerlink" title="2-1 性能测试理论 (09:17)"></a>2-1 性能测试理论 (09:17)</h3><p>目录：</p><ul><li>性能测试的概念及其分类</li><li>性能测试的流程</li><li>性能测试工具的原理</li></ul><p>软件系统的性能包括：执行效率、资源占用、系统稳定性、安全性、兼容性、可靠性、可扩展性</p><p>性能测试的概念：</p><blockquote><p>性能测试主要通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p></blockquote><p>性能测试常见分类：</p><ul><li><p>性能测试（狭义）</p><p>方法：通过模拟业务生产运行的业务压力量和使用场景组合，测试系统的性能是否满足生产性能的要求</p><p>目的：验证系统是否具有系统宣称的能力</p></li><li><p>负载测试</p><p>方法：通过在被测系统上不断加压，直到性能指标达到极限</p><p>目的：找到系统处理能力的极限</p></li><li><p>压力测试（强度测试）</p><p>方法：测试系统在一定饱和状态下，系统能够处理的会话能力，以及系统是否会出现错误</p><p>目的：检查系统处于压力性能下时，应用的表现</p></li><li><p>并发测试</p><p>方法：通过模拟用户并发访问，测试多用户并发访问同一个应用、模块或者数据记录时是否存在死锁或其他性能问题</p><p>目的：发现系统中可能隐藏的并发访问时的问题</p></li><li><p>配置测试</p><p>方法：通过对被测系统的软硬件环境进行调整，了解不同软硬件环境对系统的性能的影响程度，从而找到系统各项资源的最优分配原则</p><p>目的：了解各种不同因素对系统性能的影响程度</p></li><li><p>可靠性测试（稳定性测试）</p><p>方法：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定</p><p>目的：验证系统是否支持长期稳定的运行</p></li></ul><p>系统测试的流程：</p><ol><li>测试计划阶段<ul><li>明确测试对象</li><li>定义测试目标</li><li>定义测试通过的标准</li><li>规划测试进度</li><li>规划测试参与人员（需求、开发、测试、运维和配置）</li><li>申请测试资源</li><li>风险控制</li></ul></li><li>测试设计阶段<ul><li>设计测试数据</li><li>设计测试用例</li><li>设计测试场景</li></ul></li><li>测试开发阶段<ul><li>测试环境搭建</li><li>测试过程文档定义以及配置</li><li>测试脚本开发、调试</li><li>测试数据准备</li><li>基准测试</li></ul></li><li>测试执行阶段<ul><li>执行测试模型，包括执行脚本和场景</li><li>测试过程监控，包括查看log、监控服务器资源、数据库和中间件等</li></ul></li><li>测试结果分析阶段<ul><li>根据测试结果和监控结果进行测试分析</li><li>根据性能测试目标，分析出系统存在的性能瓶颈，并给出优化建议</li></ul></li><li>测试报告阶段<ul><li>测试范围</li><li>测试执行以及参与人员</li><li>基准测试数据</li><li>测试执行的详细步骤（场景设计）</li><li>测试数据记录、监控结果</li><li>测试结果对比以及总结性评价</li></ul></li></ol><p>性能测试工具(LoadRunner、JMeter)组成：</p><blockquote><p>脚本生成器、压力生成器、压力控制器、结果分析器</p></blockquote><p>性能测试工具🔧的原理：</p><p>LoadRunner其实是一个代理，代理客户端和服务器之间的中间人。</p><p>LoadRunner通过代理截获客户端和服务器之间的交互数据流</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghjr9kftj31m40g4dip.jpg" alt="性能测试工具🔧的原理" style="zoom:30%;" /><h2 id="第3章-工具的安装和启动"><a href="#第3章-工具的安装和启动" class="headerlink" title="第3章 工具的安装和启动"></a>第3章 工具的安装和启动</h2><blockquote><p>Loadrunner的下载和安装注意事项；Web Tours服务的启动和功能介绍</p></blockquote><h3 id="3-1-Loadrunner的安装与介绍-07-04"><a href="#3-1-Loadrunner的安装与介绍-07-04" class="headerlink" title="3-1 Loadrunner的安装与介绍 (07:04)"></a>3-1 Loadrunner的安装与介绍 (07:04)</h3><p>安装LoadRunner(<strong>==Windows版==</strong>)：</p><ul><li>下载地址⏬：<a href="https://pan.baidu.com/s/1XzfbZ7r6OlV1T61IA-mGvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XzfbZ7r6OlV1T61IA-mGvQ</a> 密码:1sbr</li></ul><p>LoadRunner的组件：</p><ul><li>Virtual User Generator：录制最终用户业务流程并创建性能测试脚本</li><li>Controller：组织、驱动、管理并监控负载测试</li><li>Analysis：用于查看、剖析和比较性能结果</li></ul><p>LoadRunner的功能：</p><ul><li>轻松创建虚拟用户</li><li>创建真实的负载</li><li>分析结果以精确定位问题所在</li><li>重复测试保证系统发布的高性能</li></ul><h3 id="3-2-HP-Web-Tours使用-05-01"><a href="#3-2-HP-Web-Tours使用-05-01" class="headerlink" title="3-2 HP Web Tours使用 (05:01)"></a>3-2 HP Web Tours使用 (05:01)</h3><p>启动Web Tours服务</p><pre><code>/HP/LoadRunner/WebTours/StartServer.bat</code></pre><p>访问Web Tours</p><pre><code>http://127.0.0.1:1080/WebTours/</code></pre><p>帐号：jojo  密码：bean</p><p>Web Tours功能介绍：</p><blockquote><p>注册，登录，订票，查看历史订票记录，取消订票，退出</p></blockquote><h2 id="第4章-录制测试脚本"><a href="#第4章-录制测试脚本" class="headerlink" title="第4章 录制测试脚本"></a>第4章 录制测试脚本</h2><blockquote><p>介绍VUGen录制脚本的步骤，介绍Loadrunner的两种录制选项；录制登录、订票、查询和退出等操作流程；对录制的脚本进行参数化和关联等增强，使得脚本能回放成功；介绍参数化不同选项组合的用途</p></blockquote><h3 id="4-1-录制选项-07-39"><a href="#4-1-录制选项-07-39" class="headerlink" title="4-1 录制选项 (07:39)"></a>4-1 录制选项 (07:39)</h3><h3 id="4-2-录制脚本前概念-11-10"><a href="#4-2-录制脚本前概念-11-10" class="headerlink" title="4-2 录制脚本前概念 (11:10)"></a>4-2 录制脚本前概念 (11:10)</h3><h3 id="4-3-调试脚本-31-59"><a href="#4-3-调试脚本-31-59" class="headerlink" title="4-3 调试脚本 (31:59)"></a>4-3 调试脚本 (31:59)</h3><h2 id="第5章-创建测试场景"><a href="#第5章-创建测试场景" class="headerlink" title="第5章 创建测试场景"></a>第5章 创建测试场景</h2><blockquote><p>从脚本到创建场景，再到运行场景的流程做详细讲解</p></blockquote><h3 id="5-1-设置并执行场景-25-18"><a href="#5-1-设置并执行场景-25-18" class="headerlink" title="5-1 设置并执行场景 (25:18)"></a>5-1 设置并执行场景 (25:18)</h3><h2 id="第6章-分析测试结果"><a href="#第6章-分析测试结果" class="headerlink" title="第6章 分析测试结果"></a>第6章 分析测试结果</h2><blockquote><p>Loadrunner结果的分析和导出报告</p></blockquote><h3 id="6-1-测试结果分析-09-41"><a href="#6-1-测试结果分析-09-41" class="headerlink" title="6-1 测试结果分析 (09:41)"></a>6-1 测试结果分析 (09:41)</h3><h2 id="第7章-课程总结"><a href="#第7章-课程总结" class="headerlink" title="第7章 课程总结"></a>第7章 课程总结</h2><blockquote><p>通过本课程，我们学习和理解了使用Loadrunner做性能测试的步骤和方法。</p></blockquote><h3 id="7-1-性能测试框架基础课程总结-03-29"><a href="#7-1-性能测试框架基础课程总结-03-29" class="headerlink" title="7-1 性能测试框架基础课程总结 (03:29)"></a>7-1 性能测试框架基础课程总结 (03:29)</h3>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> LoadRunner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>735-JMeter性能测试入门篇</title>
      <link href="/2019/09/28/735-JMeter/"/>
      <url>/2019/09/28/735-JMeter/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/735" target="_blank" rel="noopener">https://www.imooc.com/learn/735</a></p><p>简介：本课程通过通俗易懂的讲法，非常容易理解的方式去讲解如何使用jmeter进行web应用的性能测试。</p></blockquote><p>@[TOC]</p><h2 id="第1章-jmeter基本介绍"><a href="#第1章-jmeter基本介绍" class="headerlink" title="第1章 jmeter基本介绍"></a>第1章 jmeter基本介绍</h2><blockquote><p>了解Jmeter及本课程的主要内容，知道如何下载到Jmeter；了解Jmeter的组成并了解性能测试工具的组成；了解jmeter的目录及为什么使用jmeter</p></blockquote><h3 id="1-1-Jmeter整体简介-20-20"><a href="#1-1-Jmeter整体简介-20-20" class="headerlink" title="1-1 Jmeter整体简介 (20:20)"></a>1-1 Jmeter整体简介 (20:20)</h3><p>软件架构：</p><ul><li><p>BS：browser-server</p></li><li><p>CS：client-server</p></li></ul><p>Jmeter简介：</p><ul><li><p>官网：<a href="https://jmeter.apache.org/" target="_blank" rel="noopener">https://jmeter.apache.org/</a></p></li><li><p>需要Java环境作为支撑。</p></li></ul><p>下载：<a href="http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-5.1.1.zip" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-5.1.1.zip</a></p><p>Jmeter组成：</p><ul><li><p>取样器</p><p>进行脚本逻辑控制（控制业务流程。什么样的请求，什么时候发出请求等）</p></li><li><p>线程组</p><p>场景设置（多少线程。多少用户访问，访问多少次等）</p></li><li><p>监视器</p><p>监控我们的脚本运行，取得性能指标（电量等）</p></li></ul><p>任何一款性能测试工具都应该是由这三部分组成</p><p>Jmeter操作：</p><ol><li><p>添加线程组(Thread Group)：[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p><p>Thread Properties（线程属性）</p><ul><li>Numbers of Threads(users)：控制多少用户进行并发</li></ul></li></ol><ul><li>Ramp-UpPeriod(in seconds)：在多少秒之内进行并发。加压策略<ul><li>Loop Count：循环次数</li></ul></li></ul><ol start="2"><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加监听器(Listener)</p><ul><li><p>查看结果树(View Results Tree)：[Thread Group]-[Add]-[Listener]-[View Results Tree]</p><p>【查看结果树(View Results Tree)】辅助进行脚本调试</p></li><li><p>聚合报告(Aggregate Report)：[Thread Group]-[Add]-[Listener]-[Aggregate Report]</p><p>统计访问了多少次，访问时间，错误率</p></li></ul></li><li><p>逻辑控制器(Logic Controller)</p></li><li><p>配置元件(Congif Element)</p><p>如果在压测过程中出现no cookies信息，就添加HTTP Header Manager、HTTP Cookie Manager</p></li><li><p>定时器(Timer)</p></li><li><p>前置处理器(Pre Processors)</p><p>在做取样器(Sampler)之前需要做些什么操作</p></li><li><p>后置处理器(Post Processors)</p></li><li><p>断言(Assertions)</p><p>在后置处理器(Post Processors)之后判断返回是否和期望值一致。</p><p>在做多并发处理时，不建议使用JMeter进行断言。在访问请求时自定义了变量，由于多个请求访问速度的影响，共享的一个变量就有可能出现数据的不准确。</p></li><li><p>测试碎片(Test Fragment)</p></li></ol><h2 id="第2章-使用badboy录制jmeter脚本"><a href="#第2章-使用badboy录制jmeter脚本" class="headerlink" title="第2章 使用badboy录制jmeter脚本"></a>第2章 使用badboy录制jmeter脚本</h2><blockquote><p>熟悉jmeter的录制方式及如何思考去制作一个脚本；了解badboy的组成；学会使用badboy录制脚本；能够使用jmeter将badboy脚本调试运行成功</p></blockquote><h3 id="2-1-Jmeter录制方式和思路及badboy简介-10-10"><a href="#2-1-Jmeter录制方式和思路及badboy简介-10-10" class="headerlink" title="2-1 Jmeter录制方式和思路及badboy简介 (10:10)"></a>2-1 Jmeter录制方式和思路及badboy简介 (10:10)</h3><p>JMeter脚本的两种录制方式：</p><ul><li><p>使用badboy进行录制</p><p>badboy(也是一款软件)能够进行浏览器的操作行为的录制，并且能够导出JMeter脚本。</p></li><li><p>使用代理方式进行录制</p><p>代理方式是指不借助第三方软件，然后进行浏览器中的一些设置。监听端口号捕捉在浏览器上的网络请求，然后进行录制</p><p>类似于抓包工具Fiddler。抓包工具：Fiddler、Charles、Wireshark</p></li></ul><p>脚本录制的流程与思路</p><blockquote><p>业务流程=&gt;录制工具=&gt;脚本制作=&gt;性能测试</p></blockquote><p>Badboy：<a href="http://www.badboy.com.au" target="_blank" rel="noopener">http://www.badboy.com.au</a></p><p>注：目前(2019-09-14)访问不了官网，Badboy似乎也没有Mac版。</p><p>Badboy组成：</p><blockquote><p>工具区、地址栏、脚本区、视图区</p></blockquote><p>Badboy介绍与演示</p><ol><li>地址栏输入地址</li><li>视图区进行操作</li><li>脚本区自动记录生成相应操作</li><li>点击工具栏小红点完成录制</li></ol><h3 id="2-2-使用badboy进行jmeter脚本录制-07-30"><a href="#2-2-使用badboy进行jmeter脚本录制-07-30" class="headerlink" title="2-2 使用badboy进行jmeter脚本录制 (07:30)"></a>2-2 使用badboy进行jmeter脚本录制 (07:30)</h3><p>BugFree：Bug管理系统。目前已由禅道代替。</p><p>Badboy进行JMeter脚本录制：</p><ol><li>地址栏输入地址</li><li>视图区进行录制步骤操作</li><li>脚本区自动记录生成相应操作</li><li>点击工具栏小红点完成录制</li><li>点击File=&gt;Export to JMeter=&gt;保存*.jmx文件</li></ol><p>.jmx后缀名就是JMeter可执行文件</p><h3 id="2-3-Jmeter运行badboy脚本-17-57"><a href="#2-3-Jmeter运行badboy脚本-17-57" class="headerlink" title="2-3 Jmeter运行badboy脚本 (17:57)"></a>2-3 Jmeter运行badboy脚本 (17:57)</h3><ol><li>点击File=&gt;Open(command+O)=&gt;选择*.jmx文件=&gt;Open</li><li>Thread Group出现了相应步骤</li><li>Thread Group=&gt;Add=&gt;Listener=&gt;View Results Tree</li><li>点击Start(工具栏上的绿色三角形)回放所有步骤</li></ol><p>【查看结果树】中的请求为绿色并不代表请求成功，而只是代表网络是否联通。通过HTML模式查看相应结果发现所有的返回页面都是登录界面</p><p>Redirect Automatically(自动重定向)</p><p>Follow Redirects(跟重定向)</p><p>Use KeepAlive(保持长链接)</p><p>Use multipart/form-data</p><p>Browser-compatible headers</p><p>第三方录制下来的脚本可能存在的出错点：</p><ol><li><p>检查是否登录系统</p></li><li><p>录制产生的URL与实际不同</p><p>根据网页路径修改</p></li><li><p>选择为[跟踪重定向]</p></li><li><p>录制后的脚本参数出现乱码</p><p>修改字符编码格式[Content encoding]为UTF8</p></li></ol><p>自动重定向与跟随重定向的区别：</p><ul><li><p>自动重定向：HttpClient接收到请求后，如果请求中包含重定向请求，HttpClient是可以自动跳转的，但是只针对GET和Head请求。勾选此项则“跟随重定向”失效。</p><p>自动重定向可以自动转向到最终目标页面，但是JMeter是不记录重定向过程内容的，比如在[查看结果树]中是无法找到重定向过程内容的。如果此时你想做关联，那就比较遗憾了，你无法关联到。</p><p>例如：A重定向到B，此时只记录B的内容不记录A的内容，A的响应内容我们暂时且叫过程内容</p></li><li><p>跟随重定向：Http Request取样器的默认选项，但响应Code是3XX时（比如301是重定向），自动跳转至目标地址。与自动重定向不同，JMeter会记录重定向过程中的所有请求响应，在查看结果树时可以看到服务器返回的内容，所以你可以对响应的内容做关联。</p><p>比如你要测试登录，你把POST请求改为跟随重定向就可以了</p></li></ul><h2 id="第3章-jmeter代理录制及运行"><a href="#第3章-jmeter代理录制及运行" class="headerlink" title="第3章 jmeter代理录制及运行"></a>第3章 jmeter代理录制及运行</h2><blockquote><p>了解jmeter代理录制的设置方式；能够把代理录制设置完成；可以使用代理录制方式录制完成脚本；能够使用jmeter将代理录制的脚本调试运行成功</p></blockquote><h3 id="3-1-JMeter性能测试入门篇-代理录制及脚本运行-23-35"><a href="#3-1-JMeter性能测试入门篇-代理录制及脚本运行-23-35" class="headerlink" title="3-1 JMeter性能测试入门篇-代理录制及脚本运行 (23:35)"></a>3-1 JMeter性能测试入门篇-代理录制及脚本运行 (23:35)</h3><p>JMeter代理录制：</p><ul><li><p>HTTP请求默认值</p><p>输入被测试的URL地址(域名/IP+端口号)</p></li><li><p>HTTP代理服务器</p><p>HTTP代理服务器和国外翻墙代理服务器的工作原理差不多</p></li><li><p>浏览器设置</p><p>局域网设置的端口号需要与代理服务器的端口号保持一致。然后在浏览器的操作就会被代理服务器捕捉到，从而形成系统测试的脚本。</p></li></ul><ol><li><p>创建HTTP代理服务器：Test Plan=&gt;Add=&gt;Non-Test Elements=&gt;HTTP(S) Test Script Recorder</p></li><li><p>在[Global Settings]-[Port]设置端口</p></li><li><p>在[Test Plan Creation]-[Test Plan content]-[Target Controller]选择。<strong>必须设置</strong>。</p></li><li><p>浏览器设置：</p><ul><li>IE浏览器：[工具]-[Internet选项]-[连接]-[局域网设置]-[代理服务器]-[地址+端口]</li><li>Chrome：[工具]-[设置]-[高级]-[打开代理设置]-[网页代理(HTTP)/安全网页代理(HTTPS)]–[地址+端口]</li></ul><p>地址、端口为JMeter代理服务器的相应设置。</p></li><li><p>在浏览器进行相应业务操作，JMeter会自动记录操作及资源文件</p></li><li><p>使用包含模式、排除模式，保留或过滤不需要的资源文件。</p><p>[Requests Filtering]-[URL Patterns to Exclude]-[Add suggested excludes]，或者点击[Add]自定义正则匹配</p></li></ol><p>Web应用程序需添加HTTP Cookie Manager(HTTP Cookie管理器)和HTTP Cache Manager</p><blockquote><p>[Test Plan]-[Add]-[Config Element]-[HTTP Cookie Manager]</p><p>[Test Plan]-[Add]-[Config Element]-[HTTP Cache Manager]</p></blockquote><p><strong>注</strong>：必须添加【查看结果树(View Results Tree)】和【聚合报告(Aggregate Report)】通过直观数据判断脚本是否出现问题。</p><h2 id="第4章-jmeter脚本制作"><a href="#第4章-jmeter脚本制作" class="headerlink" title="第4章 jmeter脚本制作"></a>第4章 jmeter脚本制作</h2><blockquote><p>能够自定义变量，实现值的统一化管理；可以自主使用函数助手进行参数化；可以使用csv文件进行参数化配置，达成参数化的目的</p></blockquote><h3 id="4-1-JMeter性能测试入门篇-用户自定义变量-07-33"><a href="#4-1-JMeter性能测试入门篇-用户自定义变量-07-33" class="headerlink" title="4-1 JMeter性能测试入门篇-用户自定义变量 (07:33)"></a>4-1 JMeter性能测试入门篇-用户自定义变量 (07:33)</h3><p>用户自定义变量作用：</p><blockquote><p>把IP地址、端口号、应用上下文等字段用一个变量去代替，测试环境变化时改变一下变量值即可。</p></blockquote><p>添加用户变量：[Thread Group]-[Add]-[Config Element]-[User Defined Variables]</p><p>使用用户变量：<code>${variable_name}</code></p><h3 id="4-2-JMeter性能测试入门篇-CsvReader函数参数化-07-11"><a href="#4-2-JMeter性能测试入门篇-CsvReader函数参数化-07-11" class="headerlink" title="4-2 JMeter性能测试入门篇-CsvReader函数参数化 (07:11)"></a>4-2 JMeter性能测试入门篇-CsvReader函数参数化 (07:11)</h3><p>文件参数化方式：</p><blockquote><ol><li>函数助手</li><li>csv data set config</li></ol></blockquote><p>函数助手：</p><blockquote><p>[Tools]-[Function Helper Dialog(Shift+Command+F1)]-[Choose a function]-[_CSVRead]-[填写文件名称+列号]-[Generate &amp; Copy to clipboard]-[粘贴到对应属性值框]</p></blockquote><p>如：<code>${_CSVRead(D:\csv.txt,column_idx)}</code></p><p>注：</p><ol><li>文件可以是*.txt，但必须以<code>,</code>隔开。</li><li>列号从<code>0</code>开始</li><li>更改线程数(Number of Threads)，_CSVRead会自动遍历(行号递增)csv.txt</li></ol><h3 id="4-3-JMeter性能测试入门篇-CsvDataSetConfig参数化-09-03"><a href="#4-3-JMeter性能测试入门篇-CsvDataSetConfig参数化-09-03" class="headerlink" title="4-3 JMeter性能测试入门篇-CsvDataSetConfig参数化 (09:03)"></a>4-3 JMeter性能测试入门篇-CsvDataSetConfig参数化 (09:03)</h3><p>csv data set config：</p><blockquote><p>[Thread Group]-[Add]-[Config Element]-[CSV Data Set Config]</p></blockquote><ol><li><p>Variable Names(comma-delimited)：设置变量名称，<code>title,build</code></p><ul><li>引用声明的变量：<code>${title}</code>、<code>${build}</code></li></ul></li><li><p>Delimiter：分隔符</p></li><li><p>Allow quoted data：是否允许带引号</p></li><li><p>Recycle on EOF：遇到文件结束符再次循环</p></li><li><p>Stop thread on EOF：遇到文件结束符停止线程</p></li><li><p>Sharing mode：线程共享模式</p><ul><li>All threads：测试计划中所有线程，假如说有线程1到线程n (n&gt;1)，线程1取了一次值后，线程2取值时，取到的是csv文件中的下一行，即与线程1取的不是同一行。</li><li>Current thread group：当前线程组，假设有线程组A、线程组B，A组内有线程A1到线程An，线程组B内有线程B1到线程Bn。取之情况是：线程A1取到了第1行，线程A2取第2行，现在B1取第1行，线程B2取第2行。</li><li>Current thread：当前线程。假设测试计划内有线程1到线程n (n&gt;1)，则线程1取了第1行，线程2也取第1行。</li></ul></li></ol><h2 id="第5章-关联的使用及总结"><a href="#第5章-关联的使用及总结" class="headerlink" title="第5章 关联的使用及总结"></a>第5章 关联的使用及总结</h2><blockquote><p>通过关联的学习，可以准确的进行关联，排查脚本错误，完成性能测试脚本，学到这里，可以完成整个脚本的制作，独立进行基本的性能测试</p></blockquote><h3 id="5-1-JMeter性能测试入门篇-关联的使用及总结-26-40"><a href="#5-1-JMeter性能测试入门篇-关联的使用及总结-26-40" class="headerlink" title="5-1 JMeter性能测试入门篇-关联的使用及总结 (26:40)"></a>5-1 JMeter性能测试入门篇-关联的使用及总结 (26:40)</h3><p>关联：</p><blockquote><p>当上文中的有一些变量的值在下文中被使用。</p></blockquote><p>添加正则表达式提取器：[HTTP Request]-[Add]-[Post Processors]-[Regular Expression Extractor]</p><ol><li><p>引用名称(Name of created variable)：<code>bugId</code></p></li><li><p>正则表达式(Regular Expression)：<code>左边界(.+?)右边界</code></p><p><code>.</code>匹配任意字符(除了斜杠)，<code>+</code>一次或多次，<code>?</code>0次或多次</p></li><li><p>模版(Template)：<code>$1$</code>。指的是匹配第一个结果</p></li><li><p>匹配数字(0代表随机)(Match No.(0 for Random))：<code>0</code></p></li><li><p>引用上文变量名称：${bugId}</p></li></ol><p>注：在调试测试脚本时，多注意编码。</p><p>:star: <strong>解决中文乱码</strong>：</p><ol><li><p>[Content encoding]设置为UTF-8，同时勾选参数后的[编码?]</p></li><li><p>vim ~/bin/jmeter.properties</p><p>sampleresult.default.encoding=UTF-8</p></li></ol><p>loadrunner与JMeter关联的不同之处：</p><ol><li><p>在loadrunner中，关联函数是写在要获取变量值的页面的前面；</p><p>在JMeter中，关联函数是写在要获取变量值的页面的后面。</p></li><li><p>在loadrunner中，关联函数是注册函数；</p><p>在JMeter中，使用正则表达式提取器进行关联</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>719-JMeter之HTTP协议接口性能测试</title>
      <link href="/2019/09/27/791-JMeterHTTP/"/>
      <url>/2019/09/27/791-JMeterHTTP/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/791" target="_blank" rel="noopener">https://www.imooc.com/learn/791</a></p><p>简介：接口的测试，并不仅仅是掌握某一种工具。工具是死的，并且是多种多样的，本课程通过层层剖析的方式来帮助同学们了解http协议，让学习的同学并不仅仅会做接口的功能和性能测试，并且能够了解什么是真正的接口，消除歧义。 慕课网测试交流群 559506833</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程大纲介绍及接口理解"><a href="#第1章-课程大纲介绍及接口理解" class="headerlink" title="第1章 课程大纲介绍及接口理解"></a>第1章 课程大纲介绍及接口理解</h2><blockquote><p>了解本次课程的基本内容；掌握测试与开发对接口的不同理解</p></blockquote><h3 id="1-1-课程内容介绍-04-28"><a href="#1-1-课程内容介绍-04-28" class="headerlink" title="1-1 课程内容介绍 (04:28)"></a>1-1 课程内容介绍 (04:28)</h3><ol><li>不同角色眼中的接口（开发、测试）</li><li>常见的接口协议（如HTTP等）</li><li>HTTP协议栈中的位置（HTTP协议的底层原理）</li><li>HTTP协议响应码（2XX、4XX、5XX）</li><li>HTTP协议响应模型（一次请求的生命周期）</li><li>常见HTTP协议的请求方式（GET、POST等）</li><li>JMeter的功能介绍</li><li>GET请求与POST请求（实战-如何测试）</li></ol><h3 id="1-2-不同角色眼中的接口-04-50"><a href="#1-2-不同角色眼中的接口-04-50" class="headerlink" title="1-2 不同角色眼中的接口 (04:50)"></a>1-2 不同角色眼中的接口 (04:50)</h3><ul><li><p>开发眼中的接口：模块与模块之间的对接方式定义</p><p>创建一个接口，创建一个接口的实现类，必须实现这个接口里的所有方法。</p></li><li><p>测试眼中的接口：可以独立部署成服务的协议接口</p><p>协议接口（HTTP、FTP等）。利用中间件实现某个功能需求</p></li></ul><h2 id="第2章-HTTP协议基本介绍了解"><a href="#第2章-HTTP协议基本介绍了解" class="headerlink" title="第2章 HTTP协议基本介绍了解"></a>第2章 HTTP协议基本介绍了解</h2><blockquote><p>掌握常见接口的协议；理解http协议栈的位置；掌握响应码并能够根据响应码去定位错误；掌握一次请求的生命周期并掌握一次请求的数据流；掌握常用请求方式，并能够区别不同的请求的表现形式</p></blockquote><h3 id="2-1-常见的接口协议-03-30"><a href="#2-1-常见的接口协议-03-30" class="headerlink" title="2-1 常见的接口协议 (03:30)"></a>2-1 常见的接口协议 (03:30)</h3><table><thead><tr><th>协议</th><th>中文名称</th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议</td></tr><tr><td>HTTPS</td><td>安全超文本传输协议</td></tr><tr><td>FTP</td><td>文件传输协议</td></tr><tr><td>TCP</td><td>网络控制协议</td></tr><tr><td>IP</td><td>互联网协议</td></tr><tr><td>UDP</td><td>用户数据协议</td></tr></tbody></table><h3 id="2-2-HTTP协议栈中的位置-02-03"><a href="#2-2-HTTP协议栈中的位置-02-03" class="headerlink" title="2-2 HTTP协议栈中的位置 (02:03)"></a>2-2 HTTP协议栈中的位置 (02:03)</h3><p>HTTP协议栈中的位置：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghioyetnj314g0qitb4.jpg" alt="HTTP协议栈中的位置" style="zoom:30%;" /><p>注：</p><ul><li>SSL：安全套接层协议</li><li>TLS：传输层安全性协议</li></ul><p>HTTP与HTTPS网络层区别：</p><ul><li><p>HTTPS是构建在SSL（安全套接层协议）之上的，</p><p>也有构建在TLS（传输层安全性协议）之上；</p></li><li><p>HTTP是构建在TCP（网络控制协议）之上的；</p></li></ul><h3 id="2-3-HTTP协议响应码-08-50"><a href="#2-3-HTTP协议响应码-08-50" class="headerlink" title="2-3 HTTP协议响应码 (08:50)"></a>2-3 HTTP协议响应码 (08:50)</h3><blockquote><p>每一个响应码都代表了服务端反馈的一种响应状态，也标识了本次请求是否成功</p></blockquote><p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">HTTP状态码|菜鸟教程</a></p><ol><li><p>1XX：信息响应类，表示接受到请求并且继续处理（中间状态）</p></li><li><p>2XX：处理成功响应类，表示动作被成功接收、理解和接受</p></li><li><p>3XX：重定向响应类，为了完成指定的动作，必须接受进一步处理</p></li><li><p>4XX：客户端错误，客户请求包含语法错误或者是不能正确执行</p><p>检查请求URL是否正确</p></li><li><p>5XX：服务端错误，服务器不能正确执行一个正确的请求</p><p>必须在测试时解决此类型错误。查看服务器端日志，重启服务</p></li></ol><h3 id="2-4-HTTP协议请求响应模型-16-23"><a href="#2-4-HTTP协议请求响应模型-16-23" class="headerlink" title="2-4 HTTP协议请求响应模型 (16:23)"></a>2-4 HTTP协议请求响应模型 (16:23)</h3><p>HTTP协议请求响应模型：（一次请求的生命周期，最简单的软件分层）</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghipxi3nj30l40kqdgm.jpg" alt="HTTP协议请求响应模型" style="zoom:45%;" /><p>场景：登录</p><ol><li><p>客户端发起请求到API接口层</p><ul><li>用户在客户端填写用户名和密码，点击登录，发送请求</li></ul></li><li><p>API接收到客户端发起的用户请求</p><ul><li><p>API对业务逻辑进行验证</p><p>验证用户名和密码是否合法（例如：用户名要求必须为真实的手机号码。如果验证失败，即用户名不合法，那么需要给客户端返回(自定义)响应码，比如码值为1.2.3，1代表用户名格式错误，2代表用户名或密码错误，3代表密码格式错误）</p></li></ul></li><li><p>API会将用户输入的数据发给DB层（数据库）</p><p>CRUD：Create、Read、Update、Delete</p><ul><li>数据库查询成功返回1，失败返回0</li></ul></li><li><p>DB会将查询数据库的条目数返回给API</p></li><li><p>API返回成功或失败的状态码给客户端</p></li><li><p>客户端将返回信息提示给用户</p></li></ol><p>简单的软件分层：</p><ol><li><p>客户端</p><p>功能测试、性能测试、自动化测试</p></li><li><p>接口层</p><p>接口测试，功能测试、性能测试、自动化测试(更好维护脚本，不涉及页面元素的改变，最多只是接口,数据格式,传输数据内容的改变)</p></li><li><p>数据库层</p><p>可以将开发人员使用到的SQL语句单独拿出来进行性能测试</p></li></ol><h3 id="2-5-常用HTTP请求方式-08-52"><a href="#2-5-常用HTTP请求方式-08-52" class="headerlink" title="2-5 常用HTTP请求方式 (08:52)"></a>2-5 常用HTTP请求方式 (08:52)</h3><p>最常用的HTTP请求方式：</p><ol><li><p>GET请求</p><p>URL：</p><pre><code>http://127.0.0.1:8080?username=zhangsan&amp;password=123456</code></pre></li><li><p>POST请求</p><p>URL：</p><pre><code class="json">http://127.0.0.1:8080</code></pre><p>请求体：</p><pre><code class="json">{  [      &quot;username&quot;: &quot;zhangsan&quot;,      &quot;password&quot;: &quot;123456&quot;  ]}</code></pre></li></ol><p>HTTP请求的方法：</p><blockquote><p>HTTP/1.1协议中共定义了八种请求方法（有时也叫做“动作”），来表明Request-URL指定的资源不同的操作方式</p></blockquote><ol><li><p>OPTIONS</p><p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向Web服务器发送“*”的请求来测试服务器的功能性</p></li><li><p>HEAD</p><p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。</p><p>这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息</p></li><li><p><strong>:star: GET</strong></p><p>向特定的资源发出请求。</p><p>注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。</p></li><li><p><strong>:star: POST</strong></p><p>向指定资源提交数据进行处理请求（例如，提交表单或者上传文件）</p><p>数据被包含在请求体中。</p><p>POST请求可能会导致新资源的建立和/或已有资源的修改</p></li><li><p>PUT</p><p>向指定资源位置上传其最新内容</p></li><li><p>DELETE</p><p>请求服务器删除Request-URL所标识的资源</p></li><li><p>TRACE</p><p>回显服务器所收到的请求，主要用于测试或诊断</p></li><li><p>CONNECT</p><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</p></li></ol><p><strong>注意：</strong></p><ol><li><p>方法名称是区分大小写的。</p><p>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405(Method Not Allowed)；当服务器不认识或者不支持对应的请求方法时，应返回状态码501(Not Implemented)。</p></li><li><p>HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法</p></li></ol><h2 id="第3章-JMeter的get请求介绍及使用"><a href="#第3章-JMeter的get请求介绍及使用" class="headerlink" title="第3章 JMeter的get请求介绍及使用"></a>第3章 JMeter的get请求介绍及使用</h2><blockquote><p>了解jmeter能够做什么；了解get接口运行原理；能够自主开发get请求脚本并且解决乱码问题；能够掌握函数助手的参数化方式；能够掌握线程组中各个选项的意义并能够进行符合业务逻辑的场景设置</p></blockquote><h3 id="3-1-JMeter功能介绍-06-21"><a href="#3-1-JMeter功能介绍-06-21" class="headerlink" title="3-1 JMeter功能介绍 (06:21)"></a>3-1 JMeter功能介绍 (06:21)</h3><p>万能的JMeter</p><ol><li>BS(Browser-Server)架构应用性能(分三层：1.浏览器性能；2.API性能；3.数据库性能测试)</li><li>HTTP协议接口功能与性能</li><li>FTP协议接口功能与性能</li><li>MySQL数据库性能(增删改查脚本测试)</li><li>MongoDB数据库性能(数据量大，较重要的读写功能性能)</li><li><strong>:star: 支持自定义Java组件开发</strong>(JMeter工具的组件不满足是可以开发新的组件，Java代码脚本方便管理)</li></ol><h3 id="3-2-get接口代码开发及原理讲解-11-51"><a href="#3-2-get接口代码开发及原理讲解-11-51" class="headerlink" title="3-2 get接口代码开发及原理讲解 (11:51)"></a>3-2 get接口代码开发及原理讲解 (11:51)</h3><ol><li><p><a href="https://jmeter.apache.org/" target="_blank" rel="noopener">JMeter</a>下载：<a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">https://jmeter.apache.org/download_jmeter.cgi</a></p><p>Windows系统：运行jmeter.bat</p><p>Linux、Mac系统：运行jmeter.sh</p></li><li><p>SpringBoot接口开发</p><p>DemoApplication.java</p><pre><code class="java">@SpringBootApplicationpublic class DemoApplication {    public static void main(String[] args) {        ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class,args);        for (String str : context.getEnvironment().getActiveProfiles()) {            System.out.println(str);        }    }}</code></pre><p>DemoAPI.java</p><pre><code class="java">@RestController@RequestMapping(&quot;/demoAPI&quot;)public class DemoAPI {    // http://127.0.0.1:8080/demoAPI/getDemo/zhangsan    @RequestMapping(value = &quot;/getDemo/{userName}&quot;,method = RequestMethod.GET)    public String getDemo(@PathVariable String userName){        String s = &quot; is pig&quot;;        userName = userName + s;        return &quot;您输入的数据是：&quot; + userName;    }}</code></pre></li></ol><h3 id="3-3-get接口测试及常见乱码问题-24-50"><a href="#3-3-get接口测试及常见乱码问题-24-50" class="headerlink" title="3-3 get接口测试及常见乱码问题 (24:50)"></a>3-3 get接口测试及常见乱码问题 (24:50)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：GET</li><li>Path：/demoAPI/getDemo/zhangsan</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加查看结果树(View Results Tree)：[Thread Group]-[Add]-[Listener]-[View Results Tree]</p></li><li><p>点击绿色小箭头运行访问</p></li><li><p>聚合报告(Aggregate Report)：[Thread Group]-[Add]-[Listener]-[Aggregate Report]</p><p>反应整个测试结果快慢、并发量</p><p>关注指标：Average(平均值)、Error%(错误率)、Throughput(吞吐量)、</p><p>Received KB/sec(接收)、Sent KB/sec(发送)、90%Line(90%百分位)</p></li></ol><p><strong>注</strong>：在真正做测试时应该把[查看结果树(View Result Tree)]去掉，打印日志记录会消耗大量IO、CPU等资源</p><p>:star: 测试并解决请求响应数据乱码：</p><pre><code>http://www.weather.com.cn/data/sk/101010100.htmlhttp://www.weather.com.cn/data/cityinfo/101010100.html</code></pre><ol><li>在Content encoding中设置UTF-8。无效</li><li>打开/bin/jmeter.properties搜索<code>sampleresult.default.encoding=ISO-8859-1</code>，设置为UTF-8。有效</li><li>[Thread Group]-[Add]-[Post Processors]-[BeanShell PostProcessor]-[Script]：<code>prev.setDataEncoding(&quot;UTF-8&quot;)</code>。有效</li></ol><h3 id="3-4-参数化－函数助手-06-12"><a href="#3-4-参数化－函数助手-06-12" class="headerlink" title="3-4 参数化－函数助手 (06:12)"></a>3-4 参数化－函数助手 (06:12)</h3><blockquote><p>意义：数据的多变。</p></blockquote><p>[Tools]-[Function Helper Dialog]-[Choose a function(__CSVRead)]-[Generate &amp; Copy to Clipboard]</p><ul><li><p>输入参数：</p><p>CSV file to get values from | *alias：文件路径</p><p>Column number of CSV file | next | *alias：文件列号，0</p></li><li><p>点击生成：代表某个数值</p><pre><code>${__CSVRead(文件路径, 0)}</code></pre></li><li><p>复制到链接🔗：</p><pre><code>/demoAPI/getDemo/${__CSVRead(文件路径, 0)}</code></pre></li></ul><h3 id="3-5-场景设置（get请求）-06-56"><a href="#3-5-场景设置（get请求）-06-56" class="headerlink" title="3-5 场景设置（get请求） (06:56)"></a>3-5 场景设置（get请求） (06:56)</h3><blockquote><p>场景设置即配置线程组</p></blockquote><p>Thread Properties：</p><ul><li>Number of Threads：线程数</li><li>Ramp-Up Period(in seconds)：每秒当中有多少用户进行访问(加压策略)</li><li>Loop Count：循环次数</li></ul><p>复杂场景需要使用多个线程组</p><h2 id="第4章-JMeter的post请求介绍及使用"><a href="#第4章-JMeter的post请求介绍及使用" class="headerlink" title="第4章 JMeter的post请求介绍及使用"></a>第4章 JMeter的post请求介绍及使用</h2><blockquote><p>学习能够了解post接口开发的原理；能够掌握post接口中map格式的数据传递的访问方式；能够了解json格式传递数据传递的原理；能够掌握post接口中json格式的数据传递的访问方式</p></blockquote><h3 id="4-1-post接口代码开发及原理-07-52"><a href="#4-1-post接口代码开发及原理-07-52" class="headerlink" title="4-1 post接口代码开发及原理 (07:52)"></a>4-1 post接口代码开发及原理 (07:52)</h3><pre><code class="java">// http://127.0.0.1:8080/demoAPI/postDemo/*{  &quot;userName&quot;: &quot;zhangsan&quot;}*/public static int count = 0;@RequestMapping(value = &quot;/postDemo&quot;, method = RequestMethod.POST)public String postDemo(@RequestParam String userName){  count++;  String result = &quot;接口是第&quot; + count + &quot;次被调用,您的用户名是&quot; + userName;  return result;}</code></pre><p>使用POSTMAN工具🔧调用测试接口。</p><h3 id="4-2-接口测试实战－map参数格式-04-55"><a href="#4-2-接口测试实战－map参数格式-04-55" class="headerlink" title="4-2 接口测试实战－map参数格式 (04:55)"></a>4-2 接口测试实战－map参数格式 (04:55)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：POST</li><li>Path：/demoAPI/postDemo</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加参数：[Parameters]-[Add]</p><ul><li>userName：zhangsan</li></ul><p>使用函数助手__CSVRead <code>${CSVRead(文件路径, 0)}</code> 动态获取CSV的数据</p></li><li><p>点击绿色小箭头运行访问</p></li></ol><h3 id="4-3-json格式数据传递接口原理及开发-06-31"><a href="#4-3-json格式数据传递接口原理及开发-06-31" class="headerlink" title="4-3 json格式数据传递接口原理及开发 (06:31)"></a>4-3 json格式数据传递接口原理及开发 (06:31)</h3><pre><code class="java">// http://127.0.0.1:8080/demoAPI/postJson/*{  &quot;name&quot;: &quot;zhangsan&quot;,  &quot;clazz&quot;: &quot;一年一班&quot;}*/public static int count = 0;@ResponseBody@RequestMapping(value = &quot;/postJson&quot;, method = RequestMethod.POST)public String postDemo(@RequestBody Student student){  Student stu = new Student();  stu.setName(student.getName());  stu.setClazz(student.getClazz());  return stu;}</code></pre><pre><code class="java">@Datapublic class Student {  private String name;  private String clazz;}</code></pre><pre><code>Content-Type: application/json</code></pre><h3 id="4-4-json格式post请求实战-05-03"><a href="#4-4-json格式post请求实战-05-03" class="headerlink" title="4-4 json格式post请求实战 (05:03)"></a>4-4 json格式post请求实战 (05:03)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：POST</li><li>Path：/demoAPI/postJson</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加参数：[Body Data]</p><pre><code class="json">{  &quot;name&quot;: &quot;zhangsan&quot;,  &quot;clazz&quot;: &quot;一年一班&quot;}</code></pre><p>使用函数助手__CSVRead <code>${CSVRead(文件路径, 0)}</code> 动态获取CSV的数据</p></li><li><p>添加HTTP信息头管理器：[Thread Group]-[Add]-[Config Element]-[HTTP Header Manager]-[Add]</p><ul><li>Content-Type：application/json</li></ul></li><li><p>点击绿色小箭头运行访问</p></li></ol><h2 id="第5章-JMeter之接口性能测试-课程总结"><a href="#第5章-JMeter之接口性能测试-课程总结" class="headerlink" title="第5章 JMeter之接口性能测试-课程总结"></a>第5章 JMeter之接口性能测试-课程总结</h2><blockquote><p>掌握本次课程的所有重点内容，能够独立进行接口测试</p></blockquote><h3 id="5-1-课程总结-03-31"><a href="#5-1-课程总结-03-31" class="headerlink" title="5-1 课程总结 (03:31)"></a>5-1 课程总结 (03:31)</h3><ol><li>常见的接口协议（HTTP协议、FTP协议）</li><li>HTTP协议响应码</li><li>HTTP协议响应模型（HTTP生命周期）</li><li>GET请求的开发与测试</li><li>POST请求的开发与测试</li><li>场景设置（配置线程组信息）</li><li>参数化（函数助手参数化、外部文件参数化）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>889-ElasticSearch入门</title>
      <link href="/2019/08/13/889-ElasticSearch/"/>
      <url>/2019/08/13/889-ElasticSearch/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/889" target="_blank" rel="noopener">https://www.imooc.com/learn/889</a></p><p>简介：ElasticSearch是一个分布式、可扩展、实时的搜索与数据分析引擎，它能从项目一开始就赋予你的数据以搜索、分析和探索的能力。通过本课程的学习，你可以了解到，ElasticSearch在互联网行业里的火热程度，也可以了解到它的实际应用场景。本课程会通过理论与实践相结合的方式，带领你一步一步走进ElasticSearch的世界，使你轻松掌握ElasticSearch的基本概念，学习ElasticSearch的服务搭建，了解ElasticSearch的常用技巧，并通过案例项目让你拥有实际的应用能力。 老师实战课程已经上线：<a href="http://coding.imooc.com/class/167.html" target="_blank" rel="noopener">http://coding.imooc.com/class/167.html</a> ElasticSearch+MySQL+Kafka强力组合，更有ES结合百度地图，Nginx等高级应用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>介绍Elastic Search的由来，应用场景，课程需要的前置知识，环境要求，介绍课程安排</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title=" 1-1 课程介绍"></a><a href="https://www.imooc.com/video/15762" target="_blank" rel="noopener"> 1-1 课程介绍</a></h3><p>什么是ElasticSearch？</p><ul><li><p>基于Apache Lucene构建的开源搜索引擎</p><p>Lucene相对复杂，需要深厚的搜索理论知识，难以集成</p></li><li><p>采用Java编写，提供简单易用的RESTFul API</p></li><li><p>轻松的横向扩展，可支持PB级的结构化或非结构化 数据处理</p></li></ul><p>应用场景：</p><ul><li>海量数据分析引擎</li><li>站内搜索引擎</li><li>数据仓库</li></ul><p>一线公司实际应用场景：</p><ul><li>英国卫报-实时分析公众对文章的回应</li><li>维基百科、Github-站内实时搜索</li><li>百度-实时日志监控平台</li><li>阿里巴巴、Google、京东等等</li></ul><p>前置知识</p><ul><li>熟悉用Maven构建项目</li><li>了解Spring Boot的基本使用</li></ul><p>环境要求：</p><ul><li>IDE工具：Intellij IDEA、Eclipse等常用IDE即可</li><li>Java：JDK1.8</li><li>其他依赖：Maven、NodeJS(6.0以上)</li></ul><p>课程简介：</p><ul><li>安装=》基础概念=》基本用法=》高级查询=》实战演练=》课程总结</li></ul><h2 id="第2章-安装"><a href="#第2章-安装" class="headerlink" title="第2章 安装"></a>第2章 安装</h2><blockquote><p>先从单个节点的安装讲起，然后把插件安装流程走一遍，并说一下插件的主要作用，最后把分布式安装简单的介绍一下</p></blockquote><h3 id="2-1-ES版本历史和选择"><a href="#2-1-ES版本历史和选择" class="headerlink" title=" 2-1 ES版本历史和选择"></a><a href="https://www.imooc.com/video/15763" target="_blank" rel="noopener"> 2-1 ES版本历史和选择</a></h3><ul><li>版本历史 1.x -&gt; 2.x -&gt; 5.x</li><li>版本选择 5.x以上</li></ul><p>安装</p><ul><li>单实例安装</li><li>实用插件Head安装</li><li>分布式安装</li></ul><h3 id="2-2-单实例安装"><a href="#2-2-单实例安装" class="headerlink" title=" 2-2 单实例安装"></a><a href="https://www.imooc.com/video/15764" target="_blank" rel="noopener"> 2-2 单实例安装</a></h3><blockquote><p><a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">ElasticSearch官网首页</a> </p></blockquote><pre><code class="shell"># 下载wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.3.1-linux-x86_64.tar.gz# 解压tar -zvxf elasticsearch-7.3.1-linux-x86_64.tar.gz# 进入HOME目录cd elasticsearch-7.3.1-linux-x86_64# 运行ElasticSearch程序sh ./bin/elasticsearch# 获取ElasticSearch服务信息curl http://localhost:9200/</code></pre><h3 id="2-3-插件安装"><a href="#2-3-插件安装" class="headerlink" title=" 2-3 插件安装"></a><a href="https://www.imooc.com/video/15765" target="_blank" rel="noopener"> 2-3 插件安装</a></h3><blockquote><p><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">Github主页</a></p></blockquote><pre><code class="shell"># 下载wget https://github.com/mobz/elasticsearch-head/archive/master.zip# 解压unzip master.zip# 进入HOME目录cd elasticsearch-head-master# 编译源码npm install# 运行程序npm run start# 访问服务地址open http://localhost:9100/</code></pre><ul><li><p>修改ElasticSearch配置</p><pre><code class="shell">vim config/elasticsearch.yml</code></pre><pre><code class="yaml">http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p>重启ElasticSearch、Head</p></li></ul><h3 id="2-4-分布式安装"><a href="#2-4-分布式安装" class="headerlink" title=" 2-4 分布式安装"></a><a href="https://www.imooc.com/video/15766" target="_blank" rel="noopener"> 2-4 分布式安装</a></h3><p>修改ElasticSearch配置</p><ul><li><p>主节点：</p><pre><code class="shell">vim config/elasticsearch.yml# -import ~~master~~# 查看进程ps -ef | grep `pwd`# 后台启动ElasticSearch./bin/elasticsearch -d</code></pre><pre><code class="yaml"># ~~master~~cluster.name: walinode.name: masternode.master: truenetwork.host: 127.0.0.1</code></pre></li><li><p>从节点</p><pre><code class="shell"># 创建子节点目录mkdir es_slave# 拷贝ElasticSearchcp elasticsearch-7.3.1-linux-x86_64.tar.gz es_slave# 解压tar -zvxf elasticsearch-7.3.1-linux-x86_64.tar.gz# 复制两份子节点程序cp -r elasticsearch-7.3.1-linux-x86_64 es_slave1cp -r elasticsearch-7.3.1-linux-x86_64 es_slave2cd es_slave1vi config/elasticsearch.yml# -import ~~es_slave1~~# 后台启动ElasticSearch./bin/elasticsearch -dcd es_slave2vi config/elasticsearch.yml# -import ~~es_slave2~~# 后台启动ElasticSearch./bin/elasticsearch -d</code></pre><pre><code class="yaml"># ~~es_slave1~~cluster.name: walinode.name: slave1network.host: 127.0.0.1http.port: 8001</code></pre><pre><code class="yaml"># ~~es_slave2~~cluster.name: walinode.name: slave2network.host: 127.0.0.1http.port: 8002</code></pre></li></ul><h2 id="第3章-基础概念"><a href="#第3章-基础概念" class="headerlink" title="第3章 基础概念"></a>第3章 基础概念</h2><blockquote><p>结合Head插件，简单的讲解集群、节点的概念，重点讲解索引及其重要性，分片和备份属于索引的附属概念，一笔带过，类型、文档简单讲解下，并将索引、类型、文档三者的关系讲解清楚</p></blockquote><h3 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title=" 3-1 基础概念"></a><a href="https://www.imooc.com/video/15767" target="_blank" rel="noopener"> 3-1 基础概念</a></h3><p>集群和节点：</p><ul><li>节点1+节点2+…+…+节点N ==》集群</li></ul><p>基础概念</p><ul><li><p>索引：含有相同属性的文档集合</p></li><li><p>类型：索引可以定义一个或多个类型，文档必须属于一个类型</p></li><li><p>文档：文档是可以被索引的基本数据单位</p></li><li><p>分片：每个索引都有多个分片，每个分片是一个Lucene索引</p></li><li><p>备份：拷贝一份分片就可以完成了分片的备份</p></li></ul><h2 id="第4章-基本用法"><a href="#第4章-基本用法" class="headerlink" title="第4章 基本用法"></a>第4章 基本用法</h2><blockquote><p>本章节主要带领学生一起学习ElasticSearch的基本使用方法，并了解常用的REST API，讲解过程中要将命令行与head插件相结合以演示相应操作。</p></blockquote><h3 id="4-1-索引创建"><a href="#4-1-索引创建" class="headerlink" title=" 4-1 索引创建"></a><a href="https://www.imooc.com/video/15768" target="_blank" rel="noopener"> 4-1 索引创建</a></h3><blockquote><ul><li>非结构化创建</li><li>结构化创建</li></ul></blockquote><p>RESTFul API：</p><ul><li><p>API基本格式</p><pre><code>http://&lt;ip&gt;:&lt;port&gt;/&lt;索引&gt;/&lt;类型&gt;/&lt;文档ID&gt;</code></pre></li><li><p>常用HTTP动词：GET/PUT/POST/DELETE</p></li></ul><p>Head插件创建索引（非结构化）：</p><ol><li><p>访问Head服务地址：<a href="http://127.0.0.1:9100" target="_blank" rel="noopener">http://127.0.0.1:9100</a></p></li><li><p>索引-新建索引</p></li><li><p>概览</p><p>粗线框为主分片，旁边细线框为分片备份</p></li></ol><p>Head插件创建索引（结构化）：</p><ol><li><p>复合查询-查询</p></li><li><p>参数信息</p><pre><code>http://127.0.0.1:9200/book/novel/_mappings POST</code></pre><pre><code class="json">{    &quot;novel&quot;: {        &quot;properties&quot;: {            &quot;title&quot;:{                &quot;type&quot;: &quot;text&quot;            }        }    }}</code></pre></li><li><p>验证JSON-提交请求</p></li><li><p>概览-刷新-信息-索引信息-mappings</p></li></ol><p>Postman创建索引</p><ol><li><pre><code>PUT http://127.0.0.1:9200/people</code></pre></li><li><pre><code>{    &quot;settings&quot;: {        &quot;number_of_shards&quot;: 3,        &quot;number_of_replicas&quot;: 1    },    &quot;mappings&quot;: {        &quot;man&quot;: {            &quot;properties&quot;: {                &quot;name&quot;: {&quot;type&quot;: &quot;text&quot;},                &quot;country&quot;: {&quot;type&quot;: &quot;keyword&quot;},                &quot;age&quot;: {                    &quot;type&quot;: &quot;integer&quot;                },                &quot;date&quot;: {                    &quot;type&quot;: &quot;date&quot;,                    &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;                }            }        },        &quot;woman&quot;: {        }    }}</code></pre></li></ol><h3 id="4-2-插入"><a href="#4-2-插入" class="headerlink" title=" 4-2 插入"></a><a href="https://www.imooc.com/video/15769" target="_blank" rel="noopener"> 4-2 插入</a></h3><blockquote><ul><li>指定文档ID插入</li><li>自动产生文档ID插入</li></ul></blockquote><p>文档ID：唯一索引值，指向文档数据</p><p>指定文档ID插入：</p><ol><li><pre><code>PUT http://127.0.0.1:9200/people/man/1</code></pre></li><li><pre><code class="json">{    &quot;name&quot;: &quot;瓦力&quot;, &quot;country&quot;: &quot;China&quot;,    &quot;age&quot;: 30,    &quot;date&quot;: &quot;1987-03-07&quot;}</code></pre></li><li><p>概览-docs：索引下所有文档的数量值</p></li><li><p>数据浏览</p></li></ol><p>自动产生文档ID插入：</p><ol><li><pre><code>POST http://127.0.0.1:9200/people/man</code></pre></li><li><pre><code class="json">{    &quot;name&quot;: &quot;瓦力&quot;,    &quot;country&quot;: &quot;China&quot;,    &quot;age&quot;: 30,    &quot;date&quot;: &quot;1987-03-07&quot;}</code></pre></li></ol><h3 id="4-3-修改"><a href="#4-3-修改" class="headerlink" title=" 4-3 修改"></a><a href="https://www.imooc.com/video/15770" target="_blank" rel="noopener"> 4-3 修改</a></h3><blockquote><ul><li>直接修改文档</li><li>脚本修改文档</li></ul></blockquote><p>直接修改文档</p><ol><li><pre><code>POST http://127.0.0.1:9200/people/man/1/_update</code></pre></li><li><pre><code class="json">{    &quot;doc&quot;: {        &quot;name&quot;: &quot;谁是瓦力&quot;    }}</code></pre></li></ol><p>脚本修改文档</p><ol><li><pre><code>POST http://127.0.0.1:9200/people/man/1/_update</code></pre></li><li><pre><code class="json">{    &quot;script&quot;: {        &quot;lang&quot;: &quot;painless&quot;,        &quot;inline&quot;: &quot;ctx._source.age += 10&quot;    }}</code></pre><pre><code class="json">{    &quot;script&quot;: {        &quot;lang&quot;: &quot;painless&quot;,        &quot;inline&quot;: &quot;ctx._source.age += params.age&quot;,        &quot;params&quot;: {            &quot;age&quot;: 100        }    }}</code></pre></li></ol><h3 id="4-4-删除"><a href="#4-4-删除" class="headerlink" title=" 4-4 删除"></a><a href="https://www.imooc.com/video/15771" target="_blank" rel="noopener"> 4-4 删除</a></h3><blockquote><ul><li>删除文档</li><li>删除索引</li></ul></blockquote><p>删除文档</p><pre><code>DELETE http://127.0.0.1:9200/people/man/1</code></pre><p>删除索引</p><ul><li><p>Head插件删除</p><p>概览-动作-删除-输入删除-确定</p></li><li><p>Postman删除</p><pre><code>DELETE http://127.0.0.1:9200/people</code></pre></li></ul><p>删除索引是一个非常危险的操作。</p><h3 id="4-5-查询"><a href="#4-5-查询" class="headerlink" title=" 4-5 查询"></a><a href="https://www.imooc.com/video/15772" target="_blank" rel="noopener"> 4-5 查询</a></h3><blockquote><ul><li>简单查询</li><li>条件查询</li><li>聚合查询</li></ul></blockquote><p>事先创建索引book：</p><pre><code>PUT http://127.0.0.1:9200/book</code></pre><pre><code class="json">{    &quot;settings&quot;: {        &quot;number_of_shards&quot;: 3,        &quot;number_of_replicas&quot;: 1    },    &quot;mappings&quot;: {        &quot;novel&quot;: {            &quot;properties&quot;: {                &quot;word_count&quot;: {                    &quot;type&quot;: &quot;integer&quot;                },                &quot;author&quot;: {                    &quot;type&quot;: &quot;keyword&quot;                },                &quot;title&quot;: {                    &quot;type&quot;: &quot;text&quot;                },                &quot;publish_date&quot;: {                    &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;,                    &quot;type&quot;: &quot;date&quot;                }            }        }    }}</code></pre><p>插入数据：</p><pre><code>PUT http://127.0.0.1:9200/book/novel/1</code></pre><pre><code class="json">{    &quot;word_count&quot;: &quot;5000&quot;,    &quot;author&quot;: &quot;王五&quot;,    &quot;title&quot;: &quot;菜谱&quot;,    &quot;publish_date&quot;: &quot;2002-10-01&quot;}</code></pre><p>book novel 5  1 王五 菜谱                    5000  2002-10-01<br>book novel 8  1 瓦力 ElasticSearch入门       3000  2017-08-20<br>book novel 9  1 很胖的瓦力 ElasticSearch精通 3000  2017-08-15<br>book novel 10 1 牛魔王 芭蕉扇                1000  2000-10-01<br>book novel 2  1 李三 Java入门                2000  2010-10-01<br>book novel 4  1 李四 ElasticSearch大法好     1000  2017-08-01<br>book novel 6  1 赵六 剑谱                    10000 1997-01-01<br>book novel 1  1 张三 移魂大法                1000  2000-10-01<br>book novel 7  1 张三丰 太极拳                1000  1997-01-01<br>book novel 3  1 张四 Python入门              2000  2005-10-01<br>book novel 11 1 孙悟空 七十二变              1000  2000-10-01</p><p>简单查询：</p><pre><code>GET http://127.0.0.1:9200/book/novel/1</code></pre><p>条件查询：</p><ul><li><p>查询所有</p><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;match_all&quot;: {}    },    &quot;form&quot;: 1,    &quot;size&quot;: 1}</code></pre><p>关键词查询</p><pre><code class="json">{    &quot;query&quot;: {        &quot;match&quot;: {            &quot;title&quot;: &quot;ElasticSearch&quot;        }    },    &quot;sort&quot;: [        {&quot;publish_date&quot;: {&quot;order&quot;: &quot;desc&quot;}}    ]}</code></pre></li><li><p>条件查询</p><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;aggs&quot;: {        &quot;group_by_word_count&quot;: {            &quot;terms&quot;: {                &quot;field&quot;: &quot;word_count&quot;            }        },        &quot;group_by_publish_date&quot;: {            &quot;terms&quot;: {                &quot;field&quot;: &quot;publish_date&quot;            }        }    }}</code></pre></li><li><p>聚合查询</p><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;aggs&quot;: {        &quot;grades_word_count&quot;: {            &quot;stats&quot;: {                &quot;field&quot;: word_count            }        }    }}</code></pre><pre><code class="json">{    &quot;aggs&quot;: {        &quot;grades_word_count&quot;: {            &quot;min&quot;: {                &quot;field&quot;: word_count            }        }    }}</code></pre></li></ul><h2 id="第5章-高级查询"><a href="#第5章-高级查询" class="headerlink" title="第5章 高级查询"></a>第5章 高级查询</h2><blockquote><p>将query与filter分开讲解，并把相应的关键词列举一些，结合实例操作，最后将query与filter组合起来，讲解实例</p></blockquote><h3 id="5-1-query"><a href="#5-1-query" class="headerlink" title=" 5-1 query"></a><a href="https://www.imooc.com/video/15759" target="_blank" rel="noopener"> 5-1 query</a></h3><p>高级查询：</p><ul><li>子条件查询：特定字段查询所指特定值</li><li>复合条件查询：以一定的逻辑组合子条件查询</li></ul><p>子条件查询</p><ul><li>Query context</li><li>Filter context</li></ul><p>Query Context</p><blockquote><p>在查询过程中，除了判断文档是否满足查询条件外，ES还会计算一个_score来标识匹配的程度，旨在判断目标文档和查询条件匹配的有多好。</p></blockquote><p>常用查询：</p><ul><li>全文本查询：针对文本类型数据</li><li>字段级别查询：针对结构化数据，如数字、日期等</li></ul><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><ul><li><p>模糊匹配(匹配：ElasticSearch+入门)</p><pre><code class="json">{    &quot;query&quot;: {        &quot;match&quot;: {            &quot;title&quot;: &quot;ElasticSearch入门&quot;        }    }}</code></pre></li><li><p>习语匹配(匹配：ElasticSearch入门)</p><pre><code class="json">{    &quot;query&quot;: {        &quot;match_phrase&quot;: {            &quot;title&quot;: &quot;ElasticSearch入门&quot;        }    }}</code></pre></li><li><p>多字段模糊匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;multi_match&quot;: {            &quot;query&quot;: &quot;瓦力&quot;,            &quot;fields&quot;: [&quot;author&quot;, &quot;title&quot;]        }    }}</code></pre></li><li><p>语法匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;query_string&quot;: {            &quot;query&quot;: &quot;ElasticSearch AND 大法&quot;        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;query_string&quot;: {            &quot;query&quot;: &quot;(ElasticSearch AND 大法) OR Python&quot;        }    }}</code></pre></li><li><p>多字段语法匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;query_string&quot;: {            &quot;query&quot;: &quot;瓦力 OR ElasticSearch&quot;,            &quot;fields&quot;: [&quot;title&quot;, &quot;author&quot;]        }    }}</code></pre></li><li><p>字段匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;term&quot;: {            &quot;word_count&quot;: 1000        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;term&quot;: {            &quot;author&quot;: &quot;瓦力&quot;        }    }}</code></pre></li><li><p>范围匹配（数字、日期）</p><pre><code class="json">{    &quot;query&quot;: {        &quot;range&quot;: {            &quot;word_count&quot;: {                &quot;gte&quot;: 1000,                &quot;lte&quot;: 2000            }        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;range&quot;: {            &quot;publish_date&quot;: {                &quot;gt&quot;: &quot;2019-08-29&quot;,                &quot;lte&quot;: &quot;now&quot;            }        }    }}</code></pre><p>now：代表当前时间</p></li></ul><h3 id="5-2-filter"><a href="#5-2-filter" class="headerlink" title=" 5-2 filter"></a><a href="https://www.imooc.com/video/15760" target="_blank" rel="noopener"> 5-2 filter</a></h3><p>Filter Context</p><blockquote><p>在查询过程中，只判断该文档是否满足条件，只有Yes或者No</p></blockquote><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;filter&quot;: {                &quot;term&quot;: {                    &quot;word_count&quot;: 1000                }            }        }    }}</code></pre><p>filter做数据过滤的，并且会对查询结果进行缓存，所以filter比query要快一些。</p><h3 id="5-3-复合查询"><a href="#5-3-复合查询" class="headerlink" title=" 5-3 复合查询"></a><a href="https://www.imooc.com/video/15761" target="_blank" rel="noopener"> 5-3 复合查询</a></h3><p>常用查询：</p><ul><li>固定分数查询</li><li>布尔查询</li></ul><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;match&quot;: {            &quot;title&quot;: &quot;ElasticSearch&quot;        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;constant_score&quot;: {            &quot;filter&quot;: {                &quot;match&quot;: {                    &quot;title&quot;: &quot;ElasticSearch&quot;                }            },            &quot;boost&quot;: 2        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;should&quot;: [                {                    &quot;match&quot;: {                        &quot;author&quot;: &quot;瓦力&quot;                    }                },                {                    &quot;match&quot;: {                        &quot;title&quot;: &quot;ElasticSearch&quot;                    }                }            ]        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;must&quot;: [                {                    &quot;match&quot;: {                        &quot;author&quot;: &quot;瓦力&quot;                    }                },                {                    &quot;match&quot;: {                        &quot;title&quot;: &quot;ElasticSearch&quot;                    }                }            ],            &quot;filter&quot;: [                {                    &quot;term&quot;: {                        &quot;word_count&quot;: 1000                    }                }            ]        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;must_not&quot;: {                &quot;term&quot;: {                    &quot;author&quot;: &quot;瓦力&quot;                }            }        }    }}</code></pre><p>固定分数查询不支持match，只支持filter</p><h2 id="第6章-Spring-Boot集成ES"><a href="#第6章-Spring-Boot集成ES" class="headerlink" title="第6章 Spring Boot集成ES"></a>第6章 Spring Boot集成ES</h2><blockquote><p>直接演示SpringBoot集成ES，做接口开发</p><p>以下使用ElasticSearch7.3.1做演示</p></blockquote><h3 id="6-1-SpringBoot集成ElasticSearch"><a href="#6-1-SpringBoot集成ElasticSearch" class="headerlink" title=" 6-1 SpringBoot集成ElasticSearch"></a><a href="https://www.imooc.com/video/15758" target="_blank" rel="noopener"> 6-1 SpringBoot集成ElasticSearch</a></h3><p>实战演练：</p><ul><li>Spring Boot集成ES</li><li>图书信息管理接口开发</li></ul><p>Pom.xml</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch-rest-client-sniffer&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置Spring Bean</p><pre><code class="java">@Configurationpublic class ESConfig {    @Bean    public RestHighLevelClient client() throws UnknownHostException {        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(                        new HttpHost(&quot;127.0.0.1&quot;, 9200, &quot;http&quot;)));        return client;    }}</code></pre><p>ESController</p><pre><code class="java">@RestController@RequestMapping(&quot;/novel&quot;)public class ESController {  @Autowired  private RestHighLevelClient client;  // todo }</code></pre><p>运行</p><pre><code class="shell">mvn spring-boot:run</code></pre><h3 id="6-2-查询接口开发"><a href="#6-2-查询接口开发" class="headerlink" title=" 6-2 查询接口开发"></a><a href="https://www.imooc.com/video/15773" target="_blank" rel="noopener"> 6-2 查询接口开发</a></h3><p>接口开发：</p><ul><li>新增图书信息功能开发</li><li>修改图书信息功能开发</li><li>删除功能开发</li><li>综合查询接口开发</li></ul><pre><code class="java">@GetMapping(&quot;/{id}&quot;)public ResponseEntity get(@PathVariable(name = &quot;id&quot;) String id) {  if (id.isEmpty()) {    return new ResponseEntity(HttpStatus.NOT_FOUND);  }  GetRequest novelRequest = new GetRequest(&quot;novel&quot;, id);  try {    GetResponse novelResponse = this.client.get(novelRequest, RequestOptions.DEFAULT);    if (novelResponse.isExists()) {      System.out.println(novelResponse);      return new ResponseEntity(novelResponse.getSource(), HttpStatus.OK);    }  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }  return new ResponseEntity(HttpStatus.NOT_FOUND);}</code></pre><p>运行：</p><pre><code class="shell">mvn spring-boot:runGET http://127.0.0.1:8080/novel/1</code></pre><h3 id="6-3-增加接口开发"><a href="#6-3-增加接口开发" class="headerlink" title=" 6-3 增加接口开发"></a><a href="https://www.imooc.com/video/15775" target="_blank" rel="noopener"> 6-3 增加接口开发</a></h3><pre><code class="java">@PostMapping(&quot;&quot;)public ResponseEntity add(@RequestBody Novel novel) {  try {    Gson gson = new Gson();    Map novelMap = gson.fromJson(gson.toJson(novel), Map.class);    IndexRequest novelRequest = new IndexRequest(&quot;novel&quot;).id(UUID.randomUUID().toString()).source(novelMap);    IndexResponse novelResponse = this.client.index(novelRequest, RequestOptions.DEFAULT);    System.out.println(novelResponse);    return new ResponseEntity(novelResponse.getId(), HttpStatus.OK);  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }}</code></pre><pre><code class="java">@Datapublic class Novel {    private String title;    private String author;    @JsonProperty(value = &quot;word_count&quot;)    private String wordCount;    @JsonProperty(value = &quot;publish_date&quot;)    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)    private Date publishDate;}</code></pre><p>运行</p><pre><code>POST http://127.0.0.1:8080/novel</code></pre><pre><code class="json">{    &quot;title&quot;: &quot;大话西游&quot;,    &quot;author&quot;: &quot;刘镇伟&quot;,    &quot;word_count&quot;: &quot;1008&quot;,    &quot;publish_date&quot;: &quot;2019-09-08&quot;}</code></pre><h3 id="6-4-删除接口开发"><a href="#6-4-删除接口开发" class="headerlink" title=" 6-4 删除接口开发"></a><a href="https://www.imooc.com/video/15774" target="_blank" rel="noopener"> 6-4 删除接口开发</a></h3><pre><code class="java">@DeleteMapping(&quot;/{id}&quot;)public ResponseEntity delete(@PathVariable(name = &quot;id&quot;) String id) {  DeleteRequest novelRequest = new DeleteRequest(&quot;novel&quot;, id);  try {    DeleteResponse novelResponse = this.client.delete(novelRequest, RequestOptions.DEFAULT);    System.out.println(novelResponse);    return new ResponseEntity(novelResponse.getResult().toString(),HttpStatus.OK);  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }}</code></pre><p>运行</p><pre><code>DELETE http://127.0.0.1:8080/novel/1</code></pre><h3 id="6-5-更新接口开发"><a href="#6-5-更新接口开发" class="headerlink" title=" 6-5 更新接口开发"></a><a href="https://www.imooc.com/video/15776" target="_blank" rel="noopener"> 6-5 更新接口开发</a></h3><pre><code class="java">@PutMapping(&quot;/{id}&quot;)public ResponseEntity update(@PathVariable(name = &quot;id&quot;) String id, @RequestBody Novel novel) {  try {    Gson gson = new Gson();    Map map = gson.fromJson(gson.toJson(novel), Map.class);    UpdateRequest novelRequest = new UpdateRequest(&quot;novel&quot;, id).doc(map);    UpdateResponse novelResponse = this.client.update(novelRequest, RequestOptions.DEFAULT);    System.out.println(novelResponse);    return new ResponseEntity(novelResponse.getResult().toString(), HttpStatus.OK);  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }}</code></pre><p>运行</p><pre><code>PUT http://127.0.0.1:8080/novel/1</code></pre><pre><code class="json">{    &quot;title&quot;: &quot;大话西游&quot;,    &quot;author&quot;: &quot;刘镇伟&quot;,    &quot;word_count&quot;: &quot;1008&quot;,    &quot;publish_date&quot;: &quot;2019-09-08&quot;}</code></pre><h3 id="6-6-复合查询接口开发"><a href="#6-6-复合查询接口开发" class="headerlink" title=" 6-6 复合查询接口开发"></a><a href="https://www.imooc.com/video/15777" target="_blank" rel="noopener"> 6-6 复合查询接口开发</a></h3><pre><code class="java">@GetMapping(&quot;&quot;)public ResponseEntity query(@RequestParam(value = &quot;author&quot;, required = false) String author,                            @RequestParam(value = &quot;title&quot;, required = false) String title,                            @RequestParam(value = &quot;gt_word_count&quot;, defaultValue = &quot;0&quot;) Integer gtWordCount,                            @RequestParam(value = &quot;lt_word_count&quot;, required = false) Integer ltWordCount) {    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();    if (author != null) {        boolQueryBuilder.must(QueryBuilders.matchQuery(&quot;author&quot;, author));    }    if (title != null) {        boolQueryBuilder.must(QueryBuilders.matchQuery(&quot;title&quot;, title));    }    RangeQueryBuilder wordCountRangeQuery = QueryBuilders.rangeQuery(&quot;word_count&quot;)            .from(gtWordCount);    if (ltWordCount != null &amp;&amp; 0 &lt; ltWordCount) {        wordCountRangeQuery.to(ltWordCount);    }    boolQueryBuilder.filter(wordCountRangeQuery);    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()            .query(boolQueryBuilder)            .from(0)            .size(10);    SearchRequest novelSearchRequest = new SearchRequest(&quot;novel&quot;)            .source(searchSourceBuilder)            .searchType(SearchType.DFS_QUERY_THEN_FETCH);    System.out.println(novelSearchRequest.source());    try {        SearchResponse novelSearchResponse = this.client.search(novelSearchRequest, RequestOptions.DEFAULT);        System.out.println(novelSearchResponse);        ArrayList&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;&gt;();        novelSearchResponse.getHits().forEach(e -&gt; {            result.add(e.getSourceAsMap());        });        return new ResponseEntity(result, HttpStatus.OK);    } catch (IOException e) {        e.printStackTrace();        return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);    }}</code></pre><h2 id="第7章-课程总结"><a href="#第7章-课程总结" class="headerlink" title="第7章 课程总结"></a>第7章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="7-1-课程总结"><a href="#7-1-课程总结" class="headerlink" title=" 7-1 课程总结"></a><a href="https://www.imooc.com/video/15757" target="_blank" rel="noopener"> 7-1 课程总结</a></h3><ol><li><p>ES简介</p><p>ES使用场景例子</p><p>ES的火热程度-重要性</p></li><li><p>安装</p><p>ES使用插件HEAD</p><p>ES分布式安装，实现了ES的横向扩容</p></li><li><p>基础概念</p></li><li><p>基本用法</p><p>增删查改功能</p></li><li><p>高级查询</p></li><li><p>实战演练</p><p>将ES集成到SpringBoot</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>951-MyCAT入门及应用</title>
      <link href="/2019/07/09/951-MyCat/"/>
      <url>/2019/07/09/951-MyCat/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/951" target="_blank" rel="noopener">https://www.imooc.com/learn/951</a></p><p>简介：本课程从实际生产环境应用MyCAT入手，讲解MyCAT的基础知识和MyCAT的基本应用操作，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>本章节主要介绍课程结构</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>学习目的：</p><ul><li>掌握在数据库负载增大时的处理方法</li><li>理解MyCat的基础概念（分库、分表、逻辑库、逻辑表）</li><li>掌握MyCat的基础配置和监控方法</li></ul><h2 id="第2章-MyCAT介绍"><a href="#第2章-MyCAT介绍" class="headerlink" title="第2章 MyCAT介绍"></a>第2章 MyCAT介绍</h2><blockquote><p>本章节主要介绍MyCAT的主要应用场景和优势，用来帮助大家了解MyCAT具体应用在什么样的生产环境中。</p></blockquote><h3 id="2-1-MyCAT前世今生"><a href="#2-1-MyCAT前世今生" class="headerlink" title="2-1 MyCAT前世今生"></a>2-1 MyCAT前世今生</h3><p>阿里开源数据库中间件产品：</p><ul><li><p>2008年：Amoeba。</p><p>阿里使用多台MySQL数据库来替代Oracle数据库</p><p>充当MySQL分布式数据库中间层，主要应用在访问层，充当应用程序与数据库之间的代理</p><p>具有负载均衡、高可用、SQL过滤，支持对后端数据库的读写分离</p></li><li><p>2012年：Cobar</p><p>应用3000+台服务器的集群规模</p><p>明天可处理超过10亿的数据库访问</p></li><li><p>2013年：MyCat</p><p>解决了Cobar在高并发的情况下假死</p><p>前后端的……并不是统一的</p></li></ul><h3 id="2-2-MyCAT的主要功能"><a href="#2-2-MyCAT的主要功能" class="headerlink" title="2-2 MyCAT的主要功能"></a>2-2 MyCAT的主要功能</h3><p>MyCat的主要作用：</p><ul><li><p>实现了MySQL通信协议的<strong>分布式数据库系统中间层</strong></p><p>数据库中间层：在架构中的位置，位于前端应用和后端数据库之间的一个应用软件</p><p>数据库中间层：作用，读写分离、负载均衡、数据库连接池（统一控制数据库的连接数量）、屏蔽后端数据库的变更、连接多种类型数据库（如MSSQL、MongoDB等<strong>包括非关系型数据库</strong>）</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gief3798j30hm07cq3l.jpg"  width="350" alt="分布式数据库系统中间层"/></li><li><p>实现数据库的读写分离</p><p>MySQL主从复制集群（写操作在主数据库中执行、读操作在从数据库中执行）</p><p>主从复制实现原理</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gieg9chlj307x09x3yo.jpg"  width="200" alt="数据库的读写分离"/><p>MyCat支持读数据库的负载均衡</p><p>这种情况多出现在一主多从的架构上，将读负载在多个服务器上进行负载均衡</p></li></ul><p>  MyCat支持后端MySQL高可用</p><p>  此处的高可用不同于通过MHA和3M方式复制架构来实现的高可用。在MHA和3M架构中，当主节点宕机之后是可以自动从多个从节点中选择一个新的主节点，并且将其他从节点对这个新的主节点重新进行同步。</p><p>  MyCat对后端数据库的高可用是指，在配置的时候，除了主节点之外，可以指定从节点，实现写操作。当主节点宕机之后，MyCat会把写的SQL路由到配置的写从节点上，并且不支持把其他的从节点对新节点进行主从同步。</p><ul><li><p>数据库垂直拆分</p><p>垂直切蛋糕…</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giegt6poj30jy08h0tk.jpg"  width="400" alt="数据库垂直拆分"/></li><li><p>数据库水平拆分（分库、分表）</p><p>水平切蛋糕…</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giefdedqj30ml08g75d.jpg"  width="430" alt="数据库水平拆分"/><p>将一个数据库通过一定规则进行切分成多个数据库。比如，对userId取模来进行切分，将user表均匀的分到三个数据库中（三个库的表结构是完全一致的）。</p><p>前端应用通过MyCat以及切分规则来对切分后的数据库进行访问。</p><p>MyCat统一实现了切分逻辑，而不同在前端应用中实现切分逻辑。</p></li></ul><h3 id="2-3-MyCAT的主要功能"><a href="#2-3-MyCAT的主要功能" class="headerlink" title="2-3 MyCAT的主要功能"></a>2-3 MyCAT的主要功能</h3><p>见【2-2 MyCAT的主要功能】</p><h3 id="2-4-MyCAT的主要功能"><a href="#2-4-MyCAT的主要功能" class="headerlink" title="2-4 MyCAT的主要功能"></a>2-4 MyCAT的主要功能</h3><p>见【2-2 MyCAT的主要功能】</p><h3 id="2-5-MyCAT的应用场景"><a href="#2-5-MyCAT的应用场景" class="headerlink" title="2-5 MyCAT的应用场景"></a>2-5 MyCAT的应用场景</h3><ul><li><p>需要进行读写分离的场景</p><p>在一台数据库服务器上进行读写混合操作时，数据库读写性能大幅下降，并且读负载明显高于写负载</p><p>MyCat支持多种后端MySQL集群方案来进行读写分离，如一主一从、一主多从、主主复制、PXC集群等等</p></li><li><p>需要进行分库分表的场景（切分）</p><p>最大支持单表1000亿的操作</p></li><li><p>多租户场景（软件架构）</p><p>在多用户的环境下，使用共同的数据库系统的组件，并且可以确保各个 用户之间具有数据隔离性。如云服务。</p></li><li><p>数据统计系统</p></li><li><p>HBASE的一种替代方案</p><p>HBASE是基于Hadoop的一种分布式列存储数据库</p><p>MySQL关系型数据库为行存储</p></li><li><p>需要使用同样的方式查询多种数据库的场景</p><p>MyCat可以同时支持多种数据库，如关系型数据库和NoSQL非关系型数据库。MyCat只向应用提供一个IP访问地址，而数据库存储方式的实现则可以使用各种方案。</p></li></ul><h3 id="2-6-MyCAT的优势"><a href="#2-6-MyCAT的优势" class="headerlink" title="2-6 MyCAT的优势"></a>2-6 MyCAT的优势</h3><ul><li>基于阿里的Cobar系统开发</li><li>开发社区活跃</li><li>完全开源可以自定义开发</li><li>支持多种关系型及NoSQL数据库</li><li>使用JAVA开发，可以部署在多种系统上。建议部署在Linux</li><li>具有在多种行业和项目中应用的成功案例</li></ul><h2 id="第3章-MyCAT基础"><a href="#第3章-MyCAT基础" class="headerlink" title="第3章 MyCAT基础"></a>第3章 MyCAT基础</h2><blockquote><p>本章节主要讲解MyCAT的基础知识，包括MyCAT的安装，启动配置和应用等。通过老师逻辑清晰的讲解，让大家理解并掌握MyCAT在实战中的基本应用。</p></blockquote><h3 id="3-1-MyCAT的基本概念"><a href="#3-1-MyCAT的基本概念" class="headerlink" title="3-1 MyCAT的基本概念"></a>3-1 MyCAT的基本概念</h3><ul><li><p>MYCAT中的数据库一逻辑库</p><p>user_db是逻辑数据库；db01、db02、db03是物理数据库</p><p>MyCat中只保存逻辑库的定义，不保存数据，具体的数据存储在物理数据库中</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gieftwvlj30j908k0tq.jpg"  width="430" alt="MYCAT中的数据库一逻辑库"/></li><li><p>MYCAT中的数据库一逻辑表</p><p>可以用数据库中视图的概念理解</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giehbahcj30fo07paam.jpg"  width="430" alt="MYCAT中的数据库一逻辑表"/></li></ul><h3 id="3-2-MyCAT的关键特性"><a href="#3-2-MyCAT的关键特性" class="headerlink" title="3-2 MyCAT的关键特性"></a>3-2 MyCAT的关键特性</h3><ul><li><p>支持<strong>SQL92标准</strong></p></li><li><p>支持MySQL集群</p></li><li><p>支持JDBC连接数据库</p></li><li><p>支持NOSQL数据库</p></li><li><p>支持<strong>自动故障切换</strong>，高可用性</p></li><li><p>支持<strong>读写分离</strong></p></li><li><p>支持全局表</p><p>将较少变动的数据统一存储起来</p></li><li><p>支持独有的基于ER关系的分片策略</p><p>根据实体关系ER模型，将相关的表存储在一个分片上，避免调用时跨分片</p></li><li><p>支持一致性HASH分片</p></li><li><p>多平台支持，部署简单方便</p></li><li><p>支持<strong>全局序列号</strong></p><p>将多个数据库表的自增ID统一起来，不出现重复ID</p></li></ul><h3 id="3-3-安装MyCAT"><a href="#3-3-安装MyCAT" class="headerlink" title="3-3 安装MyCAT"></a>3-3 安装MyCAT</h3><ol><li><p>安装Java环境</p></li><li><p>下载MyCat</p></li><li><p>新建MyCat用户</p><p>在Linux系统环境下，最好为每一款软件都独立的建立一个运行账号。既安全又可以对账号进行资源的限制</p></li><li><p>解压MyCat</p></li><li><p>配置环境变量</p><p>Java的HOME目录</p><p>Java的CLASSPATH目录</p><p>MyCat的HOME目录</p></li><li><p>启动MyCat</p></li></ol><h3 id="3-4-MyCAT安装"><a href="#3-4-MyCAT安装" class="headerlink" title="3-4 MyCAT安装"></a>3-4 MyCAT安装</h3><pre><code class="shell">java -versionyum install java-1.7.0-openjdkwget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gzadduser mycat # 建立mycat用户tar -xzvf Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz # 解压MyCat安装文件mv mycat /usr/local/ # 移动MyCat安装文件到/usr/local/chown mycat:mycat -R mycat # #改变当前文件夹属主和属组vi /etc/profile # 配置环境变量export JAVA_HOME=/usrexport MYCAT_HOME=/usr/local/mycat</code></pre><p>Linux系统安装任何一种软件最好都要新建一个独立用户，不要用root运行，不然会产生不安全的因素</p><h3 id="3-5-MyCAT启动-03-48"><a href="#3-5-MyCAT启动-03-48" class="headerlink" title="3-5 MyCAT启动 (03:48)"></a>3-5 MyCAT启动 (03:48)</h3><p>MyCat两种启动方式：</p><ol><li><p>基于脚本的启动方式</p><p>启动脚本：</p><pre><code class="shell">$MYCAT_HOME/bin/startup_nowrap.sh==&gt;/usr/local/mycat/bin/startup_nowrap.sh</code></pre><p>脚本参数：</p><p>当运行MyCat时，报内存不足或者是内存溢出异常</p><pre><code class="shell">JAVA_OPTS=&quot;-server -Xms1G -Xmx2G -XX:MaxPermSize=64M -XX:+AggressiveOpts -XX:MaxDirectMemorySize=2G&quot;</code></pre><pre><code class="shell"># 切换到mycat用户su - mycatcd /usr/local/mycat# 通过脚本启动MyCatbin/startup_nowrap.sh# 查看进程信息ps -ef# 查看日志cd /usr/local/mycat/logsmore mycat.log</code></pre></li><li><p>bin下已打包的mycat</p></li></ol><h3 id="3-6-MyCAT配置文件"><a href="#3-6-MyCAT配置文件" class="headerlink" title="3-6 MyCAT配置文件"></a>3-6 MyCAT配置文件</h3><ul><li>schema.xml用于配置逻辑库表及数据节点，数据源</li><li>rule.xml用于配置表的分片规则</li><li>server.xml用于配置服务器权限</li></ul><p>schema.xml文件</p><ul><li><p>定义逻辑库表</p><p>逻辑表是要依赖于逻辑库存在的。</p><p>如果数据库不需要进行分片，只进行读写分离，此时不用配置<table>标签，而只保留<schema>标签</p><pre><code class="xml">&lt;schema&gt;    &lt;table&gt;    &lt;/table&gt;&lt;/schema&gt;</code></pre></li><li><p>定义数据节点</p><p>定义MyCat的分片节点，一个数据节点就代表着一个独立的分片。其内容包括数据库节点的名字、数据源真实物理数据库的名称</p><pre><code class="xml">&lt;dataNode&gt;&lt;/dataNode&gt;</code></pre></li><li><p>定义数据节点的物理数据源</p><p>定义了一组主机节点，是真实物理数据库的实例。</p><p>一个<dataHost>标签所指定的主机就是一组真实的MySQL数据库集群</p><p>读写分离配置、心跳检测。。。</p><pre><code class="xml">&lt;dataHost&gt;&lt;/dataHost&gt;</code></pre></li></ul><p>rule.xml文件</p><ul><li><p>定义表使用的分片规则</p><pre><code class="xml">&lt;tableRule name=&quot;&quot;&gt;&lt;/tableRule&gt;</code></pre></li><li><p>定义分片算法</p><pre><code class="xml">&lt;function name=&quot;&quot;&gt;&lt;/function&gt;</code></pre></li></ul><p>server.xml文件</p><ul><li><p>用于定义系统配置</p><p>系统端口号、系统使用内存大小、timeout时间</p><pre><code class="xml">&lt;system&gt;    &lt;property name=&quot;&quot;&gt;    &lt;/property&gt;&lt;/system&gt;</code></pre></li><li><p>用于定义连接MyCat的用户信息</p><p>用户名字、密码</p><p>只有在server.xml中存在的用户才可以通过MyCat连接到后端数据库</p><pre><code class="xml">&lt;user&gt;&lt;/user&gt;</code></pre></li></ul><h3 id="3-7-MyCAT读写分离"><a href="#3-7-MyCAT读写分离" class="headerlink" title="3-7 MyCAT读写分离"></a>3-7 MyCAT读写分离</h3><p>三台服务器：MyCat服务器（node1）、两台MySQL服务器（Master-node2、Slave-node3）</p><p>显示xml文件：</p><pre><code class="shell">ls -lh *xml</code></pre><p>MyCat实现数据库读写分离只需配置两个文件：schema.xml、server.xml</p><pre><code class="xml">&lt;!-- /usr/local/mycat/conf/schema.xml --&gt;&lt;mycat:schema&gt;    &lt;!-- 配置逻辑库USERDB --&gt;    &lt;schema name=&quot;USERDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;&lt;/schema&gt;    &lt;!-- 定义数据节点node1 --&gt;    &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;node1&quot; database=&quot;user_db&quot; /&gt;    &lt;!-- 定义数据库集群 --&gt;    &lt;dataHost name=&quot;node1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; blance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt;        &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;        &lt;writeHost host=&quot;10.102.13.3&quot; url=&quot;10.102.13.3:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot;&gt;            &lt;readHost host=&quot;10.102.13.4&quot; url=&quot;10.102.13.4:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot; /&gt;        &lt;/writeHost&gt;        &lt;writeHost host=&quot;10.102.13.4&quot; url=&quot;10.102.13.4:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot; /&gt;    &lt;/dataHost&gt;&lt;/mycat:schema&gt;</code></pre><p>注：</p><ul><li><p><code>sqlMaxLimit=&quot;100&quot;</code>每一条SQL只返回100行记录</p><p>如果数据库进行了分片操作，查询数据会从所有分片中查询。此时会对系统造成负载</p></li><li><p><code>dataNode=&quot;dn1&quot;</code>定义了数据节点dn1</p></li><li><p><code>blance=&quot;1&quot;</code>定义了是否对后端多个从数据库进行负载均衡。1是0否</p></li><li><p><code>&lt;heartbeat&gt;</code>定义了如何监测后端数据库是否健康</p></li><li><p><code>user=&quot;im_user&quot; password=&quot;123456&quot;</code>定义了后端物理数据库的用户名和密码</p></li></ul><pre><code class="xml">&lt;!-- /usr/local/mycat/conf/server.xml --&gt;&lt;mycat:server&gt;    &lt;system&gt;        &lt;property name=&quot;serverPort&quot;&gt;3306&lt;/property&gt;        &lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;        &lt;property name=&quot;nonePasswordLogin&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useHandshakeV10&quot;&gt;1&lt;/property&gt;        &lt;property name=&quot;useSqlStat&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useGTob]eTablecheck&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;sequnceHandlerType&quot;&gt;2&lt;/property&gt;        &lt;property name=&quot;subqueryRelationshipcheck&quot;&gt; fal se&lt;/property&gt;        &lt;property name=&quot;processorBufferPoolType&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;handlepistributedTransactions&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useoffHeapForMerge&quot;&gt;1&lt;/property&gt;        &lt;property name=&quot;memoryPageSize&quot;&gt;64k&lt;/property&gt;        &lt;property name=&quot;spi11sFileBuffersize&quot;&gt;1k&lt;/property&gt;        &lt;property name=&quot;usestreamoutput&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;systemReserveMemorysize&quot;&gt;384m&lt;/property&gt;        &lt;property name=&quot;usezkSwitch&quot;&gt;false&lt;/property&gt;    &lt;/system&gt;    &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;        &lt;property name=&quot;schemas&quot;&gt;USERDB&lt;/property&gt;    &lt;/user&gt;    &lt;user name=&quot;mc_user&quot;&gt;        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;        &lt;property name=&quot;schemas&quot;&gt;USERDB&lt;/property&gt;        &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;    &lt;/user&gt;&lt;/mycat:server&gt;</code></pre><p>注：</p><ul><li><code>&lt;user&gt;</code>定义的用户在后端数据库中实际并不存在</li></ul><p>重启MyCat：</p><pre><code class="shell"># /usr/local/mycatbin/mycat stopbin/mycat start</code></pre><p>通过MyCat写数据，然后再读取：</p><pre><code class="python"># /root/script/init_data.pyimport MySQLdbfrom faker import Fakertry:    conn = MysQLdb.connect(host=&#39;127.0.0.1&#39;, user=&#39;root&#39;,passwd=&#39;123456&#39;, db=&#39;USERDB&#39;, charset=&quot;utf8&quot;)    cursor=conn. cursor(MySQLdb.cursors.Dictcursor)except MysQLdb.Error, e:    print &quot;Error %d: %s \n&quot; % (e.args[0],e. args[1])try:    faker=Faker()    # write data    for i in range(0, 10):        InSQL=&quot;&quot;&quot;            insert into customer_login(login_name, password, user_stats) VALUES(&#39;%s&#39;, md5(&#39;%s&#39;), 1)        &quot;&quot;&quot;%(faker.name(), faker.ean13())        print InSQL        cursor.execute(InSQL)        cursor.execute(&#39;commit&#39;)    # read data    for i in range(0, 10):        sQLstr=&quot;&quot;&quot;            select login_name from customer_login where customer_id = %d;        &quot;&quot;&quot;%(i)        cursor.execute(SQLstr)        resuit = cursor. fetchall()        print resultexcept MysQLdb.Error,e:    print &quot;Error %d: %s \n&quot; % (e.args[0], e.args[1])finally    cursor.close()    conn.close()</code></pre><p>执行程序：</p><pre><code class="shell"># /root/scriptpython init_data.py</code></pre><p>查看MyCat日志：</p><pre><code class="shell">more /usr/local/mycay/logs/mycat.log</code></pre><p>跟踪日志文件：</p><pre><code class="shell">tailf /usr/local/mycay/logs/mycat.log</code></pre><h3 id="3-8-MyCAT读写分离总结"><a href="#3-8-MyCAT读写分离总结" class="headerlink" title="3-8 MyCAT读写分离总结"></a>3-8 MyCAT读写分离总结</h3><p>步骤：</p><ol><li><p>修改schema.xml文件（/usr/local/mycat/conf/schema.xml）</p><p>对后端数据库的逻辑库、数据节点、数据主机节点进行配置</p><p>由于未进行分片操作，只需配置<schema>标签，无需配置<table>标签</p></li><li><p>修改server.xml文件（/usr/local/mycat/conf/server.xml）</p><p>MyCat向应用程序提供的服务端口、MyCat用户</p></li></ol><h3 id="3-9-MyCAT管理"><a href="#3-9-MyCAT管理" class="headerlink" title="3-9 MyCAT管理"></a>3-9 MyCAT管理</h3><p>使用MySQL客户端管理MyCat</p><ul><li>管理端口：<code>&lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;</code></li><li>命令：<code>mysql -uroot -p123456 -h127.0.0.1 -P9066</code></li><li>查看管理命令：<code>show @@help</code></li></ul><p>常用管理命令</p><ul><li><p>动态加载配置文件：<code>reload @@config</code></p><p>动态加载MyCat配置文件，但是并不是所有的配置文件都能够通过该命令加载的，某些还需要对MyCat进行重启，后期还会有MyCat高可用方案避免重启对应用程序的影响。</p></li><li><p>查看数据节点：<code>show @@datanode</code></p><p>查看MyCat中配置的节点详情</p></li><li><p>查看后端数据库：<code>show @@datasource</code></p><p>查看MyCat后端的物理数据库的详情</p></li><li><p>查看后端数据库连接：<code>show @@backend</code></p><p>查看MyCat后端的数据库的连接情况</p></li></ul><h2 id="第4章-MyCAT日志分析"><a href="#第4章-MyCAT日志分析" class="headerlink" title="第4章 MyCAT日志分析"></a>第4章 MyCAT日志分析</h2><blockquote><p>通过学习MyCAT日志，掌握MyCAT运行时的相关信息以及应用日志对MyCAT运行时的错误进行跟踪处理。</p></blockquote><h3 id="4-1-MyCAT日志"><a href="#4-1-MyCAT日志" class="headerlink" title="4-1 MyCAT日志"></a>4-1 MyCAT日志</h3><p>配置MyCat日志：</p><ul><li><p>MyCat使用Apache log4j项目管理日志</p></li><li><p>MyCat配置文件：conf/log4j2.xml</p></li></ul><p>log4j2.xml作用</p><ul><li><p>配置日志格式</p><pre><code class="xml">&lt;PatternLayout&gt;    &lt;Pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [%t] - %m%n&lt;/Pattern&gt;&lt;/PatternLayout&gt;</code></pre><pre><code class="log">2019-07-07 15:22:02.485 DEBUG [Timer1] - con query sql:select user() to con:MySQLConnection</code></pre><p>注：</p><ul><li>%d：定义时间。如：2019-07-07 15:22:02.485</li><li>%5p：日志级别。如：DEBUG</li><li>%t：线程信息。如：[Timer1]</li><li>%m：代码提示信息。如：con query sql:select user() to con:MySQLConnection</li><li>%n：回车符</li></ul></li><li><p>配置日志级别</p><ul><li><p><code>&lt;asyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot; /&gt;</code></p></li><li><p>ALL &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</p></li><li><p>注：</p><ul><li>一般设置Debug模式，最强也就是Info类型</li></ul></li></ul></li></ul><h3 id="4-2-MyCAT日志"><a href="#4-2-MyCAT日志" class="headerlink" title="4-2 MyCAT日志"></a>4-2 MyCAT日志</h3><ol><li><p>MyCat启动过程中输出的日志</p><pre><code class="log">10:45:06.377 INFO [ WrapperSimpleAppMain]-total resouces of dataHost nodel is:310:45:06.389 INFO [ WrapperSimpleAppMain]-create layer cache pool TableID2DataNodeCache of type encache, default cache size 10000, default expire seconds1800010:45:06.391 INFO [ WrapperSimpleAppMain]-create child Cache: TESTDB_ORDERS for layered cache TableID2DataNodeCache, size 50000, expire seconds 1800010:45:06.523 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from ehcache. xml found in the classpath: file:/usr/1ocal/mycat/conf/ehcache. xml10:45:06.525 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from URL: file:/usr/1ocal/mycat/conf/ehcache. xmll10:45:06.525 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from InputStream10:45:06.652 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xmlns: mycat10:45:06.653 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xmlns: xsi10:45:06.653 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute maxEntriesLocalHeap10:45:06.656 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xsi: noNamespaceSchemalocation10:45:06.689 DEBUG [ WrappersimpleAppMain]-Creating new CacheManager with default config10:45:06.723 DEBUG [ WrapperSimpleAppMain]-propertiesstring is null.10:45:06.812 DEBUG[ WrapperSimpleAppMain]-Cacheuriter factory not configured. Skipping...10:45:06.812 DEBUG [ WrappersimpleAppMain]-Initialized net. sf. ehcache. store. NotifyingMemoryStore for SQLRouteCache10:45:06.813 DEBUG [ WrappersimpleAppMain]-Initialised cache: SQLRouteCache10:45:06.828 INFO [ WrappersimpleAppMain]-dyna class load from./catlet, and auto check for class file modified every 60 seconds10:45:06.830 DEBUG [ WrappersimpleAppMain]-baseDir./tmlogs/10:45:06.830 DEBUG[ WrappersimpleAppMain]-baseName tmlog</code></pre><p>注：</p><ul><li>total resouces of dataHost nodel is:3。3个主机节点</li></ul></li><li><p>MyCat线程数</p><pre><code class="log">10:45:06.875 INFO[ WrapperslimpleAppMain]-MyCat is ready to startup.….10:45:06.875 INFO [ WrappersimpleAppMain]-Startup processors..., total processors:48, aio thread pool size:96each process allocated socket buffer pool bytes,a page size:2097152 a page&#39;s chunk number(Pagesize/Chunksize) is:512buffer page&#39;s number is:960</code></pre><p>注：</p><ul><li>total processors:48。线程数为48，默认为线程数等于CPU核数。</li><li>aio thread pool size:96。aio进程池数量为CPU核数的两倍</li></ul></li><li><p>server.xml中配置MyCat的启动参数</p><pre><code class="log">10:45:06.875 INFO[ WrapperSimpleAppMain]-sysconfig params: Systemconfig[processorBufferLocalPercent=100,frontSocketSoRcvbuf=1048576,frontSocketSoSndbuf=4194304,backSocketSoRcvbuf=4194384,backSocketSosndbuf=1048576,frontSocketNoDelay=1,backSocketNoDelay=1,maxStringLiteralLength=65535,frontwriteQueueSize=2048,bindIp=0.0.0.0,serverPort=3306,managerPort=9066,charset=utf8,processors=48,processorExecutor=96,timerExecutor=2,managerExecutor=2,idleTimeout=1800000,catletC1assCheckSeconds=60,sqlExecuteTimeout=300,processorCheckPeriod=1000,dataNodeIdleCheckPeriod=300000,dataNodeHeartbeatPeriod=10000,clusterHeartbeatUser=HEARTBEAT_USER_,clusterHeartbeatPass=_HEARTBEAT_PASS_,clusterHeartbeatPeriod=5000,clusterHeartbeatTimeout=10000,clusterHeartbeatRetry=10,txIsolation=3,parserCommentVersion=50148,sq1RecordCount=10,bufferPoolPageSize=2097152,bufferPoolChunkSize=4096,bufferPoolPageNumber=960,maxResultSet=524288,bigResultsizesqlCount=10,bufferUsagePercent=80,flowControlRejectStrategy=0,clearBigSqLResultSetMapMS=600000,defaultMaxLimit=100,sequnceHandlerType=2,mutiNodeLimitType=e,mutiNodePatchSize=100,defaultSqlParser=druidparser,usingArO=0,packetHeaderSize=4,maxPacketsize=16777216,mycatNodeId=1]</code></pre><p>注：</p><ul><li>serverPort=3306。MyCat对外提供服务的端口号</li><li>managerPort=9066。MyCat管理端口</li><li>charset=utf8。MyCat默认字符集</li><li>processors=48。MyCay进程数</li><li>processorExecutor=96。MyCay进程池大小</li><li>idleTimeout=1800000。应用程序与MyCat连接超时时间</li><li>defaultMaxLimit=100。MyCat默认返回结果集行数</li><li>maxPacketsize=16777216。最大包大小，一定不能大于在MySQL中配置的大小。</li></ul></li><li><p>MyCat监听端口的启动</p><pre><code class="log">10:45:08.158 INFO [WrapperSimpleAppMain]-using nio network handler10:45:08.224 INFO [WrapperSimpleAppMain]-$ MyCatManager is started and listening on 906610:45:08.224 INFO[WrappersimpleAppMain]-$_MyCatserver is started and listening on 3306</code></pre></li><li><p>MyCat对后端连接池的初始化</p><pre><code class="log">10:45:08.224 INFO[WrapperSimpleAppMain]-============================10:45:08.224 INFO[WrapperSimpleAppMain]-Initialize dataHost...10:45:08.224 INFO[WrappersimpleAppMain]-init datahost:nodel to use datasource index:110:45:08.225 INFO[WrappersimpleAppMain]-init backend myqsl source，create connections total 10 for 192.168.13.4 index:110:45:08.226 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.227 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.228 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.229 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.271 INFO[$_NIOREACTOR-1-RW]-connected successfuly MysQLConnection[id=1, 1astTime=1520217908270, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233481, harset=utf8, txIsolat ion=3, autocommit=true, attachment=nul1, respHandler=null, host=192.168.13.4, port=3306, statussync=null, uriteQueue=e, modifiedSQLExecuted=false]10:45:08.271 INFO[$_NIOREACTOR-5-RW]-connected successfuly MysQLConnection[id=5, 1astTime=152021790827e, er=imuser, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233482, harset=utf8, txIsolat ion=3, autocommit=true, attachment=nul1, respHandler=nul1, host=192.168.13.4, port=3306, statussync=null, writeQueue=0, modifiedSQLExecuted=false]</code></pre></li><li><p>MyCat初始化完成之后的输出</p><pre><code class="log">10:45:08.334 INFO [WrapperSimpleAppMain]-init result :finished 10 success 10 target count:1010:45:08.334 INFO [WrappersimpleAppMain]-nodel index:1 init success</code></pre></li><li><p>MyCat对后端数据库进行心跳检测</p><pre><code class="log">10:45:08.347 INFO [ Timer1]-no ilde connection in pool, create new connection for 192.168.13.3 of schema user db10:45:08.348DEBUG[ Timer1]-con query sql: select user() to con: MysQLConnection [ id=2, 1astTime=1520217908348, iser=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233483, charset=utf8, txIsol ation=3, autocommit=true, attachment=nul1, respHandler=nul1, host=192.168.13.4, port=3306, statussync=null, writeQueue=0,m odifiedSQLExecuted=false]10:45:08.348 INFO[$_NIOREACTOR-11-RW]-connectionAcquired MySQLConnection [ id=11,1astTime=1520217908348, er=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=true, threadId=2233490, charset=utf8, txIsolatio1=3, autocommit=true, attachment=nul1, respHandler=null, host=192.168,13.4, port=3306, statussync=nul1, writeQueue=e, modif iedSQLExecuted=false]10:45:08.373 INFO [ Timer1]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db18:45:08.377 DEBUG[$_NTOREACTOR-12-RW]-con query sql: select user() to con: MysQLconnection [ id=12, lastTime=1520217908377, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=908148, charset=utf8, txIsolation=3, autocommit=true, attachment=nul1, respHandler=nu11, host=192.168.13.3, port=3306, statusSync=nul1, wri teQueue=e, modifiedSQLExecuted=false]</code></pre></li><li><p>应用程序登录到MyCat输出的信息</p><pre><code class="log">14:16:48.257 INFO[$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB]&#39;root&#39; login success14:16:48.259 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show databases14:16:48.260 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show tables14:16:48.260 DEBUG[$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show tables, route={    1-&gt;dnl{ show tables}} rrs</code></pre></li><li><p>向MyCat发送一条SQL语句输出的日志</p><pre><code class="log">14:16:48.262 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] select * from customer_login where login_name=&#39; John Miller14:16:48.263 DEBUG[$_NIOREACTOR-7-RW]-SQLRouteCache miss cache, key: USERDB select * from customer_1ogin where login_name=&#39;John Miller&#39;14:16:48.263 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] select * from customer_login where 1ogin_name=&#39; John Miller&#39;, route={    1-&gt; dnl{ select * from customer_login where login_name=&#39; John Miller}} rrs</code></pre></li><li><p>具体SQL执行过程</p><pre><code class="log">14:16:48.263 DEBUG [$_NIOREACTOR-7-RW]-select read source 192.168.13.4 for dataHost: nodel14:16:48.265 DEBUG[$_NIOREACTOR-13-RW]-release connection MySQLConnection [ id=13,1astTime=1520230608256, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=true, threadId=2233491, charset=utf8, txIsolation=3, autocommit=true, attachment=dnl{ select * from customer_login where login_name=&#39; John Miller&#39;}, respHandler=SingleNodeHandler [ node=dn1{ select * from customer_login where login_name=&#39;John Miller&#39;}, packetId=8], host=192.168.13.4, port=3306, statussync=null, writeQueue=0, modifiedSQLExecuted=false]</code></pre></li></ol><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>本章节主要对课程中涉及到的全部知识点进行知识总结。并介绍进一步学习MyCAT的学习途径。</p></blockquote><h3 id="5-1-总结"><a href="#5-1-总结" class="headerlink" title="5-1 总结"></a>5-1 总结</h3><p>已学内容：</p><ul><li>MyCat起源</li><li>MyCat基本概念</li><li>如何安装、启动、配置MyCat</li><li>利用MyCat实现对后端数据库的读写分离</li><li>MyCat主要功能和应用场景</li></ul><p>未讲内容：</p><ul><li>如何利用MyCat对后端数据库进行分片</li><li>如何对分片集群进行备份</li><li>分片集群中宕机一台服务器会有什么影响</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>945-SpringBoot+MyBatis搭建迷你小程序</title>
      <link href="/2019/07/06/945-mini-app/"/>
      <url>/2019/07/06/945-mini-app/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/945" target="_blank" rel="noopener">https://www.imooc.com/learn/945</a></p><p>简介：用Spring Boot框架大大简化了新Spring应用的初始搭建以及开发过程，在开发人员中越来越受到欢迎。微信小程序作为目前炙手可热的应用，很有可能在未来占据轻应用的市场。本门课程的主要目的是将两者结合起来，同时希望作为入门翔仔之前实战课的一个更低门槛的课程进行讲解。本课分为三大部分：第一部分带领大家明确需求，从零开始进行SpringBoot+MyBatis的框架搭建；第二部分咱们将依据业务模块配合UT实现后端完整的增删改查功能；最后我们将来到微信小程序开发部分，帮大家入门微信小程序开发，并教会大家前后联调。老师相关实战课程：<a href="http://coding.imooc.com/class/144.html" target="_blank" rel="noopener">http://coding.imooc.com/class/144.html</a> 老师的面试课程： <a href="https://coding.imooc.com/class/303.html" target="_blank" rel="noopener">https://coding.imooc.com/class/303.html</a></p></blockquote><p><a href="https://gitee.com/xiangze/areadisplay" target="_blank" rel="noopener">讲师源码-前端</a><br><a href="https://gitee.com/xiangze/demo" target="_blank" rel="noopener">讲师源码-后端</a></p><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>本章节讲解本门课程的主旨，便于同学掌握课程的来龙去脉。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>学习本门课程的作用：</p><ul><li>学会从0搭建后端的SpringBoot + MyBatis框架</li><li>微信小程序入门</li><li>规范的代码编写</li></ul><p>本门课程的框架：</p><ul><li>从0搭建后端的springboot + mybatis框架</li><li>实现后端的业务功能</li><li>实现本地微信小程序的前端开发</li><li>前端与后端的联调</li></ul><p>技术储备要求：</p><ul><li>基本的Java知识</li><li>基本的前端开发知识(简单了解HTML,JS等)</li><li>Spring , Mybatis基础知识(不会也没关系)</li></ul><h3 id="1-2-最终效果展示"><a href="#1-2-最终效果展示" class="headerlink" title="1-2 最终效果展示"></a>1-2 最终效果展示</h3><p>登录、区域信息的增删改查</p><h2 id="第2章-项目设计及框架搭建"><a href="#第2章-项目设计及框架搭建" class="headerlink" title="第2章 项目设计及框架搭建"></a>第2章 项目设计及框架搭建</h2><blockquote><p>本章节讲解项目的需求分析、数据库设计以及后端SpringBoot + Mybatis框架的搭建</p></blockquote><h3 id="2-1-SpringBoot的搭建与启动上"><a href="#2-1-SpringBoot的搭建与启动上" class="headerlink" title="2-1 SpringBoot的搭建与启动上"></a>2-1 SpringBoot的搭建与启动上</h3><p><a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a></p><pre><code class="yaml">server.context-path=/demo //设置上下文路径  server.port=8888 //设置端口号</code></pre><h3 id="2-3-功能点的明确"><a href="#2-3-功能点的明确" class="headerlink" title="2-3 功能点的明确"></a>2-3 功能点的明确</h3><p>区域信息的增删改查</p><h3 id="2-4-表设计与实体类的创建"><a href="#2-4-表设计与实体类的创建" class="headerlink" title="2-4 表设计与实体类的创建"></a>2-4 表设计与实体类的创建</h3><ul><li><p>表设计</p><pre><code class="sql">CREATE DATABASE IF NOT EXISTS `imooc_945_mini_app`;USE `imooc_945_mini_app`;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tb_area-- ----------------------------DROP TABLE IF EXISTS `tb_area`;CREATE TABLE `tb_area` (  `area_id`        INT(2)      NOT NULL AUTO_INCREMENT  COMMENT &#39;主键ID&#39;,  `area_name`      VARCHAR(200) CHARACTER SET utf8  COLLATE utf8_general_ci      NOT NULL  COMMENT &#39;名称&#39;,  `priority`       INT(2)      NOT NULL DEFAULT 0  COMMENT &#39;权重，越大越排前显示&#39;,  `create_time`    DATETIME(0) NULL     DEFAULT NULL  COMMENT &#39;创建时间&#39;,  `last_edit_time` DATETIME(0) NULL     DEFAULT NULL  COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`area_id`) USING BTREE,  UNIQUE INDEX `UK_AREA`(`area_name`) USING BTREE)  ENGINE = InnoDB  AUTO_INCREMENT = 1  CHARACTER SET = utf8  COLLATE = utf8_general_ci  COMMENT = &#39;区域信息&#39;  ROW_FORMAT = DYNAMIC;SET FOREIGN_KEY_CHECKS = 1;</code></pre></li><li><p>实体类</p><pre><code class="java">// 区域信息public class Area {    // 主键ID    private Integer areaId;    // 名称    private String areaName;    // 权重，越大越排前显示    private Integer priority;    // 创建时间    private Date createTime;    // 更新时间    private Date lastEditTime;}</code></pre></li></ul><h2 id="第3章-项目开发"><a href="#第3章-项目开发" class="headerlink" title="第3章 项目开发"></a>第3章 项目开发</h2><blockquote><p>本章节带领大家从零开始从Dao到Controller开发一个完整的带单元测试增删改查后端。</p></blockquote><ul><li>配置</li><li>接口</li><li>mapper</li><li>ut，即单元测试</li></ul><h3 id="3-1-pom的配置"><a href="#3-1-pom的配置" class="headerlink" title="3-1 pom的配置"></a>3-1 pom的配置</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--数据库--&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--连接池--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.mchange&lt;/groupId&gt;    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;    &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="3-2-mybatis-config的配置"><a href="#3-2-mybatis-config的配置" class="headerlink" title="3-2 mybatis-config的配置"></a>3-2 mybatis-config的配置</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置全局属性--&gt;    &lt;settings&gt;        &lt;!--使用JDBC的getGeneratedKeys获取数据库自增主键值--&gt;        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;        &lt;!--使用列标签替换列别名 默认：true--&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;        &lt;!--开启驼峰命名转换：Table{create_time} -&gt; Entity{createTime}--&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><h3 id="3-3-datasource和sessionfactorybean的配置"><a href="#3-3-datasource和sessionfactorybean的配置" class="headerlink" title="3-3 datasource和sessionfactorybean的配置"></a>3-3 datasource和sessionfactorybean的配置</h3><ul><li><p>配置datasource到ioc容器里面</p><pre><code class="java">@Configuration// 配置mybatis mapper的扫描路径@MapperScan(&quot;com.tuyrk.dao&quot;)public class DataSourceConfiguration {    @Value(&quot;${jdbc.driver}&quot;)    private String jdbcDriver;    @Value((&quot;${jdbc.url}&quot;))    private String jdbcUrl;    @Value(&quot;${jdbc.username}&quot;)    private String jdbcUsername;    @Value(&quot;${jdbc.password}&quot;)    private String jdbcPassword;    // 生成与spring-dao.xml对应的bean dataSource    @Bean(name = &quot;dataSource&quot;)    public ComboPooledDataSource createDataSource() throws PropertyVetoException {        // 生成datasource实例        ComboPooledDataSource dataSource = new ComboPooledDataSource();        // 跟配置文件一样设置以下信息        // 驱动        dataSource.setDriverClass(jdbcDriver);        // 数据库连接URL        dataSource.setJdbcUrl(jdbcUrl);        // 设置用户名        dataSource.setUser(jdbcUsername);        // 设置用户密码        dataSource.setPassword(jdbcPassword);        // 配置c3p0连接池的私有属性        // 连接池最大线程数        dataSource.setMaxPoolSize(30);        // 连接池最小线程数        dataSource.setMinPoolSize(10);        //关闭连接后不自动commit        dataSource.setAutoCommitOnClose(false);        // 连接超时时间        dataSource.setCheckoutTimeout(10000);        // 连接失败重试次数        dataSource.setAcquireRetryAttempts(2);        return dataSource;    }}</code></pre></li><li><p>创建sqlSessionFactoryBean实例</p><pre><code class="java">@Configurationpublic class SessionFactoryConfiguration {    // mybatis-config.xml配置文件的路径    @Value(&quot;${mybatis_config_file}&quot;)    private String mybatisConfigFilePath;    // mybatis mapper文件所在的路径    @Value(&quot;${mapper_path}&quot;)    private String mapperPath;    // 实体类所在的Package    @Value(&quot;${entity_package}&quot;)    private String entityPackage;    @Autowired    @Qualifier(&quot;dataSource&quot;)    private DataSource dataSource;    // 创建sqlSessionFactoryBean实例 并且设置configtion 设置mapper映射路径 设置datasource数据源    @Bean(name = &quot;sqlSessionFactory&quot;)    public SqlSessionFactoryBean createSqlSessionFactoryBean() throws IOException {        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        // 设置mybatis configuration 扫描路径        sqlSessionFactoryBean.setConfigLocation(new ClassPathResource(mybatisConfigFilePath));        // 添加mapper 扫描路径        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();        String packageSearchPath = PathMatchingResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + mapperPath;        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(packageSearchPath));        // 设置dataSource        sqlSessionFactoryBean.setDataSource(dataSource);        // 设置typeAlias 包扫描路径        sqlSessionFactoryBean.setTypeAliasesPackage(entityPackage);        return sqlSessionFactoryBean;    }}</code></pre></li></ul><h3 id="3-4-dao的创建"><a href="#3-4-dao的创建" class="headerlink" title="3-4 dao的创建"></a>3-4 dao的创建</h3><pre><code class="java">public interface AreaDao {    // 列出区域列表    List&lt;Area&gt; queryArea();    // 根据Id列出具体区域    Area queryAreaById(Integer areaId);    // 插入区域信息    Integer insertArea(Area area);    // 更新区域信息    Integer updateArea(Area area);    // 删除区域信息    Integer deleteArea(Integer areaId);}</code></pre><h3 id="3-5-mapper的编写"><a href="#3-5-mapper的编写" class="headerlink" title="3-5 mapper的编写"></a>3-5 mapper的编写</h3><p>自动化生成mapper工具：</p><ul><li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper      PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;      &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.tuyrk.dao.AreaDao&quot;&gt;  &lt;!-- 查询区域信息列表 --&gt;  &lt;select id=&quot;queryArea&quot; resultType=&quot;com.tuyrk.entity.Area&quot;&gt;      SELECT          area_id,          area_name,          priority,          create_time,          last_edit_time      FROM tb_area      ORDER BY priority DESC;  &lt;/select&gt;  &lt;!-- 根据区域ID，查询区域信息 --&gt;  &lt;select id=&quot;queryAreaById&quot; resultType=&quot;com.tuyrk.entity.Area&quot;&gt;      SELECT          area_id,          area_name,          priority,          create_time,          last_edit_time      FROM tb_area      WHERE area_id = #{areaId}  &lt;/select&gt;  &lt;!-- 新增区域信息 --&gt;  &lt;insert id=&quot;insertArea&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;areaId&quot; keyColumn=&quot;area_id&quot;          parameterType=&quot;com.tuyrk.entity.Area&quot;&gt;      INSERT INTO tb_area (area_name, priority, create_time, last_edit_time)      VALUES (#{areaName}, #{priority}, #{createTime}, #{lastEditTime});  &lt;/insert&gt;  &lt;!-- 更新区域信息 --&gt;  &lt;update id=&quot;updateArea&quot; parameterType=&quot;com.tuyrk.entity.Area&quot;&gt;      update tb_area      &lt;set&gt;          &lt;if test=&quot;areaName != null&quot;&gt;area_name = #{areaName},&lt;/if&gt;          &lt;if test=&quot;priority != null&quot;&gt;priority = #{priority},&lt;/if&gt;          &lt;if test=&quot;lastEditTime != null&quot;&gt;last_edit_time = #{lastEditTime}&lt;/if&gt;      &lt;/set&gt;      where area_id = #{areaId};  &lt;/update&gt;  &lt;!-- 根据区域ID，删除区域信息 --&gt;  &lt;delete id=&quot;deleteArea&quot;&gt;      DELETE FROM tb_area      WHERE area_id = #{areaId};  &lt;/delete&gt;&lt;/mapper&gt;</code></pre><h3 id="3-6-dao层开发"><a href="#3-6-dao层开发" class="headerlink" title="3-6 dao层开发"></a>3-6 dao层开发</h3><pre><code class="java">@Autowiredprivate AreaDao areaDao;</code></pre></li></ul><p><strong>areaDao红线报错解决方案</strong>：</p><ul><li>【File】==&gt;【settings】==&gt;【Inspections】==&gt;【Spring】==&gt;【Spring Core】==&gt;【Code】==&gt;【Autowiring for Bean Class】==&gt;【Warning】</li></ul><p>UT单元测试：</p><ul><li><p>AreaDaoTest.java的编写</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class AreaDaoTest {    //通过spring容器注入Dao的实现类    @Autowired    private AreaDao areaDao;    @Test    public void queryArea() {        List&lt;Area&gt; areaList = areaDao.queryArea();        // 验证预期值和实际值是否相符        assertEquals(2, areaList.size());    }    // ...}</code></pre></li></ul><p><strong>如此繁多的框架应该学习哪一个</strong>？</p><ul><li><p>答：Spring。多看Spring源码，学习框架设计。</p><h3 id="3-7-service层的实现"><a href="#3-7-service层的实现" class="headerlink" title="3-7 service层的实现"></a>3-7 service层的实现</h3></li><li><p>配置<br>对标spring-service里面的transactionManager<br>继承TransactionManagementConfiguration是因为开启annotation-driven</p><pre><code class="java">@Configuration// 首先使用注解 @EnableTransactionManagement 开启事务支持后// 在Service方法上添加注解 @Transactional 便可@EnableTransactionManagement// 开启事务的管理public class TransactionManagementConfiguration implements TransactionManagementConfigurer {    @Autowired    // 注入DataSourceConfiguration里边的DataSource，通过createDataSource()获取    private DataSource dataSource;     // 关于事务管理，需要返回PlatformTransactionManager的实现    @Override    public PlatformTransactionManager annotationDrivenTransactionManager() {        return new DataSourceTransactionManager(dataSource);    }}</code></pre></li><li><p>接口</p><pre><code class="java">public interface AreaService {    // 获取区域列表    List&lt;Area&gt; getAreaList();    // 通过区域Id获取区域信息    Area getAreaById(int areaId);    // 增加区域信息    boolean addArea(Area area);    // 修改区域信息    boolean modifyArea(Area area);    // 删除区域信息    boolean deleteArea(int areaId);}</code></pre></li><li><p>实现类</p><h3 id="3-8-业务controller方法的实现"><a href="#3-8-业务controller方法的实现" class="headerlink" title="3-8 业务controller方法的实现"></a>3-8 业务controller方法的实现</h3></li><li><p>业务Controller方法的实现</p></li><li><p>统一异常处理</p></li></ul><p>浏览器JSON格式化查看插件：JsonView</p><h3 id="3-9-统一异常处理功能的实现"><a href="#3-9-统一异常处理功能的实现" class="headerlink" title="3-9 统一异常处理功能的实现"></a>3-9 统一异常处理功能的实现</h3><pre><code class="java">@ControllerAdvicepublic class GlobalExceptionHandler {    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Map&lt;String, Object&gt; handlerException(HttpServletRequest request, Exception e) {        Map&lt;String, Object&gt; modelMap = new HashMap&lt;&gt;();        modelMap.put(&quot;success&quot;, false);        modelMap.put(&quot;errMsg&quot;, e.getMessage());        return modelMap;    }}</code></pre><h2 id="第4章-微信小程序的入门及前后联调"><a href="#第4章-微信小程序的入门及前后联调" class="headerlink" title="第4章 微信小程序的入门及前后联调"></a>第4章 微信小程序的入门及前后联调</h2><blockquote><p>本章节将带领大家入门微信小程序，并实现本项目的前端功能，同时进行前后端联调。</p></blockquote><h3 id="4-1-微信小程序简介"><a href="#4-1-微信小程序简介" class="headerlink" title="4-1 微信小程序简介"></a>4-1 微信小程序简介</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/index.html" target="_blank" rel="noopener">小程序开发文档</a></p><p>小程序代码构成：</p><ol><li>JSON配置</li><li>WXML模板</li><li>WXSS样式</li><li>JS逻辑交互<h3 id="4-2-微信开发者工具简介"><a href="#4-2-微信开发者工具简介" class="headerlink" title="4-2 微信开发者工具简介"></a>4-2 微信开发者工具简介</h3><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">下载</a></li></ol><p>模拟器、编辑器、调试器</p><h3 id="4-3-创建新的小程序"><a href="#4-3-创建新的小程序" class="headerlink" title="4-3 创建新的小程序"></a>4-3 创建新的小程序</h3><p>【项目目录】==&gt;【APPID（测试号）】==&gt;【项目名称】==&gt;【建立普通快速启动模板】</p><h3 id="4-4-列表页开发"><a href="#4-4-列表页开发" class="headerlink" title="4-4 列表页开发"></a>4-4 列表页开发</h3><p>修改标题：</p><ul><li>在*.json中添加<code>&quot;navigationBarTitleText&quot;: &quot;区域信息列表&quot;</code></li></ul><p>组件：</p><ul><li>view：类似于html的div</li><li>scroll-view：可滚动试图区域</li><li>text：文本</li></ul><pre><code class="html">&lt;!--pages/list/list.wxml--&gt;&lt;view class=&#39;container&#39;&gt;  &lt;!-- 表头 --&gt;  &lt;view class=&#39;widget&#39;&gt;    &lt;text class=&#39;column&#39;&gt;ID&lt;/text&gt;    &lt;text class=&#39;column&#39;&gt;区域名&lt;/text&gt;    &lt;text class=&#39;column&#39;&gt;优先级&lt;/text&gt;    &lt;text class=&#39;link-column&#39;&gt;操作&lt;/text&gt;  &lt;/view&gt;  &lt;!-- 数据展示区域 --&gt;  &lt;scroll-view scroll-y=&quot;true&quot;&gt;    &lt;view&gt;      &lt;block wx:for=&quot;{{list}}&quot;&gt;        &lt;view class=&quot;widget&quot;&gt;          &lt;text class=&#39;column&#39;&gt;{{item.areaId}}&lt;/text&gt;          &lt;text class=&#39;column&#39;&gt;{{item.areaName}}&lt;/text&gt;          &lt;text class=&#39;column&#39;&gt;{{item.priority}}&lt;/text&gt;          &lt;view class=&#39;link-column&#39;&gt;            &lt;navigator class=&#39;link&#39; url=&#39;../operation/operation?areaId={{item.areaId}}&#39;&gt;编辑&lt;/navigator&gt;|            &lt;text class=&#39;link&#39; bindtap=&#39;deleteArea&#39; data-areaid=&#39;{{item.areaId}}&#39; data-areaname=&#39;{{item.areaName}}&#39; data-index=&#39;{{index}}&#39;&gt;删除&lt;/text&gt;          &lt;/view&gt;        &lt;/view&gt;      &lt;/block&gt;    &lt;/view&gt;  &lt;/scroll-view&gt;  &lt;!-- 按钮 --&gt;  &lt;button type=&#39;primary&#39; bindtap=&#39;addArea&#39;&gt;添加区域信息&lt;/button&gt;&lt;/view&gt;</code></pre><ul><li><p>列表展示</p><pre><code class="javascript">onShow: function() {  var that = this;  wx.request({    url: &#39;http://127.0.0.1:8888/demo/superadmin/listarea&#39;,    data: {},    method: &#39;GET&#39;,    success: function(res) {      var list = res.data.areaList;      console.log(res);      if (list == null) {        var toastText = &#39;获取数据失败&#39; + res.data.errMsg;        wx.showToast({          title: toastText,          icon: &#39;&#39;,          duration: 2000        })      } else {        that.setData({          list: list        });      }    }  })}</code></pre></li><li><p>删除功能</p><pre><code class="javascript">deleteArea: function(e) {  var that = this;  // 0. 询问用户是否删除该信息  wx.showModal({    title: &#39;提示&#39;,    content: &#39;确定要删除[&#39; + e.target.dataset.areaname + &#39;]吗？&#39;,    success: function(sm) {      // 如果点击确认，      if (sm.confirm) {        // 1. 获取areaId，将其传递给后台做删除操作        wx.request({          url: &#39;http://127.0.0.1:8888/demo/superadmin/removearea&#39;,          data: {            &quot;areaId&quot;: e.target.dataset.areaid          },          method: &#39;GET&#39;,          success: function(res) {            var result = res.data.success;            var toastText = &quot;删除成功！&quot;;            if (result != true) {              toastText = &quot;刪除失敗！&quot;;            } else {              // 2. 更新list值              that.data.list.splice(e.target.dataset.index, 1);              that.setData({                list: that.data.list              })            }            // 彈出提示            wx.showToast({              title: toastText,              icon: &#39;&#39;,              duration: 2000            })          }        })      }    }  })}</code></pre></li><li><p>跳转到添加区域信息</p><pre><code class="javascript">addArea: function() {  wx.navigateTo({    url: &#39;../operation/operation&#39;  });}</code></pre></li></ul><h3 id="4-7-列表页前后端联调"><a href="#4-7-列表页前后端联调" class="headerlink" title="4-7 列表页前后端联调"></a>4-7 列表页前后端联调</h3><h3 id="4-8-区域信息编辑页的开发"><a href="#4-8-区域信息编辑页的开发" class="headerlink" title="4-8 区域信息编辑页的开发"></a>4-8 区域信息编辑页的开发</h3><pre><code class="html">&lt;!--pages/operation/operation.wxml--&gt;&lt;view class=&quot;container&quot;&gt;  &lt;form bindsubmit=&#39;formSubmit&#39; bindreset=&#39;formReset&#39;&gt;    &lt;!-- 输入框  --&gt;    &lt;view class=&#39;row&#39;&gt;      &lt;text&gt;区域名：&lt;/text&gt;      &lt;input type=&#39;text&#39; name=&#39;areaName&#39; placeholder=&#39;请输入区域名&#39; value=&#39;{{areaName}}&#39;/&gt;    &lt;/view&gt;    &lt;view class=&#39;row&#39;&gt;      &lt;text&gt;优先级：&lt;/text&gt;      &lt;input type=&#39;number&#39; name=&#39;priority&#39; placeholder=&#39;数值越大越靠前&#39; value=&#39;{{priority}}&#39;/&gt;    &lt;/view&gt;    &lt;!-- 按钮  --&gt;    &lt;view class=&#39;row&#39;&gt;      &lt;button type=&#39;primary&#39; form-type=&#39;submit&#39;&gt;提交&lt;/button&gt;      &lt;button type=&#39;primary&#39; form-type=&#39;reset&#39;&gt;清空&lt;/button&gt;    &lt;/view&gt;  &lt;/form&gt;&lt;/view&gt;</code></pre><ul><li>区域信息添加</li><li>区域信息更新</li></ul><ul><li><p>页面的初始数据</p><pre><code class="javascript">data: {  areaId: undefined,  areaName: &#39;&#39;,  priority: &#39;&#39;,  addUrl: &#39;http://127.0.0.1:8888/demo/superadmin/addarea&#39;,  modifyUrl: &#39;http://127.0.0.1:8888/demo/superadmin/modifyarea&#39;}</code></pre></li><li><p>编辑页获取区域信息</p><pre><code class="javascript">onLoad: function(options) {  var that = this;  // 页面初始化 options为页面跳转所带来的参数  this.setData({    areaId: options.areaId  });  if (options.areaId == undefined) {    return;  }  // 向后端发送请求，获取areaId的区域信息  wx.request({    url: &#39;http://127.0.0.1:8888/demo/superadmin/getareabyid&#39;,    data: {      &quot;areaId&quot;: options.areaId    },    method: &#39;GET&#39;,    success: function(res) {      var area = res.data.area;      if (area == undefined) {        var toastText = &quot;获取数据失败&quot; + res.data.errMsg;        wx.showToast({          title: toastText,          icon: &#39;&#39;,          duration: 2000        });      } else {        that.setData({          areaName: area.areaName,          priority: area.priority        });      }    }  })}</code></pre></li><li><p>提交区域信息表单</p><pre><code class="javascript">formSubmit: function (e) {  var that = this;  // 默认为新增操作  var formData = e.detail.value;  var url = that.data.addUrl;  // 如果areaId不为空，则为更新操作  if (that.data.areaId != undefined) {    formData.areaId = that.data.areaId;    url = that.data.modifyUrl;  }  wx.request({    url: url,    data: JSON.stringify(formData),    method: &#39;POST&#39;,    header: {      &#39;Content-Type&#39;: &#39;application/json&#39;    },    success: function(res) {      var result = res.data.success;      var toastText = &quot;操作成功&quot;;      if (result != true) {        toastText = &quot;操作失败&quot; + res.data.errMsg;      }      wx.showToast({        title: toastText,        icon: &#39;&#39;,        duration: 2000      });      if (that.data.areaId == undefined) {        wx.redirectTo({          url: &#39;../list/list&#39;        })      }    }  });}</code></pre></li></ul><h3 id="4-9-区域信息编辑页的联调"><a href="#4-9-区域信息编辑页的联调" class="headerlink" title="4-9 区域信息编辑页的联调"></a>4-9 区域信息编辑页的联调</h3><h2 id="第5章-课程总结与展望"><a href="#第5章-课程总结与展望" class="headerlink" title="第5章 课程总结与展望"></a>第5章 课程总结与展望</h2><blockquote><p>从整体上复习下本门课程的知识点</p></blockquote><ol><li>HelloWorld Controller</li><li>表设计和实体类的创建</li><li>dao层配置：mybatis-config，</li><li>service层配置：事务，接口及实现类</li><li>Controller层：增删改查</li><li>微信小程序，微信开发者工具</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>993-MySQL集群（PXC）入门</title>
      <link href="/2019/07/05/993-MySQL-PXC/"/>
      <url>/2019/07/05/993-MySQL-PXC/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/993" target="_blank" rel="noopener">https://www.imooc.com/learn/993</a></p><p>简介：本课程以项目演示为例，讲解PXC集群原理、PXC数据同步与Replication同步的区别、PXC的多节点并发写入、Docker虚拟机部署MySQL集群，并以案例验证Replication方案的数据不一致性、PXC方案数据一致性</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p> 本章总体介绍本课程学习的目标和学到的知识。</p></blockquote><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1-1 引言"></a>1-1 引言</h3><p>引言：</p><ul><li><p>伴随互联网经济的兴起，越来越多的领域需要相应的技术方案</p></li><li><p>行业：打车软件、电商平台、直播平台、电子支付、媒体社交</p></li><li><p>案例：滴滴出行、淘宝/京东、斗鱼直播、支付宝/微信、QQ</p></li></ul><p>单机单节点数据库没有冗余设计，如果数据库节点挂掉（断电、断网），则全部不能使用（网站不能访问）</p><p>使用冗余设计，即数据库节点集群在一起，性能翻倍。数据库集群。</p><p><strong><em>向BAT高标准看齐。</em></strong></p><h3 id="1-2-天猫双十一案例"><a href="#1-2-天猫双十一案例" class="headerlink" title="1-2 天猫双十一案例"></a>1-2 天猫双十一案例</h3><p>天猫双十一：</p><ul><li>2017年天猫双11交易额1682亿元，3分钟破百亿，9小时破干亿</li><li>交易峰值32.5万/秒，支付峰值25.6万/秒，数据库峰值4200万/秒</li><li>云服务器、负载均衡、RDS云数据库等技术</li></ul><p>淘宝/天猫使用3000+台数据库</p><h3 id="1-3-微信红包案例"><a href="#1-3-微信红包案例" class="headerlink" title="1-3 微信红包案例"></a>1-3 微信红包案例</h3><p>微信红包：</p><ul><li>2017年除夕当天，全国人民总共收发142亿个红包，峰值42万/秒</li><li>央视春晚微信摇一摇互动总量达110亿次，峰值8.1亿/秒</li><li>请求排队串行化、双维度分库表等设计</li></ul><h3 id="1-4-技术学习的目标和方式"><a href="#1-4-技术学习的目标和方式" class="headerlink" title="1-4 技术学习的目标和方式"></a>1-4 技术学习的目标和方式</h3><p>技术学习的目标和方式</p><ul><li>向大型互联网应用看齐，学习架构设计和业务处理</li><li>由浅入深，循序渐进；案例由小到大，逐步扩展</li><li>“视频学习”优于“看书学习”</li></ul><h3 id="1-5-课程学习目标"><a href="#1-5-课程学习目标" class="headerlink" title="1-5 课程学习目标"></a>1-5 课程学习目标</h3><p>本门课程学习目标</p><ul><li><p>掌握PXC集群MySQL方案的原理</p></li><li><p>掌握PXC集群的强一致性</p></li><li><p>掌握PXC集群的高可用方案</p></li></ul><h3 id="1-6-硬件环境介绍"><a href="#1-6-硬件环境介绍" class="headerlink" title="1-6 硬件环境介绍"></a>1-6 硬件环境介绍</h3><p>硬件环境需求</p><ul><li>Win10×64专业版或企业版/Linux/MacOS</li><li>Docker虚拟机</li><li>内存8GB以上</li></ul><pre><code class="shell">docker ps -apxc * 3 + haproxy * 1</code></pre><h2 id="第2章-PXC原理"><a href="#第2章-PXC原理" class="headerlink" title="第2章 PXC原理"></a>第2章 PXC原理</h2><blockquote><p>本章介绍数据库集群的必要性，以项目演示在数据库集群、Tomcat集群、Redis集群、Nginx负载均衡的部署环境下，后台程序遇到各种宕机，但是后台程序仍然高可用，最后介绍PXC数据同步的原理。</p></blockquote><h3 id="2-1-单节点数据库的介绍"><a href="#2-1-单节点数据库的介绍" class="headerlink" title="2-1 单节点数据库的介绍"></a>2-1 单节点数据库的介绍</h3><p>数据库集群的必要性</p><p>单节点数据库的弊病：<br>情况说明</p><ul><li>大型互联网程序用户群体庞大，所以架构必须要特殊设计</li><li>单节点的数据库无法满足性能上的要求</li><li>单节点的数据库没有冗余设计，无法满足高可用</li></ul><p>单节点数据库压力测试：</p><ul><li><p>测试案例</p><pre><code class="mysql">mysqlslap -hlocalhost -uroot -p123456 -P3306# 并发量5000连接--concurrency=5000 --iterations=1 --auto-generate-sql--auto-generate-sql-load-type=mixed--auto-generate-sql-add-autoincrement--engine=innodb# 共测试5000条SQL语句--number-of-queries=5000--debug-info</code></pre></li><li><p>测试结果</p><pre><code class="bash">Benchmark    Running for engine innodb    Average number of seconds to run all queries: 0.234 seconds    Minimum number of seconds to run all queries:0.234 seconds    Maximum number of seconds to run all queries:0.234 seconds    Number of clients running queries:100    Average number of queries per client50Benchmark    Running for engine innodb    Average number of seconds to run all queries: 1.656 seconds    Minimum number of seconds to run all queries:1.656 seconds    Maximum number of seconds to run all queries:1.656 seconds    Number of clients running queries:500    Average number of queries per clien:10Benchmark    Running for engine innodb    Average number of seconds to run all queries: 2.187 seconds    Minimum number of seconds to run all queries:2.187 seconds    Maximum number of seconds to run all queries:2.187 seconds    Number of clients running queries:1000    Average number of queries per client:5</code></pre><p>并发100、500和1000个连接，执行5000次查询，单节点数据还可以正常应对，没有太大的问题。</p><p>当并发10000个连接执行10000次查询，数据库则会拒绝一部分请求，仅完成另一部分接收的请求。</p></li></ul><h3 id="2-2-PXC集群方案"><a href="#2-2-PXC集群方案" class="headerlink" title="2-2 PXC集群方案"></a>2-2 PXC集群方案</h3><p>单节点数据库的高可用测试：</p><p>测试案例</p><ul><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifkl2e6j30jl08qwes.jpg"  width="350" alt="单节点数据库的高可用测试"/></li></ul><p>MySQL高性能高可用集群方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifm5x9cj31do0lo0wr.jpg"  width="600" alt="MySQL高性能高可用集群方案"/><p>MySQL单表数据量不能超过2000万条。性能极速下降。 </p><p>Mycat：国内主流数据切分中间件，阿里巴巴开源、Java编写、跨平台。</p><p>分片：利用Mycat切分后，一组集群就叫一个分片。</p><p>切分算法</p><ul><li><p>按照日期の（年份/月份/天）进行切分切分</p></li><li><p>按照某一列的固定值（主键ID，对分片数2求余）切分</p></li></ul><p>PXC–&gt;HA–&gt;Mycat</p><p>PXC数据读写是强一致性，但是牺牲了性能</p><h3 id="2-3-Replication集群方案"><a href="#2-3-Replication集群方案" class="headerlink" title="2-3 Replication集群方案"></a>2-3 Replication集群方案</h3><p>协同过滤算法：</p><ul><li>浏览记录会产生日志数据，将日志数据保存到数据库中。大数据算法根据日志数据分析当前用户行为，找出与之相同兴趣的用户，然后向当前用户推荐其他用户的喜好的商品、新闻。</li></ul><p>单条日志数据没有太大意义，而大量日志数据才有使用价值。此时便可以使用Replication集群。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifpe3gvj30u00by0tx.jpg"  width="600" alt="MySQL高性能高可用集群方案"/><p>应用软件数据架构：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifn0csaj30ff08mq37.jpg"  width="400" alt="应用软件数据架构"/><h3 id="2-4-系统架构方案介绍"><a href="#2-4-系统架构方案介绍" class="headerlink" title="2-4 系统架构方案介绍"></a>2-4 系统架构方案介绍</h3><p>互联网大型应用架构分析：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi4w17xoj31000jcjz7.jpg" alt="系统架构方案"></p><p>互联网大型应用技术分析：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi4xg1xfj30vk0k0k16.jpg" alt="系统架构方案"></p><h3 id="2-5-APP项目介绍"><a href="#2-5-APP项目介绍" class="headerlink" title="2-5 APP项目介绍"></a>2-5 APP项目介绍</h3><p>APP项目截图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifo5e3lj310e0h2q5l.jpg"  width="600" alt="APP项目截图"/><p>【登录界面】-【欢迎界面】-【人才招聘界面】</p><p>APP项目架构设计：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifjbscbj30s608y0tk.jpg"  width="600" alt="APP项目架构设计"/><p>服务器端微服务之间的调用实现：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifowc6lj30p708xwf7.jpg"  width="600" alt="服务器端微服务之间的调用实现"/><p>消息队列实现业务的解耦。</p><p>生产者不知道谁来接收这个消息，消费者也不知道是哪个生产者发来的消息。</p><p>消息队列的两个功能：</p><ol><li>异步消息发送。</li><li>利用异步消息发送，进行业务功能的解耦。即把不是强依赖，不是实时返回的功能做成消息队列，这样不管是调用方还是被调用方的改动，对另一方的依赖就会减小甚至消除。</li></ol><h3 id="2-6-Docker虚拟机部署MySQL集群"><a href="#2-6-Docker虚拟机部署MySQL集群" class="headerlink" title="2-6 Docker虚拟机部署MySQL集群"></a>2-6 Docker虚拟机部署MySQL集群</h3><p>查看正在运行的容器：</p><pre><code class="shell">docker ps -a</code></pre><h3 id="2-7-APP项目演示"><a href="#2-7-APP项目演示" class="headerlink" title="2-7 APP项目演示"></a>2-7 APP项目演示</h3><p>如果PXC集群中的主机挂掉的数目超过一半，则其它也不能提供服务</p><p>大学所储备知识做出的项目：</p><ol><li><p>性能不足</p></li><li><p>故障抵御能力不足</p></li></ol><h3 id="2-8-PXC简介"><a href="#2-8-PXC简介" class="headerlink" title="2-8 PXC简介"></a>2-8 PXC简介</h3><p>Percona XtraDB Cluster</p><ul><li>PXC通过Galera将不同的MySQL实例连接起来，实现多主机群</li><li>PXC基于Percona Server（性能较MySQL有显著提升）</li><li>PXC是众多MySQL集群方案的一种</li></ul><p>PXC方案与Replication方案对比：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gikqijyej30pt0g0my1.jpg"  width="400" alt="PXC方案"/><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gikprxo8j30hu0bvglz.jpg"  width="350" alt="Replication方案"/><h3 id="2-9-PXC测试案例"><a href="#2-9-PXC测试案例" class="headerlink" title="2-9 PXC测试案例"></a>2-9 PXC测试案例</h3><pre><code class="shell">docker pa -a</code></pre><p>PXC方案：</p><pre><code class="mysql"># node1CREATE DATABASE test;USE test;# node5CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);# node4INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;), (2, &quot;Jack&quot;);</code></pre><p>Replication方案：</p><pre><code class="mysql"># masterCREATE DATABASE test;USE test;CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student    SET id = 1, name = &quot;Scott&quot;;# slaveINSERT INTO student    SET id = 2, name = &quot;Jack&quot;;</code></pre><p>PXC集群的节点之间是双向同步，没有主从之分。</p><p>Replication是单向同步，只能由主节点同步到从节点，从节点也可以写入数据，但不会同步数据到主节点。</p><p>PXC双向同步从演示的耗时看比Replication慢6倍，一个insert约80多毫秒，replication只要10多毫秒。</p><h3 id="2-10-PXC集群工作原理"><a href="#2-10-PXC集群工作原理" class="headerlink" title="2-10 PXC集群工作原理"></a>2-10 PXC集群工作原理</h3><p>PXC集群工作原理：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifqb2j3j31b80rw76u.jpg"  width="800" alt="PXC集群工作原理"/><p>数据的同步是由PXC完成的。</p><p>数据库事务，指的是逻辑上的一组操作，组成这组事务的操作，要么全部不成功，要么全部成功。</p><p>一个事务若有多个操作，则需要手动开启事务。且要手动提交事务，才能将操作持久化到数据库。</p><h2 id="第3章-PXC数据强一致性"><a href="#第3章-PXC数据强一致性" class="headerlink" title="第3章 PXC数据强一致性"></a>第3章 PXC数据强一致性</h2><blockquote><p>本章介绍PXC和Replication两种集群方案在数据同步上的区别。</p></blockquote><h3 id="3-1-PXC与Replication方案优劣介绍"><a href="#3-1-PXC与Replication方案优劣介绍" class="headerlink" title="3-1 PXC与Replication方案优劣介绍"></a>3-1 PXC与Replication方案优劣介绍</h3><p>PXC的数据强一致性：</p><ul><li>同步复制，事务在所有集群节点要么同时提交，要么不提交</li><li>Replication采用异步复制，无法保证数据的一致性</li></ul><p>PXC和Replication方案优劣：</p><ul><li><p>Replication写入速度快，但是不能保证数据的一致性</p><p>异步复制，分为master节点和slave节点。</p><p>master节点写入数据提交事务后，即返回结果给客户端，不管slave节点的数据是否一致。</p></li><li><p>PXC可以保证数据的一致性，但是写入速康慢</p><p>PXC的数据强一致性牺牲了速度为代价。</p><p>节点间同步复制数据，将事务执行结果返回给客户端。</p></li><li><p>PXC和Replication只实现了数据的同步，没有数据切分功能</p></li></ul><p>PXC与Replication两种方案结合：</p><ol><li>重要数据保存在PXC集群。</li><li>非重要数据（操作的记录）保存在Replication集群</li></ol><p>当MySQL单表数据量超过2000万条时，性能会急剧下降，所以需要进行数据切分，即利用两个甚至多个集群来存储不同的数据</p><p>阿里巴巴开源中间件MyCat可以将两个集群做数据切分</p><h3 id="3-2-PXC与Replication方案性能对比"><a href="#3-2-PXC与Replication方案性能对比" class="headerlink" title="3-2 PXC与Replication方案性能对比"></a>3-2 PXC与Replication方案性能对比</h3><p>PXC和Replication方案性能对比：</p><ul><li>2016年春节，微信红包支付峰值15.8万次/秒，创下世界纪录</li><li>2017天猫双11，数据库峰值4200万次/秒，支付峰值25.6万次/秒</li></ul><p>PXC集群注意：</p><ol><li><p>PXC集群规模不能太大</p></li><li><p>PXC集群性能瓶颈不在于性能最好的节点，而在于性能最差的节点</p><p>尽量保证节点的配置一致</p></li></ol><p>PXC和Replication组合方案：</p><ul><li><p>PXC方案存储高价值数据，如：账户、订单、交易等等</p></li><li><p>Replication方案存储低价值数据，如：权限、通知、日志等等</p></li><li><p>用MyCat或JDBC-Sharding切分数据管理集群</p><p>按照主键ID值、年月日、某一字段等等进行切分</p></li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifk38zsj30h505iq32.jpg"  width="400" alt="PXC集群工作原理"/><p>MyCat本身也需要高可用、需冗余设计。</p><p>搭建两个MyCat，再用Linux的虚拟IP技术虚拟一个IP供客户端程序访问，再由两个MyCat去争抢这个虚拟IP，如果哪个MyCat挂了，另一个MyCat就会接收到这个IP继续提供服务。</p><h3 id="3-3-案例验证Replication方案的数据不一致性"><a href="#3-3-案例验证Replication方案的数据不一致性" class="headerlink" title="3-3 案例验证Replication方案的数据不一致性"></a>3-3 案例验证Replication方案的数据不一致性</h3><p>案例介绍：</p><ul><li><p>搭建一组两节点的Replication集群</p></li><li><p>使用MyCat实现Master和Slave节点的读写分离</p></li><li><p>设置防火墙网络规则，Master和Slave之间禁止访问，断开同步</p><p>注：</p><ul><li>MyCat默认端口8066</li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifj5gsbj30s608y0tk.jpg"  width="400" alt="Replication方案案例介绍"/></li></ul><p>步骤：</p><ol><li><p>在Master创建数据库、数据表，同时插入两条数据：</p><pre><code class="mysql"># masterCREATE DATABASE test;USE test;CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;), (2, &quot;Jack&quot;);</code></pre><p>MyCat配置文件介绍：</p><pre><code class="xml">&lt;!-- schema.xml --&gt;&lt;dataHost describe=&quot;配置数据库连接&quot;&gt;    &lt;heartbeat describe=&quot;心跳检测，实时检测MySQL节点是否有效。如果MySQL节点挂掉，则向冗余节点发送请求&quot;&gt;    &lt;/heartbeat&gt;    &lt;writeHost describe=&quot;写节点。Master&quot;&gt;        &lt;readHost describe=&quot;读节点。Slave&quot;&gt;&lt;/readHost&gt;    &lt;/writeHost&gt;&lt;/dataHost&gt;</code></pre></li><li><p>在MyCat查询数据表可以查看到两条数据：</p><pre><code class="mysql"># MyCatSELECT * FROM student;</code></pre></li><li><p>关闭Master与Slave之间的同步设置：</p><p>同步操作是在Slave节点配置的。</p><pre><code class="mysql"># slaveSHOW SLAVE STATUS;# Salve_IO_Running Slave_SQL_Running# YES               YESSTOP SLAVE;# Salve_IO_Running Slave_SQL_Running# NO               NO</code></pre></li><li><p>在MyCat插入一条数据：</p><pre><code class="mysql"># MyCatINSERT INTO student(id, name)VALUES(3, &quot;admin&quot;);</code></pre></li><li><p>在MyCat查询数据表可以查看到只有两条数据，无步骤4中插入的数据</p><pre><code class="mysql"># MyCatSELECT * FROM student;</code></pre></li></ol><h3 id="3-4-案例验证PXC方案数据一致性"><a href="#3-4-案例验证PXC方案数据一致性" class="headerlink" title="3-4 案例验证PXC方案数据一致性"></a>3-4 案例验证PXC方案数据一致性</h3><p>案例介绍：</p><ul><li><p>搭建一组三节点的PXC集群</p></li><li><p>使用MyCat实现PXC节点的读写分离</p></li><li><p>设置防火墙网络规则，PXC之间禁止访问，断开同步</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifnems7j30f50863yn.jpg"  width="400" alt="Replication方案案例介绍"/></li></ul><pre><code class="shell"># 查看正在运行的容器docker ps -a# 进入node1数据库节点docker exec -it node1 bashiptables -A INPUT -p tcp --dport 4444 -j DROPiptables -A OUTPUT -p tcp --dport 4444 -j DROPiptables -A INPUT -p tcp --dport 4567 -j DROPiptables -A OUTPUT -p tcp --dport 4567 -j DROPiptables -A INPUT -p tcp --dport 4568 -j DROPiptables -A OUTPUT -p tcp --dport 4568 -j DROP# 进入node2数据库节点...# 进入node3数据库节点...</code></pre><h2 id="第4章-PXC的多节点并发写入"><a href="#第4章-PXC的多节点并发写入" class="headerlink" title="第4章 PXC的多节点并发写入"></a>第4章 PXC的多节点并发写入</h2><blockquote><p>本章介绍并演示PXC多节点并发写入和HaProxy高可用方案</p></blockquote><h3 id="4-1-PXC多节点并发写入"><a href="#4-1-PXC多节点并发写入" class="headerlink" title="4-1 PXC多节点并发写入"></a>4-1 PXC多节点并发写入</h3><p>多节点并发写入：</p><ul><li>PXC集群没有主从节点之分，任何节点都是可读可写的</li><li>Replication集群的主节点（写节点）宕机，从节点不能自动升级为主节点</li><li>Replication集群必须为主节点设置冗余节点，而PXC不必这样</li></ul><p>案例测试：</p><ul><li>利用Java程序向三节点的PXC集群每个节点同时写入数据</li><li>程序执行结束之后，查看每个节点的数据是否同步正确</li><li>得出PXC多节点并发写入的结论</li></ul><p>Java线程：</p><pre><code class="java">// MyThread.java@Dataclass MyThread extends Thread {    String url;    String username;    String pas sword;    String threadName;    override run() {        var con = DriverManager.getConnection(url, username, password);        var pst = con.prepareStatement(&quot;INSERT INTO student(name) VALUES (?)&quot;);        for(i : 1 ... 50) {            pst.setobject(1, threadName);            pst.execute;            Thread.sleep(5000);        }        con.close();        println(&quot;线程执行结束&quot;);    }}</code></pre><pre><code class="java">// Test.javaclass Test {    def static void main(String[] args) {        var t1=new MyThread(&quot;jdbc: mysq1://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        var t2=new MyThread(&quot;jdbc: mysql://127.0.0.1:3307/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        var t3=new MyThread(&quot;jdbc: mysql://127.0.0.1:3308/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        t1. start();        t2. start();        t3. start();    }}</code></pre><p>Java语法严谨、但啰嗦。</p><p>IBM开发了Xtend、SUN发开了Groovy、Kotlin等都扩展简化Java语法</p><h3 id="4-2-PXC多节点并发写入案例"><a href="#4-2-PXC多节点并发写入案例" class="headerlink" title="4-2 PXC多节点并发写入案例"></a>4-2 PXC多节点并发写入案例</h3><p>在已设置ID主键自增的情况下，为何PXC多节点并发写入的主键值不连续？</p><ul><li>多个节点并发写入时同时生成了相同的ID主键值，此时去同步其他数据库节点会因为ID值被占用而驳回同步，需要重新生成一个ID主键值后再发起同步请求。如：A节点用了主键2，B节点也 用了主键2，这个时候同步就不能进行，然后B节点就用了主键3，A节点就用了主键4。</li></ul><p>如何避免主键值不连续？</p><ul><li>将主键生成任务从数据库本地移交给数据库集群中间件，如MyCat。从而避免冲突，不连续</li></ul><p>验证PXC多节点并发写入数据库节点的数据是否同步成功：</p><pre><code class="mysql"># node1/node2/node3use test;SELECT COUNT(*) FROM student;</code></pre><p>同时多节点并发（三线程）写入50条记录，最终有150条记录。</p><p>PXC集群多节点并发写入验证数据的强一致性。</p><h3 id="4-3-Haproxy高可用方案介绍"><a href="#4-3-Haproxy高可用方案介绍" class="headerlink" title="4-3 Haproxy高可用方案介绍"></a>4-3 Haproxy高可用方案介绍</h3><p>Haproxy高可用方案：</p><ul><li><p>PXC节点可读可写，应该采用负载均衡技术管理这些节点</p></li><li><p>程序设计中，数据源接口应该单一，对接负载均衡中间件</p></li><li><p>Haproxy是著名的负载均衡中间件，很适合负载均衡PXC集群</p><p>注：</p><ul><li>NGINX可实现Tomcat的负载均衡，是基于HTTP协议的。最近新版NGINX才支持TCP/IP协议，产品还不够成熟。</li><li>故使用Haproxy做数据库集群的负载均衡。</li></ul></li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifqpcfyj30ho0ajq3e.jpg"  width="400" alt="Haproxy高可用方案"/><p>PXC集群最好是奇数数量（最少要三个节点），PXC集群可能出现脑裂的情况</p><h3 id="4-4-Haproxy高可用案例1"><a href="#4-4-Haproxy高可用案例1" class="headerlink" title="4-4 Haproxy高可用案例1"></a>4-4 Haproxy高可用案例1</h3><pre><code class="shell"># 查看正在运行的容器实例docker ps -a</code></pre><pre><code class="cfg"># haproxy.cfg# 配置管理画面listen admin_stats  # 管理信息的名字。可随意        bind 0.0.0.0:8888  # 管理画面的IP与端口，任何IP地址均可访问。        mode http  # 网络协议使用HTTP        stats uri /dbs  # 访问URI        stats realm Global\ statistics        stats auth admin:admin  # 管理画面的登录账号密码# 负载均衡listen proxy-mysql  # 负载均衡的名字。可随意        bind 0.0.0.0:3306  # 负载均衡的入口IP与端口，任何IP地址均可访问。        mode tcp  # 网络协议使用TCP。MySQL默认为TCP协议，不能为HTTP协议        balance roundrobin  # 使用轮询的方式去分发请求（分发权重）        option tcplog  # 记录日志        option mysql-check user haproxy  # 定期发送心跳检测，‘haproxy’为Haproxy容器的用户名        server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000        server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000        server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000        option tcpka</code></pre><h3 id="4-5-Haproxy高可用案例2"><a href="#4-5-Haproxy高可用案例2" class="headerlink" title="4-5 Haproxy高可用案例2"></a>4-5 Haproxy高可用案例2</h3><pre><code class="mysql"># haproxyCREATE DATABASE test;USE test;CREATE TABLE student (    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>867-Docker入门</title>
      <link href="/2019/06/29/867-Docker/"/>
      <url>/2019/06/29/867-Docker/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/867" target="_blank" rel="noopener">https://www.imooc.com/learn/867</a></p><p>简介：本课程从最基础的安装开始，通过大量的实际操作循序渐进地介绍Docker基本知识。从最基本的镜像、容器开始，学习Dockerfile编写，容器操作，到完成一个多容器的应用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程简介"><a href="#第1章-课程简介" class="headerlink" title="第1章 课程简介"></a>第1章 课程简介</h2><blockquote><p>介绍Docker以及安装方式</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>Docker简介：</p><blockquote><p>Docker是容器技术的代表。<br>容器技术本质上是<strong>将程序隔离、打包的一个技术</strong>。</p></blockquote><p>解决问题：</p><blockquote><p><strong>解决软件包安装的问题</strong><br>理顺了开发与运维环境的差异，使开发和运维可以使用同一种语言进行沟通</p></blockquote><p>Docker入门教程</p><blockquote><p>Docker简介：什么是Docker<br>镜像与容器<br>容器存储<br>Registry<br>多容器app</p></blockquote><p>面向用户</p><blockquote><p>对docker感兴趣的。开发、测试、运维</p></blockquote><p>预备知识</p><blockquote><p>linux命令行<br>bash shell脚本</p></blockquote><h3 id="1-2-Docker介绍"><a href="#1-2-Docker介绍" class="headerlink" title="1-2 Docker介绍"></a>1-2 Docker介绍</h3><p>什么是Docker</p><blockquote><p>Docker: an open source project to pack, ship and run any application as a lightweight container.<br>是一个开源的项目，可以使任何应用以轻量级的形式打包、发布和运行</p><p>Node. js: allows to package an application with all of its dependencies into a standardized unit.<br>允许一个应用程序及其所有依赖以一种标准的单位来进行打包</p></blockquote><blockquote><p>Docker 是一个开源的应用容器引擎，开发者可以打包他们的应用以及依赖包到一个可移植的容器中，<br>然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>与现有技术进行类比</p><blockquote><p>可以粗糙地理解为轻量级的虚拟机<br>开挂的chroot（chroot：对应用程序作了文件系统的分离）</p></blockquote><p>Docker与虚拟机：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif4j6saj30mq0dbdgu.jpg"  width="450" alt="Docker与虚拟机"/><p>注：</p><ul><li>左边为虚拟机，右边为Docker</li><li>Hypervisor层：虚拟出硬件</li><li>Guest OS：硬件上安装完全独立的Guest OS</li><li>Docker Engine：利用Namespace、Control Group将应用程序分离</li><li>Docker没有Hypervisor虚拟层，会轻量很多</li></ul><h3 id="1-3-docker-mac安装"><a href="#1-3-docker-mac安装" class="headerlink" title="1-3 docker mac安装"></a>1-3 docker mac安装</h3><ul><li><p>下载</p><blockquote><p>官网地址：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>下载安装包：<a href="https://www.docker.com/docker-windows" target="_blank" rel="noopener">https://www.docker.com/docker-windows</a></p></blockquote></li><li><p>安装</p><blockquote><p>打开docker<br>open Docker.dmg或双击Docker.dmg<br>将Docker拖到Applications里面</p><p>验证安装：docker info</p></blockquote></li><li><p>配置</p><blockquote><p>镜像加速：</p><p>【Preferences…】=&gt;【Advanced】=&gt;【Registry mirrors】</p></blockquote></li></ul><h3 id="1-4-docker-linux安装"><a href="#1-4-docker-linux安装" class="headerlink" title="1-4 docker linux安装"></a>1-4 docker linux安装</h3><pre><code class="shell">## Ubuntu# 安装docker本身sudo wget -qO- https://get.docker.com | sh# 允许非root用户运行dockersudo usermod -aG docker tyk# 验证安装docker info</code></pre><p>注：</p><ul><li>-q：标识输出要简单</li><li>O-：标识标准输出，而不是输出到文件</li></ul><pre><code class="shell">## CentOS7# 系统 CentOS-Extras 库中已带 Docker，可以直接安装：sudo yum install docker# 安装之后启动Docker服务，并让它随系统启动自动加载。sudo service docker startsudo chkconfig docker on</code></pre><h3 id="1-5-docker-windows安装"><a href="#1-5-docker-windows安装" class="headerlink" title="1-5 docker windows安装"></a>1-5 docker windows安装</h3><ul><li><p>下载</p><blockquote><p>官网地址：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>下载安装包：<a href="https://www.docker.com/docker-windows" target="_blank" rel="noopener">https://www.docker.com/docker-windows</a></p></blockquote></li><li><p>安装</p><blockquote><p>执行安装包：Docker for Windows Installer.exe</p><p>验证安装：docker info</p></blockquote></li><li><p>配置</p><blockquote><p>镜像加速：</p><p>【settings】=&gt;【Daemon】=&gt;【Registry mirrors】</p></blockquote></li></ul><h2 id="第2章-实践第一步"><a href="#第2章-实践第一步" class="headerlink" title="第2章 实践第一步"></a>第2章 实践第一步</h2><blockquote><p>创建第一个Hello world</p></blockquote><h3 id="2-1-docker架构介绍与实战"><a href="#2-1-docker架构介绍与实战" class="headerlink" title="2-1 docker架构介绍与实战"></a>2-1 docker架构介绍与实战</h3><p>Docker架构：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif53qczj30mm0cowfg.jpg"  width="600" alt="Docker架构"/><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif5kicqj30ha0b63yu.jpg"  width="400" alt="Docker架构"/><p> 使用ubuntu镜像，在里面运行了echo hello docker这个命令，输出就是hello docker</p><pre><code class="shell">docker run ubuntu echo hello docker    </code></pre><p>运行NGINX服务器：</p><pre><code class="shell">docker run nginx</code></pre><p>查看本地镜像：</p><pre><code class="shell">docker images</code></pre><p>运行daocloud.io/nginx镜像：</p><pre><code class="shell">docker run -d -p 8080:80 daocloud.io/nginx</code></pre><p>注：</p><ul><li>-d：使用守护进程启动</li><li>-p：端口映射，将nginx的80端口映射到本地的8080端口</li></ul><p>查看当前正在运行的容器：</p><pre><code class="shell">docker ps</code></pre><p>显示Docker相关信息的页面：</p><pre><code class="shell"># 将文件拷贝到Docker容器。# 将index.html文件拷贝到容器ID为17asdasdasa容器内部，路径为//usr/share/nginx/html# docker cp 文件 容器ID:容器内部文件路径docker cp index.html 17add7bbc58c://usr/share/nginx/html</code></pre><p>停止指定容器：</p><pre><code class="shell">docker stop 容器ID</code></pre><p><a href="https://www.runoob.com/docker/docker-commit-command.html" target="_blank" rel="noopener"><strong>保存容器为镜像</strong></a>：</p><blockquote><p>Docker在容器内的改动都是暂时的，没有被保存</p></blockquote><pre><code class="shell"># # 保存容器为镜像，镜像名为nginx-fundocker commit -m &#39;fun&#39; 容器ID nginx-fun</code></pre><p>删除指定镜像：</p><pre><code class="shell">docker rmi 镜像ID</code></pre><p>查看所有容器（正在运行和停止运行）：</p><pre><code class="shell">docker ps -a</code></pre><p>删除指定容器：</p><pre><code class="shell">docker rm 容器ID</code></pre><p>命令小结：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>docker pull</td><td>获取image</td></tr><tr><td>docker build</td><td>创建image</td></tr><tr><td>docker images</td><td>列出image</td></tr><tr><td>docker run</td><td>运行container</td></tr><tr><td>docker ps</td><td>列出正在运行的container</td></tr><tr><td>docker rm</td><td>删除container</td></tr><tr><td>docker rmi</td><td>删除image</td></tr><tr><td>docker cp</td><td>在host和container之间拷贝文件</td></tr><tr><td>docker commit</td><td>保存改动为新的image</td></tr></tbody></table><h2 id="第3章-Dockerfile介绍"><a href="#第3章-Dockerfile介绍" class="headerlink" title="第3章 Dockerfile介绍"></a>第3章 Dockerfile介绍</h2><blockquote><p>编写dockerfile</p></blockquote><h3 id="3-1-dockerfile介绍"><a href="#3-1-dockerfile介绍" class="headerlink" title="3-1 dockerfile介绍"></a>3-1 dockerfile介绍</h3><blockquote><p>通过编写简单的文件自创docker镜像</p></blockquote><p>第一个Dockerfile：</p><pre><code class="dockerfile">FROM alpine:latestMAINTAINER tyk 766564616@qq.comCMD echo &#39;hello docker&#39;</code></pre><p>注：</p><ul><li>依赖于基础镜像alpine:latest</li><li>标识镜像信息</li><li>需要运行的命令</li></ul><pre><code class="shell">mkdir dockerfile1cd dockerfile1# 产生一个Dockerfile文件touch Dockerfile# 编辑Dockerfile文件vim Dockerfile# 构建docker镜像docker build -t hello_docker .# 查看已安装Docker镜像docker images hello_docker# 运行Docker镜像docker run hello_docker</code></pre><p>注：</p><ul><li>-t：参数指定镜像名称</li><li>最后面的点（.）表示构建镜像文件的路径</li></ul><h3 id="3-2-dockerfile实战"><a href="#3-2-dockerfile实战" class="headerlink" title="3-2 dockerfile实战"></a>3-2 dockerfile实战</h3><p>第二个Dockerfile：</p><pre><code class="dockerfile"># 依赖于基础镜像ubuntuFROM ubuntu# 标识镜像信息MAINTAINER tyk 766564616@qq.com# 运行ubuntu命令，新增一个软件仓库镜像地址RUN sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list# 运行ubuntu命令，更新软件RUN apt-get update# 运行ubuntu命令，安装nginx。-y：默认yes不询问RUN apt-get install -y nginx# 拷贝本地文件到镜像内部COPY index.html /var/www/html# 将NGINX在前台启动ENTRYPOINT [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]# 镜像暴露服务的端口EXPOSE 80</code></pre><pre><code class="shell">mkdir dockerfile2cd dockerfile2touch Dockerfilevim Dockerfiletouch index.htmlvim index.htmldocker build -t 766564616/hello-nginx .docker run -d -p 80:80 766564616/hello-nginx使用curl进行测试curl http://localhost</code></pre><p>Dockerfile语法：</p><table><thead><tr><th>命令</th><th>用途</th><th>说明</th><th>是否必填</th></tr></thead><tbody><tr><td>FROM</td><td>base_image</td><td>指明基础镜像名称。</td><td>必填</td></tr><tr><td>RUN</td><td>执行命令</td><td>用于执行命令，当RUN执行完毕后，将产生一个新的文件层。</td><td>可选</td></tr><tr><td>ADD</td><td>添加文件</td><td>向镜像添加文件。可以添加远程文件</td><td>可选</td></tr><tr><td>COPY</td><td>拷贝文件</td><td>从主机向镜像复制文件。</td><td>可选</td></tr><tr><td>CMD</td><td>执行命令</td><td>指定此镜像启动时默认执行命令。容器执行入口</td><td>可选</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>用于指定需要暴露的网络端口号。</td><td>可选</td></tr><tr><td>WORKDIR</td><td>指定路径</td><td>设定此镜像后续操作的默认工作目录。</td><td>可选</td></tr><tr><td>MAINTAINER</td><td>维护者</td><td>可用于提供作者、版本及气他备注信息。</td><td>可选</td></tr><tr><td>ENV</td><td>设定环境变量</td><td>用于在镜像中添加环境变量。</td><td>可选</td></tr><tr><td>ENTRYPOINT</td><td>容器入口</td><td>在镜像中设定默认执行的二进制程序。容器执行入口</td><td>可选</td></tr><tr><td>USER</td><td>指定用户</td><td>在镜像构建过程中，生成或者切换到另一个用户。</td><td>可选</td></tr><tr><td>VOLUME</td><td>mount point</td><td>向镜像中挂载一个卷组。</td><td>可选</td></tr></tbody></table><h3 id="3-3-镜像分层"><a href="#3-3-镜像分层" class="headerlink" title="3-3 镜像分层"></a>3-3 镜像分层</h3><blockquote><p>Dockerfile中的每一行都产生一个新层</p></blockquote><pre><code class="dockerfile">FROM alpine:latest        4dffsd5454wqMAINTAINER tyk766564616   fbdfasdfasfd554CMD echo &#39;hello docker&#39;   3df545dfad4a</code></pre><p>每个命令都是单独保存的一层。只有容器层是RW，镜像中的各层都是RO</p><p>分层的好处：假如有很多container或者很多的Image，相同的镜像层会复用共享。一定程度上减小了储存空间的使用，运行起来方便。</p><h2 id="第4章-存储"><a href="#第4章-存储" class="headerlink" title="第4章 存储"></a>第4章 存储</h2><blockquote><p>对volume进行介绍</p></blockquote><h3 id="4-1-volume介绍"><a href="#4-1-volume介绍" class="headerlink" title="4-1 volume介绍"></a>4-1 volume介绍</h3><blockquote><p>提供独立于容器之外的持久化存储</p></blockquote><p>应用场景：</p><blockquote><p>比如数据库，可以将数据存储在容器外的分卷。</p><p>可以提供容器跟容器之间的数据共享。</p></blockquote><h3 id="4-2-volume操作"><a href="#4-2-volume操作" class="headerlink" title="4-2 volume操作"></a>4-2 volume操作</h3><p>第一种形式：</p><blockquote><p>Docker虚拟路径挂载到容器里面的路径</p></blockquote><pre><code class="shell">docker run -v 容器内部地址 镜像名称</code></pre><pre><code class="shell"># 运行nginx容器，通过-v挂载一个卷组docker run -d --name nginx -v /usr/share/nginx/html nginx# 查看指定容器信息# docker inspect 容器名称docker inspect nginx# 查看Mounts节点下的Sources节点和Destination节点信息# 该容器把宿主机的Sources对应目录挂载到容器内部的Destination的目录地址cd Sources对应的目录路径# 修改index.html文件echo &quot;it&#39;s 2016&quot; &gt; index.html# 进入到容器内部# docker exec -it 容器名称 /bin/bashdocker exec -it nginx /bin/bash# cd Destination对应的路径路径# 查看index.html文件cat index.html# 打印出刚刚修改后的内容，即挂载成功，映射关系正确</code></pre><p>第二种形式：</p><blockquote><p>本地目录挂载到容器里面的路径</p></blockquote><pre><code class="shell">docker run -v $PWD/code:/var/www/html nginx</code></pre><pre><code class="shell">docker run -d -p 80:80 -v $PWD/html:/usr/share/nginx/html nginx# 查看本地文件的内容cat html/index.html# 进入到容器内部docker exec -it 容器名称 /bin/bash# 发现其内容和本地文件的内容一致，即映射关系正确cat /usr/share/nginx/html/index.html</code></pre><p>第三种形式</p><blockquote><p>创建数据卷容器，将其挂载到其他容器</p></blockquote><pre><code class="shell">docker run --volumes-from 卷容器ID</code></pre><p>好处：</p><blockquote><p>可以多个容器挂载一个数据容器，实现数据共享</p></blockquote><pre><code class="shell">mkdir data# 产生一个仅有数据的容器docker create -v $PWD/data:/var/mydata --name data_container ubuntu# 从另外一个容器挂载， 运行并直接进入容器内部docker run -it --volumes-from data_container ubuntu /bin/basemounttouch /var/mydatawhatever.txtexit# 查看本地data目录下是否有whatever.txt文件ls data</code></pre><h2 id="第5章-镜像仓库"><a href="#第5章-镜像仓库" class="headerlink" title="第5章 镜像仓库"></a>第5章 镜像仓库</h2><blockquote><p>registry介绍与实战</p></blockquote><h3 id="5-1-registry介绍"><a href="#5-1-registry介绍" class="headerlink" title="5-1 registry介绍"></a>5-1 registry介绍</h3><p>Docker相关术语：</p><table><thead><tr><th>English</th><th>中文</th></tr></thead><tbody><tr><td>host</td><td>宿主机</td></tr><tr><td>image</td><td>镜像</td></tr><tr><td>container</td><td>容器</td></tr><tr><td>registry</td><td>镜像仓库</td></tr><tr><td>daemon</td><td>守护程序</td></tr><tr><td>client</td><td>客户端</td></tr></tbody></table><p>Registry相关命令：</p><pre><code class="shell"># 从镜像仓库中搜索指定镜像docker search image_name# 从镜像仓库中拉取指定镜像docker pull image_name# 将本地镜像推送到镜像仓库docker push image_name</code></pre><p>国内的一些镜像仓库：</p><blockquote><p>daocloud<br>时速云<br>阿里云</p></blockquote><h3 id="5-2-registry实战"><a href="#5-2-registry实战" class="headerlink" title="5-2 registry实战"></a>5-2 registry实战</h3><pre><code class="shell"># 在镜像仓库中搜索whalesaydocker search whalesay# 从镜像仓库中拉取镜像docker/whalesay到本地docker pull docker/whalesay# 查看本地镜像信息docker images# 运行docker/whalesay镜像，并指定参数docker run docker/whalesay cowsay Docker so fun# 在push之前，需要登录。默认登录到docker hubdocker login# 依赖docker/whalesay镜像产生新的766564616/whalesay镜像（类似复制）docker tag docker/whalesay 766564616/whalesay# 将镜像766564616/whalesay推送到镜像仓库docker push 766564616/whalesay# 到dockerhub官方地址，查看到自己push的镜像# https://hub.docker.com/</code></pre><h2 id="第6章-多容器app"><a href="#第6章-多容器app" class="headerlink" title="第6章 多容器app"></a>第6章 多容器app</h2><blockquote><p>介绍多容器app与实例</p></blockquote><h3 id="6-1-compose介绍"><a href="#6-1-compose介绍" class="headerlink" title="6-1 compose介绍"></a>6-1 compose介绍</h3><p>多容器app</p><blockquote><p>编写文本文件，文件描述多容器APP的结构然后通过工具docker-compose把它拉起来</p></blockquote><blockquote><p>docker-compose是独立的软件</p></blockquote><p>docker-compose安装：</p><blockquote><p>Mac/Windows：自带</p><p>Linux：curl <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p></blockquote><h3 id="6-2-compose-install-linux"><a href="#6-2-compose-install-linux" class="headerlink" title="6-2 compose-install-linux"></a>6-2 compose-install-linux</h3><p><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a></p><pre><code class="shell"># 下载docker-compose包到/usr/local/bin/docker-composecurl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/docker-compose# 给/usr/local/bin/docker-compose授可执行权限chmod +x /usr/local/docker-compose    # 验证安装docker-compose --version</code></pre><pre><code class="shell">uname -s# Linux$ uname -m# x86_64</code></pre><h3 id="6-3-compose实战"><a href="#6-3-compose实战" class="headerlink" title="6-3 compose实战"></a>6-3 compose实战</h3><p>实战案例介绍</p><blockquote><p>app名称：ghost<br>是一个博客平台程序，安装之后，可自己写文章或别人发布<br>架构：nginx、ghost app、mysql<br>分别分为三个容器</p></blockquote><p>docker-compose.yml文件</p><pre><code class="yaml">ghost-app:   build: ghost  depends_on:     - db  ports:     - &quot;2368:2368&quot;nginx:   build: nginx  ports:     - &quot;80:80&quot;  depends_on:     - ghost-appdb:   images: &quot;mysql:5.7.15&quot;</code></pre><p>实战操作：</p><pre><code class="shell"># ghost根路径mkdir ghostcd ghost# 存放Dockerfile和配置文件用来构建镜像mkdir ghostmkdir nginx# 存放博客的数据mkdir data</code></pre><ol><li><p>ghost镜像构建</p><pre><code class="shell"># /ghost# ghost镜像构建cd ghosttouch Dockerfilevim Dockerfile...touch config.jsvim config.js...</code></pre><pre><code class="dockerfile">### Dockerfile #### 依赖ghost官方镜像FROM ghost# 拷贝本地配置文件到镜像中COPY ./config.js /var/lib/ghost/config.js# 声明暴露服务的端口EXPOSE 2368# 执行启动命令。ghost为node.js程序，所以使用npm命令CMD [&quot;npm&quot;,&quot;start&quot;,&quot;--production&quot;]</code></pre><pre><code class="javascript">&lt;!-- config.js --&gt;var path = require(&#39;path&#39;),config;config = {    production: {        url:&#39;http://mytestblog.com&#39;,        mail: {},        database: {            client: &#39;mysql&#39;,            connection: {                host: &#39;db&#39;,                user: &#39;ghost&#39;,                password: &#39;ghost&#39;,                database: &#39;ghost&#39;,                port: &#39;3306&#39;,                charset: &#39;utf8&#39;            },            debug: false        },        paths: {            contentPath: path.join(process.env.GHOST_CONTENT,&#39;/&#39;)        },        server: {            host: &#39;0.0.0.0&#39;,            port: &#39;2368&#39;        }    }};module.exports = config;</code></pre></li><li><p>NGINX镜像构建</p><pre><code class="shell"># /ghostcd nginxtouch Dockerfilevim Dockerfile...touch nginx.confvim nginx.conf...</code></pre><pre><code class="dockerfile">### Dockerfile #### 依赖nginx官方镜像FROM nginx# 拷贝本地配置文件到镜像中COPY nginx.conf /etc/nginx/nginx.conf# 声明暴露服务的端口EXPOSE 80</code></pre><pre><code class="nginx">### nginx.conf ###worker_processes 4;events {worker_connections 1024;}http {    server {        listen 80;        location / {            proxy_pass http://ghost-app:2368;        }    }}</code></pre></li><li><p>准备compose文件，用于描述整个系统的架构</p><pre><code class="shell"># /ghosttouch docker-compose.ymlvim docker-compose.yml</code></pre><pre><code class="yaml">### docker-compose.yml ###version: &#39;2&#39;networks:     ghost: services:     ghost-app:         build: ghost        networks:             - ghost        depends_on:             - db        ports:             - &quot;2368:2368&quot;    nginx:         build: nginx        networks:             - ghost        depends_on:             - ghost-app        ports:             - &quot;80:80&quot;    db:         image: &quot;mysql:5.7.15&quot;        networks:             - ghost        environment:             MYSQL_ROOT_PASSWORD: 123456            MYSQL_USER: ghost            MYSQL_PASSWORD: ghost        volumes:             - $PWD/data:/var/lib/mysql        ports:             - &quot;3306:3306&quot;</code></pre></li><li><p>拉起系统</p><pre><code class="shell"># /ghost# 启动docker-compose up -d# 关闭docker-compose stop# 删除docker-compose rm# 构建docker-compose build</code></pre></li><li><p>访问<a href="http://localhost、http://localhost/ghost" target="_blank" rel="noopener">http://localhost、http://localhost/ghost</a></p></li></ol><h3 id="6-4-章节回顾"><a href="#6-4-章节回顾" class="headerlink" title="6-4 章节回顾"></a>6-4 章节回顾</h3><p>docker-compose.yml常用命令：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>build</td><td>本地创建镜像</td></tr><tr><td>command</td><td>覆盖缺省命令</td></tr><tr><td>depends_on</td><td>连接容器，服务依赖</td></tr><tr><td>ports</td><td>暴露端口</td></tr><tr><td>volumes</td><td>挂载卷组</td></tr><tr><td>image</td><td>拉取镜像</td></tr></tbody></table><p>docker-compose命令：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>up</td><td>启动服务</td></tr><tr><td>stop</td><td>停止服务</td></tr><tr><td>rm</td><td>删除服务中的各个容器</td></tr><tr><td>logs</td><td>观察各个容器中的日志</td></tr><tr><td>ps</td><td>列出服务相关的容器</td></tr></tbody></table><h2 id="第7章-总结"><a href="#第7章-总结" class="headerlink" title="第7章 总结"></a>第7章 总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="7-1-课程总结"><a href="#7-1-课程总结" class="headerlink" title="7-1 课程总结"></a>7-1 课程总结</h3><blockquote><p>Docker介绍：容器、镜像<br>如何制作镜像<br>如何分享镜像<br>如何持久化容器数据<br>如何编排一个多容器的应用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>824-第一个docker化的java应用</title>
      <link href="/2019/06/21/824-docker-java/"/>
      <url>/2019/06/21/824-docker-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/824" target="_blank" rel="noopener">https://www.imooc.com/learn/824</a></p><p>简介：Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。学完本课程你将了解到什么是docker，docker的思想以及诸如镜像，仓库，容器等核心概念。你将学会怎样运行一个容器，如何搭建私有仓库，怎么写dockerfile以及怎样把自己的应用放到容器中运行。docker将会是你的IT路上一笔不小的财富。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>对docker有个简单的印象，了解课程的安排。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>docker解决企业大部分痛点：</p><blockquote><ol><li>快速的持续集成</li><li>服务的弹性伸缩 </li><li>部署简单，解放了运维 </li><li>为企业节省了机器资源</li></ol></blockquote><p>课程内容：</p><ul><li><p>什么是Docker?</p><p>对Docker的认识，Docker的历史，初步介绍</p></li><li><p>理解Docker</p><p>Docker的核心理论、思想，解决了什么实际问题</p></li><li><p>走进Docker</p><p>Docker的具体技术</p></li><li><p>HelloWorld</p></li><li><p>Nginx服务</p><p>Docker命令、Docker网络</p></li><li><p>Docker化的Java Web</p></li></ul><h3 id="1-2-什么是docker"><a href="#1-2-什么是docker" class="headerlink" title="1-2 什么是docker"></a>1-2 什么是docker</h3><p>Docker历史</p><ul><li>2010 dotCloud PAAS</li><li>2013 docker开源</li><li>2014.6 Docker 1.0</li><li>2014.7 C轮 $4000万</li><li>2015.4 D轮 $9500万</li><li>至今Docker 1.13</li></ul><p><a href="http://docker.com" target="_blank" rel="noopener">Docker官网</a></p><p>什么是Docker</p><blockquote><p>Docker是一个用来装应用的容器，就像被子可以装水，笔筒可以放笔，书包可以放书一样，可以把Hello World放在Docker里，可以把网站放在Docker里，可以把程序放在Docker里。</p></blockquote><ul><li>docker是世界领先的软件容器化平台（Docker is the world’s leading software containerization<br>platform）</li><li>docker公司开发，开源，托管在github上</li><li>跨平台，支持Windows、Macos、Linux</li></ul><h2 id="第2章-了解docker"><a href="#第2章-了解docker" class="headerlink" title="第2章 了解docker"></a>第2章 了解docker</h2><blockquote><p>用形象的类比说明docker的集装箱、标准化、隔离的思想。在用几个工作学习中碰到的问题说明docker解决了哪些问题。</p></blockquote><h3 id="2-1-docker思想"><a href="#2-1-docker思想" class="headerlink" title="2-1 docker思想"></a>2-1 docker思想</h3><ul><li><p>集装箱：容器</p><p>保证我们的程序放在任何地方都不会缺少东西</p></li><li><p>标准化</p><ul><li><p>运输方式</p><p>Docker运输程序有一个超级码头。A B两台电脑，A执行Docker命令把鲸鱼派过来把A的程序送到超级码头，在由B执行Docker命令由鲸鱼把程序从超级码头送过来</p></li><li><p>存储方式</p><p>不需要再关系拷贝过来的应用存在哪里 只需要在Docker 执行命令</p></li><li><p>API接口</p><p>Docker提供了一系列的RESTFUL API接口，包含了对Docker也就是对应用的控制，其中包括停止 查看 删除等等</p><p>只需要在Docker执行同样的命令 就可以控制所有的应用</p></li></ul></li><li><p>隔离：轻量级容器虚拟机技术</p><p>利用Linux内核LXC技术，能够非常快速地创建docker容器</p><p>最底层的技术实际上是一种Linux的一种内核的限制机制（LXC，Linux Container）。LXC是一种轻量级的容器虚拟化技术，最大效率的隔离了进程和资源，通过CGroup 、Namespace等限制隔离进程组所使用的物理资源，如CPU 、I/O 、Memory等等。</p><p>容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求</p></li></ul><h3 id="2-2-docker解决了什么问题"><a href="#2-2-docker解决了什么问题" class="headerlink" title="2-2 docker解决了什么问题"></a>2-2 docker解决了什么问题</h3><ol><li><p>我本地运行没问题啊。</p><p>一个Java Web程序要启动起来需要依赖什么？</p><ol><li><p>操作系统</p><p>调用了操作系统不一致的系统命令</p></li><li><p>JDK</p><p>JDK版本，如：JDK1.7编译的class文件在JDK1.6上运行</p></li><li><p>Tomcat</p><p>Tomcat版本，旧版本配置可能在新版本中不再支持</p></li><li><p>代码</p><p>比如代码引用了磁盘上（C盘）的一个文件，系统环境编码</p></li><li><p>配置文件</p><p>可能少了某些配置文件</p></li></ol><p>docker解决了运行环境不一致带来的问题。</p></li><li><p>系统好卡，哪个哥们又写死循环了。</p><p>docker的隔离性，使自己运行的程序不受其他程序的影响。</p></li><li><p>双11来了，服务器撑不住啦。</p><p>docker的标准化让快速扩展，弹性伸缩变得简单。</p></li></ol><h2 id="第3章-走进docker"><a href="#第3章-走进docker" class="headerlink" title="第3章 走进docker"></a>第3章 走进docker</h2><blockquote><p>结合上面的类比引出docker的核心技术：镜像、仓库和容器的概念，并分别深入讲解技术、原理。</p></blockquote><h3 id="3-1-docker核心技术"><a href="#3-1-docker核心技术" class="headerlink" title="3-1 docker核心技术"></a>3-1 docker核心技术</h3><p>核心概念</p><ul><li>镜像：集装箱</li><li>仓库：超级码头</li><li>容器：运行程序的地方</li></ul><p>docker运行程序的过程</p><ul><li>去仓库把镜像运到本地，用命令把镜像运行起来变成容器。</li></ul><p>分别讲解核心概念</p><ul><li>Build：构建镜像</li><li>Ship：运输镜像，从仓库和主机上运输</li><li>Run：运行的镜像，就是容器</li></ul><h3 id="3-2-docker镜像"><a href="#3-2-docker镜像" class="headerlink" title="3-2 docker镜像"></a>3-2 docker镜像</h3><ol><li><p>docker镜像就是image。从本质上来说镜像就是一系列的文件（包括应用程序的文件，也包括应用环境的文件）。镜像以联合文件系统分层的形式保存到本地；</p></li><li><p>docker镜像：（docker中的文件系统都是只读的）</p></li></ol><p>Docker文件保存存储格式？</p><blockquote><p>联合文件系统（Union FS），联合文件系统是一种分层的文件系统，它可以将不同的目录挂到同一个虚拟的文件系统下面。</p><p>联合文件系统可以通过这种方式实现文件的分层，比如test1可以看做是第一层，test2可以看做是第二层，每一层有每一层自己的文件，Docker镜像就是利用了这种分层的概念来实现了镜像存储。</p></blockquote><p>docker镜像的存储方式</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigviqm7j30eh0awaap.jpg" width="350" alt="Docker镜像"/><ul><li>最底层：操作系统的引导</li><li>上面一层：具体的Linux操作系统</li><li>上面一层：具体的软件，比如说JDK、Tomcat</li><li>上面一层：我们自己的应用代码</li><li>最上面一层：容器层</li></ul><h3 id="3-3-docker容器"><a href="#3-3-docker容器" class="headerlink" title="3-3 docker容器"></a>3-3 docker容器</h3><ol><li>docker的容器可理解为一个进程（可以将容器想象为一个虚拟机）</li><li>docker容器中除了Container层可写外，其他层都是只读的</li><li>镜像的各层都是可读的，如果想对可读层进行修改操作，那么本层内容会传到可写层，然后再进行修改操作；</li><li>当我们的应用进行文件查找是会从最顶层可写层查找（因为可读层内容都传到可写层），如果可写层没有相应数据才会去可读层查找</li><li>容器中Container层可以修改（即可写），但是在镜像中Container层是不可以修改的，这样也就保证了同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰。</li></ol><h3 id="3-4-docker仓库"><a href="#3-4-docker仓库" class="headerlink" title="3-4 docker仓库"></a>3-4 docker仓库</h3><p>构建镜像的目的</p><blockquote><p>是为了在其机器上运行镜像程序。</p></blockquote><p>仓库的作用</p><blockquote><p>为了在其他地方运行，我们就需要将构建的镜像传递到目的地才可以，仓库可以起到传输传递作用。</p></blockquote><p>传输过程</p><blockquote><p>先将构建的镜像传到docker仓库中，再由目的地去docker仓库将我们的镜像拉过去，这样就完成了传输过程。</p></blockquote><p>docker仓库</p><ul><li>hub.docker.com（国际）</li><li>c.163.com（国内）</li></ul><h2 id="第4章-docker安装"><a href="#第4章-docker安装" class="headerlink" title="第4章 docker安装"></a>第4章 docker安装</h2><blockquote><p>分别在三中平台上讲解docker的安装。同学可以选择自己的平台观看。</p></blockquote><h3 id="4-1-window安装docker"><a href="#4-1-window安装docker" class="headerlink" title="4-1 window安装docker"></a>4-1 window安装docker</h3><p><a href="https://hub.docker.com/?overlay=onboarding" target="_blank" rel="noopener">https://hub.docker.com/?overlay=onboarding</a></p><p>查看Docker版本：</p><pre><code class="shell">docker version</code></pre><h3 id="4-2-macos安装docker"><a href="#4-2-macos安装docker" class="headerlink" title="4-2 macos安装docker"></a>4-2 macos安装docker</h3><p><a href="https://hub.docker.com/?overlay=onboarding" target="_blank" rel="noopener">https://hub.docker.com/?overlay=onboarding</a></p><h3 id="4-3-linux安装docker"><a href="#4-3-linux安装docker" class="headerlink" title="4-3 linux安装docker"></a>4-3 linux安装docker</h3><ul><li><p>Redhat&amp;CentOS：<br>系统要求：64-bit OS and version 3.10</p></li><li><p>Ubuntu</p><p>系统要求：64-bit OS and version 3.10</p></li></ul><blockquote><p>docker是在Linux的Ubuntu系统开发的，所以在Ubuntu系统是docker的最理想运行系统。</p></blockquote><p>Redhat&amp;CentOS：</p><pre><code class="shell"># 检查内核版本uname -r# 切换到root用户sudo# 保证系统为最新版本yum update# 卸载旧版本yum remove docker docker-common docker-selinux docker-engine# 安装Dockeryum install -y docker# 查看是否安装成功yum list installed | grep docker# 启动docker服务systemclt start docker# 查看是否启动成功systemclt status docker</code></pre><p>Ubuntu：</p><pre><code class="shell"># 检查内核版本uname -r# 切换到root用户su# 保证系统为最新版本apt-get update# 安装Dockerapt-get install -y docker.io# 安装Docker最新版本curl -s https://get.docker.com|sh# 是否安装成功(Client、Server)docker version# 启动Docker俯卧撑service docker start</code></pre><h2 id="第5章-docker初体验"><a href="#第5章-docker初体验" class="headerlink" title="第5章 docker初体验"></a>第5章 docker初体验</h2><blockquote><p>第一个实例：用helloworld镜像带入，熟悉docker最基本的两个命令，拉取镜像和运行容器，并讲解背后运行逻辑。</p></blockquote><h3 id="5-1-第一个docker镜像"><a href="#5-1-第一个docker镜像" class="headerlink" title="5-1 第一个docker镜像"></a>5-1 第一个docker镜像</h3><ol><li><p>从docker远程的仓库拉取镜像到本地</p><pre><code class="shell">docker pull [OPTIONS] NAME [:TAG]</code></pre><p>注：</p><ul><li>NAME项是必填，代表需要拉取的镜像名称</li><li>[:TAG]是可选的，代表镜像的版本</li><li>[OPTIONS]代表拉取的镜像参数</li></ul><p>例如：拉取hello-world镜像命令：</p><pre><code class="shell">docker pull hello-world</code></pre></li><li><p>查看我们本机都有哪些镜像，也可以验证我们的pull是否执行成功</p><pre><code class="shell">docker images [OPTIONS] [REPOSITORY[:TAG]]</code></pre><p>注：</p><ul><li>[OPTIONS]是镜像的参数</li><li>[REPOSITORY[:TAG]]是镜像的名称和版本</li></ul></li></ol><h3 id="5-2-第一个docker容器"><a href="#5-2-第一个docker容器" class="headerlink" title="5-2 第一个docker容器"></a>5-2 第一个docker容器</h3><p>运行docker镜像命令</p><pre><code class="shell">docker run [OPTIONS] IMAGE[:TAG][COMMAND] [ARG…]</code></pre><p>注：</p><ul><li>NAME项是必填，代表运行的镜像名称</li><li>[COMMAND]代表镜像运行的时候需要执行什么命令</li><li>[ARG…]代表命令所依赖的参数</li><li>[OPTIONS]代表运行的时候选项</li></ul><p>例如：运行hello-world镜像命令：</p><pre><code class="shell">docker run hello-world</code></pre><p>docker client 执行一条命令，然后根据命令内容发送相应的请求到 docker host，docker host 解析该请求，会首先查询本地镜像仓库是否有对应的资源，假如没有，则向远程镜像中心拉取镜像放回本地，接着在执行该镜像，初始化为一个容器。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigws3xnj30mi0bvmy6.jpg"  width="500" alt="Docker初体验"/><ol><li><p>Client ：本机的docker执行命令的客户端</p></li><li><p>DOCKER_HOST：本机docker服务</p></li><li><p>Registry：docker远程仓库</p></li></ol><p>docker pull 流程：</p><ul><li>在Client主机发出docker pull执行命令到DOCKER_HOST主机docker服务的Docker daemon中，Docker daemon会先在本机中寻找是否有相应的镜像，如果存在不进行任何操作，否则会从docker的远程仓库Registry中将相应的镜像拉取到本地服务</li></ul><p>docker run 流程：</p><ul><li>在Client主机发出docker run执行命令到DOCKER_HOST主机docker服务的Docker daemon中，Docker daemon会先在本机中寻找是否有相应的镜像，如果不存在则会从docker的远程仓库Registry中将相应的镜像拉取到本地服务，然后通过一定方式将镜像运行起来变成docker的容器。</li></ul><h2 id="第6章-docker运行nginx静态网站"><a href="#第6章-docker运行nginx静态网站" class="headerlink" title="第6章 docker运行nginx静态网站"></a>第6章 docker运行nginx静态网站</h2><blockquote><p>第二个实例：从运行nginx镜像引出docker网络概念和docker的端口映射，最后运行nginx容器。</p></blockquote><h3 id="6-1-运行nginx镜像"><a href="#6-1-运行nginx镜像" class="headerlink" title="6-1 运行nginx镜像"></a>6-1 运行nginx镜像</h3><p>运行NGINX：</p><ul><li>持久运行的容器</li><li>前台挂机 &amp; 后台运行</li><li>进入容器内部</li></ul><p>常用命令：</p><pre><code class="shell"># 查找Docker的nginx镜像docker search nginx# 获取Docker的nginx镜像docker pull nginx# 查看run的帮助信息docker run --help# 以后台运行方式运行docker镜像docker run -d nginx# 查看正在运行的容器docker ps# 查看运行容器的内部信息docker exec# 查看容器指定容器ID（CONTAINER_ID）的信息docker exec -it CONTAINER_ID bash# 停止容器docker stop CONTAINER_ID</code></pre><h3 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6-2 docker网络"></a>6-2 docker网络</h3><blockquote><p>Docker使用了Linux的namespace技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Docker容器一般会分配一个独立的Network Namespace。</p></blockquote><p>docker网络：</p><ul><li><p>网络类型</p><ol><li><p>Bridge（桥接）：</p><p>docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</p></li><li><p>Host（主机）：</p><p>容器不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p></li><li><p>None（无网络）：</p><p>Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。docker将不会和外界的任何网络进行通讯。</p></li><li><p>container模式：</p><p>新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p></li></ol></li><li><p>端口映射</p><p>Bridge网络模式需要使用独立的Namespace，就需要容器内的端口可以在主机上访问，这就是端口映射。</p><p>Docker可以指定容器内的某个端口与容器所在主机的某个端口进行映射，此时访问主机的端口就是访问容器内的端口</p></li></ul><p>docker网络示意图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigwe5jlj30ll0arwfn.jpg"  width="350" alt="Docker网络"/><p>运行nginx镜像，并指定主机的端口：</p><pre><code class="shell">docker run -d -p 8080:80 nginx</code></pre><p>注：</p><ul><li>使用 –p 参数，冒号前面为主机端口，后面为容器端口。</li></ul><p>docker开放所有随机端口映射到容器上：</p><pre><code class="shell">Docker run -d -P nginx</code></pre><p>查看网络端口信息：</p><pre><code class="shell">netstart -na | grep 8080</code></pre><h2 id="第7章-第一个java-web应用"><a href="#第7章-第一个java-web应用" class="headerlink" title="第7章 第一个java web应用"></a>第7章 第一个java web应用</h2><blockquote><p>最后一个实例：创建自己的镜像，引出dockerfile，讲解基本的dockerfile语法。然后讲解私有仓库的搭建。最后分别在两台机器上演示docker的跨平台运行我们的java web项目。</p></blockquote><h3 id="7-1-制作自己的镜像"><a href="#7-1-制作自己的镜像" class="headerlink" title="7-1 制作自己的镜像"></a>7-1 制作自己的镜像</h3><p><a href="https://segmentfault.com/a/1190000009237581" target="_blank" rel="noopener">Linux_基于Docker快速搭建个人博客网站</a></p><p>制作自己的镜像：</p><ul><li><p>dockerfile</p><p>是由一系列命令和参数构成的脚本。这些命令应用于基础镜像并最终创建一个新的镜像，简化了从头到尾的流程并极大的简化了部署工作。</p></li><li><p>docker build</p><p>用于使用Dockerfile创建镜像。</p></li><li><p>Jpress: <a href="http://jpress.io/" target="_blank" rel="noopener">http://jpress.io/</a></p><p>开源的java web应用。</p></li></ul><p>制作 JAVA WEB应用：</p><blockquote><p>dockerFile是docker镜像的创建脚本文件，告诉docker按照文件里的流程去创建镜像</p></blockquote><ul><li><p>创建Dockerfile文件</p><pre><code class="dockerfile"># 创建的镜像继承自指定的tomcatfrom tomcat# 创建镜像人的信息，可不写MAINTAINER tyk 766564616@qq.com# COPY  [本地war包]  [指定的tomcat/webapps/下]COPY jpress.war /usr/local/tomcat/webapps</code></pre></li><li><p>构建镜像，并把镜像命名为jpress</p><pre><code class="shell"># 执行这个Dokerfile脚本文件docker build -t jpress:latest .</code></pre><p>注：</p><ul><li>-t：构建镜像的名字</li><li>.：dockerfile文件的目录，.代表当前目录下</li></ul></li></ul><h3 id="7-2-运行自己的容器"><a href="#7-2-运行自己的容器" class="headerlink" title="7-2 运行自己的容器"></a>7-2 运行自己的容器</h3><p>启动构建好的镜像：</p><pre><code class="shell">docker run -d -p 8888:8080 jpress</code></pre><p>查看端口是否被占用：</p><pre><code>netstat -na|grep 8888</code></pre><p>安装mysql：</p><pre><code>docker pull mysql</code></pre><p>创建数据库并启动mysql：</p><pre><code>docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jpress mysql</code></pre><p>配置jpress：</p><p>查看本机实际IP地址：</p><pre><code>ifconfig</code></pre><p>上传至dockerhub</p><pre><code class="shell"># 登录docker login -u 用户名 -p 密码# docker push [用户名]/[镜像名]:[版本]docker push 766564616/jpress:latest# 登出docker logout</code></pre><h2 id="第8章-课程总结"><a href="#第8章-课程总结" class="headerlink" title="第8章 课程总结"></a>第8章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="8-1-课程总结"><a href="#8-1-课程总结" class="headerlink" title="8-1 课程总结"></a>8-1 课程总结</h3><ul><li><p>思想：集装箱、标准化，隔离</p></li><li><p>镜像（BUILD）、容器（SHIP）、仓库（RUN）</p></li><li><p>docker命令pull，build，run，stop，restart，exec…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>821-轻松愉快之玩转SpringData</title>
      <link href="/2019/06/15/821-SpringData/"/>
      <url>/2019/06/15/821-SpringData/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/821" target="_blank" rel="noopener">https://www.imooc.com/learn/821</a></p><p>简介：在企业级JavaEE应用开发中，对数据库的访问和操作是必须的。Spring Data作为SpringSource的其中一个子项目，旨在统一和简化对各类型持久化存储和访问，而不拘泥于是关系型数据库还是NoSQL数据存储，使得对数据库的访问变得方便快捷，并支持MapReduce框架及云计算服务；对于拥有海量数据的项目，可以用Spring Data来简化项目的开发，就如Spring Framework对JDBC、ORM的支持一样，Spring Data会让数据的访问变得更加方便，极大提高开发效率、提升程序员的幸福指数！</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>课程介绍</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>什么是Spring Data</p><blockquote><p>主旨：provide a familiar and consistent，Spring-based programming model for data access<br>​            提供一个熟悉的、一致的，基于Spring框架的数据访问框架。</p><p>简化数据库的访问。<br>历史：2010年提出，作者Rod Johnso，Spring Source项目<br>网址：<a href="http://projects.spring.io/spring-data/#quick-start" target="_blank" rel="noopener">http://projects.spring.io/spring-data/#quick-start</a></p></blockquote><p>Spring Data概览</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gig4qf3wj30h40c70tv.jpg" width="500" alt="Spring Data概览"/><p>Spring Data包含多个子项目</p><blockquote><ul><li><p>Spring Data JPA<br>减少数据访问层的开发量</p></li><li><p>Spring Data Mongo DB<br>基于分布于存储的数据库</p></li><li><p>Spring Data Redis<br>开源、C语言开发、支持网络内存、可持久化的Key-Value的数据库</p></li><li><p>Spring Data Solr<br>Solr是高性能的、Java语言开发、基于Lucence的全文搜索服务器</p></li></ul></blockquote><p>课程安排</p><blockquote><ul><li>传统方式访问数据库<br>原生JDBC、Spring JdbcTemplate</li><li>Spring Data快速起步</li><li>Spring Data JPA进阶<ul><li>Spring Data JPA高级</li></ul></li></ul></blockquote><h2 id="第2章-使用传统方式访问数据库"><a href="#第2章-使用传统方式访问数据库" class="headerlink" title="第2章 使用传统方式访问数据库"></a>第2章 使用传统方式访问数据库</h2><blockquote><p>先使用传统的JDBC方法操作数据库，进而再使用Spring JdbcTemplate方式操作数据库，并对比现存操作方式的优缺点</p></blockquote><h3 id="2-1-使用传统方式访问数据库"><a href="#2-1-使用传统方式访问数据库" class="headerlink" title="2-1 使用传统方式访问数据库"></a>2-1 使用传统方式访问数据库</h3><blockquote><ul><li>JDBC</li><li>Spring JdbcTemplate</li><li>弊端分析</li></ul></blockquote><h3 id="2-2-准备工作"><a href="#2-2-准备工作" class="headerlink" title="2-2 准备工作"></a>2-2 准备工作</h3><p>JDBC</p><blockquote><p>Connection<br>Statement<br>ResultSet<br>Test Case</p></blockquote><p>搭建开发环境</p><ul><li><p>创建maven项目<br>Maven工程的目录结构</p></li><li><p>添加数据库驱动和单元测试依赖</p><pre><code class="xml">&lt;!-- mysql --&gt;&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt;&lt;!-- junit --&gt;&lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.10&lt;/version&gt;   &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre></li><li><p>数据库表的准备，使用mysql数据库</p><pre><code class="mysql"># 创建数据库create database spring_data;# 创建数据表create table student(    id int not null auto_increment,    name varchar(20)not null,    age int not null,    primary key(id));# 查看表结构desc student;# 插入数据insert into student(name,age)values(&quot;zhangsan&quot;, 20);insert into student(name,age)values(&quot;lisi&quot;, 21);insert into student(name,age)values(&quot;wangwu&quot;, 22);# 查询数据select * from student;</code></pre></li></ul><h3 id="2-3-JDBCUtil开发"><a href="#2-3-JDBCUtil开发" class="headerlink" title="2-3 JDBCUtil开发"></a>2-3 JDBCUtil开发</h3><p>开发JDBCUtil工具类：</p><blockquote><p>获取Connection，关闭Connection、Statement、ResultSet<br>注意事项：配置的属性放置配置文件中，然后通过代码的方式将配置文件中的数据加载进来即可。</p></blockquote><p>代码示例：</p><pre><code class="java">package com.myimooc.springdata.jdbc.util;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * JDBC工具类： * 1）获取Connection * 2）释放资源 */public class JDBCUtils {    /**     * 获取Connection     * @return 所获得到的JDBC的Connection     */    public static Connection getConnection() throws Exception {        /**         * 不建议大家把配置硬编码到代码中         * 最佳实践：配置性的建议写到配置文件中         * *///        String url = &quot;jdbc:mysql:///spring_data&quot;;//        String username = &quot;root&quot;;//        String password = &quot;root&quot;;//        String dirverClass = &quot;com.mysql.jdbc.Driver&quot;;        InputStream inputStream =  JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);        Properties properties = new Properties();        properties.load(inputStream);        String url = properties.getProperty(&quot;jdbc.url&quot;);        String username = properties.getProperty(&quot;jdbc.username&quot;);        String password = properties.getProperty(&quot;jdbc.password&quot;);        String driverClass = properties.getProperty(&quot;jdbc.driverClass&quot;);        Class.forName(driverClass);        return DriverManager.getConnection(url,username,password);    }    /**     * 释放DB相关资源     */    public static void release(ResultSet resultSet, Statement statement, Connection connection) throws Exception {        if(resultSet != null ){            resultSet.close();        }        if(statement != null ){            statement.close();        }        if(connection != null ){            connection.close();        }    }}</code></pre><p>数据库连接配置文件：</p><pre><code class="properties"># db.propertiesjdbc.url = jdbc:mysql:///spring_datajdbc.user = rootjdbc.password = rootjdbc.driverClass = com.mysql.jdbc.Driver</code></pre><p>注：</p><ul><li>配置的属性放在配置文件中，然后通过代码的方式将配置文件中的数据加载进来即可。</li></ul><p>单元测试：</p><pre><code class="java">@Testpublic void testGetConnection() throws Exception {    Connection connection = JDBCUtil.getConnection();    Assert.assertNotNull(connection);}</code></pre><h3 id="2-4-Dao开发"><a href="#2-4-Dao开发" class="headerlink" title="2-4 Dao开发"></a>2-4 Dao开发</h3><p>建立对象模型及DAO层开发。</p><p>代码演示：</p><ol><li><p>对象模型</p><pre><code class="java">package com.myimooc.springdata.jdbc.domain;/** * Student实体类 */@Datapublic class Student {    /** 主键ID */    private Integer id;    /** 姓名 */    private String name;    /** 年龄 */    private int age;}</code></pre></li><li><p>DAO接口</p><pre><code class="java">package com.myimooc.springdata.jdbc.dao;import com.myimooc.springdata.jdbc.domain.Student;import java.util.List;/** * Student DAO访问接口 */public interface StudentDao {    /**     * 获取所有学生     * @return 所有学生     */    List&lt;Student&gt; listStudent();    /**     * 添加一个学生     * @param student 待添加的学生     */    void saveStudent(Student student);}</code></pre></li><li><p>DAO实现</p><pre><code class="java">package com.myimooc.springdata.jdbc.dao.impl;import com.myimooc.springdata.jdbc.dao.StudentDao;import com.myimooc.springdata.jdbc.domain.Student;import com.myimooc.springdata.jdbc.util.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;/** * Student DAO访问接口实现类：通过最原始的JDBC的方式操作 */public class StudentDaoImpl implements StudentDao {    public List&lt;Student&gt; listStudent() {        List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();        String sql = &quot;select id,name,age from student&quot;;        try (Connection connection = JDBCUtils.getConnection();             PreparedStatement preparedStatement = connection.prepareStatement(sql);             ResultSet resultSet = preparedStatement.executeQuery();) {            while(resultSet.next()) {                Student student = new Student();                student.setId(resultSet.getInt(&quot;id&quot;));                student.setName(resultSet.getString(&quot;name&quot;));                student.setAge(resultSet.getInt(&quot;age&quot;));                studentList.add(student);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            JDBCUtils.release(resultSet, preparedStatement, connection);        }        return studentList;    }    public void saveStudent(Student student) {        String sql = &quot;insert into student(name,age) values(?, ?)&quot;;        try (Connection connection = JDBCUtils.getConnection();             PreparedStatement preparedStatement = connection.prepareStatement(sql);) {            preparedStatement.setString(1, student.getName());            preparedStatement.setInt(2, student.getAge());            preparedStatement.executeUpdate();        } catch (Exception e) {            e.printStackTrace();        } finally {            JDBCUtils.release(resultSet,preparedStatement,connection);        }    }}</code></pre></li><li><p>单元测试</p><pre><code class="java">@Testpublic void listStudentTest(){    StudentDao studentDao = new StudentDaoImpl();    List&lt;Student&gt;  studentList = studentDao.listStudent();    for(Student student : studentList){        System.out.println(student);    }}@Testpublic void saveStudentTest(){    StudentDao studentDao = new StudentDaoImpl();    Student student = new Student(&quot;test&quot;, 30);    studentDao.saveStudent(student);}</code></pre></li></ol><h3 id="2-5-使用JdbcTemplate"><a href="#2-5-使用JdbcTemplate" class="headerlink" title="2-5 使用JdbcTemplate"></a>2-5 使用JdbcTemplate</h3><p>Spring JdbcTemplate</p><ul><li><p>添加maven依赖</p><pre><code class="xml">&lt;!--spring--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>DataSource &amp; JdbcTemplate注入</p><p>Spring配置文件</p><pre><code class="xml">&lt;!-- beans.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///spring_data&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;studentDAO&quot; class=&quot;com.imooc.dao.StudentDAOSpringJdbcImpl&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre></li><li><p>Test Case</p><pre><code class="java">public class DataSourceTest {    private ApplicationContext ctx = null;    @Before    public void setup(){        System.out.println(&quot;setup&quot;);        ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    }    @After    public void tearDown(){        System.out.println(&quot;tearDown&quot;);        ctx = null;    }    @Test    public void testDataSource(){        System.out.println(&quot;testDataSource&quot;);        DataSource dataSource = (DataSource)ctx.getBean(&quot;dataSource&quot;);        Assert.notNull(dataSource);    }    @Test    public void testJdbcTemplate(){        System.out.println(&quot;testJdbcTemplate&quot;);        JdbcTemplate jdbcTemplate = (JdbcTemplate)ctx.getBean(&quot;jdbcTemplate&quot;);        Assert.notNull(jdbcTemplate);    }}</code></pre></li><li><p>Dao实现</p><pre><code class="java">package com.imooc.dao;import com.imooc.domain.Student;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowCallbackHandler;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * StudentDAO访问接口实现类：通过Spring jdbc的方式操作 */@Datapublic class StudentDAOSpringJdbcImpl implements StudentDAO {    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public List&lt;Student&gt; query() {        final List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();        String sql = &quot;SELECT id, name, age FROM student&quot;;        jdbcTemplate.query(sql, new RowCallbackHandler() {            @Override            public void processRow(ResultSet rs) throws SQLException {                Student student = new Student();                student.setId(rs.getInt(&quot;id&quot;));                student.setName(rs.getString(&quot;name&quot;));                student.setAge(rs.getInt(&quot;age&quot;));                students.add(student);            }        });        return students;    }    @Override    public void save(Student student) {        String sql = &quot;INSERT INTO student(name, age) VALUES(?, ?)&quot;;        jdbcTemplate.update(sql, student.getName(), student.getAge());    }}</code></pre></li><li><p>单元测试</p><pre><code class="java">public class StudentDAOSpringJdbcImplTest {    private ApplicationContext ctx = null;    private StudentDAO studentDAO = null;    @Before    public void setup(){        System.out.println(&quot;setup&quot;);        ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        studentDAO = (StudentDAO)ctx.getBean(&quot;studentDAO&quot;);    }    @After    public void tearDown(){        System.out.println(&quot;tearDown&quot;);        ctx = null;    }    @Test    public void testQuery() {        List&lt;Student&gt; students = studentDAO.query();        for (Student student : students) {            System.out.println(&quot;student:&quot; + student);        }    }    @Test    public void testSave() {        Student student = new Student(&quot;test-spring-jdbc&quot;, 40);        studentDAO.save(student);    }}</code></pre><p>END</p></li></ul><p>代码演示：</p><ol><li><p>创建DB配置文件</p><pre><code class="properties">jdbc.url = jdbc:mysql:///springdatajdbc.username = rootjdbc.password = rootjdbc.driverClass = com.mysql.jdbc.Driver</code></pre></li><li><p>创建配置文件类</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.ImportResource;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;/** * 配置参数类 */@Data@PropertySource(value=&quot;classpath:db.properties&quot;)@Componentpublic class Properties {    @Value(&quot;${jdbc.driverClass}&quot;)    private String jdbcDriverClass;    @Value(&quot;${jdbc.url}&quot;)    private String jdbcUrl;    @Value(&quot;${jdbc.username}&quot;)    private String jdbcUser;    @Value(&quot;${jdbc.password}&quot;)    private String jdbcPassword;}</code></pre></li><li><p>配置DataSource、JdbcTemplate和Spring注解扫描</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;@Configuration@ComponentScan(&quot;com.myimooc.springdata.jdbctemplate&quot;)public class SpringConfig {    @Autowired    private Properties properties;    @Bean    DriverManagerDataSource getDriverManagerDataSource(){        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();        driverManagerDataSource.setDriverClassName(properties.getJdbcDriverClass());        driverManagerDataSource.setUrl(properties.getJdbcUrl());        driverManagerDataSource.setUsername(properties.getJdbcUser());        driverManagerDataSource.setPassword(properties.getJdbcPassword());        return driverManagerDataSource;    }    @Bean    JdbcTemplate getJdbcTemplate(){        JdbcTemplate jdbcTemplate = new JdbcTemplate();        jdbcTemplate.setDataSource(getDriverManagerDataSource());        return jdbcTemplate;    }}</code></pre></li><li><p>编写实体类</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.domain;/** * Student实体类 */@Datapublic class Student {    /** 主键ID */    private Integer id;    /** 姓名 */    private String name;    /** 年龄 */    private int age;}</code></pre></li><li><p>DAO接口</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.dao;import com.myimooc.springdata.jdbctemplate.domain.Student;import java.util.List;/** * StudentDAO访问接口 */public interface StudentDao {    /**     * 获取所有学生     * @return 所有学生     */    List&lt;Student&gt; listStudent();    /**     * 添加一个学生     * @param student 待添加的学生     */    void saveStudent(Student student);}</code></pre></li><li><p>DAO实现</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.dao.impl;import com.myimooc.springdata.jdbctemplate.dao.StudentDao;import com.myimooc.springdata.jdbctemplate.domain.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * StudentDAO访问接口实现类：通过 JdbcTemplate 的方式操作 */@Repositorypublic class StudentDaoImpl implements StudentDao {    @Autowired    private JdbcTemplate jdbcTemplate;    public List&lt;Student&gt; listStudent() {        List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();        String sql = &quot;select id, name, age from student&quot;;        List&lt;Map&lt;String,Object&gt;&gt;  mapList = jdbcTemplate.queryForList(sql);        for (Map&lt;String,Object&gt; mapTemp : mapList) {            Integer id = Integer.parseInt(mapTemp.get(&quot;id&quot;).toString());            String name = mapTemp.get(&quot;name&quot;).toString();            Integer age = Integer.parseInt(mapTemp.get(&quot;age&quot;).toString());            Student student = new Student();            student.setId(id);            student.setName(name);            student.setAge(age);            studentList.add(student);        }        return studentList;    }    public void saveStudent(Student student) {        String sql = &quot;insert into student(name, age) value(?,?)&quot;;        jdbcTemplate.update(sql,student.getName(),student.getAge());    }}</code></pre></li><li><p>单元测试类</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate;import com.myimooc.springdata.jdbctemplate.config.SpringConfig;import com.myimooc.springdata.jdbctemplate.dao.StudentDao;import com.myimooc.springdata.jdbctemplate.domain.Student;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;import java.util.List;/** *  使用 JdbcTemplate 实现 StudentDao 单元测试类 */public class StudentDaoTest {    private ApplicationContext ctx = null;    private StudentDao studentDao;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        studentDao = ctx.getBean(StudentDao.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void listStudentTest(){        List&lt;Student&gt; studentList = studentDao.listStudent();        for (Student student : studentList){            System.out.println(student.toString());        }    }    @Test    public void saveTest(){        Student student = new Student(&quot;test-spring-jdbcTemplate&quot;, 25);        studentDao.saveStudent(student);    }}</code></pre></li></ol><h3 id="2-6-弊端分析"><a href="#2-6-弊端分析" class="headerlink" title="2-6 弊端分析"></a>2-6 弊端分析</h3><blockquote><ul><li>DAO里面代码量太多</li><li>DAO的实现有很多重复代码</li><li>开发分页和其它功能，需要重新进行封装</li></ul></blockquote><h2 id="第3章-Spring-Data快速入门"><a href="#第3章-Spring-Data快速入门" class="headerlink" title="第3章 Spring Data快速入门"></a>第3章 Spring Data快速入门</h2><blockquote><p>完成该框架的开发环境搭建及单元测试，本课我们将使用IDEA开发并使用Maven构建项目；</p></blockquote><h3 id="3-1-开发环境搭建"><a href="#3-1-开发环境搭建" class="headerlink" title="3-1 开发环境搭建"></a>3-1 开发环境搭建</h3><p>Spring Data JPA快速起步</p><blockquote><ol><li>开发环境搭建</li><li>Spring Data JPA HelloWorld开发</li></ol></blockquote><ul><li><p>添加maven依赖：</p><pre><code class="xml">&lt;!--spring data jpa--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;    &lt;version&gt;1.8.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;    &lt;version&gt;4.3.6.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>DataSource &amp; JdbcTemplate注入</p><p><strong>Spring配置文件</strong>：</p><pre><code class="xml">&lt;!-- beans-new.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;    &lt;!-- Spring扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;&lt;/beans&gt;</code></pre><ol><li><p>配置数据源</p><pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///spring_data&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>配置EntityManagerFactory</p><pre><code class="xml">&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;jpaVendorAdapter&quot;&gt;        &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;    &lt;/property&gt;    &lt;property name=&quot;packagesToScan&quot; value=&quot;com.imooc&quot;/&gt;    &lt;property name=&quot;jpaProperties&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;hibernate.ejb.naming_strategy&quot;&gt;org.hibernate.cfg.ImprovedNamingStrategy&lt;/prop&gt;            &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt;            &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;            &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;            &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li><p>配置事务管理器</p><pre><code class="xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;    &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>配置支持注解的事务</p><pre><code class="xml">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></pre></li><li><p>配置spring data</p><pre><code class="xml">&lt;jpa:repositories base-package=&quot;com.imooc&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot;/&gt;</code></pre></li></ol></li><li><p>创建实体类</p><pre><code class="java">/** * 雇员:  先开发实体类===&gt;自动生成数据表 */@Data@Entitypublic class Employee {    @Id    @GeneratedValue    private Integer id;    @Column(length = 20, nullable = false)    private String name;    private Integer age;}</code></pre></li><li><p>单元测试</p><pre><code class="java">public class SpringDataTest {    private ApplicationContext ctx = null;    @Before    public void setup(){        System.out.println(&quot;setup&quot;);        ctx = new ClassPathXmlApplicationContext(&quot;beans-new.xml&quot;);    }    @After    public void tearDown(){        System.out.println(&quot;tearDown&quot;);        ctx = null;    }    @Test    public void testEntityManagerFactory(){        // 运行单元测试，检查是否有生成一张数据表。有则成功，无则失败。    }}</code></pre><p>END</p></li></ul><p>代码演示：</p><ol><li><p>创建DB配置文件</p><pre><code class="properties">jdbc.url = jdbc:mysql:///springdatajdbc.username = rootjdbc.password = rootjdbc.driverClass = com.mysql.jdbc.Driver</code></pre></li><li><p>创建配置文件类</p><pre><code class="java">package com.myimooc.springdata.jpa.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Data@Component@PropertySource(value=&quot;classpath:db.properties&quot;)public class PropertiesConfig {    @Value(&quot;${jdbc.driverClass}&quot;)    private String jdbcDriverClass;    @Value(&quot;${jdbc.url}&quot;)    private String jdbcUrl;    @Value(&quot;${jdbc.username}&quot;)    private String jdbcUser;    @Value(&quot;${jdbc.password}&quot;)    private String jdbcPassword;}</code></pre></li><li><p>配置TransactionManager、EntityManagerFactory和Spring自动扫描注入</p><pre><code class="java">package com.myimooc.springdata.jpa.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.jdbc.datasource.DriverManagerDataSource;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.Database;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import java.util.Properties;/** * Spring配置类 */// 声明为配置类@Configuration// 启用事务管理@EnableTransactionManagement// 启用自动扫描继承 JpaRepository 接口的类。// 注意，此注解需要配置 entityManagerFactory 和 transactionManager// 方式一：定义获取Bean方法名为 entityManagerFactory 和 transactionManager// 方式二：配置 @EnableJpaRepositories注解的 entityManagerFactoryRef 属性 为自定义获取Bean的方法名。@EnableJpaRepositories(basePackages = &quot;com.myimooc.springdata.jpa&quot;)// 启用自动扫描 @Component 注解的Bean@ComponentScan(basePackages = &quot;com.myimooc.springdata.jpa&quot;)public class SpringConfig {    @Autowired    private PropertiesConfig propertiesConfig;    /**     * 配置数据源     * @return     */    @Bean    public DriverManagerDataSource dataSource(){        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();        driverManagerDataSource.setDriverClassName(propertiesConfig.getJdbcDriverClass());        driverManagerDataSource.setUrl(propertiesConfig.getJdbcUrl());        driverManagerDataSource.setUsername(propertiesConfig.getJdbcUser());        driverManagerDataSource.setPassword(propertiesConfig.getJdbcPassword());        return driverManagerDataSource;    }    /**     * 配置事务管理器 JpaTransactionManager     * @return     */    @Bean(name=&quot;transactionManager&quot;)    public PlatformTransactionManager transactionManager(){        JpaTransactionManager transactionManager = new JpaTransactionManager();        transactionManager.setDataSource(this.dataSource());        transactionManager.setEntityManagerFactory(this.entityManagerFactory().getObject());        return transactionManager;//        return new DataSourceTransactionManager(this.dataSource());//        return new JpaTransactionManager(this.entityManagerFactory().getObject());    }    /**     * 配置JPA的 EntityManagerFactory     * @return     */    @Bean    public LocalContainerEntityManagerFactoryBean entityManagerFactory(){        LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();        entityManagerFactory.setDataSource(dataSource());        HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();        jpaVendorAdapter.setGenerateDdl(true);        jpaVendorAdapter.setDatabase(Database.MYSQL);        entityManagerFactory.setJpaVendorAdapter(jpaVendorAdapter);        entityManagerFactory.setPackagesToScan(&quot;com.myimooc.springdata.jpa&quot;);        Properties jpaProperties = new Properties();//        jpaProperties.setProperty(&quot;hibernate.ejb.naming_strategy&quot;,&quot;org.hibernate.cfg.ImprovedNamingStrategy&quot;);        jpaProperties.setProperty(&quot;hibernate.dialect&quot;,&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;);        jpaProperties.setProperty(&quot;hibernate.show_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.format_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.hbm2ddl.auto&quot;,&quot;update&quot;);        entityManagerFactory.setJpaProperties(jpaProperties);        return entityManagerFactory;    }}</code></pre></li><li><p>编写实体类：Employee</p><pre><code class="java">package com.myimooc.springdata.jpa.domain;import javax.persistence.*;/** * 雇员：先开发实体类，然后自动生成实体表 */@Data@Entity@Table(name = &quot;test_employee&quot;)public class Employee {    @Id    @GeneratedValue    private Integer id;    @Column(length = 20)    private String name;    private Integer age;}</code></pre></li></ol><h3 id="3-2-起步程序开发"><a href="#3-2-起步程序开发" class="headerlink" title="3-2 起步程序开发"></a>3-2 起步程序开发</h3><ol><li><p>编写EmployeeRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.repository.Repository;/** * 使用 Repository 接口 */// 方式二：使用 @RepositoryDefinition 注解//  @RepositoryDefinition(domainClass = Employee.class,idClass = Integer.class)public interface EmployeeRepository extends Repository&lt;Employee,Integer&gt; { //方式一：继承 Repository 接口    /**     * 获取雇员对象通过名称     */    Employee findByName(String name);}</code></pre></li><li><p>编写单元测试类：EmployeeRepositoryTest</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeeRepository;import com.myimooc.springdata.jpa.service.EmployeeService;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import java.util.ArrayList;import java.util.List;/** * EmployeeRepository单元测试类 */public class EmployeeRepositoryTest {    private ApplicationContext ctx = null;    private EmployeeRepository employeeRepository = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeRepository = ctx.getBean(EmployeeRepository.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void findByNameTest(){        // org.springframework.data.ipa.repository.support.SimpleJpaRepository@566        System.out.println(employeeRepository);        Employee employee = employeeRepository.findByName(&quot;cc&quot;);        System.out.println(employee.toString());    }}</code></pre></li></ol><p>Repository</p><blockquote><p>Repository：Spring Data核心类<br>RepositoryDefinition：使用该注解进行配置<br>Repository Query Specification：查询时，方法命名不能乱写<br>Query Annotation：使用该注解，可以实现原生SQL查询<br>Update/Delete/Transaction：更新、删除操作，支持事务</p></blockquote><p>Repository Hierarchy：层次结构</p><blockquote><p>CrudRepository：内置了新增、更新、删除、查询方法<br>PagingAndSortingRespository：分页和排序<br>JpaRepository：<br>JpaSpecificationExcutor</p></blockquote><h2 id="第4章-Spring-Data-JPA进阶"><a href="#第4章-Spring-Data-JPA进阶" class="headerlink" title="第4章 Spring Data JPA进阶"></a>第4章 Spring Data JPA进阶</h2><blockquote><p>使用Spring Data JPA完成CRUD操作</p></blockquote><h3 id="4-1-关于Repository接口"><a href="#4-1-关于Repository接口" class="headerlink" title="4-1 关于Repository接口"></a>4-1 关于Repository接口</h3><p>Repository接口详解</p><blockquote><p>Repository接口是Spring Data的核心接口，不提供任何方法<br>public interface Repository&lt;T, ID extends Serializable&gt;{}</p><p>@RepositoryDefinition注解的使用<br>@RepositoryDefinition(domainClass = Employee.class, idClass = Integer.class)</p></blockquote><p>Repository类的定义：</p><blockquote><ul><li><p>Repository是一个空接口，标记接口。没有包含方法声明的接口</p></li><li><p>如果我们定义的接口EmployeeRepository extends Repository，会被Spring管理。<br>如果我们自己的接口没有extends Repository，运行时会报错，没有这个Bean：</p><pre><code class="java">org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.imooc.repository.EmployeeRepository&#39; available</code></pre></li><li><p>添加RepositoryDefinition注解能到达到不用extends Repository的功能</p></li></ul></blockquote><h3 id="4-2-Repository子接口详解"><a href="#4-2-Repository子接口详解" class="headerlink" title="4-2 Repository子接口详解"></a>4-2 Repository子接口详解</h3><p>Repository子接口详解</p><blockquote><p>CrudRepository：继承Repository，实现了CRUD相关的方法<br>PagingAndSortingRepository：继承CrudRepository，实现了分页排序相关的方法<br>JpaRepository：继承PagingAndSortingRepositor，实现JPA规范相关的方法</p></blockquote><h3 id="4-3-查询方法定义规则和使用"><a href="#4-3-查询方法定义规则和使用" class="headerlink" title="4-3 查询方法定义规则和使用"></a>4-3 查询方法定义规则和使用</h3><p>Repository中查询方法定义规则和使用</p><blockquote><p>了解Spring Data中查询方法名称的定义规则<br>使用Spring Data完成复杂查询方法名称的命名</p></blockquote><p>查询方法定义规则</p><table><thead><tr><th>Keyword</th><th>Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td>And</td><td>findByLastnameAndFirstname</td><td>where x.lastname=?1 and x.firstname=?2</td></tr><tr><td>Or</td><td>findByLastnameOrFirstname</td><td>where x.lastname=?1 or x.firstname=?2</td></tr><tr><td>Between</td><td>findByStartDateBetween</td><td>where x.startDate between 1? and ?2</td></tr><tr><td>LessThan</td><td>findByAgeLessThan</td><td>where x.age&lt;?1</td></tr><tr><td>GreaterThan</td><td>findByAgeGreaterThan</td><td>where x.age&gt;?1</td></tr><tr><td>After</td><td>findByStartDateAfter</td><td>where x.startDate&gt;?1</td></tr><tr><td>Before</td><td>findByStartDateBefore</td><td>where x.startDate&lt;?1</td></tr><tr><td>IsNull</td><td>findByAgelsNull</td><td>where x.age is null</td></tr><tr><td>IsNotNul, NotNull</td><td>findByAge(Is)NotNull</td><td>where x.age not null</td></tr><tr><td>Like</td><td>findByFirstnameLike</td><td>where x.firstname like ?1</td></tr><tr><td>Notlike</td><td>findByFirstnameNotlike</td><td>where x. firstname not like ?1</td></tr><tr><td>StartingWith</td><td>findByFirstnameStartingWith</td><td>where x.firstname like ?1(parameter bound with appended %)</td></tr><tr><td>EndingWith</td><td>findByFirstnameEndingWith</td><td>where x.firstname like ?1(parameter bound with prepended %)</td></tr><tr><td>Containing</td><td>findByFirstnameContaining</td><td>where x.firstname like ?1(parameter bound wrapped in %)</td></tr><tr><td>OrderBy</td><td>findByAgeOrderByLastnameDesc</td><td>where x.age=?1 order by x.lastname desc</td></tr><tr><td>Not</td><td>findByLastnameNot</td><td>where x.lastname&lt;&gt;?1</td></tr><tr><td>In</td><td>findByAgeln(Collection<Age> ages)</td><td>where x.age in ?1</td></tr><tr><td>Notln</td><td>findByAgeNotin(Collection<Age> age)</td><td>where x.age not in ?1</td></tr><tr><td>TRUE</td><td>findByActiveTrue</td><td>where x.active=true</td></tr><tr><td>FALSE</td><td>findByActiveFalse</td><td>where x.active=false</td></tr></tbody></table><p>代码演示：</p><pre><code class="sql">-- 测试数据insert into employee (name, age) values (&quot;test1&quot;,20);insert into employee (name, age) values (&quot;test2&quot;,21);insert into employee (name, age) values (&quot;test3&quot;,22);insert into employee (name, age) values (&quot;test4&quot;,20);insert into employee (name, age) values (&quot;test5&quot;,21);insert into employee (name, age) values (&quot;test6&quot;,22);insert into employee (name, age) values (&quot;test16&quot;,22);</code></pre><ol><li><p>在EmployeeRepository接口编写以下代码</p><pre><code class="java">// --- 使用JPA规范查询 ---// where name like ?% and age &lt; ?List&lt;Employee&gt; findByNameStartingWithAndAgeLessThan(String name,Integer age);// where name like %? and age &lt; ?List&lt;Employee&gt; findByNameEndingWithAndAgeLessThan(String name,Integer age);// where name in (?, ?...) or age &lt; ?List&lt;Employee&gt; findByNameInOrAgeLessThan(List&lt;String&gt; name,Integer age);// where name in (?, ?...) and age &lt; ?List&lt;Employee&gt; findByNameInAndAgeLessThan(List&lt;String&gt; name,Integer age);</code></pre></li><li><p>在EmployeeRepositoryTest单元测试类进行测试</p><pre><code class="java">@Testpublic void findByNameStartingWithAndAgeLessThanTest(){    List&lt;Employee&gt; employees = employeeRepository.findByNameStartingWithAndAgeLessThan(&quot;test&quot;,22);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}@Testpublic void findByNameEndingWithAndAgeLessThanTest(){    List&lt;Employee&gt; employees = employeeRepository.findByNameEndingWithAndAgeLessThan(&quot;6&quot;,23);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}@Testpublic void findByNameInOrAgeLessThanTest(){    List&lt;String&gt; names = new ArrayList&lt;String&gt;();    names.add(&quot;test1&quot;);    names.add(&quot;test2&quot;);    names.add(&quot;test3&quot;);    List&lt;Employee&gt; employees = employeeRepository.findByNameInOrAgeLessThan(names,22);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}@Testpublic void findByNameInAndAgeLessThanTest(){    List&lt;String&gt; names = new ArrayList&lt;String&gt;();    names.add(&quot;test1&quot;);    names.add(&quot;test2&quot;);    names.add(&quot;test3&quot;);    List&lt;Employee&gt; employees = employeeRepository.findByNameInAndAgeLessThan(names,22);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}</code></pre></li></ol><p>对于按照方法命名规则来使用的话，有弊端：</p><blockquote><p>1）方法名比较长：约定大于配置<br>2）对于一些复杂的查询，是很难实现。</p></blockquote><p>使用@Query注解来解决以上弊端。</p><h3 id="4-4-Query注解使用"><a href="#4-4-Query注解使用" class="headerlink" title="4-4 Query注解使用"></a>4-4 Query注解使用</h3><p>Query注解使用</p><blockquote><ul><li>在Respository方法中使用，不需要遵循查询方法命令规则</li><li>只需要将@Query定义在Respository中的方法之上即可</li><li>命名参数及索引参数的使用</li><li>本地查询</li></ul></blockquote><ol><li><p>在EmployeeRepository接口编写以下代码</p><pre><code class="java">// --- 使用@Query注解查询 ---// 自定义查询SQL。Employee为类名，不是表名@Query(&quot;select o from Employee o where id=(select max(id) from Employee t1)&quot;)Employee getEmployeeByMaxId();// 使用占位符进行参数绑定@Query(&quot;select o from Employee o where o.name=?1 and o.age=?2&quot;)List&lt;Employee&gt; listEmployeeByNameAndAge(String name, Integer age);// 使用命名参数进行参数绑定@Query(&quot;select o from Employee o where o.name=:name and o.age=:age&quot;)List&lt;Employee&gt; listEmployeeByNameAndAge2(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;)Integer age);// 自定义查询SQL，like,占位符进行参数绑定@Query(&quot;select o from Employee o where o.name like %?1%&quot;)List&lt;Employee&gt; listEmployeeByLikeName(String name);// 自定义查询SQL，like,命名参数进行参数绑定@Query(&quot;select o from Employee o where o.name like %:name%&quot;)List&lt;Employee&gt; listEmployeeByLikeName2(@Param(&quot;name&quot;) String name);// 使用原生态SQL查询。employee为表名@Query(nativeQuery = true,value = &quot;select count(1) from employee&quot;)long getCount();</code></pre></li><li><p>在EmployeeRepositoryTest单元测试类进行测试</p><pre><code class="java">//  使用 @Query 注解查询@Testpublic void getEmployeeByMaxIdTest(){    Employee employee = employeeRepository.getEmployeeByMaxId();    System.out.println(employee);}@Testpublic void listEmployeeByNameAndAgeTest(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByNameAndAge(&quot;zhangsan&quot;,20);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void listEmployeeByNameAndAge2Test(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByNameAndAge2(&quot;zhangsan&quot;,20);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void listEmployeeByLikeNameTest(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByLikeName(&quot;test1&quot;);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void listEmployeeByLikeName2Test(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByLikeName2(&quot;test&quot;);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void getCountTest(){    long count = employeeRepository.getCount();    System.out.println(count);}</code></pre></li></ol><h3 id="4-5-更新操作整合事务使用"><a href="#4-5-更新操作整合事务使用" class="headerlink" title="4-5 更新操作整合事务使用"></a>4-5 更新操作整合事务使用</h3><p>更新及删除操作整合事务的使用</p><blockquote><ul><li>@Modifying注解使用</li><li>@Modifying结合@Query注解执行更新操作</li><li>@Transaction在Spring Data中的使用</li></ul></blockquote><ol><li><p>基于javaconfig在SpringConfig类进行事务配置</p><pre><code class="java">package com.myimooc.springdata.jpa.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.jdbc.datasource.DriverManagerDataSource;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.Database;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import java.util.Properties;/** * Spring配置类 */// 声明为配置类@Configuration// 启用事务管理@EnableTransactionManagement// 启用自动扫描继承 JpaRepository 接口的类。// 注意，此注解需要配置 entityManagerFactory 和 transactionManager// 方式一：定义获取Bean方法名为 entityManagerFactory 和 transactionManager// 方式二：配置 @EnableJpaRepositories注解的 entityManagerFactoryRef 属性 为自定义获取Bean的方法名。@EnableJpaRepositories(basePackages = &quot;com.myimooc.springdata.jpa&quot;)// 启用自动扫描 @Component 注解的Bean@ComponentScan(basePackages = &quot;com.myimooc.springdata.jpa&quot;)public class SpringConfig{    @Autowired    private PropertiesConfig propertiesConfig;    // 配置数据源    @Bean    public DriverManagerDataSource dataSource(){        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();        driverManagerDataSource.setDriverClassName(propertiesConfig.getJdbcDriverClass());        driverManagerDataSource.setUrl(propertiesConfig.getJdbcUrl());        driverManagerDataSource.setUsername(propertiesConfig.getJdbcUser());        driverManagerDataSource.setPassword(propertiesConfig.getJdbcPassword());        return driverManagerDataSource;    }    // 配置事务管理器 JpaTransactionManager    @Bean(name=&quot;transactionManager&quot;)    public PlatformTransactionManager transactionManager(){        JpaTransactionManager transactionManager = new JpaTransactionManager();        transactionManager.setDataSource(this.dataSource());        transactionManager.setEntityManagerFactory(this.entityManagerFactory().getObject());        return transactionManager;//        return new DataSourceTransactionManager(this.dataSource());//        return new JpaTransactionManager(this.entityManagerFactory().getObject());    }    // 配置JPA的 EntityManagerFactory    @Bean    public LocalContainerEntityManagerFactoryBean entityManagerFactory(){        LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();        entityManagerFactory.setDataSource(dataSource());        HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();        jpaVendorAdapter.setGenerateDdl(true);        jpaVendorAdapter.setDatabase(Database.MYSQL);        entityManagerFactory.setJpaVendorAdapter(jpaVendorAdapter);        entityManagerFactory.setPackagesToScan(&quot;com.myimooc.springdata.jpa&quot;);        Properties jpaProperties = new Properties();//        jpaProperties.setProperty(&quot;hibernate.ejb.naming_strategy&quot;,&quot;org.hibernate.cfg.ImprovedNamingStrategy&quot;);        jpaProperties.setProperty(&quot;hibernate.dialect&quot;,&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;);        jpaProperties.setProperty(&quot;hibernate.show_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.format_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.hbm2ddl.auto&quot;,&quot;update&quot;);        entityManagerFactory.setJpaProperties(jpaProperties);        return entityManagerFactory;    }}</code></pre></li><li><p>在EmployeeRepository接口编写以下代码</p><pre><code class="java">// 更新数据，需添加@Modifying、@Transactional@Modifying@Query(&quot;update Employee o set o.age = :age where o.id = :id&quot;)void updateAgeById(@Param(&quot;id&quot;)Integer id,@Param(&quot;age&quot;)Integer age);</code></pre></li><li><p>定义Service层，实际开发中，需要定义接口，这里为了演示方便，直接使用类。</p><pre><code class="java">package com.myimooc.springdata.jpa.service;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeeCrudRepository;import com.myimooc.springdata.jpa.repository.EmployeeRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Servicepublic class EmployeeService {    @Autowired    private EmployeeRepository employeeRepository;    @Autowired    private EmployeeCrudRepository employeeCrudRepository;    @Transactional    public void updateAgeById(Integer id, Integer age){        this.employeeRepository.updateAgeById(id,age);    };    @Transactional    public void save(List&lt;Employee&gt; employees){        this.employeeCrudRepository.save(employees);    }}</code></pre></li><li><p>编写EmployeeService单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.service;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.repository.EmployeeRepository;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.transaction.PlatformTransactionManager;/** * EmployeeService单元测试类 */public class EmployeeServiceTest {    private ApplicationContext ctx = null;    private EmployeeService employeeService = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeService = ctx.getBean(EmployeeService.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void transactionManagerTest(){        PlatformTransactionManager transactionManager = (PlatformTransactionManager)ctx.getBean(PlatformTransactionManager.class);        Assert.assertNotNull(transactionManager);    }    // 更新操作    @Test    public void updateAgeByIdTest(){        employeeService.updateAgeById(1,55);    }}</code></pre></li></ol><p>事务在Spring data中的使用：</p><blockquote><ol><li>事务一般是在Service层</li><li>@Query、@Modifying、@Transaction的综合使用</li></ol></blockquote><h2 id="第5章-Spring-Data-JPA高级"><a href="#第5章-Spring-Data-JPA高级" class="headerlink" title="第5章 Spring Data JPA高级"></a>第5章 Spring Data JPA高级</h2><blockquote><p>详解Spring Data JPA的Repository核心接口的各种子类的使用</p></blockquote><h3 id="5-1-CrudRepository接口使用详解"><a href="#5-1-CrudRepository接口使用详解" class="headerlink" title="5-1 CrudRepository接口使用详解"></a>5-1 CrudRepository接口使用详解</h3><p>CrudRepository接口使用详解</p><blockquote><p>save(entity)：保存一个实体<br>save(entities)：保存多个实体<br>findOne(id)：找到一个对象<br>exists(id)：根据ID判断对象是否存在<br>findAll()：找到所有实体对象<br>delete(id)：根据ID删除实体对象<br>delete(entity)：根据实体对象删除实体对象<br>delete(entities)：删除多个实体对象<br>deleteAll()：删除所有实体对象</p></blockquote><ol><li><p>编写EmployeeCrudRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.repository.CrudRepository;/** * 使用 CrudRepository 接口 */public interface EmployeeCrudRepository extends CrudRepository&lt;Employee,Integer&gt;{}</code></pre></li><li><p>编写EmployeeCrudRepositoryTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import java.util.ArrayList;import java.util.List;/** * EmployeeRepository单元测试类 */public class EmployeeCrudRepositoryTest {    private ApplicationContext ctx = null;    private EmployeeService employeeService = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeCrudRepository = ctx.getBean(EmployeeService.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void saveTest(){        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();        Employee employee = null;        for(int i=0;i&lt;100;i++){            employee = new Employee();            employee.setName(&quot;test&quot;+i);            employee.setAge(100 - i);            employees.add(employee);        }        employeeService.save(employees);    }}</code></pre></li></ol><h3 id="5-2-PagingAndSortingRespsitory接口使用详解-14-48"><a href="#5-2-PagingAndSortingRespsitory接口使用详解-14-48" class="headerlink" title="5-2 PagingAndSortingRespsitory接口使用详解 (14:48)"></a>5-2 PagingAndSortingRespsitory接口使用详解 (14:48)</h3><p>PagingAndSortingRespository接口使用详解</p><blockquote><ul><li>该接口包含分页和排序的功能</li><li>带排序的查询：findAll(Sort sort)</li><li>带排序的分页查询：findAll(Pageable pageable)</li></ul></blockquote><ol><li><p>编写EmployeePagingAndSortingRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.repository.PagingAndSortingRepository;/** * 使用 PagingAndSortingRepository 实现分页和排序功能 */public interface EmployeePagingAndSortingRepository extends PagingAndSortingRepository&lt;Employee,Integer&gt; {}</code></pre></li><li><p>编写EmployeePagingAndSortingRepositoryTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeePagingAndSortingRepository;import com.myimooc.springdata.jpa.service.EmployeeService;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.repository.PagingAndSortingRepository;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import java.util.ArrayList;import java.util.List;/** * PagingAndSortingRepository 单元测试类 */public class EmployeePagingAndSortingRepositoryTest {    private ApplicationContext ctx = null;    private EmployeePagingAndSortingRepository employeePagingAndSortingRepository = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeePagingAndSortingRepository = ctx.getBean(EmployeePagingAndSortingRepository.class);    }    @After    public void destroy(){        ctx = null;    }    /**     * 分页功能测试     */    @Test    public void pageTest(){        // page: index是从0开始的，不是从1开始的        Pageable pageable = new PageRequest(0,9);// page,size        Page&lt;Employee&gt; employeePage = employeePagingAndSortingRepository.findAll(pageable);        System.out.println(&quot;查询的总页数：&quot;+employeePage.getTotalPages());        System.out.println(&quot;查询的总记录数：&quot;+employeePage.getTotalElements());        System.out.println(&quot;查询的当前第几页：&quot;+(employeePage.getNumber() + 1));        System.out.println(&quot;查询的当前页面的集合：&quot;+employeePage.getContent());        System.out.println(&quot;查询的当前页面的记录数：&quot;+employeePage.getNumberOfElements());    }    /**     * 分页和排序功能测试     */    @Test    public void pageAndSort(){        Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;);// 升/降序,规则字段        Sort sort = new Sort(order);        // page: index是从0开始的，不是从1开始的        Pageable pageable = new PageRequest(0,5,sort);// 先排序，再分页        Page&lt;Employee&gt; employeePage = employeePagingAndSortingRepository.findAll(pageable);        System.out.println(&quot;查询的总页数：&quot;+employeePage.getTotalPages());        System.out.println(&quot;查询的总记录数：&quot;+employeePage.getTotalElements());        System.out.println(&quot;查询的当前第几页：&quot;+(employeePage.getNumber() + 1));        System.out.println(&quot;查询的当前页面的集合：&quot;+employeePage.getContent());        System.out.println(&quot;查询的当前页面的记录数：&quot;+employeePage.getNumberOfElements());    }}</code></pre></li></ol><h3 id="5-3-JpaRepository接口使用详解"><a href="#5-3-JpaRepository接口使用详解" class="headerlink" title="5-3 JpaRepository接口使用详解"></a>5-3 JpaRepository接口使用详解</h3><p>JpaRepository接口使用详解</p><blockquote><p>finaAll：查询所有记录<br>findAll(Sort sort)：查询所有记录并排序<br>save(entities)：保存多个实体对象<br>fiush：<br>deleteInBatch(entities)：一个批次里面删除那些实体</p></blockquote><ol><li><p>编写EmployeeJpaRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.PagingAndSortingRepository;/** * 使用 JpaRepository 接口 */public interface EmployeeJpaRepository extends JpaRepository&lt;Employee,Integer&gt; {}</code></pre></li><li><p>编写EmployeeJpaRepositoryTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeeJpaRepository;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.PagingAndSortingRepository;/** * EmployeeJpaRepository 单元测试类 */public class EmployeeJpaRepositoryTest {    private ApplicationContext ctx = null;    private EmployeeJpaRepository employeeJpaRepository = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeJpaRepository = ctx.getBean(EmployeeJpaRepository.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void findTest(){        Employee employee = employeeJpaRepository.findOne(99);        System.out.println(&quot;employee&quot; + employee);        System.out.println(&quot;employee(10)&quot; + employeeJpaRepository.exists(10));// true        System.out.println(&quot;employee(102)&quot; + employeeJpaRepository.exists(102));// false    }}</code></pre></li></ol><h3 id="5-4-JpaSpecificationExecutor接口使用详解"><a href="#5-4-JpaSpecificationExecutor接口使用详解" class="headerlink" title="5-4 JpaSpecificationExecutor接口使用详解"></a>5-4 JpaSpecificationExecutor接口使用详解</h3><p>JpaSpecificationExecutor接口使用详解（JPA规范执行者）</p><blockquote><p>Specification封装了JPA Criteria(JAP标准)查询条件</p><p>Repository接口体系无法携带一些查询条件</p></blockquote><p>代码演示：</p><ol><li><p>编写EmployeeJpaSpecificationExecutor接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;/** * 使用 JpaSpecificationExecutor 接口 */public interface EmployeeJpaSpecificationExecutor extends JpaRepository&lt;Employee,Integer&gt; , JpaSpecificationExecutor&lt;Employee&gt;{}</code></pre></li><li><p>编写EmployeeJpaSpecificationExecutorTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.domain.Specification;import javax.persistence.criteria.*;/** * EmployeeJpaSpecificationExecutor 单元测试类 */public class EmployeeJpaSpecificationExecutorTest {    private ApplicationContext ctx = null;    private EmployeeJpaSpecificationExecutor employeeJpaSpecificationExecutor = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeJpaSpecificationExecutor = ctx.getBean(EmployeeJpaSpecificationExecutor.class);    }    @After    public void destroy(){        ctx = null;    }    /**     * 1、分页     * 2、排序     * 3、查询条件:age &gt; 50     */    @Test    public void queryTest(){        Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;);        Sort sort = new Sort(order);        // page: index是从0开始的，不是从1开始的        Pageable pageable = new PageRequest(0,5,sort);        /**         * root : 就是我们要查询的类型 (Employee)         * query : 添加查询条件         * cb : 构建 Predicate         */        Specification&lt;Employee&gt; specification = new Specification&lt;Employee&gt;() {            // 查询条件            public Predicate toPredicate(Root&lt;Employee&gt; root,                                         CriteriaQuery&lt;?&gt; query,                                         CriteriaBuilder cb)             {                // root (employee (age))                Path path = root.get(&quot;age&quot;);                return cb.gt(path,50);            }        };        Page&lt;Employee&gt; employeePage = employeeJpaSpecificationExecutor.findAll(specification,pageable);        System.out.println(&quot;查询的总页数：&quot; + employeePage.getTotalPages());        System.out.println(&quot;查询的总记录数：&quot; + employeePage.getTotalElements());        System.out.println(&quot;查询的当前第几页：&quot; + (employeePage.getNumber() + 1));        System.out.println(&quot;查询的当前页面的集合：&quot; + employeePage.getContent());        System.out.println(&quot;查询的当前页面的记录数：&quot; + employeePage.getNumberOfElements());    }}</code></pre></li></ol><h2 id="第6章-课程总结"><a href="#第6章-课程总结" class="headerlink" title="第6章 课程总结"></a>第6章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="6-1-课程总结"><a href="#6-1-课程总结" class="headerlink" title="6-1 课程总结"></a>6-1 课程总结</h3><blockquote><p>Spring Data概览<br>传统方式访问数据库<br>Spring Data快速起步<br>Spring Data JPA进阶<br>Spring Data JAP高级</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>810-Spring Boot进阶之Web进阶</title>
      <link href="/2019/06/09/810-SpringBoot-Web/"/>
      <url>/2019/06/09/810-SpringBoot-Web/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/810" target="_blank" rel="noopener">https://www.imooc.com/learn/810</a></p><p>简介：《2小时学习Spring Boot》后续进阶课程，主要讲述了Spring Boot针对Web方面的相关技巧 讲师实战课程《Spring Boot微信点餐系统》 <a href="http://coding.imooc.com/class/117.html" target="_blank" rel="noopener">http://coding.imooc.com/class/117.html</a> 《Spring Cloud微服务实战》 <a href="http://coding.imooc.com/class/187.html" target="_blank" rel="noopener">http://coding.imooc.com/class/187.html</a> 均已上线</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>课程介绍</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><blockquote><p>本课程紧接着《<a href="https://www.imooc.com/learn/767" target="_blank" rel="noopener">2小时学会SpringBoot</a>》课程，请先看入门课。</p></blockquote><ol><li>使用@Valid表单验证</li><li>使用AOP处理请求</li><li>统一异常处理</li><li>单元测试</li></ol><h2 id="第2章-Web进阶"><a href="#第2章-Web进阶" class="headerlink" title="第2章 Web进阶"></a>第2章 Web进阶</h2><blockquote><p>SpringBoot进阶中web方面的内容</p></blockquote><h3 id="2-0-表单验证"><a href="#2-0-表单验证" class="headerlink" title="2-0 表单验证"></a>2-0 表单验证</h3><blockquote><p>项目源码：<a href="https://gitee.com/liaoshixiong/girl" target="_blank" rel="noopener">https://gitee.com/liaoshixiong/girl</a></p></blockquote><pre><code class="shell"># 克隆项目代码git clone git@gitee.com:liaoshixiong/girl.git# 切换分支git checkout -b web-2 web-2</code></pre><p>当Girl的参数特别多的时候，可以使用Java实体类接收参数。</p><pre><code class="java">/** * 添加一个女生 */@PostMapping(value = &quot;/girls&quot;)public Girl girlAdd(Girl girl) {    return girlRepository.save(girl);}</code></pre><p>表单验证：</p><ol><li><p>在实体Bean里需要校验的字段上面添加注解</p><pre><code class="java">@Min(value = 18, message = &quot;未成年少女禁止入内&quot;)private Integer age;@NotNull(message = &quot;金额必传&quot;)private Integer money;</code></pre></li><li><p>在接收参数时，使用@Valid注解进行校验</p><pre><code class="java">@PostMapping(value = &quot;/girls&quot;)public Result&lt;Girl&gt; girlAdd(@Valid Girl girl, BindingResult bindingResult){    if(bindingResult.hasErrors()){        return ResultUtil.error(ResultUtil.RESPCODE_ERROR_PARAM,bindingResult.getFieldError().getDefaultMessage());    }    // ...}</code></pre></li></ol><h3 id="2-1-使用AOP处理请求-上）"><a href="#2-1-使用AOP处理请求-上）" class="headerlink" title="2-1 使用AOP处理请求(上）"></a>2-1 使用AOP处理请求(上）</h3><p>AOP统一处理请求日志</p><ol><li><p>AOP是一种编程方式</p><ul><li>与语言无关，是一种程序设计思想</li><li>面向切面（AOP）Aspect Oriented Programming</li><li>面向对象（OOP）Object Oriented Programming</li><li>面向过程（POP）Procedure Oriented Programming</li></ul></li><li><p>面向过程到面向对象</p><ul><li>面向过程：假如下雨了，我打开了雨伞</li><li>面向对象：天气-&gt;下雨，我-&gt;打伞</li></ul></li><li><p>换个角度看世界，换个姿势处理问题</p><ul><li><p>面向对象：将需求功能垂直划分为不同的并且相对独立的，封装为良好的类并且让其有自己的行为</p></li><li><p>面向切面：利用横切技术将面向对象的庞大体系进行水平切割，并且将影响到多个类的公共行为进行封装成一个可重用的模块（切面）</p></li></ul></li><li><p>将通用逻辑从业务逻辑中分离出来</p></li></ol><p>AOP示例：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigqdsvwj30nc0fwwg3.jpg" width="350" alt="面向对象处理流程"/><p>提取执行相同的代码为一个切面</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigpelibj30sn0gjjty.jpg" width="350" alt="面向切面处理流程"/><p>登录授权访问</p><p>使用AOP流程：</p><ol><li><p>添加POM文件</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>建立处理文件</p><pre><code class="java">@Aspect@Componentpublic class HttpAspect {    @Before(&quot;execution(public * com.imooc.controller.GirlController.girlList(...))&quot;)    public void log() {        System.out.println(11111);    }}</code></pre></li></ol><h3 id="2-2-使用AOP处理请求-中）"><a href="#2-2-使用AOP处理请求-中）" class="headerlink" title="2-2 使用AOP处理请求(中）"></a>2-2 使用AOP处理请求(中）</h3><p>编写切面通知执行方法</p><pre><code class="java">@Aspect@Componentpublic class HttpAspect {    /** 日志 */    private final static Logger LOGGER = LoggerFactory.getLogger(HttpAspect.class);    /** 定义切点 */    @Pointcut(&quot;execution(public * com.myimooc.boot.web.controller.GirlController.*(..))&quot;)    public void log(){}    /** 前置通知 */    @Before(&quot;log()&quot;)    public void doBefore(JoinPoint joinPoint){        ServletRequestAttributes attributes =  (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // url        LOGGER.info(&quot;url={}&quot;, request.getRequestURI());        // method        LOGGER.info(&quot;method={}&quot;, request.getMethod());        // ip        LOGGER.info(&quot;ip={}&quot;, request.getRemoteAddr());        // 类方法        LOGGER.info(&quot;class_method={}&quot;, joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());        // 参数        LOGGER.info(&quot;args={}&quot;, joinPoint.getArgs());    }}</code></pre><blockquote><p>@Aspect：声明当前类是一个切面处理类<br>@Component：声明当前类是一个Bean，由Spring的IOC容器进行管理<br>@Pointcut：声明需要处理的切点</p></blockquote><p>Spring AOP通知(advice)分成五类：</p><blockquote><ul><li>@Before：前置通知[Before advice]：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 </li><li>@AfterReturning：正常返回通知[After returning advice]：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 </li><li>@AfterThrowing：异常返回通知[After throwing advice]：在连接点抛出异常后执行。 </li><li>@After：返回通知[After (finally) advice]：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 </li><li>@Around：环绕通知[Around advice]：环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。</li></ul></blockquote><h3 id="2-3-使用AOP处理请求-下）"><a href="#2-3-使用AOP处理请求-下）" class="headerlink" title="2-3 使用AOP处理请求(下）"></a>2-3 使用AOP处理请求(下）</h3><pre><code class="java">/** 后置通知 */@After(&quot;log()&quot;)public void doAfter(){    LOGGER.info(&quot;方法执行之后执行&quot;);}/** 正常返回通知 */@AfterReturning(returning = &quot;object&quot;, pointcut = &quot;log()&quot;)public void doAfterReturning(Object object){    // LOGGER.info(&quot;response={}&quot;, object.toString());}</code></pre><h3 id="2-4-统一异常处理（上）"><a href="#2-4-统一异常处理（上）" class="headerlink" title="2-4 统一异常处理（上）"></a>2-4 统一异常处理（上）</h3><p>什么是异常处理？</p><blockquote><p>如果不加异常处理的话，程序出错了，用户可能不知道是啥原因。<br>加上处理后，比如加上友好信息等用户能知道错在哪。</p></blockquote><p>为什么要统一异常处理？</p><blockquote><ol><li>在框架层面封装checked exception，将其转化为unchecked exception，避免开发过程中编写繁冗的try…catch代码。 </li><li>业务层面的开发，根据程序代码职责定义不同的RuntimeException(它就是unchecked exception，一般定义为RuntimeException的子类) </li><li>通过前两个观点，系统中自定义的异常将只存在unchecked exception，系统只在于客户端交换数据的上层，设置统一异常处理机制，并将一些异常转化为用户所能理解的信息传达给用户。 </li><li>其他如业务层，数据持久层，等底层只负责将异常抛出即可，但要注意不要丢失掉异常堆栈（这一点是初学者容易犯的一个错误）。 </li></ol></blockquote><p>统一异常处理返回格式：</p><pre><code class="json">{    &quot;code&quot;: 1,    &quot;msg&quot;: &quot;金额必传&quot;,    &quot;data&quot;: null}{    &quot;code&quot;: 1,    &quot;msg&quot;: &quot;成功&quot;,    &quot;data&quot;: {        &quot;id&quot;: 20,        &quot;cupSize&quot;: &quot;B&quot;,        &quot;age&quot;: 25,        &quot;money&quot;: 1.2    }}</code></pre><p>:arrow_up_small:</p><pre><code class="java">public class Result&lt;T&gt; {    /** 响应编号 */    private Integer respCode;    /** 响应消息 */    private String respMsg;    /** 具体的内容 */    private T data;    // ...getter and setter...}</code></pre><pre><code class="java">/** * 添加一个女生 * @return */@PostMapping(value=&quot;/girls&quot;)public Result&lt;Girl&gt; girlAdd(@Valid Girl girl, BindingResult bindingResult) {    Result result = new Result();    if(bindingResult.hasErrors()) {        result.setCode(1);        result.setMsg(bindingResult.getFieldError().getDefaultMessage());        return result;    }    girl.setCupSize(girl.getCupSize());    girl.setAge(girl.getAge());    result.setCode(0);    result.setMsg(&quot;成功&quot;);    result.setData(girlRepository.save(girl));    return result;}</code></pre><p>优化：</p><pre><code class="java">/** * http请求返回的实体Bean工具类 */public class ResultUtil {    /** 成功 */    public final static Integer RESPCODE_SUCCESS = 200;    /** 请求参数错误 */    public final static Integer RESPCODE_ERROR_PARAM = 300;    /** 系统内部业务错误 */    public final static Integer RESPCODE_ERROR_SERVICE = 400;    /** 系统内部异常 */    public final static Integer RESPCODE_ERROR_EXECEPTION = 500;    /** 执行成功，返回参数 */    public  static Result success(Object object){        Result result = new Result();        result.setRespCode(ResultUtil.RESPCODE_SUCCESS);        result.setRespMsg(&quot;成功&quot;);        result.setData(object);        return result;    }    /** 执行成功，无返回参数 */    public static Result success(){        return success(null);    }    /** 执行错误 */    public static Result error(Integer code,String msg){        Result result = new Result();        result.setRespCode(code);        result.setRespMsg(msg);        return result;    }}</code></pre><pre><code class="java">// 成功返回return ResultUtil.success(girlRepository.save(girl));// 失败返回return ResultUtil.error(bindingResult.getFieldError().getDefaultMessage());</code></pre><p>例Ⅰ：</p><blockquote><p>获取某女生的年龄并判断</p><p>小于10，返回“应该在上小学”</p><p>大于10且小于16，返回“可能在上初中”</p></blockquote><p>可能比较容易想到的解决方案是：通过标识来传递信息，比如：</p><pre><code class="java">public Integer getAge1(Integer id) {    Girl girl = girlRepository.findOne(id);    Integer age = girl.getAge();    if (age &lt; 10) {        // 返回“你还在上小学吧”        return 1;    } else if (10 &lt; age &amp;&amp; age &lt; 16) {        // 返回“你可能在上初中”        return 2;    }    // 如果 &gt; 16岁，加钱    // ...    return 0;}</code></pre><h3 id="2-5-统一异常处理（中）"><a href="#2-5-统一异常处理（中）" class="headerlink" title="2-5 统一异常处理（中）"></a>2-5 统一异常处理（中）</h3><p>使用统一异常处理后，则为另一种解决方式</p><p>步骤一：自定义异常</p><pre><code class="java">public class RespException extends RuntimeException {    /** 响应编号 */    private Integer respCode;    public RespException(Integer respCode, String message) {        super(message);        this.respCode = respCode;    }    // ...getter and setter...}</code></pre><p>步骤二：全局异常统一处理类</p><pre><code class="java">@ControllerAdvicepublic class ExceptionHandle {    private final static Logger LOGGER = LoggerFactory.getLogger(ExceptionHandle.class);    /**     * 全局异常返回处理     * @param e 异常     * @return 处理后的返回结果     */    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Result handle(Exception e) {        if (e instanceof RespException) {            RespException respException = (RespException) e;            return ResultUtil.error(respException.getRespCode(), respException.getMessage());        }        LOGGER.error(&quot;【系统异常】{}&quot;, e);        return ResultUtil.error(ResultUtil.RESPCODE_ERROR_SERVICE, &quot;未知错误&quot;);    }}</code></pre><p>步骤三：使用自定义异常</p><pre><code class="java">public void getAge(Integer id) throws Exception {    Girl girl = girlRepository.findOne(id);    Integer age = girl.getAge();    if (age &lt; 10) {        // 返回“你还在上小学吧”        throw new RespException(100, &quot;你还在上小学吧&quot;);    } else if (age &gt; 10 &amp;&amp; age &lt; 16) {        // 返回“你可能在上初中”        throw new RespException(101, &quot;你可能在上初中&quot;);    }    // 如果 &gt; 16岁，价钱    // ...}</code></pre><h3 id="2-6-统一异常处理（下）"><a href="#2-6-统一异常处理（下）" class="headerlink" title="2-6 统一异常处理（下）"></a>2-6 统一异常处理（下）</h3><p>使用枚举进行优化响应编码及响应消息，便于统一维护</p><p>步骤一：定义枚举类</p><pre><code class="java">/** * http请求返回的消息响应编号 */public enum ResultResp {    SUCCESS(0, &quot;成功&quot;),    UNKONW_ERROR(-1, &quot;未知错误&quot;),    PARAM_ERROR(1, &quot;参数错误&quot;),    PRIMARY_SCHOOL(100, &quot;你可能还在上小学&quot;),    MIDDLE_SCHOOL(101, &quot;你可能在上初中&quot;);    private Integer respCode;    private String respMsg;    // ...constructor and getter and setter...}</code></pre><p>步骤二：优化自定义异常</p><pre><code class="java">public class RespException extends RuntimeException {    /** 响应编号 */    private Integer respCode;    public RespException(ResultResp resultResp) {        super(resultResp.getRespMsg());        this.respCode = resultResp.getRespCode();    }    // ...getter and setter...}</code></pre><p>步骤三：全局异常统一处理类</p><pre><code class="java">@ControllerAdvicepublic class ExceptionHandle {    private final static Logger LOGGER = LoggerFactory.getLogger(ExceptionHandle.class);    /**     * 全局异常返回处理     * @param e 异常     * @return 处理后的返回结果     */    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Result handle(Exception e) {        if (e instanceof RespException) {            RespException respException = (RespException) e;            return ResultUtil.error(respException.getRespCode(), respException.getMessage());        }        LOGGER.error(&quot;【系统异常】{}&quot;, e);        return ResultUtil.error(ResultUtil.RESPCODE_ERROR_SERVICE, &quot;未知错误&quot;);    }}</code></pre><p>步骤四：使用自定义异常</p><pre><code class="java">public void getAge(Integer id) throws Exception {    Girl girl = girlRepository.findOne(id);    Integer age = girl.getAge();    int primarySchool = 10;    int middleSchool = 16;    if (age &lt; primarySchool) {        // 返回“你还在上小学吧”        throw new RespException(ResultResp.PRIMARY_SCHOOL);    } else if (age &gt; primarySchool &amp;&amp; age &lt; middleSchool) {        // 返回“你可能在上初中”        throw new RespException(ResultResp.MIDDLE_SCHOOL);    }    // 如果 &gt; 16岁，价钱    // ...}</code></pre><h3 id="2-7-单元测试"><a href="#2-7-单元测试" class="headerlink" title="2-7 单元测试"></a>2-7 单元测试</h3><blockquote><p>测试Service<br>测试API</p></blockquote><p>测试Service</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class GirlServiceImplTest {    @Autowired    private GirlService girlService;    @Test    public void findOne() throws Exception {        Girl girl = girlService.findOne(7);        Assert.assertEquals(new Integer(22), girl.getAge());    }}</code></pre><p>测试Controller</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class GirlControllerTest {    @Autowired    private MockMvc mockMvc;    @Test    public void listGirl() throws Exception {        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/girls&quot;))                .andExpect(MockMvcResultMatchers.status().isOk());    }}</code></pre><pre><code class="shell"># 项目打包时自动进行单元测试mvn clean package# 项目打包时跳过单元测试mvn clean package -Dmaven.test.skip=true</code></pre><h2 id="第3章-课程总结"><a href="#第3章-课程总结" class="headerlink" title="第3章 课程总结"></a>第3章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="3-1-课程总结"><a href="#3-1-课程总结" class="headerlink" title="3-1 课程总结"></a>3-1 课程总结</h3><ol><li>使用@Valid表单验证</li><li>使用AOP处理请求</li><li>统一异常处理</li><li>单元测试</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>767-2小时学会Spring Boot</title>
      <link href="/2019/06/05/767-2Hours-SringBoot/"/>
      <url>/2019/06/05/767-2Hours-SringBoot/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.imooc.com/learn/767" target="_blank" rel="noopener">http://www.imooc.com/learn/767</a></p><p>简介：Spring Boot是用来简化Spring应用初始搭建以及开发过程的全新框架，被认为是Spring MVC的“接班人”，和微服务紧密联系在一起。通过本门课程的学习，你将学会如何使用Spring Boot快速构建应用程序，初步领略Spring Boot的魅力！其后续课程《Spring Boot进阶之Web进阶》.此课专为IT屌丝男程序员打造，女生请慎入！ 讲师实战课程《Spring Boot微信点餐系统》 <a href="http://coding.imooc.com/class/117.html" target="_blank" rel="noopener">http://coding.imooc.com/class/117.html</a> 《Spring Cloud微服务实战》 <a href="http://coding.imooc.com/class/187.html" target="_blank" rel="noopener">http://coding.imooc.com/class/187.html</a> 均已上线</p></blockquote><blockquote><p>项目源码：<a href="https://gitee.com/liaoshixiong/girl" target="_blank" rel="noopener">https://gitee.com/liaoshixiong/girl</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-SpringBoot介绍"><a href="#第1章-SpringBoot介绍" class="headerlink" title="第1章 SpringBoot介绍"></a>第1章 SpringBoot介绍</h2><blockquote><p>1-1 SpringBoot介绍和课程安排</p></blockquote><h3 id="1-1-SpringBoot介绍"><a href="#1-1-SpringBoot介绍" class="headerlink" title="1-1 SpringBoot介绍"></a>1-1 SpringBoot介绍</h3><p>SpringBoot优点</p><blockquote><p> 编码，部署，配置，监控变得更加简单</p></blockquote><p>SpringBoot和SpringMVC的关系</p><blockquote><p>SpringBoot是SpringMVC的升级版，两者没有必然的联系</p></blockquote><p>SpringBoot的特点</p><pre><code>1. 化繁为简，简化配置2. 备受关注，是下一代框架3. 微服务的入门级微框架</code></pre><p>微服务</p><blockquote><p>SpringBoot =&gt; SpringCloud =&gt; 微服务</p></blockquote><p>课程目录</p><pre><code>1. 第一个SpringBoot程序2. 自定义属性配置3. Controller的使用4. spring-data-jpa5. 事务管理</code></pre><p><a href="http://www.imooc.com/learn/443" target="_blank" rel="noopener">《项目管理利器maven》</a><br><a href="http://www.imooc.com/learn/196" target="_blank" rel="noopener">《Spring入门篇》</a></p><p>注意</p><pre><code>1. 具备必要的前置知识    --利用maven构建项目    --Spring注解    --RESTful API2. 可以不需要先去学SpringMVC3. Java、Maven等版本保持一致</code></pre><h2 id="第2章-第一个SpringBoot应用"><a href="#第2章-第一个SpringBoot应用" class="headerlink" title="第2章 第一个SpringBoot应用"></a>第2章 第一个SpringBoot应用</h2><blockquote><p>快速构建第一个SpringBoot应用</p></blockquote><h3 id="2-1-第一个SpringBoot应用"><a href="#2-1-第一个SpringBoot应用" class="headerlink" title="2-1 第一个SpringBoot应用"></a>2-1 第一个SpringBoot应用</h3><pre><code class="shell"># 查看Java版本java -version# 查看Maven版本mvn -version</code></pre><p>下载<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IDEA Ultimate</a></p><p>阿里云Maven镜像配置：</p><pre><code class="xml">&lt;!-- settings.xml --&gt;&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;ur1&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;</code></pre><p>启动SpringBoot项目：</p><pre><code class="shell"># /girlmvn spring-boot:run</code></pre><pre><code class="shell"># /girlmvn installjava -jar target/girl.jar</code></pre><h2 id="第3章-项目属性配置"><a href="#第3章-项目属性配置" class="headerlink" title="第3章 项目属性配置"></a>第3章 项目属性配置</h2><blockquote><p>项目属性配置的各种方法</p></blockquote><h3 id="3-1-项目属性配置"><a href="#3-1-项目属性配置" class="headerlink" title="3-1 项目属性配置"></a>3-1 项目属性配置</h3><p>属性配置</p><pre><code class="properties"># application.propertiesserver.port=8888server.context-path=/girlspring.datasource.url=jdbc:mysql://127.0.0.1:3306/spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc</code></pre><p>加载配置属性注解</p><ul><li><p>单属性</p><pre><code class="yaml">cupSize: Bage: 18content: &quot;cupSize: ${cupSize}, age: ${age}&quot;</code></pre><pre><code class="java">@Value(&quot;${cupSize}&quot;)private String cupSize;@Value(&quot;${age}&quot;)private Integer age;@Value(&quot;${content}&quot;)private String content;</code></pre></li><li><p>组属性</p><pre><code class="yaml">girl:     cupSize: B    age: 18</code></pre><pre><code class="java">@Component@ConfigurationProperties(prefix = &quot;girl&quot;)public class GirlProperties {    private String cupSize;    private Integer age;    // ...getter and setter...}</code></pre><pre><code class="java">@Autowiredprivate GrilProperties girlProperties;</code></pre></li></ul><p>多环境配置：</p><pre><code class="yaml"># application.ymlspring:    profiles:         active: dev</code></pre><pre><code class="yaml"># application-dev.yml 开发环境cupSize: B</code></pre><pre><code class="yaml"># application-prod.yml 生产环境cupSize: F</code></pre><pre><code class="shell"># 编译mvn install# 启动java -jar target/girl.jar --spring.profiles.active=prod</code></pre><h2 id="第4章-Controller的使用"><a href="#第4章-Controller的使用" class="headerlink" title="第4章 Controller的使用"></a>第4章 Controller的使用</h2><blockquote><p>介绍SpringBoot项目中Controller的使用</p></blockquote><h3 id="4-1-Controller的使用"><a href="#4-1-Controller的使用" class="headerlink" title="4-1 Controller的使用"></a>4-1 Controller的使用</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Controller</td><td>处理http请求</td></tr><tr><td>@RestController</td><td>Spring4之后新的注解，原来返回JSON需要@ResponseBody配合@Controller</td></tr><tr><td>@RequestMapping</td><td>配置url映射</td></tr></tbody></table><p>模板使用</p><pre><code class="xml">&lt;!-- pom.xml --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springf ramework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><pre><code class="html">&lt;!-- /resources/templates/index.html --&gt;&lt;hi&gt;hello Spring Boot&lt;/h1&gt;</code></pre><pre><code class="java">@RequestMapping(value=&quot;/helLo&quot;, method = RequestMethod.GET)public String say() {    return &quot;index&quot;;}</code></pre><p>处理请求中的参数</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@PathVariable</td><td>获取url中的数据</td></tr><tr><td>@RequestParam</td><td>获取请求参数的值</td></tr><tr><td>@GetMapping</td><td>组合注解</td></tr></tbody></table><ol><li><p>@RestController相当于@ResponseBody与@Controller</p></li><li><p>@RequestMapping(value={“/hi”, “/say”}, method=RequestMethod.GET)。value可以是个集合</p></li><li><p>@RequestMapping可以用@GetMapping或@PostMapping代替，省去声明方法</p></li><li><p>/luckymoney/hello/say/100</p><p>@GetMapping(value=”/{id}/say”)</p><p>@PathVariable(“id”) Integer id</p></li><li><p>/luckymoney/hello/say?id=100</p><p>@RequestParam(value=”id”, required=false, defaultValue=”0”) Integer id</p></li></ol><h2 id="第5章-数据库操作"><a href="#第5章-数据库操作" class="headerlink" title="第5章 数据库操作"></a>第5章 数据库操作</h2><blockquote><p>SpringBoot中使用spring-data-jpa</p></blockquote><h3 id="5-1-数据库操作（上）"><a href="#5-1-数据库操作（上）" class="headerlink" title="5-1 数据库操作（上）"></a>5-1 数据库操作（上）</h3><p>数据库操作</p><blockquote><p>Spring-Data-Jpa -&gt; MySQL</p></blockquote><p>Spring-Data-JPA</p><blockquote><p>JPA(Java Persistence API)定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate、TopLink等。</p><p>Spring-Data-JPA就是对Hibernate的整合</p></blockquote><p>RESTful API设计：</p><table><thead><tr><th>请求类型</th><th>请求路径</th><th>功能</th></tr></thead><tbody><tr><td>GET</td><td>/girls</td><td>获取女生列表</td></tr><tr><td>POST</td><td>/girls</td><td>创建一个女生</td></tr><tr><td>GET</td><td>/girls/id</td><td>通过id查询一个女生</td></tr><tr><td>PUT</td><td>/girls/id clipbogu</td><td>通过id更新一个女生</td></tr><tr><td>DELETE</td><td>/girls/id</td><td>通过id删除一个女生</td></tr></tbody></table><p>步骤：</p><ol><li><p>添加POM依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springf ramework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置数据库信息和Spring-Data-JPA信息</p><pre><code class="yaml">spring:     datasource:         driver-class-name: com.mysql.jdbc.Driver        ur1: jdbc:mysql://127.0.0.1:3306/dbgirl        username: root        password: 123456    jpa:         hibernate:             ddl-auto: create        show-sql: true</code></pre><p>ddl-auto参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>create</td><td>运行时自动创建表。每次程序运行都会创建空表，如果已存在则会先删除表</td></tr><tr><td>create-drop</td><td>应用停下来的时候就会把表删除</td></tr><tr><td>none</td><td>不做任何操作。</td></tr><tr><td>update</td><td>运行时自动创建表。当已存在表则不会操作</td></tr><tr><td>validate</td><td>验证实体属性是否和表结构一致，不一致则会报错。</td></tr></tbody></table></li><li><p>创建实体类</p><pre><code class="java">@Entitypublic class Girl {    @Id    @GenerateValue    private Integer id;    private String cupSize;    private Integer age;    // 无参构造函数。必须要有，否则报错    // ...getter and setter...}</code></pre></li><li><p>运行程序</p></li></ol><h3 id="5-2-数据库操作（下）"><a href="#5-2-数据库操作（下）" class="headerlink" title="5-2 数据库操作（下）"></a>5-2 数据库操作（下）</h3><ol><li><p>Dao</p><pre><code class="java">public interface GirlRepository extends JpaRepository&lt;Girl, Integer&gt; {    /**     * 通过年龄查询     */    public List&lt;Girl&gt; findByAge(Integer age);}</code></pre></li><li><p>Controller</p><pre><code class="java">@RestControllerpublic class GirlController {    @Autowired    private GirlRepository girlRepository;    /**     * 查询所有女生列表     */     @GetMapping(value = &quot;/girls&quot;)    public List&lt;Girl&gt; girlList() {        return girlRepository.findALL();    }    /**     * 添加一个女生     */     @PostMapping(value = &quot;/girls&quot;)    public Girl girlAdd(@RequestParam(&quot;cupSize&quot;) String cupSize,                        @RequestParam(&quot;age&quot;) Integer age) {        Girl girl=new Girl();        girl.setCupSize(cupSize);        girl.setAge(age);        return girlRepository.save(girl);    }    /**     * 查询一个女生     */     @GetMapping(value = &quot;/girls/{id}&quot;)    public Girl girlFindOne(@PathVariable(&quot;id&quot;) Integer id) {        return girlRepository.findOne(id);    }    /**     * 更新一个女生     */     @PutMapping(value = &quot;/girls/{id}&quot;)    public Girl girlUpdate(@PathVariable(&quot;id&quot;) Integer id,                            @RequestParam(&quot;cupSize&quot;) String cupSize,                            @RequestParam(&quot;age&quot;) Integer age) {        Girl girl = new Girl();        girl.setId(id);        girl.setCupSize(cupSize);        girl.setAge(age);        return girlRepository.save(girl);    }    /**     * 删除一个女生     */     @DeleteMapping(value = &quot;/girls/{id}&quot;)    public void girlDelete(@PathVariable(&quot;id&quot;) Integer id) {        girlRepository.delete(id);    }    /**     * 通过年龄查询女生列表     */    @GetMapping(value = &quot;/girls/age/{age}&quot;)    public List&lt;Girl&gt; girlListByAge(@PathVariable(&quot;age&quot;) Integer age) {        return girlRepository.findByAge(age);    }}</code></pre></li></ol><p>注：</p><ul><li><p><strong>Post使用form-data</strong></p></li><li><p><strong>Put使用x-www-form-urlencoded</strong></p></li></ul><h2 id="第6章-事务管理"><a href="#第6章-事务管理" class="headerlink" title="第6章 事务管理"></a>第6章 事务管理</h2><blockquote><p>演示了SpringBoot中使用事务的简单例子</p></blockquote><h3 id="6-1-事务管理"><a href="#6-1-事务管理" class="headerlink" title="6-1 事务管理"></a>6-1 事务管理</h3><pre><code class="java">@Servicepublic class GirlService {    @Autowired    private GirlRepository girlRepository;    /**     * 保存两个女生信息     */    @Transactional(rollbackFor = Exception.class)    public void saveTwo() {        Girl girlA = new Girl();        girlA.setCupSize(&quot;A&quot;);        girlA.setAge(18);        girlRepository.save(girlA);        Girl girlB = new Girl();        girlB.setAge(19);        girlB.setCupSize(&quot;B&quot;);        girlRepository.save(girlB);    }}</code></pre><pre><code class="java">@Autowiredprivate GirlService girlService;@PostMapping(value=&quot;/girls/two&quot;)public void saveGirlTwo(){    girlService.saveTwo();}</code></pre><blockquote><p>只有查询的时候不加事务，其它任何操作都要加事务。</p><p>进行添加操作的时候，如果要求，要么全部添加成功，要么全部失败</p><p>@Transactional事务处理注解的使用方法，在serive进行事务处理</p></blockquote><p>事务失败原因：数据库默认为MyISAM不支持事物回滚，需要设置为InnoDB</p><p>解决方法： 改为INNODB</p><p>更改语句：</p><pre><code class="mysql">ALTER TABLE girl ENGINE=INNODB;</code></pre><p>事务失败原因：SpringBoot2.*实体的默认引擎为MyISAM不支持事务，需要配置引擎为为innoDB<br>解决方法：在application.yml添加配置</p><pre><code class="yaml">spring:     jpa:         database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</code></pre><h2 id="第7章-课程回顾"><a href="#第7章-课程回顾" class="headerlink" title="第7章 课程回顾"></a>第7章 课程回顾</h2><blockquote><p>回顾课程内容</p></blockquote><h3 id="7-1-课程回顾"><a href="#7-1-课程回顾" class="headerlink" title="7-1 课程回顾"></a>7-1 课程回顾</h3><ol><li>SpringBoot介绍</li><li>安装IDEA、Maven并初始化SpringBoot工程</li><li>配置文件、注入属性</li><li>Controller的使用及注解</li><li>数据库增删改查</li></ol><p>下门课程介绍：</p><ol><li>@Valid表单验证</li><li>AOP统一异常处理</li><li>spring-data-jpa8.用缓存应对高并发</li><li>Jdbc Template</li><li>Mybatis</li><li>Redis</li><li>MongoDB</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1086-Java高并发之魂：synchronized深度解析</title>
      <link href="/2019/03/20/1086-synchronized/"/>
      <url>/2019/03/20/1086-synchronized/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1086" target="_blank" rel="noopener">https://www.imooc.com/learn/1086</a></p><p>简介：高并发问题向来是Java程序员进阶的重点，也是面试的难点。想要打通高并发的奇经八脉，synchronized是你不得不趟过的坑，本课程从synchronized，从使用方法到底层原理源码，娓娓道来。还对常见面试题和更深层扩展方面的思考，做出了讲解。本课程由浅入深，适合各阶段工程师观看。悟空老师的实战课【Java并发核心知识精讲+Java内存模型+死锁】已经上线啦，传送门如下 <a href="https://coding.imooc.com/class/362.html" target="_blank" rel="noopener">https://coding.imooc.com/class/362.html</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>介绍了课程结构、要点、前置知识和开发环境。</p></blockquote><h3 id="1-1-课程介绍-07-58"><a href="#1-1-课程介绍-07-58" class="headerlink" title="1-1 课程介绍 (07:58)"></a>1-1 课程介绍 (07:58)</h3><p>前置知识</p><ul><li>了解Java基本语法</li><li>了解多线程基本知识</li></ul><p>章节介绍</p><ol><li>Synchronized<strong>简介</strong>：作用、地位、不控制并发的后果</li><li>两种用法：<strong>对象锁</strong>和<strong>类锁</strong></li><li>多线程访问同步方法的<strong>7种</strong>情况：是否static、Synchronized方法等</li><li>Synchronized的<strong>性质</strong>：可重入、不可中断</li><li><strong>原理</strong>：加解锁原理、可重入原理、可见性原理</li><li>Synchronized的<strong>缺陷</strong>：效率低、不够灵活、无法预判是否成功获取到锁</li><li>常见<strong>面试</strong>问题：使用注意点、如何选择Lock或Synchronized等</li><li><strong>思考题</strong>：如何提高性能、JVM如何决定哪个线程获取锁等</li><li>总结</li></ol><p>开发环境</p><ul><li>JDK1.8</li><li>IDEA 2018.2</li></ul><p>学习路径：</p><ul><li><p>实战课：Java并发核心知识体系精讲</p><p><a href="https://coding.imooc.com/class/362.html" target="_blank" rel="noopener">https://coding.imooc.com/class/362.html</a></p></li></ul><h2 id="第2章-Synchronized简介"><a href="#第2章-Synchronized简介" class="headerlink" title="第2章 Synchronized简介"></a>第2章 Synchronized简介</h2><blockquote><p>让同学们对Synchronized关键字有整理概念，从官网解释引出通俗解释，便于理解。从Synchronized关键字的地位说明该关键字的重要性。代码演示不用并发手段会带来的问题，吸引同学们带着疑问继续学习。分享IDEA的调试技巧，便于同学们实际操作。</p></blockquote><ul><li>作用：官方解释、通俗易懂的解释</li><li>地位</li><li>不使用并发手段的后果</li></ul><h3 id="2-1-synchronized的作用-03-11"><a href="#2-1-synchronized的作用-03-11" class="headerlink" title="2-1 synchronized的作用 (03:11)"></a>2-1 synchronized的作用 (03:11)</h3><p>官方解释</p><blockquote><p>Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visable to more than one thread, all reads or wirtes or that object’s variables are done through synchronized methods </p></blockquote><p>翻译</p><blockquote><p>同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的</p></blockquote><p>一句话说出Synchronized的作用</p><blockquote><p>能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果</p></blockquote><h3 id="2-2-synchronized的地位-00-51"><a href="#2-2-synchronized的地位-00-51" class="headerlink" title="2-2 synchronized的地位 (00:51)"></a>2-2 synchronized的地位 (00:51)</h3><ul><li>Synchronized是Java的关键字，被Java语言原生支持</li><li>Synchronized是最基本的同步互斥手段</li><li>Synchronized是并发编程中的元老级角色，是并发编程的必学内容</li></ul><h3 id="2-3-不用并发手段的后果预警-01-06"><a href="#2-3-不用并发手段的后果预警-01-06" class="headerlink" title="2-3 不用并发手段的后果预警 (01:06)"></a>2-3 不用并发手段的后果预警 (01:06)</h3><p>代码实战：两个线程同时<code>a++</code>，最后结果会比预计的少。</p><h3 id="2-4-后果的代码演示和原因分析-07-23"><a href="#2-4-后果的代码演示和原因分析-07-23" class="headerlink" title="2-4 后果的代码演示和原因分析 (07:23)"></a>2-4 后果的代码演示和原因分析 (07:23)</h3><pre><code class="java">public class DisappearRequest1 implements Runnable {    private static DisappearRequest1 instance = new DisappearRequest1();    private static int a = 0;    public static void main(String[] args) throws InterruptedException {        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();t2.start();        t1.join();t2.join();        System.out.println(&quot;a = &quot; + a);    }    @Override    public void run() {        for (int i = 0; i &lt; 100000; i++) {            a++;        }    }}</code></pre><p>原因：</p><blockquote><p><code>count++</code>，它看上去只是一个操作，实际上包含了三个动作（非原子操作）：</p><ol><li>读取count</li><li>将count加1</li><li>将count的值写入到内存中</li></ol><p>非原子操作还有：<code>a--</code>、<code>a+=1</code>、<code>a-=1</code>等</p></blockquote><h2 id="第3章-Synchronized的两种用法（对象锁和类锁）"><a href="#第3章-Synchronized的两种用法（对象锁和类锁）" class="headerlink" title="第3章 Synchronized的两种用法（对象锁和类锁）"></a>第3章 Synchronized的两种用法（对象锁和类锁）</h2><blockquote><p>对使用方法进行系统分类。涵盖了所有该关键字会用到的情况。</p></blockquote><h3 id="3-1-Synchronized的两种用法介绍-02-11"><a href="#3-1-Synchronized的两种用法介绍-02-11" class="headerlink" title="3-1 Synchronized的两种用法介绍 (02:11)"></a>3-1 Synchronized的两种用法介绍 (02:11)</h3><ol><li><p>对象锁：3-2</p><blockquote><p>包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）</p></blockquote></li><li><p>类锁：3-7</p><blockquote><p>指synchronized修饰静态的方法或指定锁为class对象</p></blockquote></li></ol><h3 id="3-2-对象锁的形式1-同步代码块-13-07"><a href="#3-2-对象锁的形式1-同步代码块-13-07" class="headerlink" title="3-2 对象锁的形式1-同步代码块 (13:07)"></a>3-2 对象锁的形式1-同步代码块 (13:07)</h3><p>第一个用法：对象锁</p><ul><li>代码块形式：手动指定锁对象</li><li>方法锁形式：synchronized修饰普通方法，锁对象默认为this</li></ul><blockquote><p>代码块形式：手动指定锁对象</p></blockquote><pre><code class="java">private Object lock1 = new Object();private Object lock2 = new Object();@Overridepublic void run() {    synchronized (lock1) {        System.out.println(&quot;我是对象锁的代码块形式-lock1。我叫&quot; + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;，lock1-运行结束。&quot;);    }    synchronized (lock2) {        System.out.println(&quot;我是对象锁的代码块形式-lock2。我叫&quot; + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;，lock2-运行结束。&quot;);    }}</code></pre><p>结论：当有多个synchronized同步代码块时，如果使用this为锁对象（即同一个锁对象）则只能运行其中的一个同步代码块，不能与其他同步代码块并行运行。</p><p>注：当业务复杂时，锁对象也会变得非常复杂。JDK提供了相应非常完善的工具类，例如：JUC包下的<code>CountDownLatch</code>倒计时,门闩、<code>CyclicBarrier</code>、<code>Semaphore</code>信号量。</p><h3 id="3-3-调试技巧-看线程生命周期-03-28"><a href="#3-3-调试技巧-看线程生命周期-03-28" class="headerlink" title="3-3 调试技巧-看线程生命周期 (03:28)"></a>3-3 调试技巧-看线程生命周期 (03:28)</h3><p>在调试时查看当前线程的状态：</p><p>打好断点=&gt;使用Debug启动程序=&gt;当运行到断点时,右击断点出现图1</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8pl2tiw58j30nk0aiq3q.jpg" alt="image-20191107170337910" style="zoom:40%;" alt="图1" /><p><code>All</code>：暂停所有线程，包括JVM</p><p><code>Thread</code>：暂停当前线程</p><p>Debug=&gt;Debugger=&gt;Frames=&gt;Thread-0=&gt;run,Thread=&gt;Evaluate Expression</p><p>执行：<code>this.getState()</code></p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8plcqxdrij30hy0jymz1.jpg" style="zoom:33%;" alt="图2"/><h3 id="3-4-对象锁的形式2-普通方法锁-03-58"><a href="#3-4-对象锁的形式2-普通方法锁-03-58" class="headerlink" title="3-4 对象锁的形式2-普通方法锁 (03:58)"></a>3-4 对象锁的形式2-普通方法锁 (03:58)</h3><blockquote><p>方法锁形式：synchronized修饰普通方法，锁对象默认为this</p></blockquote><pre><code class="java">public synchronized void method() throws InterruptedException {    System.out.println(&quot;我是对象锁的方法修饰符形式，我叫&quot; + Thread.currentThread().getName());    Thread.sleep(3000);    System.out.println(Thread.currentThread().getName() + &quot;，运行结束&quot;);}</code></pre><h3 id="3-5-类锁的概念-04-54"><a href="#3-5-类锁的概念-04-54" class="headerlink" title="3-5 类锁的概念 (04:54)"></a>3-5 类锁的概念 (04:54)</h3><p>第二个用法：类锁</p><ul><li>概念（★重要）：Java类可能有很多个对象，但是只有一个Class对象</li><li>形式1：synchronized加载static静态方法上</li><li>形式2：<code>synchronized(*.class)</code>代码块</li></ul><p>概念：</p><ul><li>只有一个Class对象：Java类可能会有很多个对象，但是只有1个Class对象。特殊的对象。</li><li>本质：所谓的类锁，不过是Class对象的锁而已。</li><li>用法和效果：类锁只能在同一时刻被一个对象拥有。</li></ul><p>类锁就是使用特殊对象锁（Class对象）作为同步互斥锁，因为其只有一个，所以不同的实例会互斥，在同一时刻只有一个线程可以访问该类实例中被类锁锁住的方法。</p><h3 id="3-6-类锁的形式1-静态方法锁-03-52"><a href="#3-6-类锁的形式1-静态方法锁-03-52" class="headerlink" title="3-6 类锁的形式1-静态方法锁 (03:52)"></a>3-6 类锁的形式1-静态方法锁 (03:52)</h3><blockquote><p>形式1：synchronized加载static静态方法上</p></blockquote><p>两个线程为不同的实例：</p><pre><code class="java">Thread t1 = new Thread(instance1);Thread t2 = new Thread(instance2);</code></pre><pre><code class="java">public static synchronized void method() throws InterruptedException {    System.out.println(&quot;我是类锁的静态方法形式，我叫&quot; + Thread.currentThread().getName());    Thread.sleep(3000);    System.out.println(Thread.currentThread().getName() + &quot;，运行结束&quot;);}</code></pre><h3 id="3-7-类锁的形式2–-class-05-08"><a href="#3-7-类锁的形式2–-class-05-08" class="headerlink" title="3-7 类锁的形式2–.class (05:08)"></a>3-7 类锁的形式2–.class (05:08)</h3><blockquote><p>形式2：<code>synchronized(*.class)</code>代码块</p></blockquote><p>两个线程为不同的实例：</p><pre><code class="java">Thread t1 = new Thread(instance1);Thread t2 = new Thread(instance2);</code></pre><pre><code class="java">public void method() throws InterruptedException {    synchronized (SynchronizedClassClass5.class) {        System.out.println(&quot;我是类锁的 synchronized(*.class) 形式，我叫&quot; + Thread.currentThread().getName());        Thread.sleep(3000);        System.out.println(Thread.currentThread().getName() + &quot;，运行结束&quot;);    }}</code></pre><h3 id="3-8-消失的请求解决方案-04-25"><a href="#3-8-消失的请求解决方案-04-25" class="headerlink" title="3-8 消失的请求解决方案 (04:25)"></a>3-8 消失的请求解决方案 (04:25)</h3><p>解决方案1：对象锁-普通方法形式</p><pre><code class="java">@Overridepublic synchronized void run() {    for (int i = 0; i &lt; 100000; i++) {        a++;    }}</code></pre><p>解决方案2：对象锁-同步代码块形式</p><pre><code class="java">@Overridepublic void run() {    for (int i = 0; i &lt; 100000; i++) {        synchronized (this) {            a++;        }    }}</code></pre><p>解决方案3：类锁-*.class形式</p><pre><code class="java">@Overridepublic void run() {    for (int i = 0; i &lt; 100000; i++) {        synchronized (DisappearRequest1.class) {            a++;        }    }}</code></pre><p>解决方案4：类锁-静态方案形式</p><pre><code class="java">@Overridepublic void run() {    method();}public static synchronized void method() {    for (int i = 0; i &lt; 100000; i++) {        a++;    }}</code></pre><h2 id="第4章-多线程访问同步方法的7种具体情况"><a href="#第4章-多线程访问同步方法的7种具体情况" class="headerlink" title="第4章 多线程访问同步方法的7种具体情况"></a>第4章 多线程访问同步方法的7种具体情况</h2><blockquote><p>★面试常考</p><p>除了普通用法外，对各种情况进行讲解，让同学们有整体思维，并且理解原理。</p></blockquote><h3 id="4-1-七种常见情况之123-06-38"><a href="#4-1-七种常见情况之123-06-38" class="headerlink" title="4-1 七种常见情况之123 (06:38)"></a>4-1 七种常见情况之123 (06:38)</h3><p>多线程访问同步方法的7种情况：</p><ol><li>两个线程同时访问一个对象的同步方法</li><li>两个线程访问的是两个对象的同步方法</li><li>两个线程访问的是synchronized的静态方法</li><li>同时访问同步和非同步方法</li><li>访问同一个对象的不同的普通同步方法</li><li>同时访问静态synchronized个非静态synchronized方法</li><li>方法抛出异常后，会释放锁</li></ol><ol><li><p>两个线程同时访问一个对象的同步方法</p><p>线程同步。<code>SynchronizedObjectMethod3</code></p><p>对象锁的普通方法形式。this锁</p></li><li><p>两个线程访问的是两个对象的同步方法</p><p>线程异步。</p></li><li><p>两个线程访问的是synchronized的静态方法</p><p>线程同步。<code>SynchronizedClassStatic4</code></p></li></ol><h3 id="4-2-七种常见情况之4和5-08-21"><a href="#4-2-七种常见情况之4和5-08-21" class="headerlink" title="4-2 七种常见情况之4和5 (08:21)"></a>4-2 七种常见情况之4和5 (08:21)</h3><ol start="4"><li><p>同时访问同步和非同步方法</p><p>线程异步。<code>SynchronizedYesAndNo6</code></p><p>非同步方法不受到影响</p></li><li><p>访问同一个对象的不同的普通同步方法</p><p>线程同步。<code>SynchronizedDifferentMethod7</code></p></li></ol><h3 id="4-3-七种常见情况之6和7-11-25"><a href="#4-3-七种常见情况之6和7-11-25" class="headerlink" title="4-3 七种常见情况之6和7 (11:25)"></a>4-3 七种常见情况之6和7 (11:25)</h3><ol start="6"><li><p>同时访问静态synchronized个非静态synchronized方法</p><p>线程异步。<code>SynchronizedStaticAndNormal8</code></p><p><code>this锁</code>与<code>*.class锁</code>不是同一把锁</p></li><li><p>方法抛出异常后，会释放锁</p><p><code>SynchronizedException9</code></p><p>synchronized与Lock接口：</p><ul><li>在Lock接口中，只要是没有显式手动释放锁，即便抛出异常Lock也是不会释放锁的。</li><li>synchronized一旦抛出异常会自动释放锁。</li></ul></li></ol><h3 id="4-4-7种情况总结-03-00"><a href="#4-4-7种情况总结-03-00" class="headerlink" title="4-4 7种情况总结 (03:00)"></a>4-4 7种情况总结 (03:00)</h3><p>3点核心思想：</p><ol><li><p>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应第1、5种情况）</p></li><li><p>每个实例都对应有自己的一把锁(即this锁)，不同实例之间互不影响；（对应第2、4、6种情况）</p><p>例外：锁对象是*.class以及synchronized修饰的事static方法的时候，所有对象公用同一把锁(即类锁)（对应第3种情况）</p></li><li><p>无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应第7种情况）</p></li></ol><p>补充：</p><ul><li><p>synchronized方法调用非synchronized方法，此时是线程安全的么？</p><p>答：不是的。一旦出了synchronized方法，由于另一个方法未被synchronized修饰，所以这个方法是可以被多个线程同时访问的。</p></li></ul><h2 id="第5章-Synchronized的性质"><a href="#第5章-Synchronized的性质" class="headerlink" title="第5章 Synchronized的性质"></a>第5章 Synchronized的性质</h2><blockquote><p>重点对可重入性作深入讲解，对粒度进行代码展示。</p></blockquote><ul><li>可重入性质</li><li>不可中断性质</li></ul><h3 id="5-1-可重入性质-理论部分-07-54"><a href="#5-1-可重入性质-理论部分-07-54" class="headerlink" title="5-1 可重入性质-理论部分 (07:54)"></a>5-1 可重入性质-理论部分 (07:54)</h3><p>锁的种类：自选锁、互斥锁、可重入锁（递归锁）、中断锁、读写锁</p><p>可重入锁：<code>synchronized</code>、<code>ReentrantLock</code></p><p>什么是可重入：</p><blockquote><p>指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。</p></blockquote><p>好处：</p><blockquote><p>避免死锁、提升封装性</p></blockquote><ul><li><p>假设方法A和方法B都被synchronized修饰，线程执行到方法A并且获得了这把锁。此时方法A想要去调用方法B，由于方法B也被synchronized修饰，所以也需要获取锁。线程在这个时候既想要获取锁又不想释放锁，造成了永久等待，所以形成了死锁。</p></li><li><p>可重入性避免了一次一次的解锁加锁。</p></li></ul><p>粒度：</p><blockquote><p>指的是加锁的一个范围（scope）。线程而非调用（用3种情况来说明和pthread的区别）</p></blockquote><p>​    <strong>synchronized的粒度为线程</strong></p><p>​    pthread（Linux中的PROCESS线程）的粒度为调用</p><p>代码验证：</p><ol><li><p>情况1:证明同一个方法是可以重入的</p></li><li><p>情况2:证明可重入不要求是同一个方法（不同方法）</p></li><li><p>情况3:证明可重入不要求是同一个类中（不同类）</p><p>子类重写父类的synchronized方法，然后在子类中利用super调用父类的这个synchronized方法，如果不具备可重入性，则代码会产生死锁。</p></li></ol><h3 id="5-2-可重入性质-代码演示-10-32"><a href="#5-2-可重入性质-代码演示-10-32" class="headerlink" title="5-2 可重入性质-代码演示 (10:32)"></a>5-2 可重入性质-代码演示 (10:32)</h3><p>补充：</p><ul><li>递归三要素：<ol><li>一定有一种可以退出程序的情况</li><li>总是在尝试将一个问题化简到更小的规模</li><li>父问题与子问题不能有重叠的部分</li></ol></li></ul><ol><li><p>情况1:证明同一个方法是可以重入的</p><pre><code class="java">/** * 可重入粒度测试：递归调用本方法 */public class SynchronizedRecursion10 {    int a = 0;    public static void main(String[] args) {        SynchronizedRecursion10 synchronizedRecursion10 = new SynchronizedRecursion10();        synchronizedRecursion10.method1();    }    private synchronized void method1() {        System.out.println(&quot;this is method1, a = &quot; + a);        if (a == 0) {            a++;            method1();        }    }}</code></pre></li><li><p>情况2:证明可重入不要求是同一个方法（不同方法）</p><pre><code class="java">/** * 可重入粒度测试：调用类内另外的方法 */public class SynchronizedOtherMethod11 {    public static void main(String[] args) {        SynchronizedOtherMethod11 synchronizedOtherMethod11 = new SynchronizedOtherMethod11();        synchronizedOtherMethod11.method1();    }    public synchronized void method1() {        System.out.println(&quot;I&#39;m method1&quot;);        method2();    }    private synchronized void method2() {        System.out.println(&quot;I&#39;m method2&quot;);    }}</code></pre></li><li><p>情况3:证明可重入不要求是同一个类中（不同类）</p><pre><code class="java">/** * 可重入粒度测试：调用父类的方法 */public class SynchronizedSuperClass12 {    public synchronized void doSomething() {        System.out.println(&quot;我是父类方法&quot;);    }}class TestClass extends SynchronizedSuperClass12 {    public static void main(String[] args) {        TestClass t = new TestClass();        t.doSomething();    }    @Override    public synchronized void doSomething() {        System.out.println(&quot;我是子类方法&quot;);        super.doSomething();    }}</code></pre></li></ol><h3 id="5-3-不可中断性质-02-10"><a href="#5-3-不可中断性质-02-10" class="headerlink" title="5-3 不可中断性质 (02:10)"></a>5-3 不可中断性质 (02:10)</h3><p>一旦锁已经被其他线程获得，如果当前线程想要获得锁，那么当前线程只能选择等待或者阻塞，直到其他线程释放这个锁。如果其他线程永远不释放锁，那么当前线程只能永远地等待下去。</p><p>相比之下，<code>JUC包</code>下的<code>Lock</code>类，可以拥有中断的能力。第一点，如果我觉得我等的时间太长了，有权中断现在已经获取到锁的线程的执行；第二点，如果我觉得我等待的时间太长了不想等待了，也可以退出。</p><p><code>Lock类</code>相比<code>synchronized</code>更为灵活，但是需要注意更多的点，在编码中避免出错。</p><h2 id="第6章-深入原理"><a href="#第6章-深入原理" class="headerlink" title="第6章 深入原理"></a>第6章 深入原理</h2><blockquote><p>知其所以然，学习原理。学习monitor指令、可重入和可见性原理</p></blockquote><ul><li>加锁和释放锁的原理：现象、时机、深入JVM查看字节码</li><li>可重入原理：加锁次数计数器</li><li>保证可见性的原理：内存模型</li></ul><h3 id="6-1-加锁和释放锁的原理-08-55"><a href="#6-1-加锁和释放锁的原理-08-55" class="headerlink" title="6-1 加锁和释放锁的原理 (08:55)"></a>6-1 加锁和释放锁的原理 (08:55)</h3><ol><li><p>现象：每一个类的实例对应一把锁，每一个synchronized方法都必须获取调用该方法的类的实例的锁方能执行，否则线程会阻塞。方法一旦执行就会独占这把锁直到该方法返回或者抛出异常才将锁释放。释放锁之后，其他阻塞线程才有机会获取到锁，进入到可执行状态。</p></li><li><p>获取和释放锁的时机：内置锁（监视器锁，MonitorLock）</p></li><li><p>等价代码：</p><pre><code class="java">/** * synchronized锁与lock锁 */public class SynchronizedToLock13 {    public static void main(String[] args) {        SynchronizedToLock13 s = new SynchronizedToLock13();        s.method1();        s.method2();    }    Lock lock = new ReentrantLock();    public synchronized void method1() {        System.out.println(&quot;我是Synchronized形式的锁。&quot;);    }    public void method2() {        lock.lock();        try {            System.out.println(&quot;我是lock形式的锁。&quot;);        } finally {            lock.unlock();        }    }}</code></pre></li><li><p>深入JVM看字节码：反编译、monitor指令</p></li></ol><h3 id="6-2-反编译看monitor指令-12-06"><a href="#6-2-反编译看monitor指令-12-06" class="headerlink" title="6-2 反编译看monitor指令 (12:06)"></a>6-2 反编译看monitor指令 (12:06)</h3><p>概况：synchronized使用的锁是在Java对象头里的一个字段，表明是否被锁住。</p><p>synchronized的实现原理：进入锁和释放锁是基于monitor对象来实现同步方法和同步代码块的</p><p>monitor对象最主要是两个指令：</p><ul><li><p>monitorenter：插入到同步代码块开始的位置</p></li><li><p>monitorexit：插入到方法结束和退出的时候</p><p>monitorenter个数 &lt;= monitorexit个数</p></li></ul><p>补充：</p><ul><li>Java对象头</li><li>class类文件的结构</li></ul><p>如何反编译：</p><ol><li><p>编写Java代码</p><pre><code class="java">/** * 反编译字节码 */public class Decompilation14 {    private final Object object = new Object();    public void insert(Thread thread) {        synchronized (object) {        }    }}</code></pre></li><li><p>编译为字节码文件</p><pre><code class="shell">javac Decompilation14.java</code></pre></li><li><p>反编译/反汇编</p><pre><code class="shell">javap -verbose Decompilation14</code></pre><p><code>-verbose</code>：打印所有信息</p></li></ol><p>Monitorenter和Monitorexit指令</p><ul><li>monitorenter和monitorexit在执行的时候会让对象的锁计数器加一或减一，和操作系统的PV操作非常类似。</li><li>每一个对象都与一个monitor相关联，一个monitor的lock锁在同一时间只能被一个线程获取</li><li>一个线程在尝试获得与这个对象相关联的monitor的所有权时，会发生三种情况：<ol><li>如果monitor计数器为0，意味着目前还没有被获得，线程会立刻获得锁，然后把计数器加1</li><li>如果monitor已经拿到锁的所有权，然后又重入，会导致锁计数器累加</li><li>如果monitor已经被其他线程持有，此时线程进入阻塞状态，直到monitor计数器变为0才会再次去尝试获取锁</li></ol></li><li>monitorexit：释放对于monitor的所有权（前提是已经拥有锁的所有权）。释放所有权就是将monitor计数器减一，如果为0则当前线程不再拥有monitor的所有权，同时阻塞的线程会再次尝试获取锁；如果不为0则说明上一步为重入，当前线程依然持有monitor的所有权</li></ul><h3 id="6-3-可重入原理-01-50"><a href="#6-3-可重入原理-01-50" class="headerlink" title="6-3 可重入原理 (01:50)"></a>6-3 可重入原理 (01:50)</h3><p>加锁次数计数器</p><ul><li>JVM负责跟踪对象被加锁的次数</li><li>线程第一次给对象加锁的时候，计数器变为1；每当这个<strong>相同的线程</strong>在此对象上再次获得锁时，计数器会递增</li><li>每当任务离开时，计数器递减，当计数器为0的时候，锁被完全释放</li></ul><h3 id="6-4-可见性原理-03-34"><a href="#6-4-可见性原理-03-34" class="headerlink" title="6-4 可见性原理 (03:34)"></a>6-4 可见性原理 (03:34)</h3><ul><li><p>Java内存模型：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8qrch253bj30um0qcjzl.jpg" alt="Java内存模型" style="zoom:35%;"/><p>线程使用的内存速度要比主存所使用的内存要快。</p></li><li><p>线程A向线程B发送数据的步骤：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8qre9xvtwj30xe0pon3m.jpg" alt="线程之间的通信" style="zoom:35%;"/></li></ul><h2 id="第7章-Synchronized的缺陷"><a href="#第7章-Synchronized的缺陷" class="headerlink" title="第7章 Synchronized的缺陷"></a>第7章 Synchronized的缺陷</h2><blockquote><p>对Synchronized关键字的缺陷进行梳理</p></blockquote><h3 id="7-1-Synchronized缺陷-09-02"><a href="#7-1-Synchronized缺陷-09-02" class="headerlink" title="7-1 Synchronized缺陷 (09:02)"></a>7-1 Synchronized缺陷 (09:02)</h3><ol><li><p>效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程</p><p>在IO操作、sleep()等不会主动释放锁</p><p>永久等待别的线程释放锁，再获取锁。不到南墙不回头，不到黄河心不死</p><p>解决方案：使用Lock锁</p></li><li><p>不够灵活：加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。</p><p>读写锁在读操作时不会加锁，在写操作的时候才会加锁</p><p>解决方案：使用读写锁</p></li><li><p>无法知道是否成功获取到锁</p><p>Lock锁可以做尝试加锁。分成功、失败的情况</p></li></ol><pre><code class="java">/** * 展示Lock的方法 */public class LockExample15 {    public static void main(String[] args) throws InterruptedException {        Lock lock = new ReentrantLock();        lock.lock();        lock.unlock();        boolean tryLock1 = lock.tryLock();        boolean tryLock2 = lock.tryLock(10, TimeUnit.SECONDS);        Condition condition = lock.newCondition();    }}</code></pre><h2 id="第8章-常见面试题"><a href="#第8章-常见面试题" class="headerlink" title="第8章 常见面试题"></a>第8章 常见面试题</h2><blockquote><p>对常见面试题进行总结</p></blockquote><h3 id="8-1-常见面试问题-07-01"><a href="#8-1-常见面试问题-07-01" class="headerlink" title="8-1 常见面试问题 (07:01)"></a>8-1 常见面试问题 (07:01)</h3><ol><li><p>使用注意点：锁对象不能为空、作用域不宜过大、避免死锁</p><ul><li><p>锁对象不能为空：锁对象必须是一个实例对象，不能是一个空对象，需由new或者其他方法创建。锁的信息都保存在对象头中的。</p></li><li><p>作用域不宜过大：作用域即synchronized所包裹的范围，范围过大会降低程序运行速度。</p></li><li><p>避免死锁：</p><pre><code class="java">synchronized (instnace1) {    synchronized (instnace2) {}}synchronized (instnace2) {    synchronized (instnace1) {}}</code></pre></li></ul></li><li><p>如何选择Lock和synchronized关键字？</p><ul><li>如果可以，尽量都不使用。而是使用<code>java.util.concurrent</code>包下的原子类</li><li>如果synchronized适用，就优先使用synchronized。减少代码量。</li><li>特别需要才使用Lock、Condition</li></ul></li><li><p>多线程访问同步方法的各种具体情况</p><p>第四章。7种具体情况</p></li></ol><h2 id="第9章-思考题"><a href="#第9章-思考题" class="headerlink" title="第9章 思考题"></a>第9章 思考题</h2><blockquote><p>由点到面，进一步引发同学们的深入思考</p></blockquote><h3 id="9-1-思考题-05-47"><a href="#9-1-思考题-05-47" class="headerlink" title="9-1 思考题 (05:47)"></a>9-1 思考题 (05:47)</h3><ol><li><p>多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的是哪一个线程？用的是什么算法呢？</p><p>涉及到内部锁调度机制。可能是运行时间最短的，也有可能是等待时间最长的，甚至是随机的。这和不同JVM的版本和具体实现都有关系，所以不能依赖具体算法。只能判定为随机的、不可控制的。</p></li><li><p>synchronized使得同时只有一个线程可以运行，性能较差，有什么办法可以提升性能？</p><ul><li>优化使用范围，不宜范围过大。临界区在符合要求的情况下尽可能的小。</li><li>使用其他类型的锁，比如说读写锁</li></ul></li><li><p>我想更灵活地控制锁的获取和释放（现在释放锁的时机都被规定死了），怎们办？</p><p>可以自己实现一个Lock接口。参考已有的优秀的锁。</p></li><li><p>什么是锁的升级、降级？什么是JVM里的偏斜锁、轻量级锁、重量级锁？</p><p>随JVM版本的提高，synchronized关键字的性能得到了显著提升</p></li></ol><h2 id="第10章-课程总结"><a href="#第10章-课程总结" class="headerlink" title="第10章 课程总结"></a>第10章 课程总结</h2><blockquote><p>对课程进行总结梳理，展望。</p></blockquote><h3 id="10-1-课程总结和展望-13-35"><a href="#10-1-课程总结和展望-13-35" class="headerlink" title="10-1 课程总结和展望 (13:35)"></a>10-1 课程总结和展望 (13:35)</h3><p>一句话介绍synchronized</p><blockquote><p>JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以同时执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。</p></blockquote><p>思维导图：（百度脑图,别登录否则没有权限）</p><p><a href="https://naotu.baidu.com/file/12e7658471786e71e69cf57c9316a3de" target="_blank" rel="noopener">https://naotu.baidu.com/file/12e7658471786e71e69cf57c9316a3de</a></p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8rzca8dncj31lx0u01kx.jpg" alt="Synchronized关键字" style="zoom:100%;" /><p><strong>实战课：Java并发核心知识体系精讲</strong></p><blockquote><p><a href="https://coding.imooc.com/class/362.html" target="_blank" rel="noopener">https://coding.imooc.com/class/362.html</a></p></blockquote><ul><li>实现多线程的方式到底是1种、2种还是4种？：本质只有1种方式，实现执行内容有2种方式，而包装后的外在表现形式有多种形式</li><li>启动线程的正确和错误的方式：包含<code>start()</code>和<code>run()</code>的源码分析、对比</li><li>停止线程的正确方式：包含为什么广为流传的volatile boolean是错误的？如何做到3方配合，完美实现线程的停止？</li><li>线程的6个状态、线程的生命周期：一图说清线程的整个生命周期、究竟什么叫“线程阻塞”？</li><li>并发重要方法详解：包含<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>、<code>sleep()</code>、<code>join()</code>、<code>yield()</code>、<code>Thread.currentThread()</code>等</li><li>线程重要属性：包含守护线程和普通线程的区别？为什么不应该利用线程优先级设计程序？</li><li>线程的未捕获异常UncaughtException应该如何处理？有哪些解决方案？</li><li>线程安全：包含如何找出<code>a++</code>具体是在哪里出的错？3类线程不安全的现象、4种需要额外考虑线程安全的场景</li><li>Java内存模型详解——底层原理：重排序、可见性、原子性、happens-before、volatile</li><li>死锁详解：必然死锁的例子、发生死锁的4个条件、如何用jstack命令和代码这两种方式定位死锁？修复死锁的3种方案、实际工程中如何避免死锁？</li><li>彩蛋：如何从宏观和微观两个方面来提高技术？提高技术的途径？工作中业务缠身，如何在业务开发中得到更多成长？</li><li>常见面试问题——配有文档总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>352-细说Java多线程之内存可见性</title>
      <link href="/2019/01/05/352-volatile/"/>
      <url>/2019/01/05/352-volatile/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/352" target="_blank" rel="noopener">https://www.imooc.com/learn/352</a></p><p>简介：本课程带领大家深层次学习Java中的内存可见性、Java内存模型、指令重排序、as-if-serial语义等多线程中偏向底层的一些知识，以及synchronized和volatile实现内存可见性的原理和方法。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程简介"><a href="#第1章-课程简介" class="headerlink" title="第1章 课程简介"></a>第1章 课程简介</h2><blockquote><p>介绍课程目标和学习内容</p></blockquote><p>多线程-数据争用-内存可见性</p><ol><li>共享变量在线程间的可见性</li><li><code>synchronized</code>实现可见性</li><li><code>volatile</code>实现可见性<ul><li>指令重排序</li><li><code>as-if-serial</code>语义</li><li><code>volatile</code>使用注意事项</li></ul></li><li><code>synchronized</code>和<code>volatile</code>比较</li></ol><h2 id="第2章-可见性介绍"><a href="#第2章-可见性介绍" class="headerlink" title="第2章 可见性介绍"></a>第2章 可见性介绍</h2><blockquote><p>本章讲解Java内存模型，可见性的概念和可见性实现的原理</p></blockquote><h3 id="2-1-可见性介绍"><a href="#2-1-可见性介绍" class="headerlink" title="2-1 可见性介绍"></a>2-1 可见性介绍</h3><ol><li><p>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。</p></li><li><p>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。</p></li><li><p>线程的工作内存：<code>Java</code>内存抽象出来的概念</p></li><li><p><code>Java</code>内存模型（<code>JMM</code>）</p><p> <code>Java</code>内存模型（<code>Java Memory Model</code>）描述了<code>Java</code>程序中各种变量（线程共享变量）的访问规则，以及在<code>JVM</code>中将变量存储到内存和从内存中读取出变量这样的底层细节。</p></li><li><p>所有的变量都存储在主内存中</p><p> 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</p>  <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ol0a8of7j30xc0eq0u0.jpg" style="zoom:50%;" /></li><li><p>共享变量使用的两条规则  </p><ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成</li></ul></li><li><p>共享变量可见性实现的原理</p><p> 线程1对共享变量的修改要想被线程2及时看到，必须经过如下2个步骤：</p><ol><li><p>把工作内存1中更新过的共享变量刷新到主内存中</p></li><li><p>将主内存中最新的共享变量的值更新到工作内存2中</p><p>线程1–&gt;工作内存1中变量<code>X</code>–&gt;更新到主内存中–&gt;工作内存2中的变量<code>X</code>得到更新–&gt;线程2</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ol0lto5tj309907d74z.jpg" style="zoom:100%;" /></li></ol></li></ol><h3 id="2-2-练习题"><a href="#2-2-练习题" class="headerlink" title="2-2 练习题"></a>2-2 练习题</h3><p>下面叙述错误的是：B</p><blockquote><p>A. 通过<code>synchronized</code>和<code>volatile</code>都可以实现可见性</p><p>B. 不同线程之间可以直接访问其他线程工作内存中的变量</p><p>C. 线程对共享变量的所有操作都必须在自己的工作内存中进行</p><p>D. 所有的变量都存储在主内存中</p></blockquote><h2 id="第3章-synchronized实现可见性"><a href="#第3章-synchronized实现可见性" class="headerlink" title="第3章 synchronized实现可见性"></a>第3章 <code>synchronized</code>实现可见性</h2><blockquote><p>本章讲解synchronized实现可见性的原理和方法、指令重排序、as-if-serial语义等概念，并通过具体程序进行分析。</p></blockquote><h3 id="3-1-synchronized实现可见性原理"><a href="#3-1-synchronized实现可见性原理" class="headerlink" title="3-1 synchronized实现可见性原理"></a>3-1 <code>synchronized</code>实现可见性原理</h3><blockquote><p>要实现共享变量的可见性，必须保证两点：</p><ul><li>线程修改后的共享变量值能够及时从工作内存刷新到主内存中</li><li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中</li></ul></blockquote><blockquote><p>Java语言层面支持的可见性实现方式：<code>synchronized</code>、<code>volatile</code></p></blockquote><ol><li>synchronized能够实现：原子性（同步）、可见性</li><li>JMM关于synchronized的两条规定：<ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主存中重新读取最新的值。（注意：加锁与解锁需要是同一把锁）</li></ul></li></ol><pre><code>线程解锁前对共享变量的修改在下次加锁时对其他线程可见。</code></pre><ol start="3"><li><p>线程执行互斥代码块的过程：</p><ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行锁内代码</li><li>将更改后的共享变量值刷新到主内存</li><li>释放互斥锁</li></ol></li><li><p>指令重排序  </p><ol><li><p>重排序：代码的书写顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化</p><ul><li>编译器优化的重排序（编译器优化）重新安排代码的执行顺序</li><li>指令级并行的重排序（处理器优化）双核处理器采用了指令级并行技术，可执行多条指令</li><li>内存系统的重排序（处理器优化）对读写缓存做的优化<pre><code class="java">//代码顺序：         //执行顺序：int number = 1;     int result = 0;int result = 0;     int number = 1;</code></pre></li></ul></li><li><p><code>as-if-serial</code>：无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致（<code>Java</code>编译器都会保证<code>Java</code>在单线程下遵循<code>as-if-serial</code>语义）</p></li></ol></li></ol><pre><code>注：- 重排序不会给单线程带来内存可见性问题- 多线程中程序交错执行时，重排序可能会造成内存可见性问题  </code></pre><h3 id="3-2-synchronized实现可见性代码"><a href="#3-2-synchronized实现可见性代码" class="headerlink" title="3-2 synchronized实现可见性代码"></a>3-2 <code>synchronized</code>实现可见性代码</h3><pre><code class="java">ready = false;result = 0;number = 1;// 写操作public void write() {   ready = true; // 1.1   number = 2; // 1.2}//读操作public void read() {   if (ready) { // 2.1       result = number * 3;//2.2   }   System.out.println(&quot;result的值为：&quot; + result);}</code></pre><p>执行顺序：</p><ol><li>1.1–&gt;2.1–&gt;2.2–&gt;1.2<br>result=3;</li><li>1.2–&gt;2.1–&gt;2.2–&gt;1.1<br>result=0;</li></ol><p>导致共享变量在线程间不可见的原因：</p><ol><li>线程的交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主内存间及时更新</li></ol><p>synchronized解决不可见的方案：</p><ol><li>原子性：由于锁的关系，线程之间不允许交叉执行；相当于给该线程（或当前运行的有且仅有一个的线程）加了一把锁，外面的线程无法进入，更别提互相交叉执行。</li><li>原子性 + <code>as-if-serial</code>语义：线程不能交叉执行，重排序对于单线程不能影响运行结果。</li><li>可见性：共享变量的更新执行。</li></ol><p>常见问题：</p><ol><li>为何不加<code>synchronized</code>关键字也会执行可见性，是主内存及时更新被获取最新值么？<br>因为当时定义说加<code>synchronized</code>一定会可见性，而不加也没说一定不会，只是有可能不会。因为现在<code>Java</code>做了一些优化：尽量实现可见性；但是不能保证每次都成功，只是成功概率比较大99%，但还是有1%的情况会失败。所以处于安全性考虑，尽量加<code>synchronized</code>关键字100%成功。</li><li>有时候不存在线程交叉情况，但是会先执行第二个线程，这是因为第一个线程把<code>CPU</code>让位出来。所以为了避免这种情况，可以在第一个线程后附上代码：<code>sleep(1000);</code>1秒之后才有机会执行线程2。</li><li><code>synchronized</code> + <code>sleep();</code>黄金搭档。<h3 id="3-5-练习题"><a href="#3-5-练习题" class="headerlink" title="3-5 练习题"></a>3-5 练习题</h3>下面说法错误的是：C<blockquote><p>A. 当两个并发线程访问同一个对象<code>object</code>中的这个<code>synchronized(this)</code>同步代码块时，一个时间内只能有一个线程得到执行。</p><p>B. 当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，另一个线程仍然可以访问该<code>object</code>中的非<code>synchronized(this)</code>同步代码块。</p><p>C. 当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，其他线程对<code>object</code>中所有其它<code>synchronized(this)</code>同步代码块的访问不会被阻塞。</p><p>D. 当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，它就获得了这个<code>object</code>的对象锁。结果，其它线程对该<code>object</code>对象所有同步代码块部分的访问都被暂时阻塞。</p></blockquote></li></ol><h2 id="第4章-volatile实现可见性"><a href="#第4章-volatile实现可见性" class="headerlink" title="第4章 volatile实现可见性"></a>第4章 <code>volatile</code>实现可见性</h2><blockquote><p>本章讲解volatile实现可见性的原理和方法，以及需要使用volatile时需要注意的事项，并通过具体程序进行分析。</p></blockquote><h3 id="4-1-volatile能够保证可见性"><a href="#4-1-volatile能够保证可见性" class="headerlink" title="4-1 volatile能够保证可见性"></a>4-1 <code>volatile</code>能够保证可见性</h3><ol><li><p><code>volatile</code>关键字：</p><ul><li>能够保证<code>volatile</code>变量的可见性。</li><li>不能保证<code>volatile</code>变量复合操作的原子性。</li></ul></li><li><p><code>volatile</code>如何实现内存可见性：</p><p>通过加入内存屏障和禁止重排序优化来实现的。</p></li><li><p>对<code>volatile</code>变量执行写操作时，会在写操作后加入一条<code>store</code>屏障指令。</p></li><li><p>对<code>volatile</code>变量执行读操作时，会在读操作前加入一条<code>load</code>屏障指令。</p><p> <code>Java</code>内存模型中一共定义了8条操作指令来完成主内存和工作内存的交互</p><p> <strong>★通俗地讲</strong>：<code>volatile</code>变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时候，不同的线程总能看到该变量的最新值</p></li><li><p>线程读/写<code>volatile</code>变量的过程：</p><ul><li>线程写<code>volatile</code>变量的过程：<ol><li>改变线程工作内存的中<code>volatile</code>变量副本的值。</li><li>将改变后的副本的值从工作内存刷新到主内存。</li></ol></li><li>线程读<code>volatile</code>变量的过程：<ol><li>从主内存中读取<code>volatile</code>变量的最新值到线程的工作内存中。</li><li>从工作内存中读取<code>volatile</code>变量的副本。</li></ol></li></ul></li><li><p><code>volatile</code>不能保证<code>volatile</code>变量复合操作的原子性</p><ol><li><p><code>number++;</code>的步骤：</p><ol><li>读取<code>number</code>的值</li><li>将<code>number</code>的值加1</li><li>写入最新的<code>number</code>的值<pre><code class="java">private int number = 0;number++;//不是原子操作</code></pre></li></ol></li><li><p>加入<code>synchronized</code>，变为原子操作 </p><pre><code class="java">synchronized(this){    number++;}</code></pre></li><li><p>变为<code>volatile</code>变量，无法保证原子性 </p><p><code>private volatile int number = 0;</code></p></li></ol></li></ol><h3 id="4-2-volatile不能保证原子性"><a href="#4-2-volatile不能保证原子性" class="headerlink" title="4-2 volatile不能保证原子性"></a>4-2 <code>volatile</code>不能保证原子性</h3><p>例：</p><blockquote><p><code>number = 5</code> </p></blockquote><ol><li><p>线程<code>A</code>读取<code>number</code>的值 A=5 B=N M=5</p></li><li><p>线程<code>B</code>读取<code>number</code>的值 A=5 B=5 M=5</p></li><li><p>线程<code>B</code>执行加1操作 A=5 B=6 M=5</p></li><li><p>线程<code>B</code>写入最新的<code>number</code>的值 A=5 B=6 M=6</p></li><li><p>线程<code>A</code>执行加1操作 A=6 B=6 M=6</p></li><li><p>线程<code>A</code>写入最新的<code>number</code>的值 A=6 B=6 M=6</p><p>两次<code>number++</code>只增加了1</p></li></ol><p>解决方案：</p><blockquote><p>保证<code>number</code>自增操作的原子性：</p></blockquote><ol><li><p>使用<code>synchronized</code>关键字</p><pre><code class="java"> synchronized (this) {     this.number++; }</code></pre></li><li><p>使用<code>ReentrantLock</code>(<code>java.util.concurrent.locks</code>包下)，最好使用<code>try-finally</code></p><pre><code class="java"> private Lock lock = new ReentrantLock(); lock.lock(); try {     this.number++; } finally {     lock.unlock(); }</code></pre></li><li><p>使用<code>AtomicInteger</code>(<code>java.util.concurrent.atomic</code>包下)</p><pre><code class="java"> private AtomicInteger num = new AtomicInteger(0); num.getAndAdd(1);</code></pre></li></ol><h3 id="4-5-volatile使用注意事项"><a href="#4-5-volatile使用注意事项" class="headerlink" title="4-5 volatile使用注意事项"></a>4-5 <code>volatile</code>使用注意事项</h3><p>要在多线程中安全的使用<code>volatile</code>变量，必须同时满足：</p><ol><li><p>对变量的写入操作不依赖其当前值</p><p>不满足：<code>number++</code>、<code>count=count*5</code>等<br>满足：<code>boolean</code>变量、记录温度变化的变量等</p></li><li><p>该变量没有包含在具有其他变量的不变式中</p><p>不满足：不变式<code>low&lt;up</code></p></li></ol><h3 id="4-6-synchronized与volatile比较"><a href="#4-6-synchronized与volatile比较" class="headerlink" title="4-6 synchronized与volatile比较"></a>4-6 <code>synchronized</code>与<code>volatile</code>比较</h3><ol><li><code>volatile</code>不需要加锁，比<code>synchronized</code>更轻量级，不会阻塞线程</li><li>从内存可见性角度讲：<code>volatile</code>读操作相当于加锁；<code>volatile</code>写操作相当于解锁</li><li><code>synchronized</code>既能保证可见性，又能保证原子性；而<code>volatile</code>只能保证可见性，无法保证原子性</li></ol><p>总而言之：<code>synchronized</code>稳定性高，效率低；<code>volatile</code>稳定性低，效率高。</p><h3 id="4-7-练习题"><a href="#4-7-练习题" class="headerlink" title="4-7 练习题"></a>4-7 练习题</h3><p>下列说法中错误的是：A</p><blockquote><p>A. <code>volatile</code>是保证被修饰变量的可见性，同时也保证原子操作<br>B. <code>Java</code>中没有提供检测与避免死锁的专门机制，但应用程序员可以采用某些策略防止死锁的发生<br>C. <code>JAVA</code>中对共享数据操作的并发控制是采用加锁技术<br>D. 共享数据的访问权限都必须定义为<code>private</code></p></blockquote><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>总结本门课程的学习内容</p></blockquote><p>总结：</p><ol><li>什么是内存可见性</li><li><code>Java</code>内存模型（<code>JMM</code>）</li><li>实现可见性的方式：<code>synchronized</code>和<code>volatile</code><ul><li><code>final</code>也可以保证内存的可见性</li></ul></li><li><code>synchronized</code>和<code>volatile</code>实现内存可见性的原理</li><li><code>synchronized</code>实现可见性<ul><li>指令重排序</li><li><code>as-if-serial</code>语义</li></ul></li><li><code>volatile</code>实现可见性<ul><li><code>volatile</code>能够保证可见性</li><li><code>volatile</code>不能保证原子性(<code>number++</code>)</li><li><code>volatile</code>使用注意事项</li></ul></li><li>synchronized和volatile比较<ul><li>volatile比synchronized更轻量级</li><li>synchronized比volatile使用更广泛</li></ul></li></ol><p>补充：  </p><ol><li><p>问：即使没有保证可见性的措施(如s<code>ynchronized</code>、<code>volatile</code>、<code>final</code>)，很多时候共享变量依然能够在主内存和工作内存见得到及时的更新？</p><p>答：一般只有在短时间内高并发的情况下才会出现变量得不到及时更新的情况，因为<code>CPU</code>在执行时会很快地刷新缓存，所以一般情况下很难看到这种问题。</p></li><li><p>对64位(<code>long</code>、<code>double</code>)变量的读写可能不是原子操作：</p><p><code>Java</code>内存模型允许<code>JVM</code>将没有被<code>volatile</code>修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行</p><p>导致问题：有可能会出现读取到“半个变量”的情况</p><p>解决方法：加<code>volatile</code>关键字</p><p><strong>注</strong>：目前几乎所有虚拟机已经把64位数据的读写做了原子操作，不需将(<code>long</code>、<code>double</code>)使用<code>volatile</code>修饰</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>312-细说多线程之Thread VS Runnable</title>
      <link href="/2018/12/30/312-thread-runnable/"/>
      <url>/2018/12/30/312-thread-runnable/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/312" target="_blank" rel="noopener">https://www.imooc.com/learn/312</a></p><p>简介：本课程将带领大家更加深入地学习Java多线程的机制，深入理解创建线程的两种方式Thread和Runnable之间的差异，掌握线程的生命周期和守护线程的概念，以及如何使用jstack生成线程快照。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课前准备"><a href="#第1章-课前准备" class="headerlink" title="第1章 课前准备"></a>第1章 课前准备</h2><blockquote><p>了解学习本课程前的必备知识</p></blockquote><p><a href="https://www.imooc.com/learn/202" target="_blank" rel="noopener">《深入浅出Java多线程》</a></p><blockquote><p>比较Thread和Runnable这两种线程创建的方式，需要知道Thread和Runnable的基本创建方式。</p></blockquote><p>课程目标和学习内容</p><ul><li>线程创建的两种方式比较</li><li>线程的生命周期</li><li>线程的守护神：守护线程</li></ul><h2 id="第2章-Thread-VS-Runnable"><a href="#第2章-Thread-VS-Runnable" class="headerlink" title="第2章 Thread VS Runnable"></a>第2章 <code>Thread</code> VS <code>Runnable</code></h2><blockquote><p>本章首先回顾了线程创建的两种方式，而后通过一个程序案例，深入比较了这两种创建线程的方式。</p></blockquote><h3 id="2-1-回顾线程创建的两种方式"><a href="#2-1-回顾线程创建的两种方式" class="headerlink" title="2-1 回顾线程创建的两种方式"></a>2-1 回顾线程创建的两种方式</h3><ol><li><p>继承<code>Thread</code>类</p><pre><code class="java"> class MyThread extents Thread {     // ...     @Override     public void run() {         // ...     } } MyThread mt = new MyThread(); // 创建线程 mt.start(); // 启动线程</code></pre></li><li><p>实现<code>Runnable</code>接口</p><pre><code class="java"> class MyRunnable implements Runnable {     // ...     @Override     public void run() {         // ...     } } MyRunnable mr = new MyRunnable(); Thread td = new Thread(mr); // 创建线程 td.start(); // 启动线程</code></pre></li></ol><h3 id="2-2-应用Thread模拟卖票"><a href="#2-2-应用Thread模拟卖票" class="headerlink" title="2-2 应用Thread模拟卖票"></a>2-2 应用<code>Thread</code>模拟卖票</h3><p><code>Thread</code>与<code>Runnable</code>的区别：</p><ol><li><p><code>Runnable</code>方式可以避免<code>Thread</code>方式由于<code>Java</code>单继承特性带来的缺陷</p><p>单继承：Java语言中只能继承一个父类，而可以实现多个接口</p></li><li><p><code>Runnable</code>的实例对象可以被多个线程（<code>Thread</code>实例）共享，适合于多个线程处理<strong>同一资源</strong></p></li></ol><p>针对Thread和Runnable对于同一资源处理：</p><pre><code class="java">class MyThread extends Thread{}class MyRunnable implements Runnable{}public static void main(String[] args) {    // 注意：此时t1,t2,t3是堆内存中实例出的三个对象，对于它们所有属性也独立的    MyThread t1 = new MyThread();    MyThread t2 = new MyThread();    MyThread t3 = new MyThread();    // 注意：t1,t2,t3虽然是堆中的三个不同对象，但是此时的r是一个，所以三个线程引用r中的资源也是共有的    MyRunnable r = new MyRunnable();    Thread t1 = new Thread(r);    Thread t2 = new Thread(r);    Thread t3 = new Thread(r);}</code></pre><p>结论：Runnable可以实现资源共享，而Thread资源独立</p><p>注：</p><ul><li><code>a--</code>、<code>a++</code>、<code>++a</code>、<code>--a</code>、<code>a+=1</code>等为非原子操作（non-atomic operation），需要加锁</li></ul><h2 id="第3章-线程的生命周期和守护线程"><a href="#第3章-线程的生命周期和守护线程" class="headerlink" title="第3章 线程的生命周期和守护线程"></a>第3章 线程的生命周期和守护线程</h2><blockquote><p>本章归纳总结了线程的生命周期，讲解了守护线程，并演示了如何使用jstack生成线程快照</p></blockquote><h3 id="3-1-线程的生命周期"><a href="#3-1-线程的生命周期" class="headerlink" title="3-1 线程的生命周期"></a>3-1 线程的生命周期</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8odd59oopj30zk0k0gmb.jpg" style="zoom:50%;" /><ol><li>创建：新建一个线程对象，如<code>Thread thd = new Thread()</code></li><li>就绪：创建了线程对象后，调用了线程的<code>start()</code>方法（注意：此时线程只是进入了线程队列，等待获取<code>CPU</code>服务，具备了运行的条件，但并不一定已经开始运行了）</li><li>运行：处于就绪状态的线程，一旦获取了<code>CPU</code>资源，便进入到运行状态，开始执行<code>run()</code>方法里面的逻辑</li><li>终止：线程的<code>run()</code>方法执行完毕，或者调用线程的<code>stop()</code>方法（该方法已经废弃），线程便进入终止状态</li><li>阻塞：一个正在执行的线程在某种情况下，由于某种原因而暂时让出了<code>CPU</code>资源，暂停了自己的执行，便进入了阻塞状态，如调用了<code>sleep()</code>、<code>wait()</code>、<code>yield()</code>等方法</li></ol><h3 id="3-2-守护线程理论知识"><a href="#3-2-守护线程理论知识" class="headerlink" title="3-2 守护线程理论知识"></a>3-2 守护线程理论知识</h3><p><code>Java</code>线程分两类：</p><ol><li><p>用户线程：运行在前台，执行具体任务</p><p>例如：程序的主线程，连接网络的子线程等</p></li><li><p>守护线程：运行在后台，为其他前台线程服务</p><p>特点：一旦所有用户线程都结束运行，守护线程会随<code>JVM</code>一起结束工作</p><p>应用：</p><ol><li>数据库连接池中的监测线程</li><li><code>JVM</code>虚拟机启动后的监测线程<ul><li>垃圾回收线程</li><li>监测内存使用的线程</li><li>监测程序锁持有的线程  </li></ul></li></ol></li></ol><p>如何设置守护线程：</p><ul><li>可以通过调用<code>Thread</code>类的<code>setDaemon(true)</code>方法来设置当前的线程为守护线程  </li></ul><p><strong>注意事项</strong>：</p><ul><li><code>setDaemon(true)</code>必须在<code>start()</code>方法之前调用，否则会抛出<code>IllegalThreadStateException</code>异常</li><li>在守护线程中产生的新线程也是守护线程</li><li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li></ul><h3 id="3-3-守护线程代码示例"><a href="#3-3-守护线程代码示例" class="headerlink" title="3-3 守护线程代码示例"></a>3-3 守护线程代码示例</h3><pre><code class="java">public static void main(String[] args) {    System.out.println(&quot;进入主线程&quot; + Thread.currentThread().getName());    DaemonThread daemonThread = new DaemonThread();    Thread thread = new Thread(daemonThread);    thread.setDaemon(true);//设置为守护线程    thread.start();    Scanner scanner = new Scanner(System.in);    scanner.next();    // 主线程为唯一用户线程    // thread为守护线程    // 主线程退出导致数据的不完整性    System.out.println(&quot;退出主线程&quot; + Thread.currentThread().getName());}</code></pre><p>thread线程运行完成后程序不会立刻终止，此时thread守护线程需等待main主用户线程scanner之后才会结束运行。</p><h3 id="3-4-使用jstack生成线程快照"><a href="#3-4-使用jstack生成线程快照" class="headerlink" title="3-4 使用jstack生成线程快照"></a>3-4 使用jstack生成线程快照</h3><p>位置：<code>jdk/bin/jstack.exe</code></p><table><thead><tr><th align="center">程序</th><th align="center">工具作用</th></tr></thead><tbody><tr><td align="center">jstack</td><td align="center">生成JVM线程快照</td></tr><tr><td align="center">jstat.exe</td><td align="center">监测虚拟机的运行状态</td></tr><tr><td align="center">jconsole.exe</td><td align="center">Java监视和管理控制台GUI</td></tr><tr><td align="center">jvisualvm.exe</td><td align="center">界面化工局</td></tr><tr><td align="center">jmap.exe</td><td align="center">生成堆快照</td></tr><tr><td align="center">虚拟机的运行状态：内存的使用情况、类加载情况、锁持有的情况</td><td align="center"></td></tr></tbody></table><p><code>jstack</code></p><ul><li>作用：生成<code>JVM</code>当前时刻线程的快照（<code>threaddump</code>，即当前进程中所有线程的信息）</li><li>目的：帮助定位程序问题出现的原因(查找一些程序问题)，如长时间停顿、<code>CPU</code>占用率过高、死锁、阻塞等；看出哪些是守护线程，哪些是用户线程</li><li>使用：<code>jstack -l &lt;pid&gt;</code>—-其中<code>&lt;pid&gt;</code>可以通过任务栏管理器查看<ol><li>可以通过线程名后是否有<code>daemon</code>判断是否为守护线程，有-是、无-否</li><li>查看线程的状态<code>java.lang.Thread.State</code>帮助定位程序出现的一系列问题(死锁、阻塞)</li><li><code>tid</code>、<code>nid</code>可以帮助查找<code>CPU</code>占有率很高的线程</li><li><code>prio</code>代表优先级</li></ol></li></ul><p>线程状态：  </p><ul><li><code>New</code>尚未启动的线程（创建）；</li><li><code>Runnable</code>在<code>Java</code>虚拟机中执行的线程，即将或正在运行的线程（就绪，运行）；</li><li><code>Terminated</code>已退出的线程（终止）；</li><li><code>Blocked</code>、<code>Waiting</code>、<code>Timed_Waiting</code>对应阻塞状态。<ol><li><code>Blocked</code>：等待监视器锁定的线程，如被<code>synchronized</code>阻塞的线程。</li><li><code>Waiting</code>：无限期等待另一个线程执行特定操作的线程，调用<code>join</code>方法时。</li><li><code>Timed_Waiting</code>：等待另一个线程在指定等待时间内执行操作的线程，如<code>sleep</code>方法。</li></ol></li></ul><h2 id="第4章-课程总结"><a href="#第4章-课程总结" class="headerlink" title="第4章 课程总结"></a>第4章 课程总结</h2><blockquote><p>课程总结</p></blockquote><p>建议：使用实现<code>Runnable</code>接口的方式创建线程</p><p>补充：</p><ol><li><p>程序中的同一资源指的是同一个<code>Runnable</code>对象</p><p>如果把其他类的对象也作为共享资源，则<code>Thread</code>和<code>Runnable</code>都是可以用来处理同一资源</p></li><li><p>安全的卖票程序中需要加入同步（<code>synchronized</code>）</p></li></ol><p>Thread vs Runnable，线程的生命周期，守护线程，jstack生成线程快照</p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202-深入浅出Java多线程</title>
      <link href="/2018/12/29/202-multi-thread/"/>
      <url>/2018/12/29/202-multi-thread/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/202" target="_blank" rel="noopener">https://www.imooc.com/learn/202</a></p><p>简介：多线程是日常开发中的常用知识，也是难用知识。通过本视频，你可以了解Java中多线程相关的基本概念，如何创建，启动和停止线程？什么是正确的多线程，怎样编写多线程程序。在掌握基础之后，将为你展望进阶路线，为进一步的学习提供方向。</p></blockquote><p>@[TOC]</p><h2 id="第1章-多线程背景知识介绍"><a href="#第1章-多线程背景知识介绍" class="headerlink" title="第1章 多线程背景知识介绍"></a>第1章 多线程背景知识介绍</h2><blockquote><p>本章将介绍与多线程编程相关的背景概念</p></blockquote><p>进程  </p><ol><li><p>进程是程序（任务）的执行过程，是动态性的。</p><p>放在磁盘文件中的文件并不是进程，只有在运行状态的才可称之为进程。</p></li><li><p>持有资源（共享内存，共享文件）和线程。进程是资源和线程的载体</p></li></ol><p>线程</p><ol><li>线程是系统中最小的执行单元</li><li>同一进程中有多个线程</li><li>线程共享进程的资源</li></ol><p>线程的交互：多个线程需要正确的通信才能进行工作。</p><blockquote><p>交互方式有互斥和同步两种。</p></blockquote><ul><li><p>互斥是当一个线程正在运行时其他的线程只能等待，只有在当前线程完成后才可以运行；</p></li><li><p>同步是两个或多个线程同时进行运行。</p></li></ul><h2 id="第2章-Java-线程初体验"><a href="#第2章-Java-线程初体验" class="headerlink" title="第2章 Java 线程初体验"></a>第2章 Java 线程初体验</h2><blockquote><p>Java 语言层面对线程的支持，如何创建，启动和停止线程。如何使用常用的线程方法。用隋唐演义理解线程的代码</p></blockquote><p>Java对线程的支持体现在<code>java.lang</code>的包下的class类<code>Thread</code>和interface接口<code>Runnable</code></p><p>共通的方法是<code>public void run()</code>，为我们提供线程实际工作执行的代码</p><p><strong>Thread常用方法：</strong></p><ol><li><p>线程的创建  </p><pre><code class="java"> Thread(); Thread(String name); Thread(Runnable target); Thread(Runnable target, String name);</code></pre></li><li><p>线程的方法  </p><pre><code class="java"> void start(); // 启动线程。Java虚拟机调用该线程的run()方法。 static void sleep(long millis); // 线程休眠(暂停执行) 。millis休眠的时间，单位是毫秒，可以精确到纳秒。此操作受到系统计时器和调度程序精度和准确性的影响。 static void sleep(long millis, int nanos); void join(); // 使其他线程等待当前线程终止。指明其他线程必须等待当前结束后才能运行 void join(long millis); // 参数表示其他线程最长等待的时间 void join(long millis,int nanos); static void yield(); // 当前运行线程释放处理器资源并且重新去竞争处理器资源</code></pre></li><li><p>获取线程引用  </p><pre><code class="java"> static Thread currentThread(); // 返回当前运行的线程引用（静态方法，返回Thread类型）</code></pre></li><li><p>线程的信息<br> <code>.getName()</code>：返回线程的名字</p><p> <code>.setName(String Name)</code>：改变线程的名字  </p></li></ol><p><strong><code>Thread</code>类 和 <code>Runnable</code>接口的区别与联系：</strong>  </p><ol><li><code>Runnable</code>只是一个接口，它里面只有一个<code>run()</code>方法，没有<code>start()</code>方法， 所以即使实现了<code>Runnable</code>接口，那也无法启动线程，必须依托其他类。  </li><li><code>Thread</code>类，有一个构造方法，参数是<code>Runnable</code>对象，也就是说可以通过<code>Thread</code>类来启动<code>Runnable</code>实现的多线程。  </li></ol><p>注：</p><ul><li><p>在同一时间内同一处理器或同一个核只能运行一条线程，当一条线程休眠之后，另一条线程才获得了我们处理器的时间</p></li><li><p>一个<code>.java</code>文件中可以有多个类，但是只能有一个<code>public</code>修饰的类</p></li><li><p><code>Runnable</code>接口之中没有<code>getName()</code>方法，我们可以使用<code>Thread</code>的静态方法<code>currentThreat().getName();</code>获取该对象的名字。</p></li><li><p>若实现<code>Runnable</code>接口通过<code>Thread.currentThread().getName()</code>方法获取当前线程名称，继承<code>Thread</code>类则<code>getName()</code>方法获取当前线程。</p></li></ul><h3 id="实例：隋唐演义"><a href="#实例：隋唐演义" class="headerlink" title="实例：隋唐演义"></a>实例：隋唐演义</h3><blockquote><p>历史是人民群众创建的，英雄可以推动历史的发展  </p></blockquote><p><strong>1. 演员简介：</strong></p><ul><li><p>军队 <code>ArmyRunnable</code></p></li><li><p>英雄 <code>KeyPersonThread</code></p></li><li><p>舞台 <code>Stage</code>  </p><pre><code class="java">// 隋唐演义大戏舞台public class Stage extends Thread {    @Override    public void run() {        ArmyRunnable armyTaskOfSuiDynasty = new ArmyRunnable();        ArmyRunnable armyTaskOfArmyOfRevolt = new ArmyRunnable();        //使用 Runnable 接口创建线程        Thread armyOfSuiDynasty = new Thread(armyTaskOfSuiDynasty, &quot;隋军&quot;);        Thread armyOfRevolt = new Thread(armyTaskOfarmyOfRevolt, &quot;农民起义军&quot;);    }}</code></pre></li></ul><p><strong>2. 军队：</strong>  </p><ol><li><p>加入<code>join()</code>是为了让舞台线程最后停止。</p><p> 如果不加有可能舞台线程结束，军队线程还未停止，就好比导演喊停，演员还在演！</p><p> 可以在<code>join()</code>后面加入测试语句<code>System.out.println(&quot;舞台结束!&quot;);</code>，然后去掉或者保留<code>join</code>观察效果。</p></li><li><p><code>volatile</code>关键字保证了线程可以正确地读取其他线程写入的值。</p><p> 如果不写成<code>volatile</code>，由于可见性的问题，当前线程有可能读取不到这个值 //可见性JMM（JAVA内存模型）happens-before原则、可见性原则</p><p> 用<code>volatile</code>修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的值</p></li><li><p><code>Thread.yield();</code>当前线程让出处理器时间，公平竞争  </p></li></ol><p><strong>3. 关键先生：</strong>  </p><ol><li><code>start()</code>开始线程。  </li><li><code>sleep()</code>线程休眠。  </li><li><code>yield()</code>让出当前线程的执行权限，随机选择线程执行。  </li><li><code>join()</code>优先执行该线程，其他线程(包括主线程main)都暂停。  </li></ol><h2 id="第3章-Java-线程的正确停止"><a href="#第3章-Java-线程的正确停止" class="headerlink" title="第3章 Java 线程的正确停止"></a>第3章 Java 线程的正确停止</h2><blockquote><p>本章讨论如何正确的停止一个线程，既要线程停得了，还得线程停得好。</p></blockquote><ol><li><p>错误的停止线程方法：  </p><ol><li><p><code>stop()</code>方法会导致线程戛然而止，我们不清楚线程完成了什么，没完成什么，也没有时间来完成对应的线程运行的清理工作。</p></li><li><p><code>interrupt()</code>方法只能设置<code>interrupt</code>标志位（且在线程阻塞情况下，标志位会被清除，更无法设置中断标志位），无法停止线程</p><blockquote><ol><li><code>Interrupted</code> 相当于 旗标 (isInterrupted ==&gt;true false) <ol start="2"><li>线程中使用<code>sleep</code>等方法造成线程堵塞时， 标志位被清除，<code>Interrupted</code>方式无效同时抛出<code>InterruptedException</code>（中断异常）</li><li><code>interrupt</code>方法是用来唤醒被阻塞的线程的。如果线程使用了<code>wait</code>, <code>sleep</code>, <code>join</code>方法，那么线程就会进入阻塞状态，使用<code>interrupt</code>方法会终止这种状态，此时线程的<code>sleep</code>等方法下面的<code>catch</code>语句就会接收到这个打断，从而启动线程，继续做要做的事情。如果线程在阻塞之前使用<code>interrupt</code>方法，那么在阻塞的时候，会抛出异常，并把中断标志位设置成<code>false</code>。</li></ol></li></ol></blockquote></li></ol></li><li><p>正确的停止线程方法：</p><p> 在线程执行中设置状态标识，通过控制此状态标识，来控制线程的正常完整的结束。</p><p> 另外，<code>volatile</code>关键字是保证所有其他线程里的变量的赋值都能同步到当前内存里变量的值。</p><p> 这样做的好处是：线程有机会使得一个业务步骤被完整地执行，在执行完业务步骤后有充分的时间去做代码的清理工作，使得线程代码在实际中更安全</p></li></ol><h2 id="第4章-线程交互"><a href="#第4章-线程交互" class="headerlink" title="第4章 线程交互"></a>第4章 线程交互</h2><blockquote><p>争用条件，线程的交互，及死锁的成因及预防</p></blockquote><p><strong>争用条件：</strong></p><ol><li>定义：当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（corrupted)，这种现象称为争用条件</li><li>原因：每个线程在操作数据时，会先将数据初值读【取到自己获得的内存中】，然后在内存中进行运算后，重新赋值到数据。 </li><li>争用条件：线程1在还【未重新将值赋回去时】，线程1阻塞，线程2开始访问该数据，然后进行了修改，之后被阻塞的线程1再获得资源，而将之前计算的值覆盖掉线程2所修改的值，就出现了数据丢失情况</li></ol><p><strong>互斥与同步：</strong></p><ol><li>互斥<br>同一时间，只能有一个线程访问关键数据或临界区</li><li>同步<br>是一种通信机制，一个线程操作完成后，以某种方式通知其他线程</li><li>实现方法<blockquote><ol><li>【互斥】构建锁对象<code>private final Object lockObj = new Object();</code></li><li>通过<code>synchronized(lockObj){  互斥的代码块  }</code>加锁操作。加锁操作会开销系统资源，降低效率</li><li>在某线程的条件不满足任务时，使用<code>lockObj.wait();</code>对线程进行阻挡，防止其继续竞争<code>CPU</code>资源，滞留在<code>wait set</code>中，等待唤醒，【唤醒后继续完成业务】</li><li>【同步】在某一代码正确执行完业务后，通过<code>lockObj.notifyAll()</code>唤醒所有在<code>lockObj</code>对象等待的线程</li></ol></blockquote></li></ol><ul><li><p>互斥：关键数据在一个时间被一个线程使用。</p><p>互斥的实现：<code>private final Object lockObj = new Object()</code>、<code>synchronized(intrinsic lock) {}</code>  </p></li><li><p>同步：两个线程之间的一种交互的操作（一个线程发出消息另外一个线程响应）</p><p>同步的实现：<code>wait();</code>、<code>notify();</code>、<code>notifyAll();</code>，都是属于Java中的<code>Object</code>对象的成员函数</p></li></ul><p><strong>注：</strong> 调用<code>wait();</code>和<code>notifyAll();</code>方法使线程进入等待或者唤醒不是在同一个线程的同一次操作中执行的，当操作结束，唤醒了所有的等待线程之后，线程又将有着公平的机会竞争CPU资源。  </p><p><code>wait set</code>类似于线程的休息室，访问共享数据的代码称为临界区<code>critical section</code>。<br>一个线程获取锁，然后进入临界区,发现某些条件不满足，然后调用锁对象上的<code>wait()</code>方法，然后线程释放掉锁资源，进入锁对象上的<code>wait set</code>。其他线程可以获取锁资源，然后执行，完了以后调用<code>notify()/notifyAll()</code>，通知锁对象上的等待线程。  </p><h2 id="第5章-进阶展望"><a href="#第5章-进阶展望" class="headerlink" title="第5章 进阶展望"></a>第5章 进阶展望</h2><blockquote><p>简单介绍 Java 并发相关的类，及常用的多线程编程模型</p></blockquote><p>要点回顾：</p><ol><li>线程如何创建以及线程的基本概念</li><li>可见性以及<code>volatile</code>关键字</li><li>争用条件</li><li>如何通过<code>synchronized</code>让线程的互斥</li><li>如何通过<code>wait/notify</code>、<code>notifyAll</code>让线程同步</li></ol><p><strong>展望：</strong></p><ol><li>Java Memory Mode:  <ul><li>JMM描述了java线程如何通过内存进行交互</li><li>了解happens-before</li><li>synchronized,volatile &amp; final</li></ul></li><li>Locks % Condition：<ul><li>锁机制和等待条件的高层实现</li><li>java.util.concurrent.locks</li></ul></li><li>线程安全性<ul><li>原子性与可见性</li><li>java.util.concurrent.atomic</li><li>synchronized &amp; volatile</li><li>DeadLocks(死锁)</li></ul></li><li>多线程常用的交互模型<ul><li>Producer-Consumer模型</li><li>Read-Write Lock模型</li><li>Future模型</li><li>Worker Thread模型</li><li>了解哪些类实现了这些模型可以用来直接使用</li></ul></li><li>Java5中并发编程工具：<ul><li>java.util.concurrent</li><li>线程池ExecutorService</li><li>Callable &amp; Future</li><li>BlockingQueue</li></ul></li><li>推荐书本<ul><li>CoreJava</li><li>Java Concurrency In Practice</li></ul></li></ol><p><strong>Java多线程特性：</strong></p><ol><li><p>原子性：<code>Java</code>内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过<code>synchronized</code>和<code>Lock</code>来实现。由于<code>synchronized</code>和<code>Lock</code>能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></li><li><p>可见性：对于可见性，<code>Java</code>提供了<code>volatile</code>关键字来保证可见性。当一个共享变量被<code>volatile</code>修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>另外，通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，<code>synchronized</code>和<code>Lock</code>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></li><li><p>有序性：在<code>Java</code>内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p> 在<code>Java</code>里面，可以通过<code>volatile</code>关键字来保证一定的“有序性”。另外可以通过<code>synchronized</code>和<code>Lock</code>来保证有序性，很显然，<code>synchronized</code>和<code>Lock</code>保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p> 另外，<code>Java</code>内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为<code>happens-before</code>原则。如果两个操作的执行次序无法从<code>happens-before</code>原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
