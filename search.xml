<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1129-玩转Vim 从放弃到爱不释手</title>
      <link href="/2019/11/05/1129-vim/"/>
      <url>/2019/11/05/1129-vim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1129" target="_blank" rel="noopener">https://www.imooc.com/learn/1129</a></p><p>简介：Vim作为一个强大的编辑器，是很多巨佬的不二之选，但因为其较高的入门学习门槛劝退了很多人。中文的系统教程少之又少，讲vim插件使用的更是屈指可数，本课程从vim最基础的操作和概念开始讲起，带领大家学会使用和配置 vim，安装强大的 vim 插件，真正掌握编辑器之神 vim 的使用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-玩转vim-从放弃到爱不释手"><a href="#第1章-玩转vim-从放弃到爱不释手" class="headerlink" title="第1章 玩转vim 从放弃到爱不释手"></a>第1章 玩转vim 从放弃到爱不释手</h2><blockquote><p>课程导学</p></blockquote><h3 id="1-1-玩转vim-从放弃到爱不释手-课程导学-09-43"><a href="#1-1-玩转vim-从放弃到爱不释手-课程导学-09-43" class="headerlink" title="1-1 玩转vim 从放弃到爱不释手-课程导学 (09:43)"></a>1-1 玩转vim 从放弃到爱不释手-课程导学 (09:43)</h3><p>什么是Vim？</p><blockquote><p>Linux下两大编辑神器之一：Vim</p></blockquote><ul><li>Linux/Unix下使用最多的编辑器</li><li>Vi的改进版</li><li>可能是最难上手的编辑器之一</li></ul><p>为什么要学习Vim？</p><blockquote><p>都21世纪了，为什么还要学习Vim？</p></blockquote><ul><li>只要你用服务器，Vim就是一个必备技能</li><li>后端和运维工程师必须掌握的编辑器，不然服务器上操作很尴尬</li><li>可以纯键盘⌨️编辑，提升编辑效率</li></ul><p>痛点</p><blockquote><p>Vim难上手，学习曲线陡</p></blockquote><ul><li>Vim视频学习资料很少，网上很多博客讲解零散、不够直观</li><li>缺少系统的教程。Vim命令众多，难以学习和记忆</li><li>Vim学习曲线比较陡，需要较长时间才能上手，劝退很多初学者</li></ul><p>课程目的</p><blockquote><p>帮你驯服Vim</p></blockquote><ul><li>了解和掌握Vim中的基本概念</li><li>熟悉Vim基本使用方法，能够做到日常编辑（纯键盘编辑）</li><li>知道如何自定义Vim，安装插件无限扩充Vim的功能</li></ul><p>课程内容</p><blockquote><p>如何学习Vim？Vim经常被诟病难易上手和使用</p></blockquote><ul><li>Vim的概念和基本操作，比如移动和增删改查</li><li>如何配置Vim，编写自己的vimrc文件</li><li>如何安装和使用插件，无限扩充Vim的功能</li></ul><p>受众</p><blockquote><p>哪些人可以从本门课程受益呢？</p></blockquote><ul><li>运维工程师、后端工程师等</li><li>Linux用户</li><li>对Vim感兴趣，想要提升开发效率的开发者,甚至普通用户</li></ul><p>预备知识</p><blockquote><p>不要求掌握Vim的基础知识，但最好使用Linux/Unix系统</p></blockquote><ul><li>熟悉基本的命令行操作（一般Vim多在Linux服务器上使用）</li><li>知道如何安装Vim</li><li>有其他编辑器使用经验。几乎所有流行IDE和编辑器都有Vim扩展</li></ul><p>课程特色</p><blockquote><p>学习Vim非一日之功，得靠肌肉记忆</p></blockquote><ul><li>由浅入深，循序渐进。从基本的概念和操作讲起</li><li>授人以🐟，同时授人以渔。学会了插件自己扩充Vim功能</li><li>大量实践技巧（所有演示均使用按键回显工具，让你看得更明白）</li></ul><h2 id="第2章-初识-Vim，想说爱你不容易"><a href="#第2章-初识-Vim，想说爱你不容易" class="headerlink" title="第2章 初识 Vim，想说爱你不容易"></a>第2章 初识 Vim，想说爱你不容易</h2><blockquote><p>从基础的 Vim 操作讲起，学习 Vim 操作和涉及到的 Vim 概念。</p></blockquote><h3 id="2-1-初识-Vim，想说爱你不容易-11-50"><a href="#2-1-初识-Vim，想说爱你不容易-11-50" class="headerlink" title="2-1 初识 Vim，想说爱你不容易 (11:50)"></a>2-1 初识 Vim，想说爱你不容易 (11:50)</h3><p>下载与安装</p><blockquote><p>作为开发者的你，安装Vim应该很简单</p></blockquote><ul><li>Linux/Unix(Mac)自带Vim，直接终端里输入<code>vim</code>即可进入</li><li>Windows用户可以下载安装Gvim等体验</li><li>建议Windows用户可以尝试使用虚拟机来体验Linux下的Vim</li></ul><p>初识Vim</p><blockquote><p>据说StackOverflow帮助过上百万开发者退出过Vim！</p></blockquote><ul><li><p>输入<code>vim</code>命令进入Vim</p><pre><code>~                              VIM - Vi IMproved                                ~                                                                               ~                               version 8.0.1283                                ~                           by Bram Moolenaar et al.                            ~                 Vim is open source and freely distributable                   ~                                                                               ~                        Become a registered Vim user!                          ~                type  :help register&lt;Enter&gt;   for information                  ~                                                                          ~                type  :q&lt;Enter&gt;               to exit~                type  :help&lt;Enter&gt;  or  &lt;F1&gt;  for on-line help~                type  :help version8&lt;Enter&gt;   for version info</code></pre></li><li><p>进去之后似乎没法输入东西，起始默认进去是普通(normal)模式</p></li><li><p>使用<code>:q</code>可以退出Vim</p></li></ul><p>开始编辑</p><blockquote><p>进入编辑模式就可以像其他编辑器一样编辑了</p></blockquote><ul><li><p>使用<code>i</code>进入编辑模式，开始输入文字</p></li><li><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>insert before character</td></tr><tr><td><code>a</code></td><td>append after character</td></tr><tr><td><code>o</code></td><td>open a line below</td></tr><tr><td><code>I</code></td><td>insert before line</td></tr><tr><td><code>A</code></td><td>append after line</td></tr><tr><td><code>O</code></td><td>open a line above</td></tr></tbody></table></li><li><p>使用<code>Esc</code>又可以回到普通(normal)模式。使用<code>:wq</code>保存退出</p><p>insert -&gt; normal：<code>Esc</code></p></li></ul><p>课后练习</p><blockquote><p>用Vim靠的是肌肉记忆，赶紧自己操作练习一下吧</p></blockquote><ul><li>通过搜索引擎学习如何安装，并在你的操作系统中安装好Vim</li><li>进入Vim，使用<code>i</code>/<code>a</code>/<code>o</code>进入编辑(insert)模式输入文本</li><li>退回到默认的普通(normal)模式，保存并退出Vim</li></ul><h3 id="2-2-Vim，为什么你有这么多模式-09-15"><a href="#2-2-Vim，为什么你有这么多模式-09-15" class="headerlink" title="2-2 Vim，为什么你有这么多模式 (09:15)"></a>2-2 Vim，为什么你有这么多模式 (09:15)</h3><p>“怪异的Vim模式”</p><blockquote><p>Vim和其他很多编辑器的区别在于多种模式</p></blockquote><ul><li><p>进入Vim默认是普通(normal)模式？为什么不是编辑模式呢？</p><p>答：在日常开发中更多的是浏览代码，而不是编辑代码</p></li><li><p>使用<code>i</code>(insert)/<code>a</code>(append)等进入编辑模式</p></li><li><p>还有<code>:cmd</code>命令模式和<code>v</code>(visual)可视化模式</p></li></ul><ol><li>为什么进入Vim不能插入—普通(Normal)模式</li></ol><blockquote><p>奇怪的是，为什么Vim进入之后不能像其他编辑器一样直接插入？</p></blockquote><ul><li>进入Vim默认是普通(normal)模式。使用<code>Esc</code>从插入模式回到普通模式</li><li>普通模式下可以进行各种命令操作和移动</li><li>大部分情况下，你是在浏览而不是编辑。所以Vim默认是普通(normal)模式</li></ul><ol start="2"><li>插入(Insert)模式</li></ol><blockquote><p>插入模式下Vim可以直接编辑，和其他编辑器一样</p></blockquote><ul><li>使用<code>i</code>(insert)/<code>a</code>(append)/<code>o</code>(open a line below)进入插入模式</li><li>使用<code>Esc</code>退出插入模式到普通(normal)模式</li><li>你来试试<code>I</code>/<code>A</code>/<code>O</code>如何进入插入模式的？</li></ul><ol start="3"><li>命令(Command)模式</li></ol><blockquote><p>普通(Normal)模式下输入<code>:</code>之后执行命令，比如保存退出<code>:wq</code>，一气呵成</p></blockquote><ul><li>顾名思义，执行Vim命令。比如保存<code>:w</code>、退出<code>:q</code></li><li>比如分屏：<code>:vs</code>(vertical split)、<code>:sp</code>(split)</li><li>比如使用<code>:% s/java/python/g</code>全局替换，将<code>java</code>替换为<code>python</code></li></ul><ol start="4"><li>可视化(Visual)模式</li></ol><blockquote><p>可视化(Visual)模式一般用来块状选择文本</p></blockquote><ul><li>普通模式下，使用<code>v</code>进入字符选择</li><li>使用<code>V</code>选择行</li><li>使用<code>Ctrl+v</code>进入方块♦️选择</li></ul><p>课后练习</p><blockquote><p>理解和使用Vim常用的4种模式</p></blockquote><ul><li>找一个文件编辑，在插入模式和普通模式之间切换</li><li>使用命令模式替换单词</li><li>尝试使用可视化(Visual)模式，想想它的使用场景是？</li></ul><h3 id="2-3-Vim-插入模式小技巧-08-08"><a href="#2-3-Vim-插入模式小技巧-08-08" class="headerlink" title="2-3 Vim 插入模式小技巧 (08:08)"></a>2-3 Vim 插入模式小技巧 (08:08)</h3><p>如何快速纠错？</p><blockquote><p>代码就像人生，总是经常出错，需要我们快速修正</p></blockquote><ul><li><p>进入Vim之后，首先使用<code>i</code>/<code>a</code>/<code>o</code>进入插入模式</p></li><li><p>尝试抛弃退格键，使用<code>Ctrl</code>快捷键来完成编辑删除工作</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+h</code></td><td>删除上一个字符</td></tr><tr><td><code>Ctrl+w</code></td><td>删除上一个单词</td></tr><tr><td><code>Ctrl+u</code></td><td>删除当前行</td></tr></tbody></table></li><li><p>以上几个快捷键可以用在很多地方，比如<strong><em>终端</em></strong></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+a</code></td><td>快速移动到开头</td></tr><tr><td><code>Ctrl+e</code></td><td>快速移动到结尾</td></tr><tr><td><code>Ctrl+b</code></td><td>前移动</td></tr><tr><td><code>Ctrl+f</code></td><td>后移动</td></tr></tbody></table></li></ul><p>快速切换普通(Normal)模式和编辑(Insert)模式</p><blockquote><p>很多键盘的键位设置，<code>Esc</code>按起来不方便，不方便切换到普通模式</p></blockquote><ul><li>使用<code>Ctrl+c</code>代替<code>Esc</code>（但是可能会中断某些插件）、<code>Ctrl+[</code></li><li><strong><code>gi</code>快速跳转到最后一次编辑的地方，并进入插入模式</strong></li><li>在配置章节，我们会讲解如何映射方便的快捷键来代替<code>Esc</code></li></ul><p>让键盘适应工具</p><blockquote><p>键盘的选择会影响你的编辑速度</p></blockquote><ul><li>选择<code>Esc</code>和<code>Ctrl</code>比较容易触碰到的键盘</li><li>使用Vim，你可以使用HHKB或者Poker2这种迷你键盘</li><li>使用软件修改键位，比如<code>CapsLock</code>改成频繁使用到的<code>Ctrl</code></li></ul><ul><li><p>码农神器之HHKB—专为Linux下Vim/Emacs设计</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg8zp9kyj31jw0kojwp.jpg" alt="码农神器之HHKB" style="zoom:50%;" /></li><li><p>发烧之选—Poker2</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg90lb5nj31gi0i0dis.jpg" alt="发烧之选---Poker2" style="zoom:50%;" /></li></ul><h3 id="2-4-Vim-快速移动大法-15-11"><a href="#2-4-Vim-快速移动大法-15-11" class="headerlink" title="2-4 Vim 快速移动大法 (15:11)"></a>2-4 Vim 快速移动大法 (15:11)</h3><p>众所周知，vim normal模式使用了反人类的hjkl来移动</p><ul><li>编辑器作者在编写vim的时候，键盘还没流行上下左右按键</li><li>左（<code>h</code>），下（<code>j</code>），上（<code>k</code>），右（<code>l</code>）。移动也不会让手指脱离主键盘区</li><li>逼着自己使用hjkl一段时间之后，便会体会到它非常有效率</li></ul><p>在单词之间「飞舞」</p><blockquote><p>在单词之间移动是我们浏览操作中最常使用的命令</p></blockquote><ul><li><code>w</code>/<code>W</code>移动到下一个word/WORD开头。<code>e</code>/<code>E</code>移动到下一个word/WORD结尾</li><li><code>b</code>/<code>B</code>回到上一个word/WORD开头，可以理解为backword</li><li>word指的是以非空白符分割的单词，WORD指的是以空白符分割的单词</li></ul><p><code>synyax on</code>：打开高亮显示</p><p>行间搜索移动</p><blockquote><p>同一行快速移动的方式其实是：搜索一个字符并且移动到该字符</p></blockquote><ul><li>使用<code>f{char}</code>可以移动到char字符上，<code>t{char}</code>移动到char的前一个字符</li><li>如果第一次没搜到，可以用分号<code>;</code>/逗号<code>,</code>继续搜索该行的下一个/上一个</li><li>大写的<code>F</code>表示反过来搜索前面的字符</li></ul><p>如何快速移动到一行的行首或者行尾呢？</p><ul><li><code>0</code>移动到行首第一个字符，<code>^</code>移动到行首第一个非空白字符</li><li><code>$</code>移动到行尾，<code>_g</code>移动到行尾非空白字符</li><li>记住常用的<code>0</code>和<code>$</code>就可以满足日常需求了。</li></ul><p>Vim垂直移动</p><blockquote><p>在句子（sentence）和段落（paragraph）间移动。（不常用）</p></blockquote><ul><li>使用小括号<code>()</code>在句子间移动，可以使用<code>:help (</code>来查看帮助文档</li><li>使用大括号<code>{}</code>在段落间移动</li><li>插件章节会讲到如何使用easy-motion插件移动，这些命令就都不用记忆了</li></ul><p>Vim页面移动</p><ul><li><code>gg</code>/<code>G</code>移动到文件开头和结尾，可以使用<code>ctrl+o</code>快速返回</li><li><code>H</code>/<code>M</code>/<code>L</code>跳转到屏幕的开头（Head）、中间（Middle）、结尾（Lower）</li><li><code>ctrl+u</code>、<code>ctrl+f</code>上下翻页（upward/forward）。<code>zz</code>把光标当前行置为屏幕中间</li></ul><h3 id="2-5-Vim快速增删改查-13-29"><a href="#2-5-Vim快速增删改查-13-29" class="headerlink" title="2-5 Vim快速增删改查 (13:29)"></a>2-5 Vim快速增删改查 (13:29)</h3><p>Vim增加字符</p><ul><li>进入插入模式编辑文本</li><li><code>a</code>/<code>i</code>/<code>o</code>、<code>A</code>/<code>I</code>/<code>O</code></li></ul><p>Vim快速删除</p><ul><li>Vim在normal模式下使用<code>x</code>快速删除一个字符</li><li>使用<code>d</code>（delete）配合文本对象快速删除一个单词<code>daw</code>（d around word）</li><li><code>d</code>和<code>x</code>都可以搭配数字来执行多次</li></ul><p>Vim快速修改</p><ul><li><p><code>r{char}</code>（replace）、<code>c</code>（change）、<code>s</code>（substitute）</p></li><li><p>normal模式下使用<code>r{char}</code>可以替换一个字符char。<code>s</code>替换并进入插入模式</p><p><code>R</code>进入插入模式，将光标所在的字符直接替换为输入的字符。<code>S</code>删除整行，进入插入模式</p></li><li><p>使用<code>c</code>配合文本对象可以快速进行修改。例如：<code>ciw</code>、<code>caw</code>、<code>ct&quot;</code></p><p><code>C</code>删除整行，进入插入模式（不包含行首的非空白字符）</p></li></ul><p>Vim查询</p><ul><li>使用<code>/</code>或者<code>?</code>进行前向或者反向搜索</li><li>使用<code>n</code>/<code>N</code>跳转到下一个或者上一个匹配</li><li>使用<code>*</code>或者<code>#</code>进行当前光标所在单词的前向或者后向匹配</li></ul><h3 id="2-6-Vim-如何搜索替换-07-15"><a href="#2-6-Vim-如何搜索替换-07-15" class="headerlink" title="2-6 Vim 如何搜索替换 (07:15)"></a>2-6 Vim 如何搜索替换 (07:15)</h3><p>Vim替换命令：</p><blockquote><p>substitute命令允许查找并且替换文本，并且支持正则表达式</p></blockquote><ul><li><code>:[range] s[ubstitute]/{pattern}/{string}/[flags]</code></li><li><code>range</code>表示范围。 比如：<code>10,20</code>表示10-20行，<code>%</code>表示全部</li><li><code>pattern</code>是要替换的模式，<code>string</code>是替换后的文本，<code>flags</code>是替换标志位</li></ul><p>替换标志位</p><ul><li><code>g</code>(flobal)表示全局范围内执行</li><li><code>c</code>(confirm)表示确认，可以确认或者拒绝修改</li><li><code>n</code>(number)报告匹配到的次数而不替换，可以用来查询匹配次数</li></ul><p>例：</p><pre><code class="shell"># 在全局范围内将self替换为this:% s/self/this/g# 在1-6行将self替换为this:1,6 s/self/this/g# 统计1-6行匹配到self的次数:1,6 s/self//n# 利用正则，将quack替换为jiao，而不替换do_quack:% s/\&lt;quack\&gt;/jiao/g</code></pre><p><code>u</code>：撤销操作</p><p><code>Ctrl+r</code>：反向撤销</p><p>课后练习：</p><ul><li>如何批量替换多个文件中的匹配呢？</li><li>延伸：使用插件来批量搜索替换多个文件中的匹配</li></ul><h3 id="2-7-Vim-多文件操作-15-01"><a href="#2-7-Vim-多文件操作-15-01" class="headerlink" title="2-7 Vim 多文件操作 (15:01)"></a>2-7 Vim 多文件操作 (15:01)</h3><p>Buffer Window Tab：</p><ul><li><p>Buffer是指打开的一个文件的内存缓冲区</p></li><li><p>Window是Buffer可视化的分割区域</p></li><li><p>Tab可以组织Window为一个工作区</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg91qg8bj31dh0u0qag.jpg" alt="Buffer Window Tab" style="zoom:40%;" /></li></ul><p>Buffer（缓冲区）</p><ul><li>Vim打开一个文件后会加载文件内容到缓冲区</li><li>之后的修改都是针对内存中的缓冲区，并不会直接保存到文件</li><li>直到执行<code>:w</code>（write）的时候才会把修改的内容写入到文件里</li></ul><p>Buffer切换</p><ul><li>使用<code>:ls</code>会列举出当前缓冲区，然后使用<code>:b n</code>跳转到第n个缓冲区</li><li><code>bpre</code>、<code>bnext</code>、<code>bfirst</code>、<code>blast</code></li><li><code>:b buffer_name</code>、<code>:b filename</code>，<code>tab</code>会自动补全<code>buffer_name</code></li></ul><p><code>:e b.txt</code>：编辑(edit)b.txt</p><p>Window窗口：</p><ul><li>一个缓冲区可以分割成多个窗口，每个窗口也可以打开不同的缓冲区</li><li><code>&lt;Ctrl+w&gt;s</code>水平分割，<code>&lt;Ctrl+w&gt;v</code>垂直分割。或者<code>:sp</code>、<code>:vs</code></li><li>每个窗口可以继续被无限分割（屏幕是否足够大）</li></ul><p>分割窗口示例：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg933wfnj30vi0lqwfr.jpg" alt="Window分割窗口示例" style="zoom:40%;" /><p>如何切换窗口：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Ctrl+w&gt;w</code></td><td>在窗口间循环切换</td></tr><tr><td><code>&lt;Ctrl+w&gt;h</code></td><td>切换到左边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;j</code></td><td>切换到下边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;k</code></td><td>切换到上边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;l</code></td><td>切换到右边的窗口</td></tr></tbody></table><p><code>&lt;Ctrl+w&gt;L</code>：将当前窗口移动到右边</p><p><code>&lt;Ctrl+w&gt;H</code>：将当前窗口移动到左边</p><p>如何重排窗口？</p><blockquote><p>重排窗口可以改变窗口的大小<code>:h window-resize</code>查看文档</p></blockquote><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Ctrl+w&gt;=</code></td><td>使所有窗口等宽、等高</td></tr><tr><td><code>&lt;Ctrl+w&gt;_</code></td><td>最大化活动窗口的高度</td></tr><tr><td>`&lt;Ctrl+w&gt;</td><td>`</td></tr><tr><td><code>[n] &lt;Ctrl+w&gt;_</code></td><td>把活动窗口的高度设为[n]行</td></tr><tr><td>`[n] &lt;Ctrl+w&gt;</td><td>`</td></tr></tbody></table><p>Tab（标签页）将窗口分组</p><blockquote><p>Tab是可以容纳一系列窗口的容器<code>:h tabpage</code></p></blockquote><ul><li>Vim的Tab和其他编辑器有所不同，可以将其想象为Linux的虚拟桌面</li><li>比如一个Tab全用来编辑Python文件，一个Tab全是HTML文件</li><li>相比窗口，Tab一般使用较少，Tab太多管理起来也比较麻烦</li></ul><p>Tab操作</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:tabnew {filename}</code></td><td>在新标签中打开{filename}</td></tr><tr><td><code>:tabe[dit] {filename}</code></td><td>在新标签中打开{filename}</td></tr><tr><td><code>&lt;Ctrl+w&gt;T</code></td><td>把当前窗口移动到一个新标签页</td></tr><tr><td><code>:tabc[lose]</code></td><td>关闭当前标签页及其中的所有窗口</td></tr><tr><td><code>tabo[nly]</code></td><td>只保留活动标签页，关闭其他所有标签页</td></tr></tbody></table><p>Tab切换操作</p><table><thead><tr><th>Ex命令</th><th>普通模式命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:tabn[ext] {N}</code></td><td><code>{N} gt</code></td><td>切换到标签为{N}的标签页</td></tr><tr><td><code>:tabn[ext]</code></td><td><code>gt</code></td><td>切换到下一个标签页</td></tr><tr><td><code>tabp[revious]</code></td><td><code>gT</code></td><td>切换到上一个标签页</td></tr></tbody></table><p><code>:vs c.txt</code>：垂直分割打开c.txt</p><p><code>:tabnew duck.py</code>：在新的标签页打开duck.py</p><p>课后练习</p><ul><li>尝试打开Vim一次操作多个文件</li><li>窗口分割可以非常方便的查看代码，比如查看整个调用链</li><li>延伸：插件篇会配合<code>ctrlp</code>插件和<code>nerdtree</code>快速操作多个文件</li></ul><h3 id="2-8-什么是-Vim-的-text-object-06-49"><a href="#2-8-什么是-Vim-的-text-object-06-49" class="headerlink" title="2-8 什么是 Vim 的 text object (06:49)"></a>2-8 什么是 Vim 的 text object (06:49)</h3><p>Text Object（文本对象）</p><ul><li>Vim里文本也有对象的概念，比如一个单词、一段句子、一个段落</li><li>很多其他编辑器经常只能操作单个字符来修改文本，比较低效</li><li>通过操作文本对象来修改要比只操作单个字符高效</li></ul><p>文本对象操作方式</p><blockquote><p>之前已经使用过文本对象了，比如<code>dw</code>删除一个单词</p></blockquote><ul><li><code>[number] &lt;command&gt; [text object]</code>。次数+命令+文本对象</li><li><code>number</code>表示次数，<code>command</code>表示命令：<code>d</code>(delete)、<code>c</code>(chage)、<code>y</code>(yank)</li><li><code>text object</code>是要操作的文本对象，比如单词<code>w</code>、句子<code>s</code>、段落<code>p</code></li></ul><p><code>iw</code>：表示inner word。<code>viw</code>命令首先<code>v</code>进入选择模式，<code>iw</code>将选中当前单词</p><p><code>aw</code>：表示around word。它不但会选中当前单词，还会包含单词之后的空格</p><p><code>ci&quot;</code>：删除<code>&quot;&quot;</code>中的内容，并进入插入模式。另外还有<code>()</code>、<code>{}</code>、<code>[]</code>等。</p><p>课后练习</p><blockquote><p>摆脱低效的字符操作，使用文本对象提升效率</p></blockquote><ul><li>如何删除一个单词？</li><li>在Vim中尝试使用文本对象快速增、删、改一个单词</li><li>延伸：有些插件扩展了文本对象。比如<code>vim-go</code>可以使用<code>f</code>表示一个函数</li></ul><h3 id="2-9-Vim复制粘贴与寄存器的使用-16-51"><a href="#2-9-Vim复制粘贴与寄存器的使用-16-51" class="headerlink" title="2-9 Vim复制粘贴与寄存器的使用 (16:51)"></a>2-9 Vim复制粘贴与寄存器的使用 (16:51)</h3><p>Normal模式复制粘贴</p><ul><li><p>normal模式下复制粘贴分别使用<code>y</code>(yank)和<code>p</code>(put)，剪贴<code>d</code>和<code>p</code></p></li><li><p>可以使用<code>v</code>(visual)命令选中所要复制的地方，然后使用<code>p</code>粘贴</p></li><li><p>配合文本对象。比如使用<code>viw</code>复制一个单词，<code>yy</code>复制一行</p><p>Vim里的<strong>剪贴</strong>(cut)<strong>复制</strong>(copy)<strong>粘贴</strong>(paste)分别是<strong>delete</strong>/<strong>yank</strong>/<strong>put</strong></p></li></ul><p>Insert模式下的复制粘贴</p><ul><li>和其他文本编辑器一样，使用<code>Ctrl+v</code>或者<code>cmd+v</code>粘贴，但是粘贴代码有个坑</li><li>很多人在<code>.vimrc</code>中设置了<code>autoindent</code>，粘贴Python代码缩进错乱</li><li>这个时候需要在粘贴前后使用<code>:set paste</code>和<code>:set nopaste</code>解决、使用系统剪贴板寄存器<code>:&quot;</code>也可以解决</li></ul><p>什么是Vim的寄存器？</p><ul><li>Vim里操作的是寄存器而不是系统剪贴板。</li><li>默认使用<code>d</code>删除或者<code>y</code>复制的内容都放到了“无名寄存器”</li><li>用<code>x</code>删除一个字符放到无名寄存器，然后<code>p</code>粘贴，可以调换两字符</li></ul><p>深入寄存器（register）</p><blockquote><p>Vim不使用单一剪贴板进行剪贴、复制与粘贴，而是多组寄存器</p></blockquote><ul><li>通过<code>&quot;{register}</code>前缀可以指定寄存器，不指定则默认使用无名寄存器</li><li>比如使用<code>&quot;ayiw</code>复制一个单词到寄存器<code>a</code>中，<code>&quot;bdd</code>删除当前行到寄存器<code>b</code>中</li><li>Vim中，<code>&quot;&quot;</code>表示无名寄存器,缺省使用，<code>&quot;&quot;p</code>其实就等同于<code>p</code>。<code>&quot;+</code>系统剪贴板。</li></ul><p><code>:reg a</code>：查看寄存器<code>a</code></p><p>其他常见寄存器</p><blockquote><p>除了有名寄存器a-Z，Vim中还有一些其他常见寄存器</p></blockquote><ul><li><p>复制专用寄存器<code>&quot;0</code>，使用<code>y</code>复制文本同时会被拷贝到复制寄存器<code>0</code></p></li><li><p>系统剪贴板<code>&quot;+</code>，可以在复制前加上<code>&quot;+</code>复制到系统剪贴板。</p><p>查看是否开启系统剪贴板：<code>:echo has(&#39;clipboard&#39;)</code></p><p>设置<code>:set clipboard=unnamed</code></p></li><li><p>其他寄存器，比如<code>&quot;%</code>当前文件名，<code>&quot;.</code>上次插入的文本</p></li></ul><p><code>:e!</code>：舍弃当前修改并重新加载文本内容</p><p>课后练习</p><blockquote><p>了解normal/insert模式复制粘贴的方法，常见寄存器的用法</p></blockquote><ul><li>找一段Python代码，尝试在Vim里粘贴进入</li><li>试试将Vim中的内容复制到系统粘贴板</li><li>尝试在服务器的Vim里粘贴系统剪贴板的内容</li></ul><h3 id="2-10-Vim-如何用宏完成强大的批量操作-10-23"><a href="#2-10-Vim-如何用宏完成强大的批量操作-10-23" class="headerlink" title="2-10 Vim 如何用宏完成强大的批量操作 (10:23)"></a>2-10 Vim 如何用宏完成强大的批量操作 (10:23)</h3><p>从需求说起</p><blockquote><p>从一个需求说起，给多行URL链接加上双引号</p></blockquote><pre><code>https://www.zhihu.com/question/54919485https://www.zhihu.com/explorehttps://www.zhihu.com/topichttps://www.zhihu.com/topic/19601308https://www.zhihu.com/topic/19607351https://www.zhihu.com/topic/19630716https://www.zhihu.com/topic/19637932https://www.zhihu.com/people/weikexin-67https://www.zhihu.com/questton/267339149/answer/325252706https://www.zhihu.com/question/267339149/answer/523371968https://www.zhihu.com/people/zhang-jia-hao-15https://www.zhihu.com/question/48510028https://www.zhihu.com/question/267339149/answer/323414411https://www.zhihu.com/people/ming-ming 0701https://www.zhihu.com/question/267339149/answer/519709724https://www.zhihu.com/question/answer/519709724https://www.zhihu.com/question/22897152https://www.zhihu.com/question/22130215https://www.zhihu.com/question/19823813</code></pre><p>什么是Vim宏（macro）</p><ul><li>宏可以看成是一系列命令的集合</li><li>可以使用宏「录制」一系列操作，然后用于「回放」</li><li>宏可以非常方便地把一系列命令用在多行文本上</li></ul><p>如何使用宏</p><blockquote><p>宏的使用分为录制和回放，与拍电影类似。</p></blockquote><ul><li>Vim使用<code>q</code>来录制，同时也是使用<code>q</code>结束录制</li><li>使用<code>q{register}</code>选择要保存的寄存器，把录制的命令保存其中</li><li>使用<code>@{register}</code>回放寄存器中保存的一系列命令</li></ul><p>使用宏解决提出的问题</p><ul><li><p>先给一行加上双引号，然后再回放到其他所有行</p></li><li><p>先使用<code>q</code>开始录制，给一行加上双引号，之后使用<code>q</code>退出</p></li><li><p>在剩下所有行中回放录制的宏</p><p>录制：</p><pre><code class="shell">qaI&quot;&lt;Esc&gt;A&quot;&lt;Esc&gt;jq</code></pre><p>调用方式一：</p><pre><code>10@a</code></pre><p>调用方式二：</p><pre><code>VGG:normal @a</code></pre></li></ul><p>课后练习</p><blockquote><p>知道什么是宏，如何使用宏完成日常需求</p></blockquote><ul><li>想象一下编辑代码或者文本什么时候会使用到宏？</li><li>想一下还有没有其他方式来完成这个批量加引号的编辑需求</li><li>尝试亲自操作一下宏命令编辑。</li></ul><h3 id="2-11-Vim-补全大法-07-33"><a href="#2-11-Vim-补全大法-07-33" class="headerlink" title="2-11 Vim 补全大法 (07:33)"></a>2-11 Vim 补全大法 (07:33)</h3><p>什么是补全？</p><blockquote><p>只要手速快，补全什么的都是浮云。</p></blockquote><ul><li>补全是根据当前环境上下文由编辑器「猜」用户想要输入的内容</li><li>比如补全一个单词、文件名，或者代码中的函数名、变量名等</li><li>Vim中提供了多种补全功能，还可以由插件扩展功能实现代码补全</li></ul><p>Vim中常见的补全：</p><table><thead><tr><th>命令</th><th>补全类型</th></tr></thead><tbody><tr><td><code>&lt;C-n&gt;</code></td><td>普通关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-n&gt;</code></td><td><strong>当前缓冲区关键字</strong></td></tr><tr><td><code>&lt;C-x&gt;&lt;C-i&gt;</code></td><td>包含文件关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-]&gt;</code></td><td>标签文件关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-k&gt;</code></td><td>字典查找</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-l&gt;</code></td><td>整行补全</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-f&gt;</code></td><td><strong>文件名补全</strong></td></tr><tr><td><code>&lt;C-x&gt;&lt;C-o&gt;</code></td><td><strong>全能（Omni）补全</strong></td></tr></tbody></table><p><strong>常见的三种补全类型：</strong></p><ul><li><p>使用<code>&lt;Ctrl+n&gt;</code>和<code>&lt;Ctrl+p&gt;</code>补全单词</p><p><code>Ctrl+n</code>：n(next)代表下一个补全的选项</p><p><code>Ctrl+p</code>：p(previous)代表上一个补全的选项</p></li><li><p>使用<code>&lt;Ctrl+x&gt;</code>+<code>&lt;Ctrl+f&gt;</code>补全文件名</p><p><code>Ctrl+w</code>：回删一个单词</p></li><li><p>使用<code>&lt;Ctrl+x&gt;</code>和<code>&lt;Ctrl+o&gt;</code>补全代码，需要开启文件类型检查，安装插件</p><p><code>:filetype on</code>：开启文件类型检查</p><p><code>:set filetype</code>：查看当前文件类型</p></li></ul><p><code>:r! echo %</code>：当前文件名（文件名）。<code>&quot;%p</code>也可输出文件名</p><p><code>:r! echo %:p</code>：当前文件名称（文件路径+文件名）</p><p>For more info：</p><pre><code>:help read:help filename-modifiers</code></pre><p>课后练习：</p><blockquote><p>知道如何在Vim中使用补全，补全的几种常见类型</p></blockquote><ul><li>尝试使用Vim中的补全方式来补全单词</li><li>在Vim中输入文件名的时候尝试补全，想想如何输入现有的文件名？</li><li>延伸：目前补全都是基于文本匹配的，插件可是实现代码补全。</li></ul><h3 id="2-12-给-Vim-换个配色-06-32"><a href="#2-12-给-Vim-换个配色-06-32" class="headerlink" title="2-12 给 Vim 换个配色 (06:32)"></a>2-12 给 Vim 换个配色 (06:32)</h3><p>Vim更换颜色</p><ul><li>使用<code>:colorscheme</code>显示当前的主题配色，默认是<code>default</code></li><li>使用<code>:colorscheme &lt;Ctrl+d&gt;</code>可以显示所有的配色</li><li>有中意的配色后，使用<code>:colorscheme 配色名</code>就可以修改颜色</li></ul><p><code>vim duck.go duck.py -O</code>：打开两个文件并垂直分割。在一个窗口的一个Tab页中</p><p>从网上下载配色</p><blockquote><p>默认的配色没有喜欢的怎们办？</p></blockquote><ul><li><p>从网络上寻找更好看的配色</p></li><li><p><a href="http://github.com/flazz/vim-colorschemes" target="_blank" rel="noopener">http://github.com/flazz/vim-colorschemes</a></p><p><a href="http://github.com/w0ng/vim-hybrid" target="_blank" rel="noopener">http://github.com/w0ng/vim-hybrid</a></p></li><li><p>安装之后就有大量的主题可以更换了</p><pre><code>git clone https://github.com/w0ng/vim-hybrid.gitmkdir -p ~/.vim/colorscp vim-hybrid/colors/hybrid.vim ~/.vim/colors</code></pre></li></ul><p>课后练习</p><ul><li>尝试更改Vim的配色方案，想要持久化配置需要写到<code>.vimrc</code>中</li><li>在网上选一个喜欢的配色方案，下载并使用它，比如<code>hybird</code></li><li>下载多个配色方案到<code>.vim/colors</code>并且随时更换</li></ul><h3 id="2-13-本章小结：裸-Vim-也很强-02-37"><a href="#2-13-本章小结：裸-Vim-也很强-02-37" class="headerlink" title="2-13 本章小结：裸 Vim 也很强 (02:37)"></a>2-13 本章小结：裸 Vim 也很强 (02:37)</h3><p>裸的Vim</p><blockquote><p>本节没使用配置过的Vim，而是用裸的Vim演示，目的何在？</p></blockquote><ul><li>很多初学者Vim基本命令都不熟练就开始找一些复杂的强大配置</li><li>不利于熟悉Vim，一旦出问题了还不知道怎们修复</li><li>建议初学者从裸的Vim开始学习。有些场景，比如服务器或者容器上无法配置Vim</li></ul><p>裸的Vim也很强</p><blockquote><p>学习Vim之前，先用正确打字指法和盲打</p></blockquote><ul><li>编辑代码，脑子🧠一般比手👋快，盲打有利于跟上你的大脑速度</li><li>裸的Vim也有很多强大的功能和使用方式</li><li>学会了使用Vim，可以在任何IDE上安装Vim插件，几乎所有流行的编辑器和IDE工具都支持Vim插件</li></ul><p>下一步该学习什么？</p><blockquote><p>前提是已经无障碍使用Vim，并且没有那么痛苦纠结了。</p></blockquote><ul><li>学习<strong>Vim配置</strong>，我的Vim我做主</li><li>Vim也在与时俱进，探索学习各种炫酷和方便的<strong>插件</strong></li><li>用中学，学中用。慢慢就有了肌肉记忆</li></ul><h2 id="第3章-编写-Vim-配置，我的-Vim-我做主"><a href="#第3章-编写-Vim-配置，我的-Vim-我做主" class="headerlink" title="第3章 编写 Vim 配置，我的 Vim 我做主"></a>第3章 编写 Vim 配置，我的 Vim 我做主</h2><blockquote><p>学习如何编写Vim 的配置文件，自定义 Vim。</p></blockquote><h3 id="3-1-编写-vim-配置，我的-vim-我做主-17-09"><a href="#3-1-编写-vim-配置，我的-vim-我做主-17-09" class="headerlink" title="3-1 编写 vim 配置，我的 vim 我做主 (17:09)"></a>3-1 编写 vim 配置，我的 vim 我做主 (17:09)</h3><p>什么是Vim配置</p><blockquote><p>什么是Vim的配置，为什么要使用它呢？</p></blockquote><ul><li>Vim里有非常多常用的设置，比如<code>:set number</code>设置行号</li><li>之前的使用都是在Vim里临时设置，没法持久化，每次打开文件都需要设置</li><li><code>.vimrc</code>提供了一种持久化配置的方式，让用户自定义配置</li></ul><p>如何编写Vim配置文件</p><ul><li>Linux/Unix下新建一个隐藏文件<code>vim ~/.vimrc</code></li><li>Windows系统<code>vim $MYVIMRC</code>，通过环境变量编辑配置文件</li><li>接着就可以开始自定义配置</li></ul><p>Vim配置都包含什么？</p><ul><li>常用设置。比如：<code>set number</code>设置行号、<code>colorscheme hybrid</code>设置主题</li><li>常用的Vim映射。比如：<code>noremap &lt;leader&gt;w :w&lt;cr&gt;</code>保存文件</li><li>自定义的<code>vimscript</code>函数(vim高手)和插件的配置(插件篇)</li></ul><p>常用设置：</p><ul><li>可以把常用的设置写到<code>.vimrc</code>里，避免每次打开Vim重新设置</li><li>比如设置行号<code>set number</code>、设置主题<code>colorscheme hybrid</code></li><li>Vim里有非常多的配置，可以参考大佬的配置</li></ul><p>Vim中的映射</p><blockquote><p>Vim中的映射比较复杂，源于Vim有多种模式</p></blockquote><ul><li>设置一下<code>&lt;leader&gt;</code>键，<code>let mapleader = &#39;,&#39;</code>，常用的是逗号<code>,</code>或者空格<code>&lt;Space&gt;</code></li><li>比如用<code>inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;</code>在插入模式保存</li><li>Vim中的映射概念稍微复杂，但是非常强大</li></ul><p>Tmux使用<code>Ctrl+B+%</code>实现垂直分割屏幕</p><p>​    <code>zt</code>：将光标所在行定位于屏幕顶部</p><p>​    <code>zz</code>：将光标所在行定位于屏幕中部</p><p>​    <code>jj</code>：映射<code>&lt;Esc&gt;</code>键，退到普通normal模式</p><p>​    <code>:FormatJSON</code>：格式化JSON代码</p><p>​    <code>Ctrl+h/j/k/l</code>：映射<code>&lt;Ctrl-w&gt;+h/j/k/l</code>，光标在分屏窗口中移动</p><p>​    <code>xp</code>：普通模式下，对调字符</p><p>​    <code>:h option-list</code>：查看指令列表</p><p>Vim插件</p><blockquote><p>现代化的Vim可以通过Vim插件管理器安装插件</p></blockquote><ul><li>通过插件用户可以无限扩充Vim的功能</li><li>想要使用插件需要具备一定的Vim配置知识</li></ul><p>Vim脚本</p><blockquote><p>Vim有自己的脚本语言<code>Vimscript</code></p></blockquote><ul><li>Vim脚本对于Vim高级玩家来说可以实现强大的Vim插件</li><li>初学者知道有这个概念就好，Vim脚本是一种简单的脚本语言</li><li>可以通过<code>vimscript</code>实现更多Vim的控制，开发自己的插件</li></ul><p>课后练习</p><blockquote><p>掌握Vim配置需要对Vim本身很熟悉</p></blockquote><ul><li><p>尝试自己建立一个<code>~/.vimrc</code>文件，加入常见的设置选项</p></li><li><p>研究一下GitHub上<code>vim-go</code>教程<code>vim-go-tutoial</code>的<code>.vimrc</code>文件</p><p><a href="https://github.com/fatih/vim-go-tutorial/blob/master/vimrc" target="_blank" rel="noopener">https://github.com/fatih/vim-go-tutorial/blob/master/vimrc</a></p></li><li><p>拿来主义、网上、很多人开源了自己的配置(dotfiles)可参考学习</p><p><strong>通过把<code>.vimrc</code>配置文件放到git版本库可以同步到其他电脑或者服务器上</strong></p></li></ul><p>课程讲师的<code>.vimrc</code>文件：</p><pre><code class="shell">&quot; 常用设置&quot; 设置行号set numbercolorscheme hybrid&quot; 按F2进入粘贴模式set pastetoggle=&lt;F2&gt;&quot; 高亮搜索set hlsearch&quot; 设置折叠方式set foldmethod=indent&quot; 一些方便的映射let mapleader=&#39;,&#39;let g:mapleader=&#39;,&#39;&quot; 使用 jj 进入 normal模式inoremap jj &lt;Esc&gt;`^&quot; 使用 &lt;leader&gt;+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;noremap &lt;leader&gt;w :w&lt;cr&gt;&quot; 切换 buffernnoremap &lt;silent&gt; [p :bprevious&lt;cr&gt;nnoremap &lt;silent&gt; [n :bnext&lt;cr&gt;&quot; use ctrl+h/j/k/l switch windownoremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l&quot; Sudo to writecnoremap w!! w !sudo tee % &gt;/dev/null&quot; json 格式化com! FormatJSON %!python3 -m json.tool&quot; 插件设置，这里使用了 vim-plugcall plug#begin(&#39;~/.vim/plugged&#39;)&quot; 安装插件只需要把 github 地址放到这里重启后执行 :PlugInstall 就好了Plug &#39;mhinz/vim-startify&#39;Plug &#39;scrooloose/nerdtree&#39;call plug#end()&quot; 插件相关配置&quot; 禁止 stratify 自动切换目录let g:startify_change_to_dir = 0&quot; nerdtreenmap ,v :NERDTreeFind&lt;cr&gt;nmap ,g :NERDTreeToggle&lt;cr&gt;&quot; 定义函数SetTitle，自动插入文件头func SetTitle()    if &amp;filetype == &#39;python&#39;        call setline(1, &quot;\#!/usr/bin/env python&quot;)        call setline(2, &quot;\# -*- coding:utf-8 -*-&quot;)        normal G        normal o        normal o        call setline(5, &quot;if __name__ == &#39;__main__&#39;:&quot;)        call setline(6, &quot;    pass&quot;)    endifendfunc</code></pre><h3 id="3-2-Vim-映射迷人眼-14-53"><a href="#3-2-Vim-映射迷人眼-14-53" class="headerlink" title="3-2 Vim 映射迷人眼 (14:53)"></a>3-2 Vim 映射迷人眼 (14:53)</h3><p>什么是Vim映射</p><blockquote><p>Vim映射就是把「一个操作」映射到「另一个操作」</p></blockquote><ul><li>如果你不满意现在的按键设置，比如Vim本来的命令</li><li>或者想要映射一些方便的快捷键</li><li>按照用户意愿定制Vim</li></ul><p>基本映射</p><blockquote><p>基本映射指的是在普通normal模式下的映射，当然还有其他模式的映射</p></blockquote><ul><li><p>使用<code>map</code>就可以实现映射。比如：<code>:map - x</code>按<code>-</code>就会删除字符</p><p>取消<code>map</code>映射使用<code>:unmap -</code></p></li><li><p><strong><code>:map &lt;space&gt; viw</code>按空格键<code>&lt;space&gt;</code>就会选中光标所在的整个单词</strong></p></li><li><p><code>:map &lt;C-d&gt; dd</code>按<code>Ctrl+d</code>执行<code>dd</code>删除一行</p></li></ul><p>模式映射</p><blockquote><p>Vim常用模式normal/visual/insert都可以定义映射</p></blockquote><ul><li><p>用<code>nmap</code>/<code>vmap</code>/<code>imap</code>定义映射,只在normal/visual/insert分别有效</p></li><li><p><code>:vmap \ U</code>：把在visual模式下选中的文本大小写(u(小写)/U(大写)转化大小写)</p></li><li><p>想想如何在insert模式下映射<code>Ctrl+d</code>来删除一行</p><p><code>:imap &lt;C-d&gt; &lt;Esc&gt;ddi</code></p></li></ul><p><strong>现有映射的问题？</strong></p><blockquote><pre><code>:nmap - dd:nmap \ -</code></pre><p>当按下<code>\</code>时，Vim会解析<code>\</code>为<code>-</code>；因为又映射了<code>-</code>，Vim会继续解析<code>-</code>为<code>dd</code>，即最终按下<code>\</code>会删除整行。（类似于递归解析映射）</p></blockquote><p>递归映射和非递归映射</p><blockquote><p><strong><code>*map</code>系列命令有递归的风险</strong></p></blockquote><ul><li>如果用户安装了一个插件，插件映射了同一个按键的不同行为，有冲突就会有一个失效</li><li>想要保证插件映射没有冲突会非常痛苦</li><li>解决方案就是使用非递归映射</li></ul><p>非递归映射</p><blockquote><p>Vim提供了非递归映射，这些命令不会递归解析</p></blockquote><ul><li>使用<code>*map</code>对应的<code>nnoremap</code>/<code>vnoremap</code>/<code>inoremap</code></li><li>何时使用递归映射<code>*map</code>？何时使用非递归映射<code>*noremap</code>呢？</li><li>「任何」时候都应该使用非递归映射，拯救自己同时也拯救了插件作者</li></ul><p><strong>``^<code>：光标回到最后一次插入模式停止时光标的位置。</code>:help <code>^</code>查看帮助。</strong></p><p>课后练习</p><ul><li><p>尝试在<code>.vimrc</code>文件中定义一些映射，提升工作效率</p></li><li><p>参考一些开源的Vim配置，看看哪些映射可以拿来使用</p></li><li><p>阅读《笨方法学Vimscript》书中关于映射的章节。</p><p><a href="http://learnvimscriptthehardway.onefloweroneworld.com/" target="_blank" rel="noopener">http://learnvimscriptthehardway.onefloweroneworld.com/</a></p></li></ul><h3 id="3-3-本章小结：配置-Vim，让她更顺手-01-16"><a href="#3-3-本章小结：配置-Vim，让她更顺手-01-16" class="headerlink" title="3-3 本章小结：配置 Vim，让她更顺手 (01:16)"></a>3-3 本章小结：配置 Vim，让她更顺手 (01:16)</h3><p>学习和使用配置</p><blockquote><p>学习和使用Vim配置是Vim玩家进阶的必修之路</p></blockquote><ul><li>了解常见的配置选项</li><li>学习和使用Vim映射，用得不爽我就改</li><li>Vim进阶需要学习Vimscript。《笨发放学Vimscript》</li></ul><p>下一步该学什么？</p><blockquote><p>强大的Vim插件</p></blockquote><ul><li>Vim也在与时俱进，发布了Vim8，还有Neovim</li><li>知道如何配置Vim之后，开始探索各种强大的Vim插件</li><li>打好<strong>Vim配置</strong>和<strong>映射</strong>的基础，开始学习如何安装和使用插件</li></ul><h2 id="第4章-Vim-安装和使用插件"><a href="#第4章-Vim-安装和使用插件" class="headerlink" title="第4章 Vim 安装和使用插件"></a>第4章 Vim 安装和使用插件</h2><blockquote><p>学会如何安装和使用常见的 Vim 插件，增强 Vim 的功能。</p></blockquote><h3 id="4-1-Vim-安装插件，竟如此简单-08-40"><a href="#4-1-Vim-安装插件，竟如此简单-08-40" class="headerlink" title="4-1 Vim 安装插件，竟如此简单 (08:40)"></a>4-1 Vim 安装插件，竟如此简单 (08:40)</h3><p>什么是插件？</p><blockquote><p>和其他现代流行编辑器一样，Vim同样支持强大的插件扩展</p></blockquote><ul><li>Vim插件是使用vimscript或者其他语言编写的vim功能扩展</li><li>编辑器自带的功能有限，有了插件之后几乎可以无限扩充其功能</li><li>网络上比如GitHub.com等有很多开源的Vim插件可以使用</li></ul><p>如何安装插件？</p><blockquote><p>原始的方式是直接clone插件代码，如今Vim有很多插件管理器</p></blockquote><ul><li><p>目前Vim有很多插件管理器可供选择</p></li><li><p>常见的有：<code>vim-plug</code>、<code>Vundle</code>、<code>Pathogen</code>、<code>Dein.Vim</code>、<code>volt</code>等</p></li><li><p>综合性能、易用性、文档等几个方面，推荐使用<code>vim-plug</code></p><p><a href="https://www.slant.co/topics/1224/~best-plugin-managers-for-vim" target="_blank" rel="noopener">https://www.slant.co/topics/1224/~best-plugin-managers-for-vim</a></p></li></ul><p>使用<code>vim-plug</code>安装插件</p><ul><li><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">https://github.com/junegunn/vim-plug</a></p></li><li><p>学习一个新东西的最好方式就是看官方文档</p></li><li><p>按照官方的教程，就可以非常容易地了解它的使用方式</p><pre><code class="shell">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre></li></ul><p>安装第一个插件<code>vim-startify</code></p><blockquote><p>一个好用的vim开屏插件</p></blockquote><ul><li><p><a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">https://github.com/mhinz/vim-startify</a></p></li><li><p>修改<code>.vimrc</code>配置文件，增加该插件的名称</p></li><li><p>重新启动vim或者执行<code>:source ~/.vimrc</code>，执行<code>:PlugInstall</code></p><pre><code class="shell">call plug#begin(&#39;~/.vim/plugged&#39;)Plug &#39;mhinz/vim-startify&#39;call plug#end()</code></pre><p><code>:source ~/.vimrc</code></p><p><code>:PlugInstall</code></p></li><li><p>如果已经安装完成，退出并重新打开Vim查看效果</p></li></ul><p>课后练习</p><blockquote><p>打开Vim操练起来，首先下载vim-plug并浏览其文档</p></blockquote><ul><li>安装vim-plug插件管理器</li><li>安装vim插件vim-startify、nerdtree，看看能否生效</li></ul><h3 id="4-2-如何寻找自己需要的插件-06-42"><a href="#4-2-如何寻找自己需要的插件-06-42" class="headerlink" title="4-2 如何寻找自己需要的插件 (06:42)"></a>4-2 如何寻找自己需要的插件 (06:42)</h3><ul><li><p>Google关键词搜索</p></li><li><p><a href="https://github.com/vim-awesome/vim-awesome" target="_blank" rel="noopener">https://github.com/vim-awesome/vim-awesome</a></p><p><a href="https://vimawesome.com/" target="_blank" rel="noopener">https://vimawesome.com/</a></p></li><li><p>浏览网上开源的vim配置，借鉴想要的插件</p></li></ul><h3 id="4-3-vim美化插件，让你的-vim-与众不同-09-57"><a href="#4-3-vim美化插件，让你的-vim-与众不同-09-57" class="headerlink" title="4-3 vim美化插件，让你的 vim 与众不同 (09:57)"></a>4-3 vim美化插件，让你的 vim 与众不同 (09:57)</h3><p>vim美化插件</p><blockquote><p>更改vim的外观</p></blockquote><ul><li><p>修改启动界面：<a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">https://github.com/mhinz/vim-startify</a></p><p><code>:Startify</code></p></li><li><p>状态栏美化：<a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">https://github.com/vim-airline/vim-airline</a></p><p><a href="https://github.com/vim-airline/vim-airline-themes" target="_blank" rel="noopener">https://github.com/vim-airline/vim-airline-themes</a></p></li><li><p>增加代码缩进线条：<a href="https://github.com/Yggdroot/indentLine" target="_blank" rel="noopener">https://github.com/Yggdroot/indentLine</a></p></li></ul><p>vim配色方案</p><ul><li>vim-hybrid配色：<a href="https://github.com/w0ng/vim-hybrid" target="_blank" rel="noopener">https://github.com/w0ng/vim-hybrid</a></li><li>solarized配色：<a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="noopener">https://github.com/altercation/vim-colors-solarized</a></li><li>gruvbox配色：<a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener">https://github.com/morhetz/gruvbox</a></li></ul><p>课后练习</p><ul><li>尝试使用vim-stratify快速打开最近使用的文件</li><li>安装vim-airline美化状态栏</li><li>安装indentline给vim增加代码缩进线</li></ul><h3 id="4-4-Vim文件目录和搜索插件，跳转文件so-easy-12-20"><a href="#4-4-Vim文件目录和搜索插件，跳转文件so-easy-12-20" class="headerlink" title="4-4 Vim文件目录和搜索插件，跳转文件so easy (12:20)"></a>4-4 Vim文件目录和搜索插件，跳转文件so easy (12:20)</h3><p><strong>文件目录树</strong>：</p><blockquote><p>默认的文件目录管理比较简陋，nerdtree弥补了这个问题</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gj3vo85oj311w0o87le.jpg" alt="文件目录树" style="zoom:45%;" /><p>文件管理器nerdtree</p><blockquote><p>使用nerdtree插件进行文件目录树管理</p></blockquote><ul><li><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree</a></p><p><code>:NERDTree</code></p><p><code>:NERDTreeFind</code></p><p><code>:NERDTreeToggle</code></p></li><li><p><code>autocmd vimenter * NERDTree</code>可以在启动vim的时候打开NERDTree‘</p></li><li><p><code>map &lt;leader&gt;v :NERDTreeFind&lt;CR&gt;</code>查找文件位置</p></li></ul><p><strong>快速搜索文件</strong>：</p><blockquote><p>如何根据文件名快速查找打开一个文件</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gk4xgm5mj316e0m0137.jpg" alt="快速搜索文件" style="zoom:45%;" /><p>模糊搜索器</p><blockquote><p>使用ctrlp插件快速查找并且打开文件</p></blockquote><ul><li><a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="noopener">https://github.com/ctrlpvim/ctrlp.vim</a></li><li><code>let g:ctrlp_map = &#39;&lt;c-p&gt;&#39;</code></li><li>使用<Ctrl-p>，然后输入少量字符就可以开始搜索</li></ul><p>课后练习</p><blockquote><p>快速定位文件是常用操作，需牢牢掌握提升效率</p></blockquote><ul><li>安装nerdtree插件，加入快捷键映射</li><li>安装ctrlp插件，然后使用快速定位文件</li><li>改变自己之前低效的操作方式，适应新的操作方式</li></ul><h3 id="4-5-Vim快速定位插件，文件位置任我行-05-58"><a href="#4-5-Vim快速定位插件，文件位置任我行-05-58" class="headerlink" title="4-5 Vim快速定位插件，文件位置任我行 (05:58)"></a>4-5 Vim快速定位插件，文件位置任我行 (05:58)</h3><p>Vim移动命令：</p><blockquote><p>在基础篇学习了很多Vim移动的命令</p></blockquote><ul><li>比如，<code>w</code>/<code>e</code>基于单词移动，<code>gg</code>/<code>G</code>文件首尾，<code>0</code>/<code>$</code>行首尾，<code>f{char}</code>查询字符</li><li><code>Ctrl+f</code>、<code>Ctrl+u</code>前后翻屏</li><li>如果需要快速跳转到当前窗口显示区的任意位置需要怎们做？</li></ul><p>如何快速移动到任意位置</p><blockquote><p>可以使用vim的搜索/加上n跳转，但是使用easymotion更方便</p></blockquote><ul><li><a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">https://github.com/easymotion/vim-easymotion</a></li><li>官方文档较长，其实一个映射就能应付</li><li><code>nmap ss &lt;Plug&gt;(easymotion-s2)</code></li></ul><p>课后练习</p><blockquote><p>安装并使用easymotion插件</p></blockquote><ul><li>回忆一下vim里常用的移动操作</li><li>安装easymotion插件</li><li>使用easymotion练习在文件窗口的任意位置跳转</li></ul><h3 id="4-6-Vim-surround，编辑也要成双成对-05-27"><a href="#4-6-Vim-surround，编辑也要成双成对-05-27" class="headerlink" title="4-6 Vim-surround，编辑也要成双成对 (05:27)"></a>4-6 Vim-surround，编辑也要成双成对 (05:27)</h3><p>vim-surround</p><blockquote><p> 如何快速更换一对单引号为双引号?</p></blockquote><ul><li><p>一个一个查找然后替换</p></li><li><p><a href="https://github.com/tpope/vim-surround" target="_blank" rel="noopener">https://github.com/tpope/vim-surround</a></p></li></ul><p>vim-surround使用</p><blockquote><p>normal模式下增加、删除、修改成对内容</p></blockquote><ul><li><code>ds</code>（delete a surrounding）</li><li><code>cs</code>（change a surrounding）</li><li><code>ys</code>（you add a surrounding）</li></ul><p>例子：</p><ul><li><code>ysiw&quot;</code>：给单词增加<code>&quot;</code></li><li><code>cs&quot;&#39;</code>：修改<code>&quot;</code>为<code>&#39;</code></li><li><code>cs(]</code>：修改<code>(</code>为<code>]</code>，替换后的括号需要使用后括号，前括号会产生空格</li><li><code>ds&#39;</code>：删除<code>&#39;</code></li><li><code>ds(</code>：删除<code>(</code></li></ul><p>课后练习</p><blockquote><p>vim-surround大法好</p></blockquote><ul><li>使用vim-plug安装vim-surround插件</li><li>使用练习修改成对的内容，比如修改单引号为双引号</li><li>多练习几次，使用插件提升编辑效率</li></ul><h3 id="4-7-强大的Vim模糊搜索与替换插件-08-26"><a href="#4-7-强大的Vim模糊搜索与替换插件-08-26" class="headerlink" title="4-7 强大的Vim模糊搜索与替换插件 (08:26)"></a>4-7 强大的Vim模糊搜索与替换插件 (08:26)</h3><p>模糊搜索</p><blockquote><p>经常需要在一个代码项目中模糊搜索一些文本，怎们办？</p></blockquote><ul><li>vim自带的搜索可以搜索当前文件，但是项目有很多个文件</li><li>需要使用插件来模糊搜索多个文件内容</li><li>使用Ag.vim或者fzf.vim，都可以很好的支持模糊搜索</li></ul><p>fzf与fzf.vim</p><blockquote><p>fzf是一个强大的命令行模糊搜索工具，fzf.vim集成到了vim里</p></blockquote><ul><li><p><a href="https://github.com/junegunn/fzf.vim" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim</a></p></li><li><p>安装</p><pre><code class="shell">Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;</code></pre></li><li><p>使用<code>Ag [PATTERN]</code>模糊搜索字符串</p></li><li><p>使用<code>Files [PATH]</code>模糊搜索目录</p></li><li><p>更多命令：<a href="https://github.com/junegunn/fzf.vim#commands" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim#commands</a></p></li></ul><p>例子：</p><p><code>:Files .</code>：查看当前目录下的所有文件，再输入文件名实现搜索</p><p><code>:Ag {PATTERN}</code>：查找文本内容。</p><p>此处遇到了一个问题：ag is not found</p><p>解决方法参考：<a href="https://github.com/junegunn/fzf.vim/issues/440" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim/issues/440</a></p><p>搜索替换插件far.vim</p><blockquote><p>如果想要批量搜索替换，可以使用far.vim</p></blockquote><ul><li><p><a href="https://github.com/brooth/far.vim" target="_blank" rel="noopener">https://github.com/brooth/far.vim</a></p></li><li><p>使用</p><pre><code class="shell">:Far foo bar **/*.py:Fardo</code></pre></li><li><p>比如在代码重构的时候会经常使用到</p></li><li><p><code>:Far foo bar **/*.py</code></p></li></ul><p>课后练习</p><blockquote><p>模糊搜索和替换是一个非常常用的操作</p></blockquote><ul><li>使用vim-plug安装fzf.vim和far.vim</li><li>使用fzf.vim在一个项目中搜索想要的文本</li><li>使用far.vim批量替换一个项目下的文本</li></ul><h3 id="4-8-愉快写-golang-之vim-go插件-10-19"><a href="#4-8-愉快写-golang-之vim-go插件-10-19" class="headerlink" title="4-8 愉快写 golang 之vim-go插件 (10:19)"></a>4-8 愉快写 golang 之vim-go插件 (10:19)</h3><p>编辑器 VS IDE</p><blockquote><p>IDE一代又一代，经典的编辑器却长久不衰</p></blockquote><ul><li>除了Java，很多人用vim编写shell/php/golang/python/ruby</li><li>前端很多人使用VSCode，sublime/Atom有没落之势</li><li>很多后端和运维工程师使用vim，微信后台和阿里飞天系统很多代码出自在服务器上使用vim的工程师</li></ul><p>vim-go</p><blockquote><p>功能强大的golang插件vim-go</p></blockquote><ul><li><p><a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">https://github.com/fatih/vim-go</a></p></li><li><p>代码补全、重构、跳转、自动格式化、自动导入等功能</p></li><li><p>基本可以满足golang日常开发</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;Ctrl-x&gt;&lt;Ctrl-o&gt;</code></td><td>打开补全列表</td></tr><tr><td><code>&lt;Ctrl-p&gt;</code></td><td>向上选择补全</td></tr><tr><td><code>&lt;Ctrl-n&gt;</code></td><td>向下选择补全</td></tr><tr><td><code>&lt;Ctrl-]&gt;</code></td><td>跳转到定义的方法</td></tr><tr><td><code>&lt;Ctrl-o&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-i&gt;</code></td><td>跳转到上一次的地方</td></tr></tbody></table><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:GoFmt</code></td><td>格式化代码</td></tr><tr><td><code>:GoRename</code></td><td>重构名称</td></tr><tr><td><code>:GoImports</code></td><td>自动带入包</td></tr><tr><td><code>:GoRun</code></td><td>运行代码</td></tr><tr><td><code>:w</code></td><td>保存文件自动格式化代码</td></tr></tbody></table></li><li><p>vimrc配置：</p><pre><code class="shell">autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4</code></pre></li></ul><p>课后练习</p><ul><li>安装vim-go插件，阅读vim-go-tutorial教程</li><li>使用vim-go编写Go语言代码</li><li>如果遇到了问题，请查看vim-go-tutorial教程或者vim-go文档</li></ul><h3 id="4-9-python-mode把-vim-打造成轻量-Python-IDE-07-11"><a href="#4-9-python-mode把-vim-打造成轻量-Python-IDE-07-11" class="headerlink" title="4-9 python-mode把 vim 打造成轻量 Python IDE (07:11)"></a>4-9 python-mode把 vim 打造成轻量 Python IDE (07:11)</h3><p>Python-mode</p><blockquote><p>Python插件使用比较多的是jedi-vim和Python-mode</p></blockquote><ul><li><a href="https://github.com/python-mode/python-mode" target="_blank" rel="noopener">https://github.com/python-mode/python-mode</a></li><li>Python-mode具备基本的补全、跳转、重构、格式化功能</li><li>即使是在服务器上也能方便的调试Python代码</li></ul><ul><li><p>查看是否支持python：<code>vim --version | grep python</code>：</p></li><li><p>vimrc配置</p><pre><code class="shell">let g:pymode_python = &#39;python3&#39;let g:pymode_trim_whitespaces = 1let g:pymode_doc = 1let g:pymode_doc_bind = &#39;K&#39;let g:pymode_rope_goto_definition_bind = &#39;&lt;C-]&gt;&#39;let g:pymode_lint = 1let g:pymode_lint_checkers = [&#39;pyflakes&#39;, &#39;pep8&#39;, &#39;mccabe&#39;, &#39;pylint&#39;]let g:pymode_options_max_line_length = 120</code></pre></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;Ctrl-x&gt;&lt;Ctrl-o&gt;</code></td><td>打开补全列表</td></tr><tr><td><code>&lt;Ctrl-p&gt;</code></td><td>向上选择补全</td></tr><tr><td><code>&lt;Ctrl-n&gt;</code></td><td>向下选择补全</td></tr><tr><td><code>&lt;Ctrl-]&gt;</code></td><td>跳转到定义的方法</td></tr><tr><td><code>&lt;Ctrl-o&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-i&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-C&gt;ro</code></td><td>整理导入包的顺序</td></tr></tbody></table><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:PymodeLintAuto</code></td><td>自动Lint整理格式代码</td></tr><tr><td><code>:w</code></td><td>保存文件时做文件静态检查，并提示相应错误</td></tr></tbody></table><p>课后练习：</p><ul><li>安装python-mode插件</li><li>使用python-mode编写Python代码</li><li>如果遇到了问题，尝试查询python-mode文档解决</li></ul><h3 id="4-10-Vim-tagbar，更愉快地浏览代码-11-14"><a href="#4-10-Vim-tagbar，更愉快地浏览代码-11-14" class="headerlink" title="4-10 Vim tagbar，更愉快地浏览代码 (11:14)"></a>4-10 Vim tagbar，更愉快地浏览代码 (11:14)</h3><p>tagbar</p><blockquote><p>代码大纲，支持多种编程语言</p></blockquote><ul><li><p><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a></p></li><li><p>需要安装Universal Ctags生成对应的tag文件</p></li><li><p>快速浏览当前文件代码结构，并且搜索跳转到对应代码块</p></li><li><p>vimrc配置</p><pre><code class="shell">nnoremap &lt;leader&gt;t :TagbarToggle&lt;CR&gt;</code></pre></li></ul><p>安装ctags：</p><ul><li><p>Universal Ctags：<a href="https://ctags.io/" target="_blank" rel="noopener">https://ctags.io/</a></p></li><li><p><a href="https://docs.ctags.io/en/latest/osx.html#building-with-homebrew" target="_blank" rel="noopener">https://docs.ctags.io/en/latest/osx.html#building-with-homebrew</a></p><pre><code class="shell">brew tap universal-ctags/universal-ctagsbrew install --HEAD universal-ctags</code></pre></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:Tagbar</code></td><td>显示Tagbar</td></tr><tr><td><code>:TagbarToggle</code></td><td>显示Tagbar并定位到当前方法的目录</td></tr><tr><td><code>:ls</code></td><td>查看buffer</td></tr><tr><td><code>:b duck.py</code></td><td>跳转到duck.py的buffer</td></tr></tbody></table><p>vim-interestingwords</p><blockquote><p>高亮感兴趣的单词，浏览代码很有用</p></blockquote><ul><li><a href="https://github.com/lfv89/vim-interestingwords" target="_blank" rel="noopener">https://github.com/lfv89/vim-interestingwords</a></li><li>浏览代码的时候经常需要知道一个变量的使用方式</li><li>可以使用这个插件同时高亮多个单词</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;leader&gt;k</code></td><td>高亮单词</td></tr><tr><td><code>u</code>/<code>U</code></td><td>下/上一个高亮</td></tr><tr><td><code>&lt;leader&gt;K</code></td><td>取消所有高亮</td></tr></tbody></table><p>课后练习</p><ul><li>安装tagbar，开启文件代码大纲</li><li>安装interestingwords，高亮感兴趣的单词</li><li>如果遇到了问题，尝试查询插件的官方文档/Google搜索/vim help解决</li></ul><h3 id="4-11-强大的-vim-代码补全插件-07-16"><a href="#4-11-强大的-vim-代码补全插件-07-16" class="headerlink" title="4-11 强大的 vim 代码补全插件 (07:16)"></a>4-11 强大的 vim 代码补全插件 (07:16)</h3><p>deoplete.nvim</p><blockquote><p>一个强大的neovim/vim8异步补全插件</p></blockquote><ul><li><a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">https://github.com/Shougo/deoplete.nvim</a></li><li>多编程语言的支持，支持模糊匹配</li><li>需要安装对应编程语言的扩展</li></ul><p>安装：</p><pre><code class="shell">if has(&#39;nvim&#39;)  Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }else  Plug &#39;Shougo/deoplete.nvim&#39;  Plug &#39;roxma/nvim-yarp&#39;  Plug &#39;roxma/vim-hug-neovim-rpc&#39;endif</code></pre><p>如若报错请安装依赖：</p><pre><code class="shell">pip3 install --user pynvim</code></pre><p>配置：</p><pre><code class="shell">let g:deoplete#enable_at_startup = 1</code></pre><p>其他代码补全插件</p><ol><li><p>deoplete-jedi：</p><blockquote><p>Python语言代码补全，可以补全自己所写的库</p><p><a href="https://github.com/deoplete-plugins/deoplete-jedi" target="_blank" rel="noopener">https://github.com/deoplete-plugins/deoplete-jedi</a></p></blockquote></li><li><p>deoplete-go：</p><blockquote><p>Go语言代码补全</p><p><a href="https://github.com/deoplete-plugins/deoplete-go" target="_blank" rel="noopener">https://github.com/deoplete-plugins/deoplete-go</a></p></blockquote></li></ol><p>coc.nvim</p><blockquote><p>一个强大的neovim/vim8补全插件。LSP支持</p><p>LSP（Language-Server-Protocol）</p></blockquote><ul><li><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">https://github.com/neoclide/coc.nvim</a></li><li>full language server protocol support as VSCode</li><li>多语言插件支持</li></ul><p>课后练习</p><ul><li>安装deoplete.nvim和coc.nvim</li><li>安装对应的编程语言扩展</li><li>vim/neovim补全插件很多，有些支持异步。</li></ul><h3 id="4-12-Vim代码格式化与静态检查-09-43"><a href="#4-12-Vim代码格式化与静态检查-09-43" class="headerlink" title="4-12 Vim代码格式化与静态检查 (09:43)"></a>4-12 Vim代码格式化与静态检查 (09:43)</h3><p>格式化与静态检查</p><blockquote><p>为什么需要这些工具呢？能让工具做的就不用让人去费心</p></blockquote><ul><li>把精力集中在代码逻辑本身，而不是整理格式这些浪费精力的事情上</li><li>静态检查是为了让编写的代码更加规范。golint/pylint/eslint等</li><li>无论编写何种编程语言，最好都加上自动格式化和静态检查</li></ul><p>Neoformat</p><blockquote><p>vim-autoformat和Neoformat是两种使用较多的格式化插件，这里使用neoformat</p></blockquote><ul><li><a href="https://github.com/sbdchd/neoformat" target="_blank" rel="noopener">https://github.com/sbdchd/neoformat</a></li><li>需要安装对应语言的格式化库。python的autopep8、javascript的prettier等</li></ul><p>安装依赖：</p><pre><code class="shell">pip3 install autopep8</code></pre><p><code>:Neoformat</code>：格式化Python代码</p><p>静态检查Lint</p><blockquote><p>neomake和ale是两种常见的lint插件，这里使用ale</p></blockquote><ul><li><a href="https://github.com/dense-analysis/ale" target="_blank" rel="noopener">https://github.com/dense-analysis/ale</a></li><li>需要安装对应语言的lint库。比如golint/pylint/eslint等</li><li>vim8/neovim支持异步检查，不会影响vim编辑，推荐使用</li></ul><p>安装依赖：</p><pre><code class="shell">pip3 install pylint</code></pre><p>课后练习</p><blockquote><p>让插件帮助完成代码的格式化和静态检查吧。</p></blockquote><ul><li>安装noeformat插件和相关的格式化库，格式化代码</li><li>安装ale和对应语言的lint库，修复代码的缺陷</li><li>需要自定义检查功能（比如忽略某些检查错误），参考官方文档</li></ul><h3 id="4-13-Vim快速注释代码-03-06"><a href="#4-13-Vim快速注释代码-03-06" class="headerlink" title="4-13 Vim快速注释代码 (03:06)"></a>4-13 Vim快速注释代码 (03:06)</h3><p>vim-commentary</p><blockquote><p>vim注释插件有很多，推荐使用轻量的vim-commentary</p></blockquote><ul><li><a href="https://github.com/tpope/vim-commentary" target="_blank" rel="noopener">https://github.com/tpope/vim-commentary</a></li><li>记住常用的命令：gc注释和取消注释</li><li>插件会根据不同的文件类型使用不同注释。python(#)、golang(//)</li></ul><p>行注释：</p><ul><li><code>gcc</code>：注释代码</li><li><code>gcgc</code>：取消注释代码</li></ul><p>块注释：</p><ul><li><code>gc</code>：注释/取消注释代码</li></ul><p>课后练习</p><ul><li>安装vim-commentary插件</li><li>尝试打开Python文件并快速注释一段代码</li><li>打开不同类型的文件，比如go文件，试试注释一段代码或文字</li></ul><h3 id="4-14-vim和git，强强联手-07-11"><a href="#4-14-vim和git，强强联手-07-11" class="headerlink" title="4-14 vim和git，强强联手 (07:11)"></a>4-14 vim和git，强强联手 (07:11)</h3><p>Fugitive</p><blockquote><p>在vim里使用git</p></blockquote><ul><li><a href="https://github.com/tpope/vim-fugitive" target="_blank" rel="noopener">https://github.com/tpope/vim-fugitive</a></li><li>Gedit、Gdiff、Gblame、Gcommit等</li><li>使用tmux新开一个窗口来使用git</li></ul><p>vim-gitgutter</p><blockquote><p>在vim里显示文件变动</p></blockquote><ul><li><a href="https://github.com/airblade/vim-gitgutter" target="_blank" rel="noopener">https://github.com/airblade/vim-gitgutter</a></li><li>当修改文件之后可以显示当前文件的变动</li><li>哪些行新增，哪些行修改，哪些行删除</li></ul><p>配置：</p><pre><code class="shell">set updatetime = 100</code></pre><p>gv.vim</p><blockquote><p>在命令行查看提交记录，命令行工具tig</p></blockquote><ul><li><p><a href="https://github.com/junegunn/gv.vim" target="_blank" rel="noopener">https://github.com/junegunn/gv.vim</a></p></li><li><p>使用<code>:GV</code>命令调用</p></li><li><p>可以浏览代码提交变更</p></li></ul><p>tig</p><ul><li><p><a href="https://github.com/jonas/tig" target="_blank" rel="noopener">https://github.com/jonas/tig</a></p></li><li><p><a href="https://www.jianshu.com/p/d9f60c0abbf7" target="_blank" rel="noopener">tig — 让 git 命令行可视化</a></p></li></ul><p>课后练习</p><ul><li>安装三个git插件</li><li>使用<code>:Gblame</code>等命令</li><li>vim和tmux配合使用</li></ul><h3 id="4-15-本章小结：授人以渔，寻找自己需要的插件-02-29"><a href="#4-15-本章小结：授人以渔，寻找自己需要的插件-02-29" class="headerlink" title="4-15 本章小结：授人以渔，寻找自己需要的插件 (02:29)"></a>4-15 本章小结：授人以渔，寻找自己需要的插件 (02:29)</h3><p>Vim插件千千万</p><blockquote><p>本章介绍了如何安装使用常用的插件</p></blockquote><ul><li>Vim插件很多，不可能都全部介绍。学会自己寻找个安装</li><li>通过搜索引擎Google关键词、vimawesome、参考开源配置寻找插件</li><li>学会阅读插件的README文件和doc里的帮助文件，学习插件使用</li></ul><p>缺什么就找什么插件吧！</p><h2 id="第5章-与时俱进的-Vim"><a href="#第5章-与时俱进的-Vim" class="headerlink" title="第5章 与时俱进的 Vim"></a>第5章 与时俱进的 Vim</h2><blockquote><p>介绍如何安装和使用现有的开源配置，什么是 Neovim 等，站在巨人的肩膀上。</p></blockquote><h3 id="5-1-Vim和Tmux-天作之合-08-27"><a href="#5-1-Vim和Tmux-天作之合-08-27" class="headerlink" title="5-1 Vim和Tmux,天作之合 (08:27)"></a>5-1 Vim和Tmux,天作之合 (08:27)</h3><p>Tmux</p><blockquote><p>强大的终端复用工具。通过brew(Mac)、apt-get(ubuntu)安装</p></blockquote><ul><li>可以复用终端、分屏、托管进程等</li><li>在服务器上即使退出服务器也不会被kill，托管进程也很方便</li><li>可以方便地分割屏幕，实现多个进程公用屏幕</li></ul><p>Tmux使用文章：<a href="https://zhuanlan.zhihu.com/p/43687973" target="_blank" rel="noopener">手把手教你使用终端复用神器 Tmux，丢掉鼠标不是梦</a></p><p><code>&lt;Ctrl-b&gt;%</code>：垂直分屏</p><p><code>&lt;Ctrl-b&gt;&quot;</code>：水平分屏</p><p><code>&lt;Ctrl-b&gt;c</code>：创建新tmux窗口</p><p><code>&lt;Ctrl-b&gt;n</code>：跳转到下一个tmux窗口</p><p><code>&lt;Ctrl-b&gt;p</code>：跳转到上一个tmux窗口</p><p><code>&lt;Ctrl-b&gt;h</code>：向左切换分屏</p><p><code>&lt;Ctrl-b&gt;l</code>：向右切换分屏</p><p><code>&lt;Ctrl-b&gt;s</code>：查看所有会话</p><p><code>&lt;Ctrl-b&gt;d</code>：脱离当前会话。d(etach）</p><p><code>tmux ls</code>：查看会话列表</p><p><code>tmux new -s &lt;session_name&gt;</code>：创建会话</p><p><code>tmux att -t &lt;session_name&gt;</code>：链接会话。att(ach)</p><p>课后练习</p><blockquote><p>在系统或者服务器上安装tmux</p></blockquote><ul><li>使用tmux分割屏幕</li><li>尝试一个窗口编写代码，另一个窗口使用shell命令</li><li>尝试退出和重新attach到一个tmux的会话</li></ul><h3 id="5-2-无处不在的-vim，让-vim-嵌入你的开发工具-01-42"><a href="#5-2-无处不在的-vim，让-vim-嵌入你的开发工具-01-42" class="headerlink" title="5-2 无处不在的 vim，让 vim 嵌入你的开发工具 (01:42)"></a>5-2 无处不在的 vim，让 vim 嵌入你的开发工具 (01:42)</h3><p>几乎流行的编辑器和IDE都支持VIM插件</p><blockquote><p>让vim嵌入开发工具，甚至Chrome都有vimium插件</p></blockquote><ul><li>即使不用vim作为主力编辑器，依然可以使用它的编辑方式</li><li>几乎流行的开发工具都支持vim插件，以vim的方式编辑</li><li>比如VSCode/Atom/PyCharm等都支持安装vim插件</li></ul><p>课后练习</p><ul><li>搜索相应开发工具的vim插件</li><li>安装vim插件到开发工具里</li><li>尝试在各种开发工具中使用vim的方式编辑提升效率</li></ul><h3 id="5-3-与时俱进的-vim-之-neovim-02-07"><a href="#5-3-与时俱进的-vim-之-neovim-02-07" class="headerlink" title="5-3 与时俱进的 vim 之 neovim (02:07)"></a>5-3 与时俱进的 vim 之 neovim (02:07)</h3><p>Neovim</p><blockquote><p>一个新的vim版本，支持异步特性（vim8也支持）</p></blockquote><ul><li><a href="https://neovim.io/" target="_blank" rel="noopener">https://neovim.io/</a></li><li><a href="https://github.com/neovim/neovim" target="_blank" rel="noopener">https://github.com/neovim/neovim</a></li><li>开发更活跃，更丰富的特性和扩展异步支持</li><li>neovim的设计可以嵌入到很多GUI里，加上好看的外壳</li></ul><p>感兴趣的同学可以使用neovim代替vim啦！</p><h3 id="5-4-站在巨人的肩膀上，使用强大的开源配置-03-37"><a href="#5-4-站在巨人的肩膀上，使用强大的开源配置-03-37" class="headerlink" title="5-4 站在巨人的肩膀上，使用强大的开源配置 (03:37)"></a>5-4 站在巨人的肩膀上，使用强大的开源配置 (03:37)</h3><p>开箱即用</p><blockquote><p>如果你已经熟悉了vim配置，可以从网上直接使用一些开源配置</p></blockquote><ul><li><a href="https://github.com/SpaceVim/SpaceVim" target="_blank" rel="noopener">https://github.com/SpaceVim/SpaceVim</a></li><li><a href="https://github.com/pegasuswang/vim-config" target="_blank" rel="noopener">https://github.com/pegasuswang/vim-config</a></li><li>其他开源配置。不推荐新手直接使用，越复杂的配置上手成本越高</li></ul><p>课后练习</p><ul><li>找到一个合适的开源配置，尝试安装它</li><li>阅读其他文档，了解使用方式。一般开源配置都安装了很多插件</li><li>对于新手来说，配置太复杂太强大有时候可能会出现很多小问题</li></ul><h2 id="第6章-Vim虐我千百遍，我待Vim如初恋"><a href="#第6章-Vim虐我千百遍，我待Vim如初恋" class="headerlink" title="第6章 Vim虐我千百遍，我待Vim如初恋~"></a>第6章 Vim虐我千百遍，我待Vim如初恋~</h2><blockquote><p>Vim虐我千百遍，我待Vim如初恋~</p></blockquote><h3 id="6-1-课程总结-vim虐我千百遍，我待-vim-如初恋-03-17"><a href="#6-1-课程总结-vim虐我千百遍，我待-vim-如初恋-03-17" class="headerlink" title="6-1 课程总结-vim虐我千百遍，我待 vim 如初恋 (03:17)"></a>6-1 课程总结-vim虐我千百遍，我待 vim 如初恋 (03:17)</h3><p>可以用一生的编辑器</p><blockquote><p>vim从诞生到现在已经走过了快30个年头</p></blockquote><ul><li>几十年之间，无数的编辑器或者开发工具昙花一现</li><li>但是vim一直到现在依然有很多人在使用，甚至嵌入到各种开发工具</li><li>如今vim/neovim依然在活跃开发，很多开发者贡献插件</li></ul><p>学习方法</p><blockquote><p>熟悉vim靠的是肌肉记忆。脱离鼠标编辑能提升编辑效率</p></blockquote><ul><li>讲了很多，但是vim中依然有很多东西没有讲到，时不时发现一些使用技巧</li><li>在学中练，在练中学。熟能生巧，肌肉记忆</li><li>衡量投入产出比，是点到为止还是继续深入</li></ul><p>继续练级</p><blockquote><p>网络上有很多vim的资源，甚至练习的小游戏</p></blockquote><ul><li>《Practical vim》、中文版《Vim实用技巧》</li><li>《笨方法学vimscript》</li><li>学习和开发自己的插件</li></ul><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><pre><code class="shell">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;                                 Sample vimrc                                 &quot;&quot;                                                                              &quot;&quot;                                 Provided by:                                 &quot;&quot;                                     Tuyk                                     &quot;&quot;                                                                              &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax on &quot; 自动语法高亮&quot; colorscheme xcode-default &quot; 更换主题配色&quot; ======================...Basic Start...====================== &quot;&quot; Turn on line numbering &quot; 显示行号set number&quot; Save 1,000 items in history &quot; 设置历史行号set history=1000&quot; Show the line and column number of the cursor position &quot; 设置光标的位置值set ruler&quot; Display the incomplete commands in the bottom right-hand side of your screen.  set showcmd&quot; Display completion matches on your status lineset wildmenu&quot; Show a few lines of context around the cursorset scrolloff=5&quot; Highlight search matches &quot; 设置查找的值高亮显示set hlsearch&quot; Enable incremental searching &quot; 设置边搜索边高亮set incsearch&quot; Ignore case when searching &quot; 设置忽略查找选项的大小写set ignorecase&quot; Override the &#39;ignorecase&#39; option if the search pattern contains upper case characters.set smartcase&quot; Turn on file backupsset backup&quot; Don&#39;t line wrap mid-word.set lbr&quot; Copy the indentation from the current line. &quot; 设置自动复制上一行的缩进到下一行set autoindent&quot; Enable smart autoindenting. &quot; 设置自动识别“{}”缩进，写代码非常有用set smartindent&quot; Use spaces instead of tabs &quot; 使用空格替换tabset expandtab&quot; Enable smart tabsset smarttab&quot; Make a tab equal to 4 spacesset shiftwidth=4 &quot; 默认缩进4个空格set tabstop=4 &quot; tab 代表4个空格set softtabstop=4 &quot; 使用tab时 tab空格数&quot; 按F2进入粘贴模式set pastetoggle=&lt;F2&gt;&quot; 设置折叠方式&quot; set foldmethod=indent&quot; 开启系统剪贴板set clipboard=unnamed&quot; 解决中文乱码set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8&quot; Tell vim what background you are using &quot; 设置背景颜色&quot; set bg=light&quot; set bg=dark&quot; 退格删除键不能用set backspace=indent,eol,start&quot; ======================...Basic End...====================== &quot;&quot; ======================...Mapping Start...====================== &quot;&quot; Map Y to act like D and C, i.e. yank until EOL, rather than act like yy &quot; Map 映射&quot; map Y y$&quot; Remap VIM 0 to first non-blank character&quot; map 0 ^noremap &lt;space&gt; viw&quot; change the mapleader from \ to , &quot; 一些方便的映射&quot; NOTE: This has to be set before &lt;leader&gt; is used.let mapleader=&#39;,&#39;let g:mapleader=&#39;,&#39;&quot; 使用 jj 进入 normal模式inoremap jj &lt;Esc&gt;`^&quot; 使用 &lt;leader&gt;+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w!&lt;cr&gt;noremap &lt;leader&gt;w :w!&lt;cr&gt;&quot; 切换 buffernnoremap &lt;silent&gt; [p :bprevious&lt;cr&gt;nnoremap &lt;silent&gt; [n :bnext&lt;cr&gt;&quot; use ctrl+h/j/k/l switch windownoremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l&quot; Sudo to writecnoremap w!! w !sudo tee % &gt;/dev/null&quot; NERDTreemap &lt;leader&gt;v :NERDTreeFind&lt;CR&gt;map &lt;leader&gt;g :NERDTreeToggle&lt;CR&gt;&quot; ctrlp.vimlet g:ctrlp_map = &#39;&lt;c-p&gt;&#39;&quot; vim-easymotionnmap ss &lt;Plug&gt;(easymotion-s2)&quot; vim-goautocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4&quot; python-modelet g:pymode_python = &#39;python3&#39;let g:pymode_trim_whitespaces = 1let g:pymode_doc = 1let g:pymode_doc_bind = &#39;K&#39;let g:pymode_rope_goto_definition_bind = &#39;&lt;C-]&gt;&#39;let g:pymode_lint = 1let g:pymode_lint_checkers = [&#39;pyflakes&#39;, &#39;pep8&#39;, &#39;mccabe&#39;, &#39;pylint&#39;]let g:pymode_options_max_line_length = 120&quot; tagbarnnoremap &lt;leader&gt;t :TagbarToggle&lt;CR&gt;&quot; deoplete.nvimlet g:deoplete#enable_at_startup = 1set completeopt -=preview &quot; 关闭预览窗口&quot; vim-gitgutterset updatetime =100&quot; ======================...Mapping End...====================== &quot;&quot; ============================================================================== &quot;&quot; json 格式化com! FormatJSON %!python3 -m json.tool&quot; ============================================================================== &quot;&quot; ======================...Plugins Start...====================== &quot;&quot; 插件设置，这里使用了 vim-plugcall plug#begin(&#39;~/.vim/plugged&#39;)&quot; 安装插件只需要把 github 地址放到这里重启后执行 :PlugInstall 就好了Plug &#39;mhinz/vim-startify&#39;Plug &#39;vim-airline/vim-airline&#39;Plug &#39;vim-airline/vim-airline-themes&#39;Plug &#39;Yggdroot/indentLine&#39;Plug &#39;scrooloose/nerdtree&#39;Plug &#39;ctrlpvim/ctrlp.vim&#39;Plug &#39;easymotion/vim-easymotion&#39;Plug &#39;tpope/vim-surround&#39;Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;Plug &#39;ggreer/the_silver_searcher&#39;Plug &#39;brooth/far.vim&#39;Plug &#39;fatih/vim-go&#39;, { &#39;do&#39;: &#39;:GoUpdateBinaries&#39; }Plug &#39;python-mode/python-mode&#39;, { &#39;for&#39;: &#39;python&#39;, &#39;branch&#39;: &#39;develop&#39; }Plug &#39;majutsushi/tagbar&#39;Plug &#39;lfv89/vim-interestingwords&#39;if has(&#39;nvim&#39;)  Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }else  Plug &#39;Shougo/deoplete.nvim&#39;  Plug &#39;roxma/nvim-yarp&#39;  Plug &#39;roxma/vim-hug-neovim-rpc&#39;endifPlug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}Plug &#39;sbdchd/neoformat&#39;Plug &#39;dense-analysis/ale&#39;Plug &#39;tpope/vim-commentary&#39;Plug &#39;tpope/vim-fugitive&#39;Plug &#39;airblade/vim-gitgutter&#39;Plug &#39;junegunn/gv.vim&#39;call plug#end()&quot; 插件相关配置&quot; 禁止 stratify 自动切换目录let g:startify_change_to_dir = 0&quot; 启动时自动打开NERDTree&quot; autocmd vimenter * NERDTree&quot; ======================...Plugins End...====================== &quot;&quot; ======================...Function Start...====================== &quot;&quot; 定义函数SetTitle，自动插入文件头func SetTitle()    if &amp;filetype == &#39;python&#39;        call setline(1, &quot;\#!/usr/bin/env python&quot;)        call setline(2, &quot;\# -*- coding:utf-8 -*-&quot;)        normal G        normal o        normal o        call setline(5, &quot;if __name__ == &#39;__main__&#39;:&quot;)        call setline(6, &quot;    pass&quot;)    endifendfunc&quot; ======================...Function End...====================== &quot;&quot; For more options see &quot;:help option-list&quot; and &quot;:options&quot;.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1049-优雅玩转Vim</title>
      <link href="/2019/11/04/1049-vim/"/>
      <url>/2019/11/04/1049-vim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1049" target="_blank" rel="noopener">https://www.imooc.com/learn/1049</a></p><p>简介：Vim作为Linux 平台首选编辑器，无论是运维还是开发等IT人员都应该系统地学习下这款优秀经典的上古神器。本课程系统提炼vim 的精华、通过抛砖引玉把它展现到你的面前，更能让你的工作如虎添翼、事半功倍。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>Vim课程介绍。</p></blockquote><h3 id="1-1-课程简介-04-34"><a href="#1-1-课程简介-04-34" class="headerlink" title="1-1 课程简介 (04:34)"></a>1-1 课程简介 (04:34)</h3><p>在所有的类Unix操作系统中都会默认内置Vi/Vim文本编辑器</p><ol><li><p>Vim简介</p><ul><li>Vim和Vi的区别</li><li>Vimrc配置</li><li>Vim四种模式</li></ul></li><li><p>基础入门</p><ul><li>Vim寄存器（类似于Windows的粘贴板）</li><li>增查删改等常规操作（快捷键、按键）</li><li>Vim组合规律</li></ul></li><li><p>高级功能</p><ul><li>缓冲区与多文件编辑</li><li>多窗口与标签分组</li><li>文本对象和宏</li><li>Visual模式</li></ul></li></ol><h2 id="第2章-Vim简介"><a href="#第2章-Vim简介" class="headerlink" title="第2章 Vim简介"></a>第2章 Vim简介</h2><blockquote><p>为什么选择Vim作为编辑器，Vim安装与简洁Vimrc配置</p></blockquote><h3 id="2-1-vim介绍及Vimrc-18-02"><a href="#2-1-vim介绍及Vimrc-18-02" class="headerlink" title="2-1 vim介绍及Vimrc (18:02)"></a>2-1 vim介绍及Vimrc (18:02)</h3><p>Vim介绍：</p><ul><li>Vim是一个Unix以及类Unix文本编辑器</li><li>特点：功能强大、高度可定制(Vimrc、插件等)</li></ul><p>Vim vs Vi：</p><blockquote><p>Vim = Vi + IMproved</p></blockquote><ul><li>多级撤销</li><li>语法加亮和自动补全</li><li>支持多种插件</li><li>通过网络协议（HTTP/SSH）编辑文件</li><li>多文件编辑</li><li>Vim可以编辑压缩格式文件（gzip、zip等）</li></ul><p>Vimrc概述：</p><ul><li>rc = run command</li><li>系统级vimrc和用户级vimrc</li><li>每一行作为一个命令执行</li></ul><p>Vimrc使用：</p><blockquote><p>默认.Vimrc是没有得。需要用户自己手动创建。Vim 会自动搜索到。</p></blockquote><ul><li><p><code>:h vimrc</code> 查看Vimrc文档</p></li><li><p><code>:version</code> 查看vim版本</p></li><li><p><code>vim &lt;filename&gt;</code> 或 <code>:e &lt;filename&gt;</code> 打开文件📃</p></li><li><p><code>“</code> 注释</p></li><li><p>Vimrc-Sample：<a href="https://raw.githubusercontent.com/yangvipguang/vimrc-sample/master/vimrc-sample" target="_blank" rel="noopener">https://raw.githubusercontent.com/yangvipguang/vimrc-sample/master/vimrc-sample</a></p></li></ul><pre><code class="shell">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;                                 Sample vimrc                                 &quot;&quot;                                                                              &quot;&quot;                                 Provided by:                                 &quot;&quot;                                     Tuyk                                     &quot;&quot;                                                                              &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax on &quot; 自动语法高亮&quot; Save 1,000 items in history &quot; 设置历史行号set history=1000&quot; Show the line and column number of the cursor position &quot; 设置光标的位置值set ruler&quot; Display the incomplete commands in the bottom right-hand side of your screen.  set showcmd&quot; Display completion matches on your status lineset wildmenu&quot; Show a few lines of context around the cursorset scrolloff=5&quot; Highlight search matches &quot; 设置查找的值高亮显示set hlsearch&quot; Enable incremental searching &quot; 设置边搜索边高亮set incsearch&quot; Ignore case when searching &quot; 设置忽略查找选项的大小写set ignorecase&quot; Override the &#39;ignorecase&#39; option if the search pattern contains upper case characters.set smartcase&quot; Turn on line numbering &quot; 显示行号set number&quot; Turn on file backupsset backup&quot; Don&#39;t line wrap mid-word.set lbr&quot; Copy the indentation from the current line. &quot; 设置自动复制上一行的缩进到下一行set autoindent&quot; Enable smart autoindenting. &quot; 设置自动识别“{}”缩进，写代码非常有用set smartindent&quot; Use spaces instead of tabs &quot; 使用空格替换tabset expandtab&quot; Enable smart tabsset smarttab&quot; Make a tab equal to 4 spacesset shiftwidth=4 &quot; 默认缩进4个空格set tabstop=4 &quot; tab 代表4个空格set softtabstop=4 &quot; 使用tab时 tab空格数&quot; Specifiy a color scheme.colorscheme slate&quot; Tell vim what background you are using &quot; 设置背景颜色&quot; set bg=light&quot; set bg=dark&quot; Map Y to act like D and C, i.e. yank until EOL, rather than act like yy &quot; Map 映射&quot; map Y y$&quot; Remap VIM 0 to first non-blank character&quot; map 0 ^&quot; Easily create HTML unorded lists. &quot; map &lt;F3&gt; i&lt;ul&gt;&lt;CR&gt;&lt;Space&gt;&lt;Space&gt;&lt;li&gt;&lt;/li&gt;&lt;CR&gt;&lt;Esc&gt;I&lt;/ul&gt;&lt;Esc&gt;kcit&quot; map &lt;F4&gt; &lt;Esc&gt;o&lt;li&gt;&lt;/li&gt;&lt;Esc&gt;cit&quot; change the mapleader from \ to ,&quot; NOTE: This has to be set before &lt;leader&gt; is used.&quot; let mapleader=&quot;,&quot;&quot; Quickly save your file.&quot; map &lt;leader&gt;w :w!&lt;cr&gt;&quot; For more options see &quot;:help option-list&quot; and &quot;:options&quot;.</code></pre><h3 id="2-2-vim的四种模式-05-22"><a href="#2-2-vim的四种模式-05-22" class="headerlink" title="2-2 vim的四种模式 (05:22)"></a>2-2 vim的四种模式 (05:22)</h3><ol><li>普通模式<ul><li>打开的默认模式</li><li>移查删改</li></ul></li><li>可视化模式<ul><li>对一块区域操作</li></ul></li><li>插入模式<ul><li>添加文本</li></ul></li><li>命令模式<ul><li>和普通模式类似</li></ul></li></ol><p><code>v</code>：进入可视化模式</p><p><code>i</code>：进入插入模式</p><p><code>:</code>：使用命令模式</p><p><code>dd</code>：删除</p><p><code>Esc</code>：返回普通模式</p><p><code>:h vim-modes-intro</code>：查看vim模式文档（7种）</p><h2 id="第3章-Vim基础入门"><a href="#第3章-Vim基础入门" class="headerlink" title="第3章 Vim基础入门"></a>第3章 Vim基础入门</h2><blockquote><p>本章主要讲解移动、跳转与缩进，删除、复制与粘贴，修改、查找与替换相关内容。</p></blockquote><h3 id="3-1-移动、跳转与缩进-07-55"><a href="#3-1-移动、跳转与缩进-07-55" class="headerlink" title="3-1 移动、跳转与缩进 (07:55)"></a>3-1 移动、跳转与缩进 (07:55)</h3><p>Vim布局起源</p><ul><li><p>Vim最初的作者Bill Joy使用的机器ADM-3A终端机</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbdnjipj31bs0fmgod.jpg" alt="ADM-3A终端机" style="zoom:30%;" /><p>注意看上下左右键的位置</p></li></ul><p><strong>光标移动：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code></td><td>左移</td></tr><tr><td><code>l</code></td><td>右移</td></tr><tr><td><code>j</code></td><td>下移</td></tr><tr><td><code>k</code></td><td>上移</td></tr><tr><td><code>shift+6</code>/<code>0</code></td><td>移动到行首<code>^</code>/包含缩进空格</td></tr><tr><td><code>shift+4</code></td><td>移动到行尾<code>$</code></td></tr></tbody></table><p><strong>单词和字符移动：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>w/W</td><td>正向移动到下一个单词开头(小写识别特殊字符)</td></tr><tr><td>e/E</td><td>正向移动到下一个单词结尾</td></tr><tr><td>b/B</td><td>反向移动到上一个单词开头</td></tr><tr><td>ge</td><td>反向移动到上一个单词结尾</td></tr></tbody></table><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbf4b5oj30ja0asmxt.jpg" alt="单词和字符移动" style="zoom:50%;" /><p><strong>跳转：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>control+b/B</code></td><td>上一页</td></tr><tr><td><code>control+f/F</code></td><td>下一页</td></tr><tr><td><code>control+u/d</code></td><td>向上/下翻半页</td></tr><tr><td><code>gg</code></td><td>跳转到文件📁首行</td></tr><tr><td><code>G</code></td><td>跳转到文件📁尾行</td></tr><tr><td><code>&lt;line_number&gt;gg/G</code></td><td>跳转到指定行</td></tr><tr><td><code>{g}+control+g/G</code></td><td>查看文件信息/{g}更加详细</td></tr></tbody></table><p><strong>缩进：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;&gt;</code>===<code>:&gt;</code></td><td>右缩进(普通模式)</td></tr><tr><td><code>&lt;&lt;</code>===<code>:&lt;</code></td><td>左缩进(普通模式)</td></tr><tr><td><code>:m,n&gt;</code>===<code>:m&gt;(n-m+1)</code></td><td>m到n行缩进(命令行模式)</td></tr><tr><td><code>:m&gt;n</code>===<code>:m,m+n-1&gt;</code></td><td>m行开始,共n行缩进一次(命令行模式)</td></tr></tbody></table><h3 id="3-2-删除、复制与粘贴-25-41"><a href="#3-2-删除、复制与粘贴-25-41" class="headerlink" title="3-2 删除、复制与粘贴 (25:41)"></a>3-2 删除、复制与粘贴 (25:41)</h3><table><thead><tr><th>Windows</th><th>Vim</th><th>不同处</th></tr></thead><tbody><tr><td>cut</td><td>delete</td><td>和剪切相同，而不是直接删除</td></tr><tr><td>copy</td><td>yank</td><td>等同于复制,由于c用于(change)被迫选了yank</td></tr><tr><td>paste</td><td>put</td><td>粘贴完全相同</td></tr></tbody></table><p>Vim特性</p><ul><li><p>寄存器（保存临时数据）</p><table><thead><tr><th align="left">类型</th><th align="center">含义</th><th>表示方式</th><th>举例</th><th>特点</th></tr></thead><tbody><tr><td align="left">无名寄存器</td><td align="center">默认寄存器</td><td>“”</td><td>“” p=p</td><td>会被最后一条覆盖</td></tr><tr><td align="left">数字寄存器</td><td align="center">“+{0-9}缓存最近10次操作</td><td>“0”{1-9}</td><td>“0P<br />“1P</td><td>0用于复制专用<br />1-9用于最近9次行删除或者修改记录</td></tr><tr><td align="left">有名寄存器</td><td align="center">26英文字母命名有名寄存器</td><td>“[a-z]/[A-Z]”</td><td>“ayw</td><td>“A会通过^J追加到”a寄存器中</td></tr><tr><td align="left">黑洞寄存器</td><td align="center">有去无回</td><td>“-</td><td>“_dw</td><td>只想删除而不想覆盖无名寄存器</td></tr></tbody></table><p><code>:register</code>/<code>:reg</code>：进入寄存器</p><p><code>:h reg</code>：查看寄存器文档</p></li></ul><p>基础操作</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td>d = delete = cut</td><td>剪切</td></tr><tr><td>y = yank ≈ copy</td><td>类似于复制</td></tr><tr><td>P/p = put ≈ paste</td><td>粘贴到光标后/前</td></tr><tr><td>u = undo</td><td>撤销之前操作</td></tr><tr><td>Control+r = redo</td><td>重做/恢复之前操作(反撤销)</td></tr></tbody></table><p><code>yy</code>：复制整行。记录到<code>&quot;&quot;</code>默认寄存器/无名寄存器、<code>&quot;0</code>寄存器/复制专用寄存器</p><p><code>dd</code>：剪切整行。记录到<code>&quot;&quot;</code>默认寄存器/无名寄存器、<code>&quot;1</code>寄存器/剪切寄存器</p><p><code>p</code>：粘贴</p><p><code>u</code>：撤销</p><p><code>Control+r</code>：重做(反撤销)</p><p><code>&quot;ayy</code>：复制整行到<code>&quot;a</code>寄存器。记录到默认寄存器，不会记录到复制专用寄存器</p><p><code>&quot;_dd</code>：删除整行。不会记录到任何寄存器。黑洞寄存器</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td>yw</td><td>复制当前光标单词(从光标后开始截取)</td></tr><tr><td>y2w</td><td>复制正向倆个单词(从光标后开始截取)</td></tr></tbody></table><p>调换字符</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Practical vim</td></tr><tr><td>F{space}</td><td>Practical vim</td></tr><tr><td>x</td><td>Practical vim</td></tr><tr><td>p</td><td>Practical vim</td></tr></tbody></table><p><code>x</code>：剪切单个字符。记录到默认寄存器、<code>-</code>寄存器</p><p>行剪切粘贴</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Line1   Line2</td></tr><tr><td>dd</td><td>Line2</td></tr><tr><td>p</td><td>Line2   Line1</td></tr></tbody></table><p>行复制</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Line1   Line2</td></tr><tr><td>yy</td><td>Line1   Line2</td></tr><tr><td>p</td><td>Line1   Line2   Line1</td></tr></tbody></table><p>组合删除([count] operation [count] {motion})</p><table><thead><tr><th>操作按键</th><th>定义</th></tr></thead><tbody><tr><td><code>x</code>/<code>X</code></td><td>删除光标下/前单个字符</td></tr><tr><td><code>dw</code>(d = delete,w = word)</td><td>删除一个单词(必须在词首👋)(删除光标处到单词末尾🔚)</td></tr><tr><td><code>d{hjkl}</code></td><td>删除到上下左右一个操作前的字符</td></tr><tr><td><code>d$</code>===<code>D</code></td><td>删除光标到行尾的字符</td></tr><tr><td><code>d^</code></td><td>删除光标到行首的字符</td></tr><tr><td><code>dd</code></td><td>删除当前整行</td></tr><tr><td><code>{n}dd</code></td><td>向下删除n行（包括当前行）</td></tr><tr><td><code>5dw</code></td><td>删除正向单词5次</td></tr><tr><td><code>d3w</code></td><td>正向删除3w 动作</td></tr><tr><td><code>3w</code></td><td>正向移动单词3次</td></tr><tr><td><code>2d3w</code></td><td>正向删除3w 动作 2次</td></tr></tbody></table><h3 id="3-3-修改、查找与替换-15-59"><a href="#3-3-修改、查找与替换-15-59" class="headerlink" title="3-3 修改、查找与替换 (15:59)"></a>3-3 修改、查找与替换 (15:59)</h3><p>插入</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>Shift+i</code>/<code>Shift+a</code></td><td>插入模式并移动到行首/尾</td></tr><tr><td><code>i</code>/<code>a</code></td><td>光标前/后插入</td></tr><tr><td>[n]+<code>O</code>/<code>o</code></td><td>行前/后插入n次</td></tr><tr><td>[n]+<code>i</code></td><td>插入模式重复n次</td></tr></tbody></table><p>转换</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>~</code></td><td>单个字符大小写转换</td></tr><tr><td><code>g ~ w</code></td><td>单词大小写转换</td></tr><tr><td><code>g ~ $</code>/<code>g ~ ~</code></td><td>整行大小写转换(<code>^</code>光标处到行首大小写反转,<code>$</code>光标处到行尾大小写反转)</td></tr><tr><td><code>gUw</code>/<code>guw</code></td><td>单词转换成大小写</td></tr></tbody></table><p><code>.</code>：对上一个操作的重🐛复</p><p>查找</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>f{char}</code>/<code>F{char}</code></td><td>正向/反向查找某个单词(适用于查找某一行)</td></tr><tr><td><code>t{char}</code></td><td>查找字符前一个字符</td></tr><tr><td><code>dt{char}</code>/<code>df{char}</code></td><td>删除光标到查找字符间的字符</td></tr><tr><td><code>/{char}</code></td><td>命令行查找</td></tr></tbody></table><p><code>/{char}</code>：</p><ul><li><code>n</code>：向下⬇️查找🔎</li><li><code>N</code>：向上⬆️查找🔎</li></ul><p>替换(substitute)</p><p>语法：<code>[range]s[ubstitute]/{pattern}/{string}/[flags]</code></p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>:s/going/rolling/g</code></td><td>当前行所有going替换成rolling</td></tr><tr><td><code>:%s/going/rolling/g</code></td><td>%匹配所有范围</td></tr><tr><td><code>⇧+r</code>/<code>R</code></td><td>替换模式</td></tr><tr><td><code>r</code></td><td>单个字符替换</td></tr><tr><td><code>cw</code>、<code>c2w</code></td><td>修改单个单词</td></tr><tr><td><code>c$</code>/<code>C</code>类似于<code>d</code>操作符</td><td>修改光标之后行内内容</td></tr></tbody></table><h2 id="第4章-Vim高级功能"><a href="#第4章-Vim高级功能" class="headerlink" title="第4章 Vim高级功能"></a>第4章 Vim高级功能</h2><blockquote><p>本章主要讲解缓冲区与多文件编辑、多窗口操作（分屏）与标签分组、宏和文本对象以及Visual模式。</p></blockquote><h3 id="4-1-缓冲区与多文件编辑-13-25"><a href="#4-1-缓冲区与多文件编辑-13-25" class="headerlink" title="4-1 缓冲区与多文件编辑 (13:25)"></a>4-1 缓冲区与多文件编辑 (13:25)</h3><blockquote><p>缓冲区、标签、窗口</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbe71ptj31340hcmyi.jpg" alt="缓冲区与多文件编辑" style="zoom:45%;" /><p>编辑操作并不是真正的编辑文件，而是编辑文件在内存中的映射或快照或缓冲区</p><p>缓冲区：就是内容缓存区域。</p><ul><li>Buffer是内存中的一块缓冲区，用于临时存放Vim打开过的文件</li></ul><p>查看缓冲区列表：</p><ul><li><code>:files</code></li><li><code>:buffers</code></li><li><code>:ls</code><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbeqzfdj31kg0cwgoo.jpg" alt="缓冲区列表" style="zoom:30%;" /></li></ul><p>缓冲区列表指示状态</p><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>激活缓冲区，缓冲区被加载且显示</td></tr><tr><td>h</td><td>隐藏缓冲区，缓冲区被加载但🥚不显示</td></tr><tr><td>%</td><td>当前缓冲区</td></tr><tr><td>#</td><td>交换缓冲区</td></tr><tr><td>=</td><td>只读缓冲区</td></tr><tr><td>+</td><td>已经更改缓冲区</td></tr><tr><td>-</td><td>不可更改缓冲区，’modifiable’选项不置位</td></tr></tbody></table><p>缓冲区列表操作</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>:bp[revious]</code></td><td>上一个缓冲区</td></tr><tr><td><code>:bn[ext]</code></td><td>下一个缓冲区</td></tr><tr><td><code>:bf[irst]</code></td><td>到第一个缓冲区</td></tr><tr><td><code>:bl[ast]</code></td><td>到最后一个缓冲区</td></tr><tr><td><code>:buffer Number/File_name</code></td><td>指定缓冲区</td></tr><tr><td><code>:ball</code></td><td>编辑所有缓冲区</td></tr><tr><td><code>⌃+^</code>/<code>b#</code></td><td>切换到前一个buffer（交换buffer）</td></tr><tr><td><code>:qall!</code></td><td>退出全部缓冲区</td></tr><tr><td><code>:wall!</code></td><td>写入全部缓冲区</td></tr><tr><td><code>:badd</code></td><td>添加一个新缓冲区，但不设置为当前缓冲区</td></tr><tr><td><code>:bd[elete]</code></td><td>删除缓冲区</td></tr><tr><td><code>:m,nbd</code>/<code>:%db</code></td><td>删除m到n编号/所有的缓冲区文件</td></tr><tr><td><code>:bufdo {CMD}</code></td><td>bufdo set number</td></tr><tr><td><code>:E /:bd</code></td><td>打开文件目录列表/返回到🔙最初的buffer</td></tr></tbody></table><h3 id="4-2-多窗口操作与标签分组-16-57"><a href="#4-2-多窗口操作与标签分组-16-57" class="headerlink" title="4-2 多窗口操作与标签分组 (16:57)"></a>4-2 多窗口操作与标签分组 (16:57)</h3><ul><li>多窗口（分屏）</li></ul><p>分屏操作</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>vim -On</code>/<code>vim -on</code></td><td>垂直/水平分屏（n：数字，o：Open）</td></tr><tr><td><code>⌃+w c/q</code></td><td>关闭当前窗口/最后一个窗口时退</td></tr><tr><td><code>⌃+w s</code></td><td>上下分割当前打开的文件</td></tr><tr><td><code>⌃+w v</code></td><td>左右分割当前打开的文件</td></tr><tr><td><code>:sp filename</code></td><td>上下分割并打开一个新的文件</td></tr><tr><td><code>:vsp filename</code></td><td>左右分割并打开一个新的文件</td></tr></tbody></table><p>移动分屏和尺寸变动</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>⌃+w H</code></td><td>向左⬅️移动</td></tr><tr><td><code>⌃+w J</code></td><td>向下⬇️移动</td></tr><tr><td><code>⌃+w K</code></td><td>向上⬆️移动</td></tr><tr><td><code>⌃+w L</code></td><td>向右➡️移动</td></tr><tr><td><code>⌃+w +</code></td><td>增加高度</td></tr><tr><td><code>⌃+w -</code></td><td>减少高度</td></tr><tr><td><code>⌃+w _</code></td><td>减小到最低高度</td></tr><tr><td><code>⌃+w =</code></td><td>让所有屏的高度一致</td></tr></tbody></table><ul><li><p>标签</p><p>标签就是容纳一系列窗口的容器</p></li></ul><p>标签操作</p><table><thead><tr><th>指令</th><th><code>含义</code></th></tr></thead><tbody><tr><td><code>:tabnew [tab_name]</code></td><td><code>新建标签页</code></td></tr><tr><td><code>:tabfind</code></td><td><code>查找并在新标签中打开文件</code></td></tr><tr><td><code>:tabs</code></td><td>显示已打开标签页的列表</td></tr><tr><td><code>:tabclose</code></td><td>关闭当前标签页</td></tr><tr><td><code>:tabonly</code></td><td>仅保留当前标签页打开</td></tr><tr><td><code>:tabn/p/first/last</code></td><td>跳转到下/上/第一/最后一个标签页</td></tr><tr><td><code>:tabm</code></td><td>将当前标签页放置到指定位置</td></tr></tbody></table><p>标签操作和命令键</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>gt/T</code></td><td>移动到下/上一个标签</td></tr><tr><td><code>{i}gt</code></td><td><strong>跳转到i位置的标签</strong></td></tr><tr><td><code>noremap &lt;C-L&gt; &lt;Esc&gt; :tabnext &lt;CR&gt;</code></td><td>Vimrc中自定义快捷键</td></tr><tr><td><code>noremap &lt;C-H&gt; &lt;Esc&gt; :tabprevious &lt;CR&gt;</code></td><td>Vimrc中自定义快捷键</td></tr><tr><td><code>:tabe</code></td><td>编辑标签中的某个文件</td></tr><tr><td><code>:tabm 0/tabm</code></td><td>移动当前tab到第一个/最后一个</td></tr><tr><td><code>t:abm {i}</code></td><td><strong>移动当前tab到第i+1位置</strong></td></tr></tbody></table><h3 id="4-3-文本对象与宏-18-40"><a href="#4-3-文本对象与宏-18-40" class="headerlink" title="4-3 文本对象与宏 (18:40)"></a>4-3 文本对象与宏 (18:40)</h3><ul><li>文本对象</li></ul><pre><code>{operator} {a} {object}{operator} {i} {object}</code></pre><p>例：</p><ul><li><p>daw = Delete A Word</p><p><code>==a==n object</code>：包含尾部间隔空格</p></li><li><p>ciw = Change Inner Word</p><p><code>==i==nner object</code>：只是内容本身，不包含尾部单词间隔🈳️格</p></li></ul><p>Word/Sentence/Paragraph</p><table><thead><tr><th>textobject</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>word</td></tr><tr><td>s</td><td>sentence</td></tr><tr><td>p</td><td>paragraph</td></tr></tbody></table><p>块对象</p><table><thead><tr><th>textobject</th><th>说明</th></tr></thead><tbody><tr><td>]/[</td><td><code>[]</code> block</td></tr><tr><td>)/(、b</td><td><code>()</code> block</td></tr><tr><td>&gt;/&lt;、&gt;/&lt;</td><td><code>&lt;&gt;</code> block</td></tr><tr><td>}/{、B</td><td><code>()</code> block</td></tr><tr><td>t</td><td>tag block: <code>&lt;&gt; &lt;/&gt;</code></td></tr></tbody></table><p>Visual mode</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>viw</code></td><td>选中单词</td></tr><tr><td><code>vis</code></td><td>选中句子🍊</td></tr><tr><td><code>vip</code></td><td>选中段落</td></tr><tr><td>vi<code>(</code></td><td>选中<code>()</code>圆括号中的内容</td></tr><tr><td><code>vi[</code></td><td>选中<code>[]</code>中括号中的内容</td></tr><tr><td><code>vit</code></td><td>选中标签中的内容</td></tr></tbody></table><table>    <tr>        <th>指令</th>        <th>说明</th>    </tr>    <tr>        <td>v2i{</td>        <td>          选中两层`{}`大括号之间的所有内容<br/>          数字限制选择的嵌套层数        </td>    </tr>    <tr>        <td>v3aw</td>        <td>选择3⃣️个单词（3个单词➕2个间隔空格）</td>    </tr>    <tr>        <td>v3iw</td>        <td>选择3⃣️个单词（2个单词➕1个间隔空格）</td>    </tr>    <tr>        <td colspan="2" align="center">可将v选择操作指令替换为c(change), x, d(delete), y(yank)等操作符(operator)，来针对文本对象操作</td>    </tr>·</table><ul><li>宏</li></ul><blockquote><p>If you write a thing once, it is okay. However if you’re writing twice or more times, then you should find a better way to do it.</p><p>Vim的Micro就是用来解决重复的问题</p></blockquote><p>宏就是批处理，类似于命令行脚本或者编程中的函数</p><p><code>h: operator</code>：查看操作符文档</p><p>简单操作</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>qa</code></td><td>开始录制⏺️宏到寄存器a🀄️</td></tr><tr><td><code>qA</code></td><td>追加宏，在寄存器a🀄️追加</td></tr><tr><td><code>n@a</code></td><td>执行n遍a寄存器中的操作</td></tr><tr><td><code>@@</code></td><td>再执行一遍上一次操作</td></tr><tr><td><code>:n,mnormal @a</code></td><td>n到m行执行寄存器a宏操作</td></tr><tr><td><code>:let @a= &#39;</code></td><td>编辑宏a寄存器</td></tr></tbody></table><p>宏最佳操作</p><ul><li>规范光标位置：0</li><li>执行编辑和操作</li><li>移动光标到容易回放的位置：j</li></ul><p><code>Ctrl+a</code>：当前数字递增1</p><p>示例步骤：</p><ol><li><p>循环递增插入数字</p><pre><code class="shell"># 添加数字1i1Esc# 开始录制宏,此时光标在数字1行qa # 开始yy # 复制p # 粘贴q # 结束# 执行宏操作10@a</code></pre><pre><code></code></pre></li><li><p>为多行添加注释</p><pre><code class="shell"># 开始录制宏,此时光标在需注释行首qb # 开始i # 进入编辑模式`# ` # 添加注释Esc # 退出编辑模式^ # 移动到行首j # 光标下行移动q # 结束</code></pre></li></ol><p>宏保存</p><ul><li><code>viminfo</code>/<code>vimrc file</code></li><li>保存历史和非空寄存器</li><li>vim启动时读取</li><li>容易被覆盖</li></ul><h3 id="4-4-Visual-模式-15-51"><a href="#4-4-Visual-模式-15-51" class="headerlink" title="4-4 Visual 模式 (15:51)"></a>4-4 Visual 模式 (15:51)</h3><blockquote><p>在可视化模式下，可以对一个文本块的整体进行操作</p></blockquote><p>三种子模式</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>v</code></td><td>激活面向字符的可视化模式</td></tr><tr><td><code>V</code>/<code>shift+v</code></td><td>激活面向行的可视化模式</td></tr><tr><td><code>command+v</code></td><td>激活面向列块的可视化模式</td></tr></tbody></table><p>字符可视化模式=&gt;行可视化模式=&gt;块可视化模式</p><p>可视化模式操作</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>gv</td><td>重选上次的高亮选区</td></tr><tr><td>o</td><td>切换选取边界</td></tr></tbody></table><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="5-1-课程总结-03-18"><a href="#5-1-课程总结-03-18" class="headerlink" title="5-1 课程总结 (03:18)"></a>5-1 课程总结 (03:18)</h3><ol><li><p>Vim模式（四种）</p><p>普通模式、编辑模式、可视化模式、命令行模式</p></li><li><p>Vim组合 {operation}{motion}</p><p>增查删改</p></li><li><p>Vim配置多样性</p><p>配置文件.vimrc、Vim插件</p></li><li><p>Vim视图多样性</p><p>缓冲区、多文件编辑、多窗口、标签分组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1052-Git入门</title>
      <link href="/2019/11/01/1052-Git/"/>
      <url>/2019/11/01/1052-Git/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1052" target="_blank" rel="noopener">https://www.imooc.com/learn/1052</a></p><p>简介：本课程主要通过命令行和图形界面工具来介绍Git的安装、仓库创建、工作流、远程仓库、克隆仓库、标签管理和分支管理等Git的主要内容。</p></blockquote><p>@[TOC]</p><h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h2><blockquote><p>主要介绍Git的作用以及安装过程。</p></blockquote><h3 id="1-1-为什么学习git"><a href="#1-1-为什么学习git" class="headerlink" title="1-1 为什么学习git"></a>1-1 为什么学习git</h3><blockquote><p>作者：Linus Torvalds，同时也是Linux的作者。</p><p>版本控制：记录所有文件的所有版本，可以有效地追踪文件的变化。同时很容易回到之前的状态</p></blockquote><p>为什么学习Git：</p><ul><li>牛通的互联网、牛逼的大神们都在用</li><li>完整的版本控制功能，解决多人协作的问题</li><li>提高开发效率</li><li>如果你是程序猿,请务必学Git，井习惯把日己的代码同步到GitHub上</li></ul><p>注：Git不等于 GitHub大家注意了! Git和GitHub就是球和球场的关系!</p><p>课程安排：</p><blockquote><p>Git介绍<br>Git安装（命令行、图形化界面）<br>Git工作流<br>本地与远程仓库<br>分支管理<br>标签管理</p></blockquote><h3 id="1-2-Git安装"><a href="#1-2-Git安装" class="headerlink" title="1-2 Git安装"></a>1-2 Git安装</h3><p>命令行：</p><ul><li><p>下载Window Git</p></li><li><p>Msysgit <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p></li><li><p>配置用户信息</p><pre><code class="shell"># git bashgit config --global user.name &quot;tyk&quot;git config --global user.email &quot;tyk@163.com&quot;</code></pre></li><li><p>查看用户名邮箱是否配置成功</p><pre><code class="shell">git config --list</code></pre></li></ul><p>图形化界面：</p><ul><li>下载安装SourceTree <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">https://www.sourcetreeapp.com/</a></li><li>注册登录</li></ul><h2 id="第2章-Git仓库创建及工作量"><a href="#第2章-Git仓库创建及工作量" class="headerlink" title="第2章 Git仓库创建及工作量"></a>第2章 Git仓库创建及工作量</h2><blockquote><p>主要介绍Git如何创建仓库以及工作流的内容。</p></blockquote><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2-1 创建仓库"></a>2-1 创建仓库</h3><ul><li><p>初始化版本库</p><pre><code class="shell">git init</code></pre></li><li><p>添加文件到版本库</p><pre><code class="shell">git addgit commit</code></pre></li><li><p>查看仓库状态</p><pre><code class="shell">git status</code></pre></li></ul><p>创建Git仓库：</p><pre><code class="shell">mkdir democd demogit init # 初始化版本库ls -a # 查看所有文件（包含隐藏文件）echo &quot;git repo&quot; &gt;&gt; test.txt # 创建文件并追加输入内容git add test.txt # 添加文件到版本库git commit -m &quot;repo first commit&quot; # 提交文件到本地仓库git status # 查看仓库状态git push -f origin master # 将本地仓库内容同步到远程仓库</code></pre><h3 id="2-2-工作流"><a href="#2-2-工作流" class="headerlink" title="2-2 工作流"></a>2-2 工作流</h3><pre><code class="shell">git add &lt;file&gt;   # 将文件从本地工作区上传到暂存区git commit -m &quot;说明操作内容&quot;  # 将暂存区的文件上传到本地仓库git reset HEAD &lt;file&gt; # 将本地仓库的内容返回到暂存区git checkout -- 文件名 # 清除工作区git log # 查询提交记录的commit号git reset --hard &lt;commit_id&gt; # 将本地仓库和暂存区的内容全部回滚到commit号提交时的内容git rm &lt;file&gt; # 清空文件git rm --cached # 清除工作区里暂存区没有的文件git checkout HEAD &lt;file&gt; # 用最终仓库的文件替换掉暂存区和工作区的</code></pre><p>Git工作流：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigfvzdzj30pk0bzta6.jpg" width="600" alt="Git工作流"/><h2 id="第3章-Git主要功能"><a href="#第3章-Git主要功能" class="headerlink" title="第3章 Git主要功能"></a>第3章 Git主要功能</h2><blockquote><p>主要介绍Git远程仓库、克隆仓库、标签管理和分支管理的主要内容。</p></blockquote><h3 id="3-1-远程仓库"><a href="#3-1-远程仓库" class="headerlink" title="3-1 远程仓库"></a>3-1 远程仓库</h3><p>创建SSH Key</p><pre><code class="shell">ssh-keygen -t rsa -C &quot;github_registry_mail@github.com&quot;cd .ssh/cat id_rsa.pub</code></pre><p>GitHub设置：</p><p>​    [GitHub首页]-[个人头像]-[Settings]-[SSH and GPG keys]-[New SSH key]</p><p>查看本地是否与Github关联</p><pre><code class="shell">ssh -T git@github.com</code></pre><p>添加远程仓库</p><pre><code class="shell">git remote add origin git@github.com:tuyrk/demo.gitgit pull origin master --allow-unrelated-historiesgit push -u origin master</code></pre><p>在GitHub创建新仓库：</p><p>​    [GitHub首页]-[加号]-[New repository]-[Create repository]</p><p>将本地仓库提交到远程</p><pre><code class="shell">echo &quot;# demo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:tuyrk/demo.gitgit push -u origin master</code></pre><p>将远程仓库克隆到本地</p><pre><code class="shell">git remote add origin git@github.com:tuyrk/demo.gitgit push -u origin master</code></pre><h3 id="3-2-克隆仓库"><a href="#3-2-克隆仓库" class="headerlink" title="3-2 克隆仓库"></a>3-2 克隆仓库</h3><pre><code class="shell">git clone git@github.com:tuyrk/demo.git # 路径为GitHub中SSH路径</code></pre><p>流程：</p><ol><li>将远程仓库GitHub中的代码克隆一份到本地</li><li>在本地进行开发</li><li>开发完之后将代码推送到远程仓库</li></ol><h3 id="3-3-标签管理"><a href="#3-3-标签管理" class="headerlink" title="3-3 标签管理"></a>3-3 标签管理</h3><pre><code class="shell">git tag # 查看所有标签git tag &lt;name&gt; # 创建标签git tag -a &lt;name&gt; -m &quot;comment&quot; # 指定提交信息git tag -d &lt;name&gt; # 删除标签git push origin &lt;name&gt; # 标签发布git checkout &lt;name&gt; # 切换标签-快照git checkout -b &lt;分支名称&gt; &lt;tag标签名称&gt; # 切换标签-编辑</code></pre><h3 id="3-4-分支管理"><a href="#3-4-分支管理" class="headerlink" title="3-4 分支管理"></a>3-4 分支管理</h3><pre><code class="shell">git branch # 查看所有分支，“*”代表当前所在分支git branch &lt;分支名称&gt; # 创建分支git checkout &lt;分支名称&gt; # 切换分支git merge &lt;分支名称&gt; # 合并到master分支。首先需切换到master分支，然后进行合并git branch -d &lt;分支名称&gt; # 删除分支</code></pre><h2 id="第4章-课程总结"><a href="#第4章-课程总结" class="headerlink" title="第4章 课程总结"></a>第4章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="4-1-课程总结"><a href="#4-1-课程总结" class="headerlink" title="4-1 课程总结"></a>4-1 课程总结</h3><ul><li><p>介绍与安装</p></li><li><p>工作流</p><p>[工作区]=&gt;[暂存区]=&gt;[版本库]</p></li><li><p>初始化</p><pre><code class="shell">git initgit addgit commit</code></pre></li><li><p>远程仓库</p><pre><code class="shell">git remote addgit pullgit pushgit clone</code></pre></li><li><p>分支管理</p><pre><code class="shell">git branchgit checkoutgit merge</code></pre></li><li><p>标签管理</p><pre><code class="shell">git taggit push</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>390-版本控制入门 – 搬进 Github</title>
      <link href="/2019/11/01/390-Github/"/>
      <url>/2019/11/01/390-Github/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/390" target="_blank" rel="noopener">https://www.imooc.com/learn/390</a></p><p>简介：版本控制能够大大提高程序员的工作效率，但是通常会涉及到命令行操作，学习曲线陡峭。本课程中使用 Github 网站和图形化客户端来完成版本控制工作，提供一套简单实用的流程，配合图解方式的原理讲解，让大家以最短的时间上手 Git 和 Github 。</p></blockquote><p><a href="https://gitbeijing.com/" target="_blank" rel="noopener">https://gitbeijing.com/</a></p><p>@[TOC]</p><h2 id="第1章-Github课程介绍"><a href="#第1章-Github课程介绍" class="headerlink" title="第1章 Github课程介绍"></a>第1章 Github课程介绍</h2><blockquote><p>阐述本课程的覆盖内容，适合观众。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>Git和Linux之父，Linus</p><blockquote><p>我是个自负的混蛋，所有我的项目都以我自己的名字命名，先有Linux，现在是Git.<br>–Linus</p></blockquote><p>Global Information Tracker：全局信息跟踪器</p><p>Git：版本控制工具</p><p><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><h2 id="第2章-浏览器中使用-Github"><a href="#第2章-浏览器中使用-Github" class="headerlink" title="第2章 浏览器中使用 Github"></a>第2章 浏览器中使用 Github</h2><blockquote><p>不会用 Git，其实也可以直接使用 Github 来进行基本的版本控制操作的。</p></blockquote><h3 id="2-1-浏览器中使用Github"><a href="#2-1-浏览器中使用Github" class="headerlink" title="2-1 浏览器中使用Github"></a>2-1 浏览器中使用Github</h3><h2 id="第3章-Github-客户端的使用"><a href="#第3章-Github-客户端的使用" class="headerlink" title="第3章 Github 客户端的使用"></a>第3章 Github 客户端的使用</h2><blockquote><p>以 Mac 系统的客户端 Github For Mac 为例子来讲解，不过 Windows 系统上也有类似的客户端。</p></blockquote><h3 id="3-1-Github客户端的使用"><a href="#3-1-Github客户端的使用" class="headerlink" title="3-1 Github客户端的使用"></a>3-1 Github客户端的使用</h3><h2 id="第4章-简单分支操作"><a href="#第4章-简单分支操作" class="headerlink" title="第4章 简单分支操作"></a>第4章 简单分支操作</h2><blockquote><p>分支操作几乎是所有的 Git 高级操作的基础，本章来学会使用分支。</p></blockquote><h3 id="4-1-Github-简单分支操作"><a href="#4-1-Github-简单分支操作" class="headerlink" title="4-1 Github-简单分支操作"></a>4-1 Github-简单分支操作</h3><h2 id="第5章-分支合并"><a href="#第5章-分支合并" class="headerlink" title="第5章 分支合并"></a>第5章 分支合并</h2><blockquote><p>分支合并过程其实就是代码融合过程，会涉及到处理代码冲突的问题。</p></blockquote><h3 id="5-1-Github-合并分支（上）"><a href="#5-1-Github-合并分支（上）" class="headerlink" title="5-1 Github-合并分支（上）"></a>5-1 Github-合并分支（上）</h3><h3 id="5-2-Github-合并分支（下）"><a href="#5-2-Github-合并分支（下）" class="headerlink" title="5-2 Github-合并分支（下）"></a>5-2 Github-合并分支（下）</h3><h2 id="第6章-团队协作流程"><a href="#第6章-团队协作流程" class="headerlink" title="第6章 团队协作流程"></a>第6章 团队协作流程</h2><blockquote><p>Github 公司内部使用的工作流程 Github Flow，是 Git 多种协作流程中，最简单也是最流行的一套思路。本章来看看在团队内部如何应用这套流程。</p></blockquote><h3 id="6-1-Github-团队协作流程（上）"><a href="#6-1-Github-团队协作流程（上）" class="headerlink" title="6-1 Github-团队协作流程（上）"></a>6-1 Github-团队协作流程（上）</h3><h3 id="6-2-Github-团队协作流程（下）"><a href="#6-2-Github-团队协作流程（下）" class="headerlink" title="6-2 Github-团队协作流程（下）"></a>6-2 Github-团队协作流程（下）</h3><h2 id="第7章-开源项目贡献流程"><a href="#第7章-开源项目贡献流程" class="headerlink" title="第7章 开源项目贡献流程"></a>第7章 开源项目贡献流程</h2><blockquote><p>开源项目由于贡献者互相不认识，所以流程上必然是区别于团队流程的，但是本质上依然是基于 Pull Request 的 Github Flow。</p></blockquote><h3 id="7-1-开源项目贡献流程"><a href="#7-1-开源项目贡献流程" class="headerlink" title="7-1 开源项目贡献流程"></a>7-1 开源项目贡献流程</h3><h2 id="第8章-Github-Issues"><a href="#第8章-Github-Issues" class="headerlink" title="第8章 Github Issues"></a>第8章 Github Issues</h2><blockquote><p>Issues 相当于项目论坛，集中讨论项目新功能，bug 修复以及任何项目相关的事情。会涉及到 Markdown 使用和多种技巧。</p></blockquote><h3 id="8-1-Github-Issues"><a href="#8-1-Github-Issues" class="headerlink" title="8-1 Github Issues"></a>8-1 Github Issues</h3><h2 id="第9章-Github-Pages-搭建网站"><a href="#第9章-Github-Pages-搭建网站" class="headerlink" title="第9章 Github Pages 搭建网站"></a>第9章 Github Pages 搭建网站</h2><blockquote><p>Github 提供了自己搭建项目网站的一套框架，非常的简单实用。</p></blockquote><h3 id="9-1-Github-Pages-搭建网站"><a href="#9-1-Github-Pages-搭建网站" class="headerlink" title="9-1 Github Pages 搭建网站"></a>9-1 Github Pages 搭建网站</h3><p><a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></p><h2 id="第10章-Github-的秘密机关"><a href="#第10章-Github-的秘密机关" class="headerlink" title="第10章 Github 的秘密机关"></a>第10章 Github 的秘密机关</h2><blockquote><p>为了保证界面的简约美观，Github 的很多功能其实是隐藏的，例如一些非常能够提高工作效率的快捷键。</p></blockquote><h3 id="10-1-Github的秘密机关"><a href="#10-1-Github的秘密机关" class="headerlink" title="10-1 Github的秘密机关"></a>10-1 Github的秘密机关</h3><p>GitHub官网中搜索文件快捷键：T</p><p>GitHub社交化编程</p><p>怎么筛选学习内容？：可以追星</p><h2 id="第11章-Until-Next-Time-Goodbye"><a href="#第11章-Until-Next-Time-Goodbye" class="headerlink" title="第11章 Until Next Time, Goodbye!"></a>第11章 Until Next Time, Goodbye!</h2><blockquote><p>总结和下一步的学习建议。</p></blockquote><h3 id="11-1-Until-Next-Time-Goodbye-01-10"><a href="#11-1-Until-Next-Time-Goodbye-01-10" class="headerlink" title="11-1 Until Next Time, Goodbye! (01:10)"></a>11-1 Until Next Time, Goodbye! (01:10)</h3>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208-版本管理工具介绍—Git篇</title>
      <link href="/2019/11/01/208-Git/"/>
      <url>/2019/11/01/208-Git/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/208" target="_blank" rel="noopener">https://www.imooc.com/learn/208</a></p><p>简介：本课程主要讲解了git在各平台的安装和基本使用，Git能够帮助我们解决文件的提交、检出、回溯历史、冲突解决、多人协作模式等问题，并且大大提升我们的工作效率。</p></blockquote><p>@[TOC]</p><h2 id="第1章-版本管理工具初探"><a href="#第1章-版本管理工具初探" class="headerlink" title="第1章 版本管理工具初探"></a>第1章 版本管理工具初探</h2><blockquote><p>聊聊版本管理工具是什么，它能为我们做什么。</p></blockquote><h3 id="1-1-版本管理工具简介"><a href="#1-1-版本管理工具简介" class="headerlink" title="1-1 版本管理工具简介"></a>1-1 版本管理工具简介</h3><p>版本管理工具是干什么用的？</p><ul><li>备份文件（类似U盘，网盘）</li><li>记录历史（有各个阶段的代码历史版本）</li><li>回到过去（恢复历史版本）</li><li>多端协作（可以在家工作，也可以在公司）</li><li>团队协作（代码整合，多人共同完成一个项目）</li></ul><h2 id="第2章-工具的历史"><a href="#第2章-工具的历史" class="headerlink" title="第2章 工具的历史"></a>第2章 工具的历史</h2><blockquote><p>聊聊cvs、svn、git、github这些工具的发展历史。</p></blockquote><h3 id="2-1-版本管理工具发展历史"><a href="#2-1-版本管理工具发展历史" class="headerlink" title="2-1 版本管理工具发展历史"></a>2-1 版本管理工具发展历史</h3><ol><li><p>CVS 1985，集中式，始祖（网络环境）</p><p>最早期的版本控制软件，是把文件集中保存到中心服务器</p></li><li><p>SVN 2000，集中式，集大成者（网络环境）</p><p>在CVS的基础上的加强版，可以还原到某个时间点</p></li><li><p>Git 2005，分布式，geek主流（无网环境）</p><p>分布式的版本控制软件</p></li><li><p>GitHub 2008，托管网站，geek社区（程序员托管网站）</p><p>网站托管，基于Git</p></li></ol><p>集中式：服务器。需要联网</p><p>分布式：效率高。拥有版本库即可（Git）</p><h2 id="第3章-如何做个英雄"><a href="#第3章-如何做个英雄" class="headerlink" title="第3章 如何做个英雄"></a>第3章 如何做个英雄</h2><blockquote><p>演示git和github的基本使用，提升工作效率，让我们在独立工作中成为英雄</p></blockquote><h3 id="3-1-Git下载和安装"><a href="#3-1-Git下载和安装" class="headerlink" title="3-1 Git下载和安装"></a>3-1 Git下载和安装</h3><p>安装Git环境一Windows：</p><ul><li>下载Github for Windows：<a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a></li></ul><h3 id="3-2-linux下安装Git环境"><a href="#3-2-linux下安装Git环境" class="headerlink" title="3-2 linux下安装Git环境"></a>3-2 linux下安装Git环境</h3><p>安装Git环境一Linux：</p><pre><code class="shell">yum install gitgit --help</code></pre><h3 id="3-3-github注册"><a href="#3-3-github注册" class="headerlink" title="3-3 github注册"></a>3-3 github注册</h3><p><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><h3 id="3-4-创建一个新的项目"><a href="#3-4-创建一个新的项目" class="headerlink" title="3-4 创建一个新的项目"></a>3-4 创建一个新的项目</h3><p><a href="https://github.com/new" target="_blank" rel="noopener">https://github.com/new</a></p><h3 id="3-5-Linux环境下检出项目到本地"><a href="#3-5-Linux环境下检出项目到本地" class="headerlink" title="3-5 Linux环境下检出项目到本地"></a>3-5 Linux环境下检出项目到本地</h3><pre><code class="shell">git clone https://github.com/tuyrk/demo.git</code></pre><h3 id="3-6-Linux环境下第一次提交项目"><a href="#3-6-Linux环境下第一次提交项目" class="headerlink" title="3-6 Linux环境下第一次提交项目"></a>3-6 Linux环境下第一次提交项目</h3><pre><code class="shell">vi log.txtgit add log.txtgit commit -m &quot;comment&quot;git pushgit config</code></pre><p>忽略修改：</p><ol><li>gitignore添加需要忽略的文件</li></ol><h3 id="3-7-windows下检出项目和提交项目"><a href="#3-7-windows下检出项目和提交项目" class="headerlink" title="3-7 windows下检出项目和提交项目"></a>3-7 windows下检出项目和提交项目</h3><h2 id="第4章-和其他英雄一起工作"><a href="#第4章-和其他英雄一起工作" class="headerlink" title="第4章 和其他英雄一起工作"></a>第4章 和其他英雄一起工作</h2><blockquote><p>演示如何通过git和github，让我们和其他英雄一起工作，减少和解决合作中出现的冲突</p></blockquote><h3 id="4-1-关于代码冲突"><a href="#4-1-关于代码冲突" class="headerlink" title="4-1 关于代码冲突"></a>4-1 关于代码冲突</h3><h3 id="4-2-Linux下如何解决冲突"><a href="#4-2-Linux下如何解决冲突" class="headerlink" title="4-2 Linux下如何解决冲突"></a>4-2 Linux下如何解决冲突</h3><p>解决冲突步骤：</p><ol><li>git pull拉取最新代码</li><li>git diff查看</li><li>手动修改提交哪次冲突</li><li>再次提交</li></ol><pre><code class="shell">git pullgit diffgit add log.txtgit commit -m &quot;解决冲突后提交&quot;git push origin master</code></pre><h3 id="4-3-windows下如何解决冲突"><a href="#4-3-windows下如何解决冲突" class="headerlink" title="4-3 windows下如何解决冲突"></a>4-3 windows下如何解决冲突</h3><h3 id="4-4-如何回到过去"><a href="#4-4-如何回到过去" class="headerlink" title="4-4 如何回到过去"></a>4-4 如何回到过去</h3><p>版本回滚操作步骤：</p><pre><code class="shell">git log # 显示所有提交记录.git reset --hard &lt;提交ID&gt; # 完成回滚操作git pushgit log # 显示新的提交记录</code></pre><p>版本跳转操作步骤：</p><pre><code class="shell">git reflog # 查看该用户的所有操作git reset --hard &lt;提交ID&gt; # 完成跳转到现在</code></pre><h3 id="4-5-建立里程碑"><a href="#4-5-建立里程碑" class="headerlink" title="4-5 建立里程碑"></a>4-5 建立里程碑</h3><p>里程碑，即版本号。标签</p><pre><code class="shell">git tag -a &lt;name&gt; -m &quot;comment&quot; # 创建标签git push origin &lt;name&gt;git checkout &lt;name&gt; # 切换标签git checkout -b &lt;分支名称&gt; &lt;name&gt; # 切换标签git tag -d &lt;name&gt; # 删除标签</code></pre><h3 id="4-6-分支开发之分支合并"><a href="#4-6-分支开发之分支合并" class="headerlink" title="4-6 分支开发之分支合并"></a>4-6 分支开发之分支合并</h3><pre><code class="shell">git branch &lt;分支名称&gt; # 创建分支git checkout &lt;分支名称&gt; # 切换分支git merge &lt;分支名称&gt; # 合并到master分支。首先需切换到master分支，然后进行合并git branch -d &lt;分支名称&gt; # 删除分支</code></pre><h3 id="4-7-分支开发之合并到master"><a href="#4-7-分支开发之合并到master" class="headerlink" title="4-7 分支开发之合并到master"></a>4-7 分支开发之合并到master</h3><p>通过Github网页合并分支</p><h3 id="4-8-关于多人合作的一些经验"><a href="#4-8-关于多人合作的一些经验" class="headerlink" title="4-8 关于多人合作的一些经验"></a>4-8 关于多人合作的一些经验</h3><p><strong>利用工具提升工作效率，而不是去学习工具本身</strong></p><ol><li>多用客户端和工具，少用命令行，除非在linux服务器上直接开发</li><li>每次提交前，diff自己的代码，以免提交错误的代码</li><li>下班回家前，整理好自己的工作区</li><li>并行的项目，使用分支开发</li><li>遇到冲突时，搞明白冲突的原因，千万不要随意丢弃别人的代码</li><li>产品发布后，记得打tag，方便将来拉分支修bug</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo重新发布后GitPages自定义域名失效</title>
      <link href="/2019/10/29/hexo-gitpages-invalid/"/>
      <url>/2019/10/29/hexo-gitpages-invalid/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 <code>Github Pages</code> 功能将博客托管在了 Github 上，并配置 <code>CNAME</code> 将自己的域名解析了过去，在 <code>Github</code> 的仓库设置中开始 <code>Custom domain</code> 的功能，这时候就可以直接使用自己的域名访问啦。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8felp76szj311g0u00u4.jpg" alt="GitHub Pages" style="zoom:40%;" /><p>但是发现一个问题是，每次配置 <code>Custom domain</code> 之后，再次 <code>hexo deploy</code> 之后，<code>Custom domain</code> 会被重置失效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 <code>hexo</code> 生成的博客的 <code>source</code> 目录下新建一个 <code>CNAME</code> 文件，然后在这个文件中填入你的域名，最后重新部署hexo。这样就不会每次发布之后，<code>Github pages</code> 里的 <code>Custom domain</code> 都被重置掉啦。</p><pre><code class="shell">vim ource/CNAME</code></pre><pre><code class="shell">www.tuyrk.cn</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 同时管理Github和Gitee</title>
      <link href="/2019/10/29/git-manage-github-gitee/"/>
      <url>/2019/10/29/git-manage-github-gitee/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="1-取消git全局配置"><a href="#1-取消git全局配置" class="headerlink" title="1.取消git全局配置"></a>1.取消git全局配置</h2><blockquote><p>取消全局的user.name和user.email</p></blockquote><pre><code class="shell">git config --global --unset user.name &quot;xxx&quot;git config --global --unset user.email &quot;xxx&quot;</code></pre><p>其中<code>xxx</code>是以前配置的信息，可以通过 下边命令查看</p><pre><code class="shell">git confg --global --list</code></pre><h2 id="2-生成new的ssh-keys"><a href="#2-生成new的ssh-keys" class="headerlink" title="2.生成new的ssh keys"></a>2.生成new的ssh keys</h2><blockquote><p>如果需要github和gitee都能存在，那么就需要生成github和gitee的id_rsa， 然后放在一起</p></blockquote><ol><li><p>生成Github 和 Gitee的keys</p><pre><code class="shell">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;xxx&quot;</code></pre><p>注：其中<code>xxx</code>是github平台的注册邮箱</p><pre><code class="shell">ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C &quot;...&quot;</code></pre><p>注：其中<code>...</code>是你gitee平台的注邮箱</p></li><li><p>将生成的新keys添加到ssh agent</p><pre><code class="shell">ssh-agent bash</code></pre><pre><code class="shell">ssh-add ~/.ssh/id_rsa.githubssh-add ~/.ssh/id_rsa.giteeexit</code></pre></li><li><p>配置config文件</p><blockquote><p>在.ssh文件夹下面配置config文件</p></blockquote><pre><code class="shell">vim ~/.ssh/config</code></pre><pre><code class="shell"># githubHost github.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.githubPort 443# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.gitee</code></pre></li></ol><h2 id="3-平台设置SSH"><a href="#3-平台设置SSH" class="headerlink" title="3.平台设置SSH"></a>3.平台设置SSH</h2><blockquote><p>钥匙和配置文件搞定后，就需要将我们的公钥放入到我们的平台中了</p></blockquote><ol><li><p>Github：复制<code>~/.ssh/id_rsa.github.pub</code>的内容到Github公钥</p><p>Settings &gt; SSH and GPG keys &gt; New SSH key</p></li><li><p>Gitee：复制<code>~/.ssh/id_rsa.gitee.pub</code>的内容到Gitee公钥</p><p>设置 &gt; 安全设置 &gt; SSH公钥</p></li></ol><h2 id="4-测试是否成功"><a href="#4-测试是否成功" class="headerlink" title="4.测试是否成功"></a>4.测试是否成功</h2><ol><li><p>Github</p><pre><code class="shell">ssh -T git@github.com</code></pre><p>结果：</p><pre><code>Hi 766564616! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></li><li><p>Gitee</p><pre><code class="shell">ssh -T git@gitee.com</code></pre><p>结果：</p><pre><code>Hi 神秘的小岛岛! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-hexo快捷键说明</title>
      <link href="/2019/10/29/3-hexo-shortcuts/"/>
      <url>/2019/10/29/3-hexo-shortcuts/</url>
      
        <content type="html"><![CDATA[<p>快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可</p><p>如果有比较好的建议，欢迎骚扰。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><table><thead><tr><th align="left">Key</th><th align="left">Descption</th></tr></thead><tbody><tr><td align="left">ESC</td><td align="left">1.如果输入框有内容，清除内容 2.如果输入框无内容，失去焦点</td></tr><tr><td align="left">i/I</td><td align="left">获取焦点</td></tr><tr><td align="left">下</td><td align="left">向下选择文章</td></tr><tr><td align="left">上</td><td align="left">向上选择文章</td></tr><tr><td align="left">回车</td><td align="left">打开当前选中的文章，若没有，则默认打开第一个</td></tr></tbody></table><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><table><thead><tr><th align="left">Key</th><th align="left">Descption</th></tr></thead><tbody><tr><td align="left">s/S</td><td align="left">全屏/取消全屏</td></tr><tr><td align="left">w/W</td><td align="left">打开/关闭文章目录</td></tr><tr><td align="left">j/J</td><td align="left">向下滑动</td></tr><tr><td align="left">k/K</td><td align="left">向上滑动</td></tr><tr><td align="left">gg/GG</td><td align="left">到最顶端</td></tr><tr><td align="left">shift+G/g</td><td align="left">到最下端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS配置OpenVPN之Tunnelblick</title>
      <link href="/2019/10/10/MacOS-OpenVPN/"/>
      <url>/2019/10/10/MacOS-OpenVPN/</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接公司内网需要使用到OpenVPN，之前在Windows系统直接使用公司提供的<a href="https://openvpn.net/community-downloads/" target="_blank" rel="noopener">OpenVPN客户端</a>，但是似乎没有Mac版，所以使用了<a href="https://tunnelblick.net/index.html" target="_blank" rel="noopener">Tunnelblick工具</a>，下边记录一下在使用中遇到的一些问题。</p></blockquote><ol><li><p>下载⏬<a href="https://tunnelblick.net/index.html" target="_blank" rel="noopener">Tunnelblick工具</a>，安装</p></li><li><p>准备<code>*.ovpn</code>、<code>*.key</code>、<code>*.crt</code>在同一目录下</p><ul><li><p>问题一：<code>“comp-lzo” 在openvpn 2.4 中已弃用,将会在未来的版本中移除。</code></p><p>解决：<a href="https://github.com/Nyr/openvpn-install/issues/430" target="_blank" rel="noopener">https://github.com/Nyr/openvpn-install/issues/430</a></p><p>在<code>*.ovpn</code>使用<code>compress lzo</code>代替<code>comp-lzo</code> </p></li><li><p>问题二：<code>• &#39;ns-cert-type&#39; 这个选项在 OpenVPN 2.4 版本的配置中是过时的，已经在 OpenVPN 2.5 版本中移除。</code></p><p>解决：在<code>*.ovpn</code>使用<code>remote-cert-tls server</code>代替<code>ns-cert-type server</code></p></li><li><p>问题三：<code>unrecognized option or missing or extra parameter(s) ip-win32 (2.4.7)</code></p><p>解决：由于脚本是公司为Windows系统提供的，所以我在这里直接注释这个。</p><pre><code class="shell"># ip-win32 dynamic -1# route-method exe</code></pre></li></ul></li><li><p>点击<code>*.ovpn</code>、连接</p></li></ol><p><strong>==OpenVPN中不推荐使用的选项==</strong>：<a href="https://community.openvpn.net/openvpn/wiki/DeprecatedOptions" target="_blank" rel="noopener">https://community.openvpn.net/openvpn/wiki/DeprecatedOptions</a></p><p>OpenVPN客户端配置文件详解：<a href="https://blog.faystar.com/openvpn_client/" target="_blank" rel="noopener">https://blog.faystar.com/openvpn_client/</a></p><pre><code class="shell"># 定义是一个客户端client# 定义使用设备类型，与服务端一致;dev tapdev tun# 定义Windows下使用的网卡名称,linux不需要;dev-node 我的连接# 定义使用的协议，与服务端一致;proto tcpproto udp# 指定服务端地址和端口,可以用多行指定多台服务器# 实现负载均衡（从上往下尝试）remote 118.112.188.108 1194;remote my-server-2 1194# 若上面配置了多台服务器，让客户端随机连接;remote-random# 解析服务器域名# Keep trying indefinitely to resolve the# host name of the OpenVPN server.  Very useful# on machines which are not permanently connected# to the internet such as laptops.resolv-retry infinite# 客户端不需要绑定端口# Most clients do not need to bind to# a specific local port number.nobind# 也是为了让Openvpn也nobody运行（安全）# 注意：Windows不能设置;user nobody;group nobody# Try to preserve some state across restarts.persist-keypersist-tun# 若客户端通过HTTP Proxy，在这里设置# 要使用Proxy，不能使用UDP为VPN的通讯协议;http-proxy-retry # retry on connection failures;http-proxy [proxy server] [proxy port #]# 无线网络有很多多余的头文件，设置忽略它;mute-replay-warnings# 重点，就是指定ca和客户端的证书# 注意，下面的两个号是连在一起的，之间没有空格.需同时存在/注释ca &quot;ca.crt&quot;# cert &quot;test-1.crt&quot;# key &quot;test-1.key&quot;# 如果服务端打开了PAM认证模块，如mysql，LDAP数据库验证，客户端需要另其有效;auth-user-pass# 一些安全措施# Verify server certificate by checking# that the certicate has the nsCertType# field set to “server”.  This is an# important precaution to protect against# a potential attack discussed here:# http://openvpn.net/howto.html#mitm## To use this feature, you will need to generate# your server certificates with the nsCertType# field set to “server”.  The build-key-server# script in the easy-rsa folder will do this.remote-cert-tls server# 增强验证加密，如果你在服务器端生成了ta.key，那么这里就需要加上# then every client must also have the key.tls-auth ta.key 1# Select a cryptographic cipher.# If the cipher option is used on the server# then you must also specify it here.;cipher x# 使用lzo压缩，与服务端一致compress lzo# Set log file verbosity.verb 3# Silence repeating messages;mute 20#采用用户名密码方式验证,若不用证书的话,可以考虑这种方式,可以结合LDAP或者mysql;auth-user-pass#windows7上会报错,建议加上此行# route-method exe#强行指定添加路由前的延时route-delay 2#不存储验证缓存auth-nocache#设置IP地址过期时间# ip-win32 dynamic 0 7200</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>714-性能测试之LoadRunner</title>
      <link href="/2019/09/29/714-LoadRunner/"/>
      <url>/2019/09/29/714-LoadRunner/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/714" target="_blank" rel="noopener">https://www.imooc.com/learn/714</a></p><p>简介：性能测试的实施不仅仅是掌握LoadRunner即可，还需要进行性能测试设计与性能测试构建实施等。本课程的目标就是帮助各位朋友提高实战能力，让性能测试落地，接地气，课程中会拿实际案例作为分析手段进行演练，增强动手操作技能。 项目实战进阶推荐课程！！！ 性能测试 LoadRunner 工具实战-慕课网实战 <a href="http://coding.imooc.com/class/127.html" target="_blank" rel="noopener">http://coding.imooc.com/class/127.html</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>通过详细的细分教学，让学生理解什么是性能测试，性能测试的流程，使用Loadrunner做性能测试的步骤</p></blockquote><h3 id="1-1-性能测试学习内容指南-03-52"><a href="#1-1-性能测试学习内容指南-03-52" class="headerlink" title="1-1 性能测试学习内容指南 (03:52)"></a>1-1 性能测试学习内容指南 (03:52)</h3><p>目录：</p><ul><li>第一章 性能测试理论</li><li>第二章 LoadRunner的基本操作</li><li>第三章 系统的监控、分析与调优</li></ul><p>第一章 性能测试理论</p><ul><li>性能测试的<strong>常用术语</strong></li><li>性能测试的<strong>应用领域</strong></li><li>性能测试常用<strong>工具的原理</strong></li></ul><p>第二章 LoadRunner的基本操作</p><ul><li><p>LoadRunner的原理分析</p></li><li><p>LoadRunner脚本的开发流程</p><p>LoadRunner的<strong>三个组件</strong>：</p><ul><li>VuGen：基本设置、检查点、参数化、关联、调试、事务</li><li>Controller：场景设置、场景执行、资源监控、集合点、IP欺骗、负载均衡</li><li>Analysis：摘要报告、常见图分析、结果分析实践</li></ul></li></ul><p>第三章 系统的监控、分析、调优</p><ul><li>Windows/Linux的监控、分析、调优</li><li>数据库的监控、分析、调优</li><li>中间件的监控、分析、调优</li></ul><h2 id="第2章-主要概念介绍"><a href="#第2章-主要概念介绍" class="headerlink" title="第2章 主要概念介绍"></a>第2章 主要概念介绍</h2><blockquote><p>介绍性能测试的衍生史以及特点等。</p></blockquote><h3 id="2-1-性能测试理论-09-17"><a href="#2-1-性能测试理论-09-17" class="headerlink" title="2-1 性能测试理论 (09:17)"></a>2-1 性能测试理论 (09:17)</h3><p>目录：</p><ul><li>性能测试的概念及其分类</li><li>性能测试的流程</li><li>性能测试工具的原理</li></ul><p>软件系统的性能包括：执行效率、资源占用、系统稳定性、安全性、兼容性、可靠性、可扩展性</p><p>性能测试的概念：</p><blockquote><p>性能测试主要通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p></blockquote><p>性能测试常见分类：</p><ul><li><p>性能测试（狭义）</p><p>方法：通过模拟业务生产运行的业务压力量和使用场景组合，测试系统的性能是否满足生产性能的要求</p><p>目的：验证系统是否具有系统宣称的能力</p></li><li><p>负载测试</p><p>方法：通过在被测系统上不断加压，直到性能指标达到极限</p><p>目的：找到系统处理能力的极限</p></li><li><p>压力测试（强度测试）</p><p>方法：测试系统在一定饱和状态下，系统能够处理的会话能力，以及系统是否会出现错误</p><p>目的：检查系统处于压力性能下时，应用的表现</p></li><li><p>并发测试</p><p>方法：通过模拟用户并发访问，测试多用户并发访问同一个应用、模块或者数据记录时是否存在死锁或其他性能问题</p><p>目的：发现系统中可能隐藏的并发访问时的问题</p></li><li><p>配置测试</p><p>方法：通过对被测系统的软硬件环境进行调整，了解不同软硬件环境对系统的性能的影响程度，从而找到系统各项资源的最优分配原则</p><p>目的：了解各种不同因素对系统性能的影响程度</p></li><li><p>可靠性测试（稳定性测试）</p><p>方法：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定</p><p>目的：验证系统是否支持长期稳定的运行</p></li></ul><p>系统测试的流程：</p><ol><li>测试计划阶段<ul><li>明确测试对象</li><li>定义测试目标</li><li>定义测试通过的标准</li><li>规划测试进度</li><li>规划测试参与人员（需求、开发、测试、运维和配置）</li><li>申请测试资源</li><li>风险控制</li></ul></li><li>测试设计阶段<ul><li>设计测试数据</li><li>设计测试用例</li><li>设计测试场景</li></ul></li><li>测试开发阶段<ul><li>测试环境搭建</li><li>测试过程文档定义以及配置</li><li>测试脚本开发、调试</li><li>测试数据准备</li><li>基准测试</li></ul></li><li>测试执行阶段<ul><li>执行测试模型，包括执行脚本和场景</li><li>测试过程监控，包括查看log、监控服务器资源、数据库和中间件等</li></ul></li><li>测试结果分析阶段<ul><li>根据测试结果和监控结果进行测试分析</li><li>根据性能测试目标，分析出系统存在的性能瓶颈，并给出优化建议</li></ul></li><li>测试报告阶段<ul><li>测试范围</li><li>测试执行以及参与人员</li><li>基准测试数据</li><li>测试执行的详细步骤（场景设计）</li><li>测试数据记录、监控结果</li><li>测试结果对比以及总结性评价</li></ul></li></ol><p>性能测试工具(LoadRunner、JMeter)组成：</p><blockquote><p>脚本生成器、压力生成器、压力控制器、结果分析器</p></blockquote><p>性能测试工具🔧的原理：</p><p>LoadRunner其实是一个代理，代理客户端和服务器之间的中间人。</p><p>LoadRunner通过代理截获客户端和服务器之间的交互数据流</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghjr9kftj31m40g4dip.jpg" alt="性能测试工具🔧的原理" style="zoom:30%;" /><h2 id="第3章-工具的安装和启动"><a href="#第3章-工具的安装和启动" class="headerlink" title="第3章 工具的安装和启动"></a>第3章 工具的安装和启动</h2><blockquote><p>Loadrunner的下载和安装注意事项；Web Tours服务的启动和功能介绍</p></blockquote><h3 id="3-1-Loadrunner的安装与介绍-07-04"><a href="#3-1-Loadrunner的安装与介绍-07-04" class="headerlink" title="3-1 Loadrunner的安装与介绍 (07:04)"></a>3-1 Loadrunner的安装与介绍 (07:04)</h3><p>安装LoadRunner(<strong>==Windows版==</strong>)：</p><ul><li>下载地址⏬：<a href="https://pan.baidu.com/s/1XzfbZ7r6OlV1T61IA-mGvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XzfbZ7r6OlV1T61IA-mGvQ</a> 密码:1sbr</li></ul><p>LoadRunner的组件：</p><ul><li>Virtual User Generator：录制最终用户业务流程并创建性能测试脚本</li><li>Controller：组织、驱动、管理并监控负载测试</li><li>Analysis：用于查看、剖析和比较性能结果</li></ul><p>LoadRunner的功能：</p><ul><li>轻松创建虚拟用户</li><li>创建真实的负载</li><li>分析结果以精确定位问题所在</li><li>重复测试保证系统发布的高性能</li></ul><h3 id="3-2-HP-Web-Tours使用-05-01"><a href="#3-2-HP-Web-Tours使用-05-01" class="headerlink" title="3-2 HP Web Tours使用 (05:01)"></a>3-2 HP Web Tours使用 (05:01)</h3><p>启动Web Tours服务</p><pre><code>/HP/LoadRunner/WebTours/StartServer.bat</code></pre><p>访问Web Tours</p><pre><code>http://127.0.0.1:1080/WebTours/</code></pre><p>帐号：jojo  密码：bean</p><p>Web Tours功能介绍：</p><blockquote><p>注册，登录，订票，查看历史订票记录，取消订票，退出</p></blockquote><h2 id="第4章-录制测试脚本"><a href="#第4章-录制测试脚本" class="headerlink" title="第4章 录制测试脚本"></a>第4章 录制测试脚本</h2><blockquote><p>介绍VUGen录制脚本的步骤，介绍Loadrunner的两种录制选项；录制登录、订票、查询和退出等操作流程；对录制的脚本进行参数化和关联等增强，使得脚本能回放成功；介绍参数化不同选项组合的用途</p></blockquote><h3 id="4-1-录制选项-07-39"><a href="#4-1-录制选项-07-39" class="headerlink" title="4-1 录制选项 (07:39)"></a>4-1 录制选项 (07:39)</h3><h3 id="4-2-录制脚本前概念-11-10"><a href="#4-2-录制脚本前概念-11-10" class="headerlink" title="4-2 录制脚本前概念 (11:10)"></a>4-2 录制脚本前概念 (11:10)</h3><h3 id="4-3-调试脚本-31-59"><a href="#4-3-调试脚本-31-59" class="headerlink" title="4-3 调试脚本 (31:59)"></a>4-3 调试脚本 (31:59)</h3><h2 id="第5章-创建测试场景"><a href="#第5章-创建测试场景" class="headerlink" title="第5章 创建测试场景"></a>第5章 创建测试场景</h2><blockquote><p>从脚本到创建场景，再到运行场景的流程做详细讲解</p></blockquote><h3 id="5-1-设置并执行场景-25-18"><a href="#5-1-设置并执行场景-25-18" class="headerlink" title="5-1 设置并执行场景 (25:18)"></a>5-1 设置并执行场景 (25:18)</h3><h2 id="第6章-分析测试结果"><a href="#第6章-分析测试结果" class="headerlink" title="第6章 分析测试结果"></a>第6章 分析测试结果</h2><blockquote><p>Loadrunner结果的分析和导出报告</p></blockquote><h3 id="6-1-测试结果分析-09-41"><a href="#6-1-测试结果分析-09-41" class="headerlink" title="6-1 测试结果分析 (09:41)"></a>6-1 测试结果分析 (09:41)</h3><h2 id="第7章-课程总结"><a href="#第7章-课程总结" class="headerlink" title="第7章 课程总结"></a>第7章 课程总结</h2><blockquote><p>通过本课程，我们学习和理解了使用Loadrunner做性能测试的步骤和方法。</p></blockquote><h3 id="7-1-性能测试框架基础课程总结-03-29"><a href="#7-1-性能测试框架基础课程总结-03-29" class="headerlink" title="7-1 性能测试框架基础课程总结 (03:29)"></a>7-1 性能测试框架基础课程总结 (03:29)</h3>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> LoadRunner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>735-JMeter性能测试入门篇</title>
      <link href="/2019/09/28/735-JMeter/"/>
      <url>/2019/09/28/735-JMeter/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/735" target="_blank" rel="noopener">https://www.imooc.com/learn/735</a></p><p>简介：本课程通过通俗易懂的讲法，非常容易理解的方式去讲解如何使用jmeter进行web应用的性能测试。</p></blockquote><p>@[TOC]</p><h2 id="第1章-jmeter基本介绍"><a href="#第1章-jmeter基本介绍" class="headerlink" title="第1章 jmeter基本介绍"></a>第1章 jmeter基本介绍</h2><blockquote><p>了解Jmeter及本课程的主要内容，知道如何下载到Jmeter；了解Jmeter的组成并了解性能测试工具的组成；了解jmeter的目录及为什么使用jmeter</p></blockquote><h3 id="1-1-Jmeter整体简介-20-20"><a href="#1-1-Jmeter整体简介-20-20" class="headerlink" title="1-1 Jmeter整体简介 (20:20)"></a>1-1 Jmeter整体简介 (20:20)</h3><p>软件架构：</p><ul><li><p>BS：browser-server</p></li><li><p>CS：client-server</p></li></ul><p>Jmeter简介：</p><ul><li><p>官网：<a href="https://jmeter.apache.org/" target="_blank" rel="noopener">https://jmeter.apache.org/</a></p></li><li><p>需要Java环境作为支撑。</p></li></ul><p>下载：<a href="http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-5.1.1.zip" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-5.1.1.zip</a></p><p>Jmeter组成：</p><ul><li><p>取样器</p><p>进行脚本逻辑控制（控制业务流程。什么样的请求，什么时候发出请求等）</p></li><li><p>线程组</p><p>场景设置（多少线程。多少用户访问，访问多少次等）</p></li><li><p>监视器</p><p>监控我们的脚本运行，取得性能指标（电量等）</p></li></ul><p>任何一款性能测试工具都应该是由这三部分组成</p><p>Jmeter操作：</p><ol><li><p>添加线程组(Thread Group)：[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p><p>Thread Properties（线程属性）</p><ul><li>Numbers of Threads(users)：控制多少用户进行并发</li></ul></li></ol><ul><li>Ramp-UpPeriod(in seconds)：在多少秒之内进行并发。加压策略<ul><li>Loop Count：循环次数</li></ul></li></ul><ol start="2"><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加监听器(Listener)</p><ul><li><p>查看结果树(View Results Tree)：[Thread Group]-[Add]-[Listener]-[View Results Tree]</p><p>【查看结果树(View Results Tree)】辅助进行脚本调试</p></li><li><p>聚合报告(Aggregate Report)：[Thread Group]-[Add]-[Listener]-[Aggregate Report]</p><p>统计访问了多少次，访问时间，错误率</p></li></ul></li><li><p>逻辑控制器(Logic Controller)</p></li><li><p>配置元件(Congif Element)</p><p>如果在压测过程中出现no cookies信息，就添加HTTP Header Manager、HTTP Cookie Manager</p></li><li><p>定时器(Timer)</p></li><li><p>前置处理器(Pre Processors)</p><p>在做取样器(Sampler)之前需要做些什么操作</p></li><li><p>后置处理器(Post Processors)</p></li><li><p>断言(Assertions)</p><p>在后置处理器(Post Processors)之后判断返回是否和期望值一致。</p><p>在做多并发处理时，不建议使用JMeter进行断言。在访问请求时自定义了变量，由于多个请求访问速度的影响，共享的一个变量就有可能出现数据的不准确。</p></li><li><p>测试碎片(Test Fragment)</p></li></ol><h2 id="第2章-使用badboy录制jmeter脚本"><a href="#第2章-使用badboy录制jmeter脚本" class="headerlink" title="第2章 使用badboy录制jmeter脚本"></a>第2章 使用badboy录制jmeter脚本</h2><blockquote><p>熟悉jmeter的录制方式及如何思考去制作一个脚本；了解badboy的组成；学会使用badboy录制脚本；能够使用jmeter将badboy脚本调试运行成功</p></blockquote><h3 id="2-1-Jmeter录制方式和思路及badboy简介-10-10"><a href="#2-1-Jmeter录制方式和思路及badboy简介-10-10" class="headerlink" title="2-1 Jmeter录制方式和思路及badboy简介 (10:10)"></a>2-1 Jmeter录制方式和思路及badboy简介 (10:10)</h3><p>JMeter脚本的两种录制方式：</p><ul><li><p>使用badboy进行录制</p><p>badboy(也是一款软件)能够进行浏览器的操作行为的录制，并且能够导出JMeter脚本。</p></li><li><p>使用代理方式进行录制</p><p>代理方式是指不借助第三方软件，然后进行浏览器中的一些设置。监听端口号捕捉在浏览器上的网络请求，然后进行录制</p><p>类似于抓包工具Fiddler。抓包工具：Fiddler、Charles、Wireshark</p></li></ul><p>脚本录制的流程与思路</p><blockquote><p>业务流程=&gt;录制工具=&gt;脚本制作=&gt;性能测试</p></blockquote><p>Badboy：<a href="http://www.badboy.com.au" target="_blank" rel="noopener">http://www.badboy.com.au</a></p><p>注：目前(2019-09-14)访问不了官网，Badboy似乎也没有Mac版。</p><p>Badboy组成：</p><blockquote><p>工具区、地址栏、脚本区、视图区</p></blockquote><p>Badboy介绍与演示</p><ol><li>地址栏输入地址</li><li>视图区进行操作</li><li>脚本区自动记录生成相应操作</li><li>点击工具栏小红点完成录制</li></ol><h3 id="2-2-使用badboy进行jmeter脚本录制-07-30"><a href="#2-2-使用badboy进行jmeter脚本录制-07-30" class="headerlink" title="2-2 使用badboy进行jmeter脚本录制 (07:30)"></a>2-2 使用badboy进行jmeter脚本录制 (07:30)</h3><p>BugFree：Bug管理系统。目前已由禅道代替。</p><p>Badboy进行JMeter脚本录制：</p><ol><li>地址栏输入地址</li><li>视图区进行录制步骤操作</li><li>脚本区自动记录生成相应操作</li><li>点击工具栏小红点完成录制</li><li>点击File=&gt;Export to JMeter=&gt;保存*.jmx文件</li></ol><p>.jmx后缀名就是JMeter可执行文件</p><h3 id="2-3-Jmeter运行badboy脚本-17-57"><a href="#2-3-Jmeter运行badboy脚本-17-57" class="headerlink" title="2-3 Jmeter运行badboy脚本 (17:57)"></a>2-3 Jmeter运行badboy脚本 (17:57)</h3><ol><li>点击File=&gt;Open(command+O)=&gt;选择*.jmx文件=&gt;Open</li><li>Thread Group出现了相应步骤</li><li>Thread Group=&gt;Add=&gt;Listener=&gt;View Results Tree</li><li>点击Start(工具栏上的绿色三角形)回放所有步骤</li></ol><p>【查看结果树】中的请求为绿色并不代表请求成功，而只是代表网络是否联通。通过HTML模式查看相应结果发现所有的返回页面都是登录界面</p><p>Redirect Automatically(自动重定向)</p><p>Follow Redirects(跟重定向)</p><p>Use KeepAlive(保持长链接)</p><p>Use multipart/form-data</p><p>Browser-compatible headers</p><p>第三方录制下来的脚本可能存在的出错点：</p><ol><li><p>检查是否登录系统</p></li><li><p>录制产生的URL与实际不同</p><p>根据网页路径修改</p></li><li><p>选择为[跟踪重定向]</p></li><li><p>录制后的脚本参数出现乱码</p><p>修改字符编码格式[Content encoding]为UTF8</p></li></ol><p>自动重定向与跟随重定向的区别：</p><ul><li><p>自动重定向：HttpClient接收到请求后，如果请求中包含重定向请求，HttpClient是可以自动跳转的，但是只针对GET和Head请求。勾选此项则“跟随重定向”失效。</p><p>自动重定向可以自动转向到最终目标页面，但是JMeter是不记录重定向过程内容的，比如在[查看结果树]中是无法找到重定向过程内容的。如果此时你想做关联，那就比较遗憾了，你无法关联到。</p><p>例如：A重定向到B，此时只记录B的内容不记录A的内容，A的响应内容我们暂时且叫过程内容</p></li><li><p>跟随重定向：Http Request取样器的默认选项，但响应Code是3XX时（比如301是重定向），自动跳转至目标地址。与自动重定向不同，JMeter会记录重定向过程中的所有请求响应，在查看结果树时可以看到服务器返回的内容，所以你可以对响应的内容做关联。</p><p>比如你要测试登录，你把POST请求改为跟随重定向就可以了</p></li></ul><h2 id="第3章-jmeter代理录制及运行"><a href="#第3章-jmeter代理录制及运行" class="headerlink" title="第3章 jmeter代理录制及运行"></a>第3章 jmeter代理录制及运行</h2><blockquote><p>了解jmeter代理录制的设置方式；能够把代理录制设置完成；可以使用代理录制方式录制完成脚本；能够使用jmeter将代理录制的脚本调试运行成功</p></blockquote><h3 id="3-1-JMeter性能测试入门篇-代理录制及脚本运行-23-35"><a href="#3-1-JMeter性能测试入门篇-代理录制及脚本运行-23-35" class="headerlink" title="3-1 JMeter性能测试入门篇-代理录制及脚本运行 (23:35)"></a>3-1 JMeter性能测试入门篇-代理录制及脚本运行 (23:35)</h3><p>JMeter代理录制：</p><ul><li><p>HTTP请求默认值</p><p>输入被测试的URL地址(域名/IP+端口号)</p></li><li><p>HTTP代理服务器</p><p>HTTP代理服务器和国外翻墙代理服务器的工作原理差不多</p></li><li><p>浏览器设置</p><p>局域网设置的端口号需要与代理服务器的端口号保持一致。然后在浏览器的操作就会被代理服务器捕捉到，从而形成系统测试的脚本。</p></li></ul><ol><li><p>创建HTTP代理服务器：Test Plan=&gt;Add=&gt;Non-Test Elements=&gt;HTTP(S) Test Script Recorder</p></li><li><p>在[Global Settings]-[Port]设置端口</p></li><li><p>在[Test Plan Creation]-[Test Plan content]-[Target Controller]选择。<strong>必须设置</strong>。</p></li><li><p>浏览器设置：</p><ul><li>IE浏览器：[工具]-[Internet选项]-[连接]-[局域网设置]-[代理服务器]-[地址+端口]</li><li>Chrome：[工具]-[设置]-[高级]-[打开代理设置]-[网页代理(HTTP)/安全网页代理(HTTPS)]–[地址+端口]</li></ul><p>地址、端口为JMeter代理服务器的相应设置。</p></li><li><p>在浏览器进行相应业务操作，JMeter会自动记录操作及资源文件</p></li><li><p>使用包含模式、排除模式，保留或过滤不需要的资源文件。</p><p>[Requests Filtering]-[URL Patterns to Exclude]-[Add suggested excludes]，或者点击[Add]自定义正则匹配</p></li></ol><p>Web应用程序需添加HTTP Cookie Manager(HTTP Cookie管理器)和HTTP Cache Manager</p><blockquote><p>[Test Plan]-[Add]-[Config Element]-[HTTP Cookie Manager]</p><p>[Test Plan]-[Add]-[Config Element]-[HTTP Cache Manager]</p></blockquote><p><strong>注</strong>：必须添加【查看结果树(View Results Tree)】和【聚合报告(Aggregate Report)】通过直观数据判断脚本是否出现问题。</p><h2 id="第4章-jmeter脚本制作"><a href="#第4章-jmeter脚本制作" class="headerlink" title="第4章 jmeter脚本制作"></a>第4章 jmeter脚本制作</h2><blockquote><p>能够自定义变量，实现值的统一化管理；可以自主使用函数助手进行参数化；可以使用csv文件进行参数化配置，达成参数化的目的</p></blockquote><h3 id="4-1-JMeter性能测试入门篇-用户自定义变量-07-33"><a href="#4-1-JMeter性能测试入门篇-用户自定义变量-07-33" class="headerlink" title="4-1 JMeter性能测试入门篇-用户自定义变量 (07:33)"></a>4-1 JMeter性能测试入门篇-用户自定义变量 (07:33)</h3><p>用户自定义变量作用：</p><blockquote><p>把IP地址、端口号、应用上下文等字段用一个变量去代替，测试环境变化时改变一下变量值即可。</p></blockquote><p>添加用户变量：[Thread Group]-[Add]-[Config Element]-[User Defined Variables]</p><p>使用用户变量：<code>${variable_name}</code></p><h3 id="4-2-JMeter性能测试入门篇-CsvReader函数参数化-07-11"><a href="#4-2-JMeter性能测试入门篇-CsvReader函数参数化-07-11" class="headerlink" title="4-2 JMeter性能测试入门篇-CsvReader函数参数化 (07:11)"></a>4-2 JMeter性能测试入门篇-CsvReader函数参数化 (07:11)</h3><p>文件参数化方式：</p><blockquote><ol><li>函数助手</li><li>csv data set config</li></ol></blockquote><p>函数助手：</p><blockquote><p>[Tools]-[Function Helper Dialog(Shift+Command+F1)]-[Choose a function]-[_CSVRead]-[填写文件名称+列号]-[Generate &amp; Copy to clipboard]-[粘贴到对应属性值框]</p></blockquote><p>如：<code>${_CSVRead(D:\csv.txt,column_idx)}</code></p><p>注：</p><ol><li>文件可以是*.txt，但必须以<code>,</code>隔开。</li><li>列号从<code>0</code>开始</li><li>更改线程数(Number of Threads)，_CSVRead会自动遍历(行号递增)csv.txt</li></ol><h3 id="4-3-JMeter性能测试入门篇-CsvDataSetConfig参数化-09-03"><a href="#4-3-JMeter性能测试入门篇-CsvDataSetConfig参数化-09-03" class="headerlink" title="4-3 JMeter性能测试入门篇-CsvDataSetConfig参数化 (09:03)"></a>4-3 JMeter性能测试入门篇-CsvDataSetConfig参数化 (09:03)</h3><p>csv data set config：</p><blockquote><p>[Thread Group]-[Add]-[Config Element]-[CSV Data Set Config]</p></blockquote><ol><li><p>Variable Names(comma-delimited)：设置变量名称，<code>title,build</code></p><ul><li>引用声明的变量：<code>${title}</code>、<code>${build}</code></li></ul></li><li><p>Delimiter：分隔符</p></li><li><p>Allow quoted data：是否允许带引号</p></li><li><p>Recycle on EOF：遇到文件结束符再次循环</p></li><li><p>Stop thread on EOF：遇到文件结束符停止线程</p></li><li><p>Sharing mode：线程共享模式</p><ul><li>All threads：测试计划中所有线程，假如说有线程1到线程n (n&gt;1)，线程1取了一次值后，线程2取值时，取到的是csv文件中的下一行，即与线程1取的不是同一行。</li><li>Current thread group：当前线程组，假设有线程组A、线程组B，A组内有线程A1到线程An，线程组B内有线程B1到线程Bn。取之情况是：线程A1取到了第1行，线程A2取第2行，现在B1取第1行，线程B2取第2行。</li><li>Current thread：当前线程。假设测试计划内有线程1到线程n (n&gt;1)，则线程1取了第1行，线程2也取第1行。</li></ul></li></ol><h2 id="第5章-关联的使用及总结"><a href="#第5章-关联的使用及总结" class="headerlink" title="第5章 关联的使用及总结"></a>第5章 关联的使用及总结</h2><blockquote><p>通过关联的学习，可以准确的进行关联，排查脚本错误，完成性能测试脚本，学到这里，可以完成整个脚本的制作，独立进行基本的性能测试</p></blockquote><h3 id="5-1-JMeter性能测试入门篇-关联的使用及总结-26-40"><a href="#5-1-JMeter性能测试入门篇-关联的使用及总结-26-40" class="headerlink" title="5-1 JMeter性能测试入门篇-关联的使用及总结 (26:40)"></a>5-1 JMeter性能测试入门篇-关联的使用及总结 (26:40)</h3><p>关联：</p><blockquote><p>当上文中的有一些变量的值在下文中被使用。</p></blockquote><p>添加正则表达式提取器：[HTTP Request]-[Add]-[Post Processors]-[Regular Expression Extractor]</p><ol><li><p>引用名称(Name of created variable)：<code>bugId</code></p></li><li><p>正则表达式(Regular Expression)：<code>左边界(.+?)右边界</code></p><p><code>.</code>匹配任意字符(除了斜杠)，<code>+</code>一次或多次，<code>?</code>0次或多次</p></li><li><p>模版(Template)：<code>$1$</code>。指的是匹配第一个结果</p></li><li><p>匹配数字(0代表随机)(Match No.(0 for Random))：<code>0</code></p></li><li><p>引用上文变量名称：${bugId}</p></li></ol><p>注：在调试测试脚本时，多注意编码。</p><p>:star: <strong>解决中文乱码</strong>：</p><ol><li><p>[Content encoding]设置为UTF-8，同时勾选参数后的[编码?]</p></li><li><p>vim ~/bin/jmeter.properties</p><p>sampleresult.default.encoding=UTF-8</p></li></ol><p>loadrunner与JMeter关联的不同之处：</p><ol><li><p>在loadrunner中，关联函数是写在要获取变量值的页面的前面；</p><p>在JMeter中，关联函数是写在要获取变量值的页面的后面。</p></li><li><p>在loadrunner中，关联函数是注册函数；</p><p>在JMeter中，使用正则表达式提取器进行关联</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>719-JMeter之HTTP协议接口性能测试</title>
      <link href="/2019/09/27/791-JMeterHTTP/"/>
      <url>/2019/09/27/791-JMeterHTTP/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/791" target="_blank" rel="noopener">https://www.imooc.com/learn/791</a></p><p>简介：接口的测试，并不仅仅是掌握某一种工具。工具是死的，并且是多种多样的，本课程通过层层剖析的方式来帮助同学们了解http协议，让学习的同学并不仅仅会做接口的功能和性能测试，并且能够了解什么是真正的接口，消除歧义。 慕课网测试交流群 559506833</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程大纲介绍及接口理解"><a href="#第1章-课程大纲介绍及接口理解" class="headerlink" title="第1章 课程大纲介绍及接口理解"></a>第1章 课程大纲介绍及接口理解</h2><blockquote><p>了解本次课程的基本内容；掌握测试与开发对接口的不同理解</p></blockquote><h3 id="1-1-课程内容介绍-04-28"><a href="#1-1-课程内容介绍-04-28" class="headerlink" title="1-1 课程内容介绍 (04:28)"></a>1-1 课程内容介绍 (04:28)</h3><ol><li>不同角色眼中的接口（开发、测试）</li><li>常见的接口协议（如HTTP等）</li><li>HTTP协议栈中的位置（HTTP协议的底层原理）</li><li>HTTP协议响应码（2XX、4XX、5XX）</li><li>HTTP协议响应模型（一次请求的生命周期）</li><li>常见HTTP协议的请求方式（GET、POST等）</li><li>JMeter的功能介绍</li><li>GET请求与POST请求（实战-如何测试）</li></ol><h3 id="1-2-不同角色眼中的接口-04-50"><a href="#1-2-不同角色眼中的接口-04-50" class="headerlink" title="1-2 不同角色眼中的接口 (04:50)"></a>1-2 不同角色眼中的接口 (04:50)</h3><ul><li><p>开发眼中的接口：模块与模块之间的对接方式定义</p><p>创建一个接口，创建一个接口的实现类，必须实现这个接口里的所有方法。</p></li><li><p>测试眼中的接口：可以独立部署成服务的协议接口</p><p>协议接口（HTTP、FTP等）。利用中间件实现某个功能需求</p></li></ul><h2 id="第2章-HTTP协议基本介绍了解"><a href="#第2章-HTTP协议基本介绍了解" class="headerlink" title="第2章 HTTP协议基本介绍了解"></a>第2章 HTTP协议基本介绍了解</h2><blockquote><p>掌握常见接口的协议；理解http协议栈的位置；掌握响应码并能够根据响应码去定位错误；掌握一次请求的生命周期并掌握一次请求的数据流；掌握常用请求方式，并能够区别不同的请求的表现形式</p></blockquote><h3 id="2-1-常见的接口协议-03-30"><a href="#2-1-常见的接口协议-03-30" class="headerlink" title="2-1 常见的接口协议 (03:30)"></a>2-1 常见的接口协议 (03:30)</h3><table><thead><tr><th>协议</th><th>中文名称</th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议</td></tr><tr><td>HTTPS</td><td>安全超文本传输协议</td></tr><tr><td>FTP</td><td>文件传输协议</td></tr><tr><td>TCP</td><td>网络控制协议</td></tr><tr><td>IP</td><td>互联网协议</td></tr><tr><td>UDP</td><td>用户数据协议</td></tr></tbody></table><h3 id="2-2-HTTP协议栈中的位置-02-03"><a href="#2-2-HTTP协议栈中的位置-02-03" class="headerlink" title="2-2 HTTP协议栈中的位置 (02:03)"></a>2-2 HTTP协议栈中的位置 (02:03)</h3><p>HTTP协议栈中的位置：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghioyetnj314g0qitb4.jpg" alt="HTTP协议栈中的位置" style="zoom:30%;" /><p>注：</p><ul><li>SSL：安全套接层协议</li><li>TLS：传输层安全性协议</li></ul><p>HTTP与HTTPS网络层区别：</p><ul><li><p>HTTPS是构建在SSL（安全套接层协议）之上的，</p><p>也有构建在TLS（传输层安全性协议）之上；</p></li><li><p>HTTP是构建在TCP（网络控制协议）之上的；</p></li></ul><h3 id="2-3-HTTP协议响应码-08-50"><a href="#2-3-HTTP协议响应码-08-50" class="headerlink" title="2-3 HTTP协议响应码 (08:50)"></a>2-3 HTTP协议响应码 (08:50)</h3><blockquote><p>每一个响应码都代表了服务端反馈的一种响应状态，也标识了本次请求是否成功</p></blockquote><p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">HTTP状态码|菜鸟教程</a></p><ol><li><p>1XX：信息响应类，表示接受到请求并且继续处理（中间状态）</p></li><li><p>2XX：处理成功响应类，表示动作被成功接收、理解和接受</p></li><li><p>3XX：重定向响应类，为了完成指定的动作，必须接受进一步处理</p></li><li><p>4XX：客户端错误，客户请求包含语法错误或者是不能正确执行</p><p>检查请求URL是否正确</p></li><li><p>5XX：服务端错误，服务器不能正确执行一个正确的请求</p><p>必须在测试时解决此类型错误。查看服务器端日志，重启服务</p></li></ol><h3 id="2-4-HTTP协议请求响应模型-16-23"><a href="#2-4-HTTP协议请求响应模型-16-23" class="headerlink" title="2-4 HTTP协议请求响应模型 (16:23)"></a>2-4 HTTP协议请求响应模型 (16:23)</h3><p>HTTP协议请求响应模型：（一次请求的生命周期，最简单的软件分层）</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghipxi3nj30l40kqdgm.jpg" alt="HTTP协议请求响应模型" style="zoom:45%;" /><p>场景：登录</p><ol><li><p>客户端发起请求到API接口层</p><ul><li>用户在客户端填写用户名和密码，点击登录，发送请求</li></ul></li><li><p>API接收到客户端发起的用户请求</p><ul><li><p>API对业务逻辑进行验证</p><p>验证用户名和密码是否合法（例如：用户名要求必须为真实的手机号码。如果验证失败，即用户名不合法，那么需要给客户端返回(自定义)响应码，比如码值为1.2.3，1代表用户名格式错误，2代表用户名或密码错误，3代表密码格式错误）</p></li></ul></li><li><p>API会将用户输入的数据发给DB层（数据库）</p><p>CRUD：Create、Read、Update、Delete</p><ul><li>数据库查询成功返回1，失败返回0</li></ul></li><li><p>DB会将查询数据库的条目数返回给API</p></li><li><p>API返回成功或失败的状态码给客户端</p></li><li><p>客户端将返回信息提示给用户</p></li></ol><p>简单的软件分层：</p><ol><li><p>客户端</p><p>功能测试、性能测试、自动化测试</p></li><li><p>接口层</p><p>接口测试，功能测试、性能测试、自动化测试(更好维护脚本，不涉及页面元素的改变，最多只是接口,数据格式,传输数据内容的改变)</p></li><li><p>数据库层</p><p>可以将开发人员使用到的SQL语句单独拿出来进行性能测试</p></li></ol><h3 id="2-5-常用HTTP请求方式-08-52"><a href="#2-5-常用HTTP请求方式-08-52" class="headerlink" title="2-5 常用HTTP请求方式 (08:52)"></a>2-5 常用HTTP请求方式 (08:52)</h3><p>最常用的HTTP请求方式：</p><ol><li><p>GET请求</p><p>URL：</p><pre><code>http://127.0.0.1:8080?username=zhangsan&amp;password=123456</code></pre></li><li><p>POST请求</p><p>URL：</p><pre><code class="json">http://127.0.0.1:8080</code></pre><p>请求体：</p><pre><code class="json">{  [      &quot;username&quot;: &quot;zhangsan&quot;,      &quot;password&quot;: &quot;123456&quot;  ]}</code></pre></li></ol><p>HTTP请求的方法：</p><blockquote><p>HTTP/1.1协议中共定义了八种请求方法（有时也叫做“动作”），来表明Request-URL指定的资源不同的操作方式</p></blockquote><ol><li><p>OPTIONS</p><p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向Web服务器发送“*”的请求来测试服务器的功能性</p></li><li><p>HEAD</p><p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。</p><p>这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息</p></li><li><p><strong>:star: GET</strong></p><p>向特定的资源发出请求。</p><p>注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。</p></li><li><p><strong>:star: POST</strong></p><p>向指定资源提交数据进行处理请求（例如，提交表单或者上传文件）</p><p>数据被包含在请求体中。</p><p>POST请求可能会导致新资源的建立和/或已有资源的修改</p></li><li><p>PUT</p><p>向指定资源位置上传其最新内容</p></li><li><p>DELETE</p><p>请求服务器删除Request-URL所标识的资源</p></li><li><p>TRACE</p><p>回显服务器所收到的请求，主要用于测试或诊断</p></li><li><p>CONNECT</p><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</p></li></ol><p><strong>注意：</strong></p><ol><li><p>方法名称是区分大小写的。</p><p>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405(Method Not Allowed)；当服务器不认识或者不支持对应的请求方法时，应返回状态码501(Not Implemented)。</p></li><li><p>HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法</p></li></ol><h2 id="第3章-JMeter的get请求介绍及使用"><a href="#第3章-JMeter的get请求介绍及使用" class="headerlink" title="第3章 JMeter的get请求介绍及使用"></a>第3章 JMeter的get请求介绍及使用</h2><blockquote><p>了解jmeter能够做什么；了解get接口运行原理；能够自主开发get请求脚本并且解决乱码问题；能够掌握函数助手的参数化方式；能够掌握线程组中各个选项的意义并能够进行符合业务逻辑的场景设置</p></blockquote><h3 id="3-1-JMeter功能介绍-06-21"><a href="#3-1-JMeter功能介绍-06-21" class="headerlink" title="3-1 JMeter功能介绍 (06:21)"></a>3-1 JMeter功能介绍 (06:21)</h3><p>万能的JMeter</p><ol><li>BS(Browser-Server)架构应用性能(分三层：1.浏览器性能；2.API性能；3.数据库性能测试)</li><li>HTTP协议接口功能与性能</li><li>FTP协议接口功能与性能</li><li>MySQL数据库性能(增删改查脚本测试)</li><li>MongoDB数据库性能(数据量大，较重要的读写功能性能)</li><li><strong>:star: 支持自定义Java组件开发</strong>(JMeter工具的组件不满足是可以开发新的组件，Java代码脚本方便管理)</li></ol><h3 id="3-2-get接口代码开发及原理讲解-11-51"><a href="#3-2-get接口代码开发及原理讲解-11-51" class="headerlink" title="3-2 get接口代码开发及原理讲解 (11:51)"></a>3-2 get接口代码开发及原理讲解 (11:51)</h3><ol><li><p><a href="https://jmeter.apache.org/" target="_blank" rel="noopener">JMeter</a>下载：<a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">https://jmeter.apache.org/download_jmeter.cgi</a></p><p>Windows系统：运行jmeter.bat</p><p>Linux、Mac系统：运行jmeter.sh</p></li><li><p>SpringBoot接口开发</p><p>DemoApplication.java</p><pre><code class="java">@SpringBootApplicationpublic class DemoApplication {    public static void main(String[] args) {        ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class,args);        for (String str : context.getEnvironment().getActiveProfiles()) {            System.out.println(str);        }    }}</code></pre><p>DemoAPI.java</p><pre><code class="java">@RestController@RequestMapping(&quot;/demoAPI&quot;)public class DemoAPI {    // http://127.0.0.1:8080/demoAPI/getDemo/zhangsan    @RequestMapping(value = &quot;/getDemo/{userName}&quot;,method = RequestMethod.GET)    public String getDemo(@PathVariable String userName){        String s = &quot; is pig&quot;;        userName = userName + s;        return &quot;您输入的数据是：&quot; + userName;    }}</code></pre></li></ol><h3 id="3-3-get接口测试及常见乱码问题-24-50"><a href="#3-3-get接口测试及常见乱码问题-24-50" class="headerlink" title="3-3 get接口测试及常见乱码问题 (24:50)"></a>3-3 get接口测试及常见乱码问题 (24:50)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：GET</li><li>Path：/demoAPI/getDemo/zhangsan</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加查看结果树(View Results Tree)：[Thread Group]-[Add]-[Listener]-[View Results Tree]</p></li><li><p>点击绿色小箭头运行访问</p></li><li><p>聚合报告(Aggregate Report)：[Thread Group]-[Add]-[Listener]-[Aggregate Report]</p><p>反应整个测试结果快慢、并发量</p><p>关注指标：Average(平均值)、Error%(错误率)、Throughput(吞吐量)、</p><p>Received KB/sec(接收)、Sent KB/sec(发送)、90%Line(90%百分位)</p></li></ol><p><strong>注</strong>：在真正做测试时应该把[查看结果树(View Result Tree)]去掉，打印日志记录会消耗大量IO、CPU等资源</p><p>:star: 测试并解决请求响应数据乱码：</p><pre><code>http://www.weather.com.cn/data/sk/101010100.htmlhttp://www.weather.com.cn/data/cityinfo/101010100.html</code></pre><ol><li>在Content encoding中设置UTF-8。无效</li><li>打开/bin/jmeter.properties搜索<code>sampleresult.default.encoding=ISO-8859-1</code>，设置为UTF-8。有效</li><li>[Thread Group]-[Add]-[Post Processors]-[BeanShell PostProcessor]-[Script]：<code>prev.setDataEncoding(&quot;UTF-8&quot;)</code>。有效</li></ol><h3 id="3-4-参数化－函数助手-06-12"><a href="#3-4-参数化－函数助手-06-12" class="headerlink" title="3-4 参数化－函数助手 (06:12)"></a>3-4 参数化－函数助手 (06:12)</h3><blockquote><p>意义：数据的多变。</p></blockquote><p>[Tools]-[Function Helper Dialog]-[Choose a function(__CSVRead)]-[Generate &amp; Copy to Clipboard]</p><ul><li><p>输入参数：</p><p>CSV file to get values from | *alias：文件路径</p><p>Column number of CSV file | next | *alias：文件列号，0</p></li><li><p>点击生成：代表某个数值</p><pre><code>${__CSVRead(文件路径, 0)}</code></pre></li><li><p>复制到链接🔗：</p><pre><code>/demoAPI/getDemo/${__CSVRead(文件路径, 0)}</code></pre></li></ul><h3 id="3-5-场景设置（get请求）-06-56"><a href="#3-5-场景设置（get请求）-06-56" class="headerlink" title="3-5 场景设置（get请求） (06:56)"></a>3-5 场景设置（get请求） (06:56)</h3><blockquote><p>场景设置即配置线程组</p></blockquote><p>Thread Properties：</p><ul><li>Number of Threads：线程数</li><li>Ramp-Up Period(in seconds)：每秒当中有多少用户进行访问(加压策略)</li><li>Loop Count：循环次数</li></ul><p>复杂场景需要使用多个线程组</p><h2 id="第4章-JMeter的post请求介绍及使用"><a href="#第4章-JMeter的post请求介绍及使用" class="headerlink" title="第4章 JMeter的post请求介绍及使用"></a>第4章 JMeter的post请求介绍及使用</h2><blockquote><p>学习能够了解post接口开发的原理；能够掌握post接口中map格式的数据传递的访问方式；能够了解json格式传递数据传递的原理；能够掌握post接口中json格式的数据传递的访问方式</p></blockquote><h3 id="4-1-post接口代码开发及原理-07-52"><a href="#4-1-post接口代码开发及原理-07-52" class="headerlink" title="4-1 post接口代码开发及原理 (07:52)"></a>4-1 post接口代码开发及原理 (07:52)</h3><pre><code class="java">// http://127.0.0.1:8080/demoAPI/postDemo/*{  &quot;userName&quot;: &quot;zhangsan&quot;}*/public static int count = 0;@RequestMapping(value = &quot;/postDemo&quot;, method = RequestMethod.POST)public String postDemo(@RequestParam String userName){  count++;  String result = &quot;接口是第&quot; + count + &quot;次被调用,您的用户名是&quot; + userName;  return result;}</code></pre><p>使用POSTMAN工具🔧调用测试接口。</p><h3 id="4-2-接口测试实战－map参数格式-04-55"><a href="#4-2-接口测试实战－map参数格式-04-55" class="headerlink" title="4-2 接口测试实战－map参数格式 (04:55)"></a>4-2 接口测试实战－map参数格式 (04:55)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：POST</li><li>Path：/demoAPI/postDemo</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加参数：[Parameters]-[Add]</p><ul><li>userName：zhangsan</li></ul><p>使用函数助手__CSVRead <code>${CSVRead(文件路径, 0)}</code> 动态获取CSV的数据</p></li><li><p>点击绿色小箭头运行访问</p></li></ol><h3 id="4-3-json格式数据传递接口原理及开发-06-31"><a href="#4-3-json格式数据传递接口原理及开发-06-31" class="headerlink" title="4-3 json格式数据传递接口原理及开发 (06:31)"></a>4-3 json格式数据传递接口原理及开发 (06:31)</h3><pre><code class="java">// http://127.0.0.1:8080/demoAPI/postJson/*{  &quot;name&quot;: &quot;zhangsan&quot;,  &quot;clazz&quot;: &quot;一年一班&quot;}*/public static int count = 0;@ResponseBody@RequestMapping(value = &quot;/postJson&quot;, method = RequestMethod.POST)public String postDemo(@RequestBody Student student){  Student stu = new Student();  stu.setName(student.getName());  stu.setClazz(student.getClazz());  return stu;}</code></pre><pre><code class="java">@Datapublic class Student {  private String name;  private String clazz;}</code></pre><pre><code>Content-Type: application/json</code></pre><h3 id="4-4-json格式post请求实战-05-03"><a href="#4-4-json格式post请求实战-05-03" class="headerlink" title="4-4 json格式post请求实战 (05:03)"></a>4-4 json格式post请求实战 (05:03)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：POST</li><li>Path：/demoAPI/postJson</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加参数：[Body Data]</p><pre><code class="json">{  &quot;name&quot;: &quot;zhangsan&quot;,  &quot;clazz&quot;: &quot;一年一班&quot;}</code></pre><p>使用函数助手__CSVRead <code>${CSVRead(文件路径, 0)}</code> 动态获取CSV的数据</p></li><li><p>添加HTTP信息头管理器：[Thread Group]-[Add]-[Config Element]-[HTTP Header Manager]-[Add]</p><ul><li>Content-Type：application/json</li></ul></li><li><p>点击绿色小箭头运行访问</p></li></ol><h2 id="第5章-JMeter之接口性能测试-课程总结"><a href="#第5章-JMeter之接口性能测试-课程总结" class="headerlink" title="第5章 JMeter之接口性能测试-课程总结"></a>第5章 JMeter之接口性能测试-课程总结</h2><blockquote><p>掌握本次课程的所有重点内容，能够独立进行接口测试</p></blockquote><h3 id="5-1-课程总结-03-31"><a href="#5-1-课程总结-03-31" class="headerlink" title="5-1 课程总结 (03:31)"></a>5-1 课程总结 (03:31)</h3><ol><li>常见的接口协议（HTTP协议、FTP协议）</li><li>HTTP协议响应码</li><li>HTTP协议响应模型（HTTP生命周期）</li><li>GET请求的开发与测试</li><li>POST请求的开发与测试</li><li>场景设置（配置线程组信息）</li><li>参数化（函数助手参数化、外部文件参数化）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>951-MyCAT入门及应用</title>
      <link href="/2019/07/09/951-MyCat/"/>
      <url>/2019/07/09/951-MyCat/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/951" target="_blank" rel="noopener">https://www.imooc.com/learn/951</a></p><p>简介：本课程从实际生产环境应用MyCAT入手，讲解MyCAT的基础知识和MyCAT的基本应用操作，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>本章节主要介绍课程结构</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>学习目的：</p><ul><li>掌握在数据库负载增大时的处理方法</li><li>理解MyCat的基础概念（分库、分表、逻辑库、逻辑表）</li><li>掌握MyCat的基础配置和监控方法</li></ul><h2 id="第2章-MyCAT介绍"><a href="#第2章-MyCAT介绍" class="headerlink" title="第2章 MyCAT介绍"></a>第2章 MyCAT介绍</h2><blockquote><p>本章节主要介绍MyCAT的主要应用场景和优势，用来帮助大家了解MyCAT具体应用在什么样的生产环境中。</p></blockquote><h3 id="2-1-MyCAT前世今生"><a href="#2-1-MyCAT前世今生" class="headerlink" title="2-1 MyCAT前世今生"></a>2-1 MyCAT前世今生</h3><p>阿里开源数据库中间件产品：</p><ul><li><p>2008年：Amoeba。</p><p>阿里使用多台MySQL数据库来替代Oracle数据库</p><p>充当MySQL分布式数据库中间层，主要应用在访问层，充当应用程序与数据库之间的代理</p><p>具有负载均衡、高可用、SQL过滤，支持对后端数据库的读写分离</p></li><li><p>2012年：Cobar</p><p>应用3000+台服务器的集群规模</p><p>明天可处理超过10亿的数据库访问</p></li><li><p>2013年：MyCat</p><p>解决了Cobar在高并发的情况下假死</p><p>前后端的……并不是统一的</p></li></ul><h3 id="2-2-MyCAT的主要功能"><a href="#2-2-MyCAT的主要功能" class="headerlink" title="2-2 MyCAT的主要功能"></a>2-2 MyCAT的主要功能</h3><p>MyCat的主要作用：</p><ul><li><p>实现了MySQL通信协议的<strong>分布式数据库系统中间层</strong></p><p>数据库中间层：在架构中的位置，位于前端应用和后端数据库之间的一个应用软件</p><p>数据库中间层：作用，读写分离、负载均衡、数据库连接池（统一控制数据库的连接数量）、屏蔽后端数据库的变更、连接多种类型数据库（如MSSQL、MongoDB等<strong>包括非关系型数据库</strong>）</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gief3798j30hm07cq3l.jpg"  width="350" alt="分布式数据库系统中间层"/></li><li><p>实现数据库的读写分离</p><p>MySQL主从复制集群（写操作在主数据库中执行、读操作在从数据库中执行）</p><p>主从复制实现原理</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gieg9chlj307x09x3yo.jpg"  width="200" alt="数据库的读写分离"/><p>MyCat支持读数据库的负载均衡</p><p>这种情况多出现在一主多从的架构上，将读负载在多个服务器上进行负载均衡</p></li></ul><p>  MyCat支持后端MySQL高可用</p><p>  此处的高可用不同于通过MHA和3M方式复制架构来实现的高可用。在MHA和3M架构中，当主节点宕机之后是可以自动从多个从节点中选择一个新的主节点，并且将其他从节点对这个新的主节点重新进行同步。</p><p>  MyCat对后端数据库的高可用是指，在配置的时候，除了主节点之外，可以指定从节点，实现写操作。当主节点宕机之后，MyCat会把写的SQL路由到配置的写从节点上，并且不支持把其他的从节点对新节点进行主从同步。</p><ul><li><p>数据库垂直拆分</p><p>垂直切蛋糕…</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giegt6poj30jy08h0tk.jpg"  width="400" alt="数据库垂直拆分"/></li><li><p>数据库水平拆分（分库、分表）</p><p>水平切蛋糕…</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giefdedqj30ml08g75d.jpg"  width="430" alt="数据库水平拆分"/><p>将一个数据库通过一定规则进行切分成多个数据库。比如，对userId取模来进行切分，将user表均匀的分到三个数据库中（三个库的表结构是完全一致的）。</p><p>前端应用通过MyCat以及切分规则来对切分后的数据库进行访问。</p><p>MyCat统一实现了切分逻辑，而不同在前端应用中实现切分逻辑。</p></li></ul><h3 id="2-3-MyCAT的主要功能"><a href="#2-3-MyCAT的主要功能" class="headerlink" title="2-3 MyCAT的主要功能"></a>2-3 MyCAT的主要功能</h3><p>见【2-2 MyCAT的主要功能】</p><h3 id="2-4-MyCAT的主要功能"><a href="#2-4-MyCAT的主要功能" class="headerlink" title="2-4 MyCAT的主要功能"></a>2-4 MyCAT的主要功能</h3><p>见【2-2 MyCAT的主要功能】</p><h3 id="2-5-MyCAT的应用场景"><a href="#2-5-MyCAT的应用场景" class="headerlink" title="2-5 MyCAT的应用场景"></a>2-5 MyCAT的应用场景</h3><ul><li><p>需要进行读写分离的场景</p><p>在一台数据库服务器上进行读写混合操作时，数据库读写性能大幅下降，并且读负载明显高于写负载</p><p>MyCat支持多种后端MySQL集群方案来进行读写分离，如一主一从、一主多从、主主复制、PXC集群等等</p></li><li><p>需要进行分库分表的场景（切分）</p><p>最大支持单表1000亿的操作</p></li><li><p>多租户场景（软件架构）</p><p>在多用户的环境下，使用共同的数据库系统的组件，并且可以确保各个 用户之间具有数据隔离性。如云服务。</p></li><li><p>数据统计系统</p></li><li><p>HBASE的一种替代方案</p><p>HBASE是基于Hadoop的一种分布式列存储数据库</p><p>MySQL关系型数据库为行存储</p></li><li><p>需要使用同样的方式查询多种数据库的场景</p><p>MyCat可以同时支持多种数据库，如关系型数据库和NoSQL非关系型数据库。MyCat只向应用提供一个IP访问地址，而数据库存储方式的实现则可以使用各种方案。</p></li></ul><h3 id="2-6-MyCAT的优势"><a href="#2-6-MyCAT的优势" class="headerlink" title="2-6 MyCAT的优势"></a>2-6 MyCAT的优势</h3><ul><li>基于阿里的Cobar系统开发</li><li>开发社区活跃</li><li>完全开源可以自定义开发</li><li>支持多种关系型及NoSQL数据库</li><li>使用JAVA开发，可以部署在多种系统上。建议部署在Linux</li><li>具有在多种行业和项目中应用的成功案例</li></ul><h2 id="第3章-MyCAT基础"><a href="#第3章-MyCAT基础" class="headerlink" title="第3章 MyCAT基础"></a>第3章 MyCAT基础</h2><blockquote><p>本章节主要讲解MyCAT的基础知识，包括MyCAT的安装，启动配置和应用等。通过老师逻辑清晰的讲解，让大家理解并掌握MyCAT在实战中的基本应用。</p></blockquote><h3 id="3-1-MyCAT的基本概念"><a href="#3-1-MyCAT的基本概念" class="headerlink" title="3-1 MyCAT的基本概念"></a>3-1 MyCAT的基本概念</h3><ul><li><p>MYCAT中的数据库一逻辑库</p><p>user_db是逻辑数据库；db01、db02、db03是物理数据库</p><p>MyCat中只保存逻辑库的定义，不保存数据，具体的数据存储在物理数据库中</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gieftwvlj30j908k0tq.jpg"  width="430" alt="MYCAT中的数据库一逻辑库"/></li><li><p>MYCAT中的数据库一逻辑表</p><p>可以用数据库中视图的概念理解</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giehbahcj30fo07paam.jpg"  width="430" alt="MYCAT中的数据库一逻辑表"/></li></ul><h3 id="3-2-MyCAT的关键特性"><a href="#3-2-MyCAT的关键特性" class="headerlink" title="3-2 MyCAT的关键特性"></a>3-2 MyCAT的关键特性</h3><ul><li><p>支持<strong>SQL92标准</strong></p></li><li><p>支持MySQL集群</p></li><li><p>支持JDBC连接数据库</p></li><li><p>支持NOSQL数据库</p></li><li><p>支持<strong>自动故障切换</strong>，高可用性</p></li><li><p>支持<strong>读写分离</strong></p></li><li><p>支持全局表</p><p>将较少变动的数据统一存储起来</p></li><li><p>支持独有的基于ER关系的分片策略</p><p>根据实体关系ER模型，将相关的表存储在一个分片上，避免调用时跨分片</p></li><li><p>支持一致性HASH分片</p></li><li><p>多平台支持，部署简单方便</p></li><li><p>支持<strong>全局序列号</strong></p><p>将多个数据库表的自增ID统一起来，不出现重复ID</p></li></ul><h3 id="3-3-安装MyCAT"><a href="#3-3-安装MyCAT" class="headerlink" title="3-3 安装MyCAT"></a>3-3 安装MyCAT</h3><ol><li><p>安装Java环境</p></li><li><p>下载MyCat</p></li><li><p>新建MyCat用户</p><p>在Linux系统环境下，最好为每一款软件都独立的建立一个运行账号。既安全又可以对账号进行资源的限制</p></li><li><p>解压MyCat</p></li><li><p>配置环境变量</p><p>Java的HOME目录</p><p>Java的CLASSPATH目录</p><p>MyCat的HOME目录</p></li><li><p>启动MyCat</p></li></ol><h3 id="3-4-MyCAT安装"><a href="#3-4-MyCAT安装" class="headerlink" title="3-4 MyCAT安装"></a>3-4 MyCAT安装</h3><pre><code class="shell">java -versionyum install java-1.7.0-openjdkwget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gzadduser mycat # 建立mycat用户tar -xzvf Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz # 解压MyCat安装文件mv mycat /usr/local/ # 移动MyCat安装文件到/usr/local/chown mycat:mycat -R mycat # #改变当前文件夹属主和属组vi /etc/profile # 配置环境变量export JAVA_HOME=/usrexport MYCAT_HOME=/usr/local/mycat</code></pre><p>Linux系统安装任何一种软件最好都要新建一个独立用户，不要用root运行，不然会产生不安全的因素</p><h3 id="3-5-MyCAT启动-03-48"><a href="#3-5-MyCAT启动-03-48" class="headerlink" title="3-5 MyCAT启动 (03:48)"></a>3-5 MyCAT启动 (03:48)</h3><p>MyCat两种启动方式：</p><ol><li><p>基于脚本的启动方式</p><p>启动脚本：</p><pre><code class="shell">$MYCAT_HOME/bin/startup_nowrap.sh==&gt;/usr/local/mycat/bin/startup_nowrap.sh</code></pre><p>脚本参数：</p><p>当运行MyCat时，报内存不足或者是内存溢出异常</p><pre><code class="shell">JAVA_OPTS=&quot;-server -Xms1G -Xmx2G -XX:MaxPermSize=64M -XX:+AggressiveOpts -XX:MaxDirectMemorySize=2G&quot;</code></pre><pre><code class="shell"># 切换到mycat用户su - mycatcd /usr/local/mycat# 通过脚本启动MyCatbin/startup_nowrap.sh# 查看进程信息ps -ef# 查看日志cd /usr/local/mycat/logsmore mycat.log</code></pre></li><li><p>bin下已打包的mycat</p></li></ol><h3 id="3-6-MyCAT配置文件"><a href="#3-6-MyCAT配置文件" class="headerlink" title="3-6 MyCAT配置文件"></a>3-6 MyCAT配置文件</h3><ul><li>schema.xml用于配置逻辑库表及数据节点，数据源</li><li>rule.xml用于配置表的分片规则</li><li>server.xml用于配置服务器权限</li></ul><p>schema.xml文件</p><ul><li><p>定义逻辑库表</p><p>逻辑表是要依赖于逻辑库存在的。</p><p>如果数据库不需要进行分片，只进行读写分离，此时不用配置<table>标签，而只保留<schema>标签</p><pre><code class="xml">&lt;schema&gt;    &lt;table&gt;    &lt;/table&gt;&lt;/schema&gt;</code></pre></li><li><p>定义数据节点</p><p>定义MyCat的分片节点，一个数据节点就代表着一个独立的分片。其内容包括数据库节点的名字、数据源真实物理数据库的名称</p><pre><code class="xml">&lt;dataNode&gt;&lt;/dataNode&gt;</code></pre></li><li><p>定义数据节点的物理数据源</p><p>定义了一组主机节点，是真实物理数据库的实例。</p><p>一个<dataHost>标签所指定的主机就是一组真实的MySQL数据库集群</p><p>读写分离配置、心跳检测。。。</p><pre><code class="xml">&lt;dataHost&gt;&lt;/dataHost&gt;</code></pre></li></ul><p>rule.xml文件</p><ul><li><p>定义表使用的分片规则</p><pre><code class="xml">&lt;tableRule name=&quot;&quot;&gt;&lt;/tableRule&gt;</code></pre></li><li><p>定义分片算法</p><pre><code class="xml">&lt;function name=&quot;&quot;&gt;&lt;/function&gt;</code></pre></li></ul><p>server.xml文件</p><ul><li><p>用于定义系统配置</p><p>系统端口号、系统使用内存大小、timeout时间</p><pre><code class="xml">&lt;system&gt;    &lt;property name=&quot;&quot;&gt;    &lt;/property&gt;&lt;/system&gt;</code></pre></li><li><p>用于定义连接MyCat的用户信息</p><p>用户名字、密码</p><p>只有在server.xml中存在的用户才可以通过MyCat连接到后端数据库</p><pre><code class="xml">&lt;user&gt;&lt;/user&gt;</code></pre></li></ul><h3 id="3-7-MyCAT读写分离"><a href="#3-7-MyCAT读写分离" class="headerlink" title="3-7 MyCAT读写分离"></a>3-7 MyCAT读写分离</h3><p>三台服务器：MyCat服务器（node1）、两台MySQL服务器（Master-node2、Slave-node3）</p><p>显示xml文件：</p><pre><code class="shell">ls -lh *xml</code></pre><p>MyCat实现数据库读写分离只需配置两个文件：schema.xml、server.xml</p><pre><code class="xml">&lt;!-- /usr/local/mycat/conf/schema.xml --&gt;&lt;mycat:schema&gt;    &lt;!-- 配置逻辑库USERDB --&gt;    &lt;schema name=&quot;USERDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;&lt;/schema&gt;    &lt;!-- 定义数据节点node1 --&gt;    &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;node1&quot; database=&quot;user_db&quot; /&gt;    &lt;!-- 定义数据库集群 --&gt;    &lt;dataHost name=&quot;node1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; blance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt;        &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;        &lt;writeHost host=&quot;10.102.13.3&quot; url=&quot;10.102.13.3:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot;&gt;            &lt;readHost host=&quot;10.102.13.4&quot; url=&quot;10.102.13.4:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot; /&gt;        &lt;/writeHost&gt;        &lt;writeHost host=&quot;10.102.13.4&quot; url=&quot;10.102.13.4:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot; /&gt;    &lt;/dataHost&gt;&lt;/mycat:schema&gt;</code></pre><p>注：</p><ul><li><p><code>sqlMaxLimit=&quot;100&quot;</code>每一条SQL只返回100行记录</p><p>如果数据库进行了分片操作，查询数据会从所有分片中查询。此时会对系统造成负载</p></li><li><p><code>dataNode=&quot;dn1&quot;</code>定义了数据节点dn1</p></li><li><p><code>blance=&quot;1&quot;</code>定义了是否对后端多个从数据库进行负载均衡。1是0否</p></li><li><p><code>&lt;heartbeat&gt;</code>定义了如何监测后端数据库是否健康</p></li><li><p><code>user=&quot;im_user&quot; password=&quot;123456&quot;</code>定义了后端物理数据库的用户名和密码</p></li></ul><pre><code class="xml">&lt;!-- /usr/local/mycat/conf/server.xml --&gt;&lt;mycat:server&gt;    &lt;system&gt;        &lt;property name=&quot;serverPort&quot;&gt;3306&lt;/property&gt;        &lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;        &lt;property name=&quot;nonePasswordLogin&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useHandshakeV10&quot;&gt;1&lt;/property&gt;        &lt;property name=&quot;useSqlStat&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useGTob]eTablecheck&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;sequnceHandlerType&quot;&gt;2&lt;/property&gt;        &lt;property name=&quot;subqueryRelationshipcheck&quot;&gt; fal se&lt;/property&gt;        &lt;property name=&quot;processorBufferPoolType&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;handlepistributedTransactions&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useoffHeapForMerge&quot;&gt;1&lt;/property&gt;        &lt;property name=&quot;memoryPageSize&quot;&gt;64k&lt;/property&gt;        &lt;property name=&quot;spi11sFileBuffersize&quot;&gt;1k&lt;/property&gt;        &lt;property name=&quot;usestreamoutput&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;systemReserveMemorysize&quot;&gt;384m&lt;/property&gt;        &lt;property name=&quot;usezkSwitch&quot;&gt;false&lt;/property&gt;    &lt;/system&gt;    &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;        &lt;property name=&quot;schemas&quot;&gt;USERDB&lt;/property&gt;    &lt;/user&gt;    &lt;user name=&quot;mc_user&quot;&gt;        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;        &lt;property name=&quot;schemas&quot;&gt;USERDB&lt;/property&gt;        &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;    &lt;/user&gt;&lt;/mycat:server&gt;</code></pre><p>注：</p><ul><li><code>&lt;user&gt;</code>定义的用户在后端数据库中实际并不存在</li></ul><p>重启MyCat：</p><pre><code class="shell"># /usr/local/mycatbin/mycat stopbin/mycat start</code></pre><p>通过MyCat写数据，然后再读取：</p><pre><code class="python"># /root/script/init_data.pyimport MySQLdbfrom faker import Fakertry:    conn = MysQLdb.connect(host=&#39;127.0.0.1&#39;, user=&#39;root&#39;,passwd=&#39;123456&#39;, db=&#39;USERDB&#39;, charset=&quot;utf8&quot;)    cursor=conn. cursor(MySQLdb.cursors.Dictcursor)except MysQLdb.Error, e:    print &quot;Error %d: %s \n&quot; % (e.args[0],e. args[1])try:    faker=Faker()    # write data    for i in range(0, 10):        InSQL=&quot;&quot;&quot;            insert into customer_login(login_name, password, user_stats) VALUES(&#39;%s&#39;, md5(&#39;%s&#39;), 1)        &quot;&quot;&quot;%(faker.name(), faker.ean13())        print InSQL        cursor.execute(InSQL)        cursor.execute(&#39;commit&#39;)    # read data    for i in range(0, 10):        sQLstr=&quot;&quot;&quot;            select login_name from customer_login where customer_id = %d;        &quot;&quot;&quot;%(i)        cursor.execute(SQLstr)        resuit = cursor. fetchall()        print resultexcept MysQLdb.Error,e:    print &quot;Error %d: %s \n&quot; % (e.args[0], e.args[1])finally    cursor.close()    conn.close()</code></pre><p>执行程序：</p><pre><code class="shell"># /root/scriptpython init_data.py</code></pre><p>查看MyCat日志：</p><pre><code class="shell">more /usr/local/mycay/logs/mycat.log</code></pre><p>跟踪日志文件：</p><pre><code class="shell">tailf /usr/local/mycay/logs/mycat.log</code></pre><h3 id="3-8-MyCAT读写分离总结"><a href="#3-8-MyCAT读写分离总结" class="headerlink" title="3-8 MyCAT读写分离总结"></a>3-8 MyCAT读写分离总结</h3><p>步骤：</p><ol><li><p>修改schema.xml文件（/usr/local/mycat/conf/schema.xml）</p><p>对后端数据库的逻辑库、数据节点、数据主机节点进行配置</p><p>由于未进行分片操作，只需配置<schema>标签，无需配置<table>标签</p></li><li><p>修改server.xml文件（/usr/local/mycat/conf/server.xml）</p><p>MyCat向应用程序提供的服务端口、MyCat用户</p></li></ol><h3 id="3-9-MyCAT管理"><a href="#3-9-MyCAT管理" class="headerlink" title="3-9 MyCAT管理"></a>3-9 MyCAT管理</h3><p>使用MySQL客户端管理MyCat</p><ul><li>管理端口：<code>&lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;</code></li><li>命令：<code>mysql -uroot -p123456 -h127.0.0.1 -P9066</code></li><li>查看管理命令：<code>show @@help</code></li></ul><p>常用管理命令</p><ul><li><p>动态加载配置文件：<code>reload @@config</code></p><p>动态加载MyCat配置文件，但是并不是所有的配置文件都能够通过该命令加载的，某些还需要对MyCat进行重启，后期还会有MyCat高可用方案避免重启对应用程序的影响。</p></li><li><p>查看数据节点：<code>show @@datanode</code></p><p>查看MyCat中配置的节点详情</p></li><li><p>查看后端数据库：<code>show @@datasource</code></p><p>查看MyCat后端的物理数据库的详情</p></li><li><p>查看后端数据库连接：<code>show @@backend</code></p><p>查看MyCat后端的数据库的连接情况</p></li></ul><h2 id="第4章-MyCAT日志分析"><a href="#第4章-MyCAT日志分析" class="headerlink" title="第4章 MyCAT日志分析"></a>第4章 MyCAT日志分析</h2><blockquote><p>通过学习MyCAT日志，掌握MyCAT运行时的相关信息以及应用日志对MyCAT运行时的错误进行跟踪处理。</p></blockquote><h3 id="4-1-MyCAT日志"><a href="#4-1-MyCAT日志" class="headerlink" title="4-1 MyCAT日志"></a>4-1 MyCAT日志</h3><p>配置MyCat日志：</p><ul><li><p>MyCat使用Apache log4j项目管理日志</p></li><li><p>MyCat配置文件：conf/log4j2.xml</p></li></ul><p>log4j2.xml作用</p><ul><li><p>配置日志格式</p><pre><code class="xml">&lt;PatternLayout&gt;    &lt;Pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [%t] - %m%n&lt;/Pattern&gt;&lt;/PatternLayout&gt;</code></pre><pre><code class="log">2019-07-07 15:22:02.485 DEBUG [Timer1] - con query sql:select user() to con:MySQLConnection</code></pre><p>注：</p><ul><li>%d：定义时间。如：2019-07-07 15:22:02.485</li><li>%5p：日志级别。如：DEBUG</li><li>%t：线程信息。如：[Timer1]</li><li>%m：代码提示信息。如：con query sql:select user() to con:MySQLConnection</li><li>%n：回车符</li></ul></li><li><p>配置日志级别</p><ul><li><p><code>&lt;asyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot; /&gt;</code></p></li><li><p>ALL &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</p></li><li><p>注：</p><ul><li>一般设置Debug模式，最强也就是Info类型</li></ul></li></ul></li></ul><h3 id="4-2-MyCAT日志"><a href="#4-2-MyCAT日志" class="headerlink" title="4-2 MyCAT日志"></a>4-2 MyCAT日志</h3><ol><li><p>MyCat启动过程中输出的日志</p><pre><code class="log">10:45:06.377 INFO [ WrapperSimpleAppMain]-total resouces of dataHost nodel is:310:45:06.389 INFO [ WrapperSimpleAppMain]-create layer cache pool TableID2DataNodeCache of type encache, default cache size 10000, default expire seconds1800010:45:06.391 INFO [ WrapperSimpleAppMain]-create child Cache: TESTDB_ORDERS for layered cache TableID2DataNodeCache, size 50000, expire seconds 1800010:45:06.523 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from ehcache. xml found in the classpath: file:/usr/1ocal/mycat/conf/ehcache. xml10:45:06.525 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from URL: file:/usr/1ocal/mycat/conf/ehcache. xmll10:45:06.525 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from InputStream10:45:06.652 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xmlns: mycat10:45:06.653 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xmlns: xsi10:45:06.653 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute maxEntriesLocalHeap10:45:06.656 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xsi: noNamespaceSchemalocation10:45:06.689 DEBUG [ WrappersimpleAppMain]-Creating new CacheManager with default config10:45:06.723 DEBUG [ WrapperSimpleAppMain]-propertiesstring is null.10:45:06.812 DEBUG[ WrapperSimpleAppMain]-Cacheuriter factory not configured. Skipping...10:45:06.812 DEBUG [ WrappersimpleAppMain]-Initialized net. sf. ehcache. store. NotifyingMemoryStore for SQLRouteCache10:45:06.813 DEBUG [ WrappersimpleAppMain]-Initialised cache: SQLRouteCache10:45:06.828 INFO [ WrappersimpleAppMain]-dyna class load from./catlet, and auto check for class file modified every 60 seconds10:45:06.830 DEBUG [ WrappersimpleAppMain]-baseDir./tmlogs/10:45:06.830 DEBUG[ WrappersimpleAppMain]-baseName tmlog</code></pre><p>注：</p><ul><li>total resouces of dataHost nodel is:3。3个主机节点</li></ul></li><li><p>MyCat线程数</p><pre><code class="log">10:45:06.875 INFO[ WrapperslimpleAppMain]-MyCat is ready to startup.….10:45:06.875 INFO [ WrappersimpleAppMain]-Startup processors..., total processors:48, aio thread pool size:96each process allocated socket buffer pool bytes,a page size:2097152 a page&#39;s chunk number(Pagesize/Chunksize) is:512buffer page&#39;s number is:960</code></pre><p>注：</p><ul><li>total processors:48。线程数为48，默认为线程数等于CPU核数。</li><li>aio thread pool size:96。aio进程池数量为CPU核数的两倍</li></ul></li><li><p>server.xml中配置MyCat的启动参数</p><pre><code class="log">10:45:06.875 INFO[ WrapperSimpleAppMain]-sysconfig params: Systemconfig[processorBufferLocalPercent=100,frontSocketSoRcvbuf=1048576,frontSocketSoSndbuf=4194304,backSocketSoRcvbuf=4194384,backSocketSosndbuf=1048576,frontSocketNoDelay=1,backSocketNoDelay=1,maxStringLiteralLength=65535,frontwriteQueueSize=2048,bindIp=0.0.0.0,serverPort=3306,managerPort=9066,charset=utf8,processors=48,processorExecutor=96,timerExecutor=2,managerExecutor=2,idleTimeout=1800000,catletC1assCheckSeconds=60,sqlExecuteTimeout=300,processorCheckPeriod=1000,dataNodeIdleCheckPeriod=300000,dataNodeHeartbeatPeriod=10000,clusterHeartbeatUser=HEARTBEAT_USER_,clusterHeartbeatPass=_HEARTBEAT_PASS_,clusterHeartbeatPeriod=5000,clusterHeartbeatTimeout=10000,clusterHeartbeatRetry=10,txIsolation=3,parserCommentVersion=50148,sq1RecordCount=10,bufferPoolPageSize=2097152,bufferPoolChunkSize=4096,bufferPoolPageNumber=960,maxResultSet=524288,bigResultsizesqlCount=10,bufferUsagePercent=80,flowControlRejectStrategy=0,clearBigSqLResultSetMapMS=600000,defaultMaxLimit=100,sequnceHandlerType=2,mutiNodeLimitType=e,mutiNodePatchSize=100,defaultSqlParser=druidparser,usingArO=0,packetHeaderSize=4,maxPacketsize=16777216,mycatNodeId=1]</code></pre><p>注：</p><ul><li>serverPort=3306。MyCat对外提供服务的端口号</li><li>managerPort=9066。MyCat管理端口</li><li>charset=utf8。MyCat默认字符集</li><li>processors=48。MyCay进程数</li><li>processorExecutor=96。MyCay进程池大小</li><li>idleTimeout=1800000。应用程序与MyCat连接超时时间</li><li>defaultMaxLimit=100。MyCat默认返回结果集行数</li><li>maxPacketsize=16777216。最大包大小，一定不能大于在MySQL中配置的大小。</li></ul></li><li><p>MyCat监听端口的启动</p><pre><code class="log">10:45:08.158 INFO [WrapperSimpleAppMain]-using nio network handler10:45:08.224 INFO [WrapperSimpleAppMain]-$ MyCatManager is started and listening on 906610:45:08.224 INFO[WrappersimpleAppMain]-$_MyCatserver is started and listening on 3306</code></pre></li><li><p>MyCat对后端连接池的初始化</p><pre><code class="log">10:45:08.224 INFO[WrapperSimpleAppMain]-============================10:45:08.224 INFO[WrapperSimpleAppMain]-Initialize dataHost...10:45:08.224 INFO[WrappersimpleAppMain]-init datahost:nodel to use datasource index:110:45:08.225 INFO[WrappersimpleAppMain]-init backend myqsl source，create connections total 10 for 192.168.13.4 index:110:45:08.226 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.227 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.228 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.229 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.271 INFO[$_NIOREACTOR-1-RW]-connected successfuly MysQLConnection[id=1, 1astTime=1520217908270, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233481, harset=utf8, txIsolat ion=3, autocommit=true, attachment=nul1, respHandler=null, host=192.168.13.4, port=3306, statussync=null, uriteQueue=e, modifiedSQLExecuted=false]10:45:08.271 INFO[$_NIOREACTOR-5-RW]-connected successfuly MysQLConnection[id=5, 1astTime=152021790827e, er=imuser, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233482, harset=utf8, txIsolat ion=3, autocommit=true, attachment=nul1, respHandler=nul1, host=192.168.13.4, port=3306, statussync=null, writeQueue=0, modifiedSQLExecuted=false]</code></pre></li><li><p>MyCat初始化完成之后的输出</p><pre><code class="log">10:45:08.334 INFO [WrapperSimpleAppMain]-init result :finished 10 success 10 target count:1010:45:08.334 INFO [WrappersimpleAppMain]-nodel index:1 init success</code></pre></li><li><p>MyCat对后端数据库进行心跳检测</p><pre><code class="log">10:45:08.347 INFO [ Timer1]-no ilde connection in pool, create new connection for 192.168.13.3 of schema user db10:45:08.348DEBUG[ Timer1]-con query sql: select user() to con: MysQLConnection [ id=2, 1astTime=1520217908348, iser=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233483, charset=utf8, txIsol ation=3, autocommit=true, attachment=nul1, respHandler=nul1, host=192.168.13.4, port=3306, statussync=null, writeQueue=0,m odifiedSQLExecuted=false]10:45:08.348 INFO[$_NIOREACTOR-11-RW]-connectionAcquired MySQLConnection [ id=11,1astTime=1520217908348, er=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=true, threadId=2233490, charset=utf8, txIsolatio1=3, autocommit=true, attachment=nul1, respHandler=null, host=192.168,13.4, port=3306, statussync=nul1, writeQueue=e, modif iedSQLExecuted=false]10:45:08.373 INFO [ Timer1]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db18:45:08.377 DEBUG[$_NTOREACTOR-12-RW]-con query sql: select user() to con: MysQLconnection [ id=12, lastTime=1520217908377, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=908148, charset=utf8, txIsolation=3, autocommit=true, attachment=nul1, respHandler=nu11, host=192.168.13.3, port=3306, statusSync=nul1, wri teQueue=e, modifiedSQLExecuted=false]</code></pre></li><li><p>应用程序登录到MyCat输出的信息</p><pre><code class="log">14:16:48.257 INFO[$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB]&#39;root&#39; login success14:16:48.259 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show databases14:16:48.260 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show tables14:16:48.260 DEBUG[$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show tables, route={    1-&gt;dnl{ show tables}} rrs</code></pre></li><li><p>向MyCat发送一条SQL语句输出的日志</p><pre><code class="log">14:16:48.262 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] select * from customer_login where login_name=&#39; John Miller14:16:48.263 DEBUG[$_NIOREACTOR-7-RW]-SQLRouteCache miss cache, key: USERDB select * from customer_1ogin where login_name=&#39;John Miller&#39;14:16:48.263 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] select * from customer_login where 1ogin_name=&#39; John Miller&#39;, route={    1-&gt; dnl{ select * from customer_login where login_name=&#39; John Miller}} rrs</code></pre></li><li><p>具体SQL执行过程</p><pre><code class="log">14:16:48.263 DEBUG [$_NIOREACTOR-7-RW]-select read source 192.168.13.4 for dataHost: nodel14:16:48.265 DEBUG[$_NIOREACTOR-13-RW]-release connection MySQLConnection [ id=13,1astTime=1520230608256, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=true, threadId=2233491, charset=utf8, txIsolation=3, autocommit=true, attachment=dnl{ select * from customer_login where login_name=&#39; John Miller&#39;}, respHandler=SingleNodeHandler [ node=dn1{ select * from customer_login where login_name=&#39;John Miller&#39;}, packetId=8], host=192.168.13.4, port=3306, statussync=null, writeQueue=0, modifiedSQLExecuted=false]</code></pre></li></ol><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>本章节主要对课程中涉及到的全部知识点进行知识总结。并介绍进一步学习MyCAT的学习途径。</p></blockquote><h3 id="5-1-总结"><a href="#5-1-总结" class="headerlink" title="5-1 总结"></a>5-1 总结</h3><p>已学内容：</p><ul><li>MyCat起源</li><li>MyCat基本概念</li><li>如何安装、启动、配置MyCat</li><li>利用MyCat实现对后端数据库的读写分离</li><li>MyCat主要功能和应用场景</li></ul><p>未讲内容：</p><ul><li>如何利用MyCat对后端数据库进行分片</li><li>如何对分片集群进行备份</li><li>分片集群中宕机一台服务器会有什么影响</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>993-MySQL集群（PXC）入门</title>
      <link href="/2019/07/05/993-MySQL-PXC/"/>
      <url>/2019/07/05/993-MySQL-PXC/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/993" target="_blank" rel="noopener">https://www.imooc.com/learn/993</a></p><p>简介：本课程以项目演示为例，讲解PXC集群原理、PXC数据同步与Replication同步的区别、PXC的多节点并发写入、Docker虚拟机部署MySQL集群，并以案例验证Replication方案的数据不一致性、PXC方案数据一致性</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p> 本章总体介绍本课程学习的目标和学到的知识。</p></blockquote><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1-1 引言"></a>1-1 引言</h3><p>引言：</p><ul><li><p>伴随互联网经济的兴起，越来越多的领域需要相应的技术方案</p></li><li><p>行业：打车软件、电商平台、直播平台、电子支付、媒体社交</p></li><li><p>案例：滴滴出行、淘宝/京东、斗鱼直播、支付宝/微信、QQ</p></li></ul><p>单机单节点数据库没有冗余设计，如果数据库节点挂掉（断电、断网），则全部不能使用（网站不能访问）</p><p>使用冗余设计，即数据库节点集群在一起，性能翻倍。数据库集群。</p><p><strong><em>向BAT高标准看齐。</em></strong></p><h3 id="1-2-天猫双十一案例"><a href="#1-2-天猫双十一案例" class="headerlink" title="1-2 天猫双十一案例"></a>1-2 天猫双十一案例</h3><p>天猫双十一：</p><ul><li>2017年天猫双11交易额1682亿元，3分钟破百亿，9小时破干亿</li><li>交易峰值32.5万/秒，支付峰值25.6万/秒，数据库峰值4200万/秒</li><li>云服务器、负载均衡、RDS云数据库等技术</li></ul><p>淘宝/天猫使用3000+台数据库</p><h3 id="1-3-微信红包案例"><a href="#1-3-微信红包案例" class="headerlink" title="1-3 微信红包案例"></a>1-3 微信红包案例</h3><p>微信红包：</p><ul><li>2017年除夕当天，全国人民总共收发142亿个红包，峰值42万/秒</li><li>央视春晚微信摇一摇互动总量达110亿次，峰值8.1亿/秒</li><li>请求排队串行化、双维度分库表等设计</li></ul><h3 id="1-4-技术学习的目标和方式"><a href="#1-4-技术学习的目标和方式" class="headerlink" title="1-4 技术学习的目标和方式"></a>1-4 技术学习的目标和方式</h3><p>技术学习的目标和方式</p><ul><li>向大型互联网应用看齐，学习架构设计和业务处理</li><li>由浅入深，循序渐进；案例由小到大，逐步扩展</li><li>“视频学习”优于“看书学习”</li></ul><h3 id="1-5-课程学习目标"><a href="#1-5-课程学习目标" class="headerlink" title="1-5 课程学习目标"></a>1-5 课程学习目标</h3><p>本门课程学习目标</p><ul><li><p>掌握PXC集群MySQL方案的原理</p></li><li><p>掌握PXC集群的强一致性</p></li><li><p>掌握PXC集群的高可用方案</p></li></ul><h3 id="1-6-硬件环境介绍"><a href="#1-6-硬件环境介绍" class="headerlink" title="1-6 硬件环境介绍"></a>1-6 硬件环境介绍</h3><p>硬件环境需求</p><ul><li>Win10×64专业版或企业版/Linux/MacOS</li><li>Docker虚拟机</li><li>内存8GB以上</li></ul><pre><code class="shell">docker ps -apxc * 3 + haproxy * 1</code></pre><h2 id="第2章-PXC原理"><a href="#第2章-PXC原理" class="headerlink" title="第2章 PXC原理"></a>第2章 PXC原理</h2><blockquote><p>本章介绍数据库集群的必要性，以项目演示在数据库集群、Tomcat集群、Redis集群、Nginx负载均衡的部署环境下，后台程序遇到各种宕机，但是后台程序仍然高可用，最后介绍PXC数据同步的原理。</p></blockquote><h3 id="2-1-单节点数据库的介绍"><a href="#2-1-单节点数据库的介绍" class="headerlink" title="2-1 单节点数据库的介绍"></a>2-1 单节点数据库的介绍</h3><p>数据库集群的必要性</p><p>单节点数据库的弊病：<br>情况说明</p><ul><li>大型互联网程序用户群体庞大，所以架构必须要特殊设计</li><li>单节点的数据库无法满足性能上的要求</li><li>单节点的数据库没有冗余设计，无法满足高可用</li></ul><p>单节点数据库压力测试：</p><ul><li><p>测试案例</p><pre><code class="mysql">mysqlslap -hlocalhost -uroot -p123456 -P3306# 并发量5000连接--concurrency=5000 --iterations=1 --auto-generate-sql--auto-generate-sql-load-type=mixed--auto-generate-sql-add-autoincrement--engine=innodb# 共测试5000条SQL语句--number-of-queries=5000--debug-info</code></pre></li><li><p>测试结果</p><pre><code class="bash">Benchmark    Running for engine innodb    Average number of seconds to run all queries: 0.234 seconds    Minimum number of seconds to run all queries:0.234 seconds    Maximum number of seconds to run all queries:0.234 seconds    Number of clients running queries:100    Average number of queries per client50Benchmark    Running for engine innodb    Average number of seconds to run all queries: 1.656 seconds    Minimum number of seconds to run all queries:1.656 seconds    Maximum number of seconds to run all queries:1.656 seconds    Number of clients running queries:500    Average number of queries per clien:10Benchmark    Running for engine innodb    Average number of seconds to run all queries: 2.187 seconds    Minimum number of seconds to run all queries:2.187 seconds    Maximum number of seconds to run all queries:2.187 seconds    Number of clients running queries:1000    Average number of queries per client:5</code></pre><p>并发100、500和1000个连接，执行5000次查询，单节点数据还可以正常应对，没有太大的问题。</p><p>当并发10000个连接执行10000次查询，数据库则会拒绝一部分请求，仅完成另一部分接收的请求。</p></li></ul><h3 id="2-2-PXC集群方案"><a href="#2-2-PXC集群方案" class="headerlink" title="2-2 PXC集群方案"></a>2-2 PXC集群方案</h3><p>单节点数据库的高可用测试：</p><p>测试案例</p><ul><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifkl2e6j30jl08qwes.jpg"  width="350" alt="单节点数据库的高可用测试"/></li></ul><p>MySQL高性能高可用集群方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifm5x9cj31do0lo0wr.jpg"  width="600" alt="MySQL高性能高可用集群方案"/><p>MySQL单表数据量不能超过2000万条。性能极速下降。 </p><p>Mycat：国内主流数据切分中间件，阿里巴巴开源、Java编写、跨平台。</p><p>分片：利用Mycat切分后，一组集群就叫一个分片。</p><p>切分算法</p><ul><li><p>按照日期の（年份/月份/天）进行切分切分</p></li><li><p>按照某一列的固定值（主键ID，对分片数2求余）切分</p></li></ul><p>PXC–&gt;HA–&gt;Mycat</p><p>PXC数据读写是强一致性，但是牺牲了性能</p><h3 id="2-3-Replication集群方案"><a href="#2-3-Replication集群方案" class="headerlink" title="2-3 Replication集群方案"></a>2-3 Replication集群方案</h3><p>协同过滤算法：</p><ul><li>浏览记录会产生日志数据，将日志数据保存到数据库中。大数据算法根据日志数据分析当前用户行为，找出与之相同兴趣的用户，然后向当前用户推荐其他用户的喜好的商品、新闻。</li></ul><p>单条日志数据没有太大意义，而大量日志数据才有使用价值。此时便可以使用Replication集群。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifpe3gvj30u00by0tx.jpg"  width="600" alt="MySQL高性能高可用集群方案"/><p>应用软件数据架构：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifn0csaj30ff08mq37.jpg"  width="400" alt="应用软件数据架构"/><h3 id="2-4-系统架构方案介绍"><a href="#2-4-系统架构方案介绍" class="headerlink" title="2-4 系统架构方案介绍"></a>2-4 系统架构方案介绍</h3><p>互联网大型应用架构分析：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi4w17xoj31000jcjz7.jpg" alt="系统架构方案"></p><p>互联网大型应用技术分析：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi4xg1xfj30vk0k0k16.jpg" alt="系统架构方案"></p><h3 id="2-5-APP项目介绍"><a href="#2-5-APP项目介绍" class="headerlink" title="2-5 APP项目介绍"></a>2-5 APP项目介绍</h3><p>APP项目截图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifo5e3lj310e0h2q5l.jpg"  width="600" alt="APP项目截图"/><p>【登录界面】-【欢迎界面】-【人才招聘界面】</p><p>APP项目架构设计：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifjbscbj30s608y0tk.jpg"  width="600" alt="APP项目架构设计"/><p>服务器端微服务之间的调用实现：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifowc6lj30p708xwf7.jpg"  width="600" alt="服务器端微服务之间的调用实现"/><p>消息队列实现业务的解耦。</p><p>生产者不知道谁来接收这个消息，消费者也不知道是哪个生产者发来的消息。</p><p>消息队列的两个功能：</p><ol><li>异步消息发送。</li><li>利用异步消息发送，进行业务功能的解耦。即把不是强依赖，不是实时返回的功能做成消息队列，这样不管是调用方还是被调用方的改动，对另一方的依赖就会减小甚至消除。</li></ol><h3 id="2-6-Docker虚拟机部署MySQL集群"><a href="#2-6-Docker虚拟机部署MySQL集群" class="headerlink" title="2-6 Docker虚拟机部署MySQL集群"></a>2-6 Docker虚拟机部署MySQL集群</h3><p>查看正在运行的容器：</p><pre><code class="shell">docker ps -a</code></pre><h3 id="2-7-APP项目演示"><a href="#2-7-APP项目演示" class="headerlink" title="2-7 APP项目演示"></a>2-7 APP项目演示</h3><p>如果PXC集群中的主机挂掉的数目超过一半，则其它也不能提供服务</p><p>大学所储备知识做出的项目：</p><ol><li><p>性能不足</p></li><li><p>故障抵御能力不足</p></li></ol><h3 id="2-8-PXC简介"><a href="#2-8-PXC简介" class="headerlink" title="2-8 PXC简介"></a>2-8 PXC简介</h3><p>Percona XtraDB Cluster</p><ul><li>PXC通过Galera将不同的MySQL实例连接起来，实现多主机群</li><li>PXC基于Percona Server（性能较MySQL有显著提升）</li><li>PXC是众多MySQL集群方案的一种</li></ul><p>PXC方案与Replication方案对比：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gikqijyej30pt0g0my1.jpg"  width="400" alt="PXC方案"/><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gikprxo8j30hu0bvglz.jpg"  width="350" alt="Replication方案"/><h3 id="2-9-PXC测试案例"><a href="#2-9-PXC测试案例" class="headerlink" title="2-9 PXC测试案例"></a>2-9 PXC测试案例</h3><pre><code class="shell">docker pa -a</code></pre><p>PXC方案：</p><pre><code class="mysql"># node1CREATE DATABASE test;USE test;# node5CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);# node4INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;), (2, &quot;Jack&quot;);</code></pre><p>Replication方案：</p><pre><code class="mysql"># masterCREATE DATABASE test;USE test;CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student    SET id = 1, name = &quot;Scott&quot;;# slaveINSERT INTO student    SET id = 2, name = &quot;Jack&quot;;</code></pre><p>PXC集群的节点之间是双向同步，没有主从之分。</p><p>Replication是单向同步，只能由主节点同步到从节点，从节点也可以写入数据，但不会同步数据到主节点。</p><p>PXC双向同步从演示的耗时看比Replication慢6倍，一个insert约80多毫秒，replication只要10多毫秒。</p><h3 id="2-10-PXC集群工作原理"><a href="#2-10-PXC集群工作原理" class="headerlink" title="2-10 PXC集群工作原理"></a>2-10 PXC集群工作原理</h3><p>PXC集群工作原理：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifqb2j3j31b80rw76u.jpg"  width="800" alt="PXC集群工作原理"/><p>数据的同步是由PXC完成的。</p><p>数据库事务，指的是逻辑上的一组操作，组成这组事务的操作，要么全部不成功，要么全部成功。</p><p>一个事务若有多个操作，则需要手动开启事务。且要手动提交事务，才能将操作持久化到数据库。</p><h2 id="第3章-PXC数据强一致性"><a href="#第3章-PXC数据强一致性" class="headerlink" title="第3章 PXC数据强一致性"></a>第3章 PXC数据强一致性</h2><blockquote><p>本章介绍PXC和Replication两种集群方案在数据同步上的区别。</p></blockquote><h3 id="3-1-PXC与Replication方案优劣介绍"><a href="#3-1-PXC与Replication方案优劣介绍" class="headerlink" title="3-1 PXC与Replication方案优劣介绍"></a>3-1 PXC与Replication方案优劣介绍</h3><p>PXC的数据强一致性：</p><ul><li>同步复制，事务在所有集群节点要么同时提交，要么不提交</li><li>Replication采用异步复制，无法保证数据的一致性</li></ul><p>PXC和Replication方案优劣：</p><ul><li><p>Replication写入速度快，但是不能保证数据的一致性</p><p>异步复制，分为master节点和slave节点。</p><p>master节点写入数据提交事务后，即返回结果给客户端，不管slave节点的数据是否一致。</p></li><li><p>PXC可以保证数据的一致性，但是写入速康慢</p><p>PXC的数据强一致性牺牲了速度为代价。</p><p>节点间同步复制数据，将事务执行结果返回给客户端。</p></li><li><p>PXC和Replication只实现了数据的同步，没有数据切分功能</p></li></ul><p>PXC与Replication两种方案结合：</p><ol><li>重要数据保存在PXC集群。</li><li>非重要数据（操作的记录）保存在Replication集群</li></ol><p>当MySQL单表数据量超过2000万条时，性能会急剧下降，所以需要进行数据切分，即利用两个甚至多个集群来存储不同的数据</p><p>阿里巴巴开源中间件MyCat可以将两个集群做数据切分</p><h3 id="3-2-PXC与Replication方案性能对比"><a href="#3-2-PXC与Replication方案性能对比" class="headerlink" title="3-2 PXC与Replication方案性能对比"></a>3-2 PXC与Replication方案性能对比</h3><p>PXC和Replication方案性能对比：</p><ul><li>2016年春节，微信红包支付峰值15.8万次/秒，创下世界纪录</li><li>2017天猫双11，数据库峰值4200万次/秒，支付峰值25.6万次/秒</li></ul><p>PXC集群注意：</p><ol><li><p>PXC集群规模不能太大</p></li><li><p>PXC集群性能瓶颈不在于性能最好的节点，而在于性能最差的节点</p><p>尽量保证节点的配置一致</p></li></ol><p>PXC和Replication组合方案：</p><ul><li><p>PXC方案存储高价值数据，如：账户、订单、交易等等</p></li><li><p>Replication方案存储低价值数据，如：权限、通知、日志等等</p></li><li><p>用MyCat或JDBC-Sharding切分数据管理集群</p><p>按照主键ID值、年月日、某一字段等等进行切分</p></li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifk38zsj30h505iq32.jpg"  width="400" alt="PXC集群工作原理"/><p>MyCat本身也需要高可用、需冗余设计。</p><p>搭建两个MyCat，再用Linux的虚拟IP技术虚拟一个IP供客户端程序访问，再由两个MyCat去争抢这个虚拟IP，如果哪个MyCat挂了，另一个MyCat就会接收到这个IP继续提供服务。</p><h3 id="3-3-案例验证Replication方案的数据不一致性"><a href="#3-3-案例验证Replication方案的数据不一致性" class="headerlink" title="3-3 案例验证Replication方案的数据不一致性"></a>3-3 案例验证Replication方案的数据不一致性</h3><p>案例介绍：</p><ul><li><p>搭建一组两节点的Replication集群</p></li><li><p>使用MyCat实现Master和Slave节点的读写分离</p></li><li><p>设置防火墙网络规则，Master和Slave之间禁止访问，断开同步</p><p>注：</p><ul><li>MyCat默认端口8066</li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifj5gsbj30s608y0tk.jpg"  width="400" alt="Replication方案案例介绍"/></li></ul><p>步骤：</p><ol><li><p>在Master创建数据库、数据表，同时插入两条数据：</p><pre><code class="mysql"># masterCREATE DATABASE test;USE test;CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;), (2, &quot;Jack&quot;);</code></pre><p>MyCat配置文件介绍：</p><pre><code class="xml">&lt;!-- schema.xml --&gt;&lt;dataHost describe=&quot;配置数据库连接&quot;&gt;    &lt;heartbeat describe=&quot;心跳检测，实时检测MySQL节点是否有效。如果MySQL节点挂掉，则向冗余节点发送请求&quot;&gt;    &lt;/heartbeat&gt;    &lt;writeHost describe=&quot;写节点。Master&quot;&gt;        &lt;readHost describe=&quot;读节点。Slave&quot;&gt;&lt;/readHost&gt;    &lt;/writeHost&gt;&lt;/dataHost&gt;</code></pre></li><li><p>在MyCat查询数据表可以查看到两条数据：</p><pre><code class="mysql"># MyCatSELECT * FROM student;</code></pre></li><li><p>关闭Master与Slave之间的同步设置：</p><p>同步操作是在Slave节点配置的。</p><pre><code class="mysql"># slaveSHOW SLAVE STATUS;# Salve_IO_Running Slave_SQL_Running# YES               YESSTOP SLAVE;# Salve_IO_Running Slave_SQL_Running# NO               NO</code></pre></li><li><p>在MyCat插入一条数据：</p><pre><code class="mysql"># MyCatINSERT INTO student(id, name)VALUES(3, &quot;admin&quot;);</code></pre></li><li><p>在MyCat查询数据表可以查看到只有两条数据，无步骤4中插入的数据</p><pre><code class="mysql"># MyCatSELECT * FROM student;</code></pre></li></ol><h3 id="3-4-案例验证PXC方案数据一致性"><a href="#3-4-案例验证PXC方案数据一致性" class="headerlink" title="3-4 案例验证PXC方案数据一致性"></a>3-4 案例验证PXC方案数据一致性</h3><p>案例介绍：</p><ul><li><p>搭建一组三节点的PXC集群</p></li><li><p>使用MyCat实现PXC节点的读写分离</p></li><li><p>设置防火墙网络规则，PXC之间禁止访问，断开同步</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifnems7j30f50863yn.jpg"  width="400" alt="Replication方案案例介绍"/></li></ul><pre><code class="shell"># 查看正在运行的容器docker ps -a# 进入node1数据库节点docker exec -it node1 bashiptables -A INPUT -p tcp --dport 4444 -j DROPiptables -A OUTPUT -p tcp --dport 4444 -j DROPiptables -A INPUT -p tcp --dport 4567 -j DROPiptables -A OUTPUT -p tcp --dport 4567 -j DROPiptables -A INPUT -p tcp --dport 4568 -j DROPiptables -A OUTPUT -p tcp --dport 4568 -j DROP# 进入node2数据库节点...# 进入node3数据库节点...</code></pre><h2 id="第4章-PXC的多节点并发写入"><a href="#第4章-PXC的多节点并发写入" class="headerlink" title="第4章 PXC的多节点并发写入"></a>第4章 PXC的多节点并发写入</h2><blockquote><p>本章介绍并演示PXC多节点并发写入和HaProxy高可用方案</p></blockquote><h3 id="4-1-PXC多节点并发写入"><a href="#4-1-PXC多节点并发写入" class="headerlink" title="4-1 PXC多节点并发写入"></a>4-1 PXC多节点并发写入</h3><p>多节点并发写入：</p><ul><li>PXC集群没有主从节点之分，任何节点都是可读可写的</li><li>Replication集群的主节点（写节点）宕机，从节点不能自动升级为主节点</li><li>Replication集群必须为主节点设置冗余节点，而PXC不必这样</li></ul><p>案例测试：</p><ul><li>利用Java程序向三节点的PXC集群每个节点同时写入数据</li><li>程序执行结束之后，查看每个节点的数据是否同步正确</li><li>得出PXC多节点并发写入的结论</li></ul><p>Java线程：</p><pre><code class="java">// MyThread.java@Dataclass MyThread extends Thread {    String url;    String username;    String pas sword;    String threadName;    override run() {        var con = DriverManager.getConnection(url, username, password);        var pst = con.prepareStatement(&quot;INSERT INTO student(name) VALUES (?)&quot;);        for(i : 1 ... 50) {            pst.setobject(1, threadName);            pst.execute;            Thread.sleep(5000);        }        con.close();        println(&quot;线程执行结束&quot;);    }}</code></pre><pre><code class="java">// Test.javaclass Test {    def static void main(String[] args) {        var t1=new MyThread(&quot;jdbc: mysq1://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        var t2=new MyThread(&quot;jdbc: mysql://127.0.0.1:3307/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        var t3=new MyThread(&quot;jdbc: mysql://127.0.0.1:3308/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        t1. start();        t2. start();        t3. start();    }}</code></pre><p>Java语法严谨、但啰嗦。</p><p>IBM开发了Xtend、SUN发开了Groovy、Kotlin等都扩展简化Java语法</p><h3 id="4-2-PXC多节点并发写入案例"><a href="#4-2-PXC多节点并发写入案例" class="headerlink" title="4-2 PXC多节点并发写入案例"></a>4-2 PXC多节点并发写入案例</h3><p>在已设置ID主键自增的情况下，为何PXC多节点并发写入的主键值不连续？</p><ul><li>多个节点并发写入时同时生成了相同的ID主键值，此时去同步其他数据库节点会因为ID值被占用而驳回同步，需要重新生成一个ID主键值后再发起同步请求。如：A节点用了主键2，B节点也 用了主键2，这个时候同步就不能进行，然后B节点就用了主键3，A节点就用了主键4。</li></ul><p>如何避免主键值不连续？</p><ul><li>将主键生成任务从数据库本地移交给数据库集群中间件，如MyCat。从而避免冲突，不连续</li></ul><p>验证PXC多节点并发写入数据库节点的数据是否同步成功：</p><pre><code class="mysql"># node1/node2/node3use test;SELECT COUNT(*) FROM student;</code></pre><p>同时多节点并发（三线程）写入50条记录，最终有150条记录。</p><p>PXC集群多节点并发写入验证数据的强一致性。</p><h3 id="4-3-Haproxy高可用方案介绍"><a href="#4-3-Haproxy高可用方案介绍" class="headerlink" title="4-3 Haproxy高可用方案介绍"></a>4-3 Haproxy高可用方案介绍</h3><p>Haproxy高可用方案：</p><ul><li><p>PXC节点可读可写，应该采用负载均衡技术管理这些节点</p></li><li><p>程序设计中，数据源接口应该单一，对接负载均衡中间件</p></li><li><p>Haproxy是著名的负载均衡中间件，很适合负载均衡PXC集群</p><p>注：</p><ul><li>NGINX可实现Tomcat的负载均衡，是基于HTTP协议的。最近新版NGINX才支持TCP/IP协议，产品还不够成熟。</li><li>故使用Haproxy做数据库集群的负载均衡。</li></ul></li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifqpcfyj30ho0ajq3e.jpg"  width="400" alt="Haproxy高可用方案"/><p>PXC集群最好是奇数数量（最少要三个节点），PXC集群可能出现脑裂的情况</p><h3 id="4-4-Haproxy高可用案例1"><a href="#4-4-Haproxy高可用案例1" class="headerlink" title="4-4 Haproxy高可用案例1"></a>4-4 Haproxy高可用案例1</h3><pre><code class="shell"># 查看正在运行的容器实例docker ps -a</code></pre><pre><code class="cfg"># haproxy.cfg# 配置管理画面listen admin_stats  # 管理信息的名字。可随意        bind 0.0.0.0:8888  # 管理画面的IP与端口，任何IP地址均可访问。        mode http  # 网络协议使用HTTP        stats uri /dbs  # 访问URI        stats realm Global\ statistics        stats auth admin:admin  # 管理画面的登录账号密码# 负载均衡listen proxy-mysql  # 负载均衡的名字。可随意        bind 0.0.0.0:3306  # 负载均衡的入口IP与端口，任何IP地址均可访问。        mode tcp  # 网络协议使用TCP。MySQL默认为TCP协议，不能为HTTP协议        balance roundrobin  # 使用轮询的方式去分发请求（分发权重）        option tcplog  # 记录日志        option mysql-check user haproxy  # 定期发送心跳检测，‘haproxy’为Haproxy容器的用户名        server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000        server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000        server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000        option tcpka</code></pre><h3 id="4-5-Haproxy高可用案例2"><a href="#4-5-Haproxy高可用案例2" class="headerlink" title="4-5 Haproxy高可用案例2"></a>4-5 Haproxy高可用案例2</h3><pre><code class="mysql"># haproxyCREATE DATABASE test;USE test;CREATE TABLE student (    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>867-Docker入门</title>
      <link href="/2019/06/29/867-Docker/"/>
      <url>/2019/06/29/867-Docker/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/867" target="_blank" rel="noopener">https://www.imooc.com/learn/867</a></p><p>简介：本课程从最基础的安装开始，通过大量的实际操作循序渐进地介绍Docker基本知识。从最基本的镜像、容器开始，学习Dockerfile编写，容器操作，到完成一个多容器的应用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程简介"><a href="#第1章-课程简介" class="headerlink" title="第1章 课程简介"></a>第1章 课程简介</h2><blockquote><p>介绍Docker以及安装方式</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>Docker简介：</p><blockquote><p>Docker是容器技术的代表。<br>容器技术本质上是<strong>将程序隔离、打包的一个技术</strong>。</p></blockquote><p>解决问题：</p><blockquote><p><strong>解决软件包安装的问题</strong><br>理顺了开发与运维环境的差异，使开发和运维可以使用同一种语言进行沟通</p></blockquote><p>Docker入门教程</p><blockquote><p>Docker简介：什么是Docker<br>镜像与容器<br>容器存储<br>Registry<br>多容器app</p></blockquote><p>面向用户</p><blockquote><p>对docker感兴趣的。开发、测试、运维</p></blockquote><p>预备知识</p><blockquote><p>linux命令行<br>bash shell脚本</p></blockquote><h3 id="1-2-Docker介绍"><a href="#1-2-Docker介绍" class="headerlink" title="1-2 Docker介绍"></a>1-2 Docker介绍</h3><p>什么是Docker</p><blockquote><p>Docker: an open source project to pack, ship and run any application as a lightweight container.<br>是一个开源的项目，可以使任何应用以轻量级的形式打包、发布和运行</p><p>Node. js: allows to package an application with all of its dependencies into a standardized unit.<br>允许一个应用程序及其所有依赖以一种标准的单位来进行打包</p></blockquote><blockquote><p>Docker 是一个开源的应用容器引擎，开发者可以打包他们的应用以及依赖包到一个可移植的容器中，<br>然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>与现有技术进行类比</p><blockquote><p>可以粗糙地理解为轻量级的虚拟机<br>开挂的chroot（chroot：对应用程序作了文件系统的分离）</p></blockquote><p>Docker与虚拟机：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif4j6saj30mq0dbdgu.jpg"  width="450" alt="Docker与虚拟机"/><p>注：</p><ul><li>左边为虚拟机，右边为Docker</li><li>Hypervisor层：虚拟出硬件</li><li>Guest OS：硬件上安装完全独立的Guest OS</li><li>Docker Engine：利用Namespace、Control Group将应用程序分离</li><li>Docker没有Hypervisor虚拟层，会轻量很多</li></ul><h3 id="1-3-docker-mac安装"><a href="#1-3-docker-mac安装" class="headerlink" title="1-3 docker mac安装"></a>1-3 docker mac安装</h3><ul><li><p>下载</p><blockquote><p>官网地址：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>下载安装包：<a href="https://www.docker.com/docker-windows" target="_blank" rel="noopener">https://www.docker.com/docker-windows</a></p></blockquote></li><li><p>安装</p><blockquote><p>打开docker<br>open Docker.dmg或双击Docker.dmg<br>将Docker拖到Applications里面</p><p>验证安装：docker info</p></blockquote></li><li><p>配置</p><blockquote><p>镜像加速：</p><p>【Preferences…】=&gt;【Advanced】=&gt;【Registry mirrors】</p></blockquote></li></ul><h3 id="1-4-docker-linux安装"><a href="#1-4-docker-linux安装" class="headerlink" title="1-4 docker linux安装"></a>1-4 docker linux安装</h3><pre><code class="shell">## Ubuntu# 安装docker本身sudo wget -qO- https://get.docker.com | sh# 允许非root用户运行dockersudo usermod -aG docker tyk# 验证安装docker info</code></pre><p>注：</p><ul><li>-q：标识输出要简单</li><li>O-：标识标准输出，而不是输出到文件</li></ul><pre><code class="shell">## CentOS7# 系统 CentOS-Extras 库中已带 Docker，可以直接安装：sudo yum install docker# 安装之后启动Docker服务，并让它随系统启动自动加载。sudo service docker startsudo chkconfig docker on</code></pre><h3 id="1-5-docker-windows安装"><a href="#1-5-docker-windows安装" class="headerlink" title="1-5 docker windows安装"></a>1-5 docker windows安装</h3><ul><li><p>下载</p><blockquote><p>官网地址：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>下载安装包：<a href="https://www.docker.com/docker-windows" target="_blank" rel="noopener">https://www.docker.com/docker-windows</a></p></blockquote></li><li><p>安装</p><blockquote><p>执行安装包：Docker for Windows Installer.exe</p><p>验证安装：docker info</p></blockquote></li><li><p>配置</p><blockquote><p>镜像加速：</p><p>【settings】=&gt;【Daemon】=&gt;【Registry mirrors】</p></blockquote></li></ul><h2 id="第2章-实践第一步"><a href="#第2章-实践第一步" class="headerlink" title="第2章 实践第一步"></a>第2章 实践第一步</h2><blockquote><p>创建第一个Hello world</p></blockquote><h3 id="2-1-docker架构介绍与实战"><a href="#2-1-docker架构介绍与实战" class="headerlink" title="2-1 docker架构介绍与实战"></a>2-1 docker架构介绍与实战</h3><p>Docker架构：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif53qczj30mm0cowfg.jpg"  width="600" alt="Docker架构"/><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif5kicqj30ha0b63yu.jpg"  width="400" alt="Docker架构"/><p> 使用ubuntu镜像，在里面运行了echo hello docker这个命令，输出就是hello docker</p><pre><code class="shell">docker run ubuntu echo hello docker    </code></pre><p>运行NGINX服务器：</p><pre><code class="shell">docker run nginx</code></pre><p>查看本地镜像：</p><pre><code class="shell">docker images</code></pre><p>运行daocloud.io/nginx镜像：</p><pre><code class="shell">docker run -d -p 8080:80 daocloud.io/nginx</code></pre><p>注：</p><ul><li>-d：使用守护进程启动</li><li>-p：端口映射，将nginx的80端口映射到本地的8080端口</li></ul><p>查看当前正在运行的容器：</p><pre><code class="shell">docker ps</code></pre><p>显示Docker相关信息的页面：</p><pre><code class="shell"># 将文件拷贝到Docker容器。# 将index.html文件拷贝到容器ID为17asdasdasa容器内部，路径为//usr/share/nginx/html# docker cp 文件 容器ID:容器内部文件路径docker cp index.html 17add7bbc58c://usr/share/nginx/html</code></pre><p>停止指定容器：</p><pre><code class="shell">docker stop 容器ID</code></pre><p><a href="https://www.runoob.com/docker/docker-commit-command.html" target="_blank" rel="noopener"><strong>保存容器为镜像</strong></a>：</p><blockquote><p>Docker在容器内的改动都是暂时的，没有被保存</p></blockquote><pre><code class="shell"># # 保存容器为镜像，镜像名为nginx-fundocker commit -m &#39;fun&#39; 容器ID nginx-fun</code></pre><p>删除指定镜像：</p><pre><code class="shell">docker rmi 镜像ID</code></pre><p>查看所有容器（正在运行和停止运行）：</p><pre><code class="shell">docker ps -a</code></pre><p>删除指定容器：</p><pre><code class="shell">docker rm 容器ID</code></pre><p>命令小结：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>docker pull</td><td>获取image</td></tr><tr><td>docker build</td><td>创建image</td></tr><tr><td>docker images</td><td>列出image</td></tr><tr><td>docker run</td><td>运行container</td></tr><tr><td>docker ps</td><td>列出正在运行的container</td></tr><tr><td>docker rm</td><td>删除container</td></tr><tr><td>docker rmi</td><td>删除image</td></tr><tr><td>docker cp</td><td>在host和container之间拷贝文件</td></tr><tr><td>docker commit</td><td>保存改动为新的image</td></tr></tbody></table><h2 id="第3章-Dockerfile介绍"><a href="#第3章-Dockerfile介绍" class="headerlink" title="第3章 Dockerfile介绍"></a>第3章 Dockerfile介绍</h2><blockquote><p>编写dockerfile</p></blockquote><h3 id="3-1-dockerfile介绍"><a href="#3-1-dockerfile介绍" class="headerlink" title="3-1 dockerfile介绍"></a>3-1 dockerfile介绍</h3><blockquote><p>通过编写简单的文件自创docker镜像</p></blockquote><p>第一个Dockerfile：</p><pre><code class="dockerfile">FROM alpine:latestMAINTAINER tyk 766564616@qq.comCMD echo &#39;hello docker&#39;</code></pre><p>注：</p><ul><li>依赖于基础镜像alpine:latest</li><li>标识镜像信息</li><li>需要运行的命令</li></ul><pre><code class="shell">mkdir dockerfile1cd dockerfile1# 产生一个Dockerfile文件touch Dockerfile# 编辑Dockerfile文件vim Dockerfile# 构建docker镜像docker build -t hello_docker .# 查看已安装Docker镜像docker images hello_docker# 运行Docker镜像docker run hello_docker</code></pre><p>注：</p><ul><li>-t：参数指定镜像名称</li><li>最后面的点（.）表示构建镜像文件的路径</li></ul><h3 id="3-2-dockerfile实战"><a href="#3-2-dockerfile实战" class="headerlink" title="3-2 dockerfile实战"></a>3-2 dockerfile实战</h3><p>第二个Dockerfile：</p><pre><code class="dockerfile"># 依赖于基础镜像ubuntuFROM ubuntu# 标识镜像信息MAINTAINER tyk 766564616@qq.com# 运行ubuntu命令，新增一个软件仓库镜像地址RUN sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list# 运行ubuntu命令，更新软件RUN apt-get update# 运行ubuntu命令，安装nginx。-y：默认yes不询问RUN apt-get install -y nginx# 拷贝本地文件到镜像内部COPY index.html /var/www/html# 将NGINX在前台启动ENTRYPOINT [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]# 镜像暴露服务的端口EXPOSE 80</code></pre><pre><code class="shell">mkdir dockerfile2cd dockerfile2touch Dockerfilevim Dockerfiletouch index.htmlvim index.htmldocker build -t 766564616/hello-nginx .docker run -d -p 80:80 766564616/hello-nginx使用curl进行测试curl http://localhost</code></pre><p>Dockerfile语法：</p><table><thead><tr><th>命令</th><th>用途</th><th>说明</th><th>是否必填</th></tr></thead><tbody><tr><td>FROM</td><td>base_image</td><td>指明基础镜像名称。</td><td>必填</td></tr><tr><td>RUN</td><td>执行命令</td><td>用于执行命令，当RUN执行完毕后，将产生一个新的文件层。</td><td>可选</td></tr><tr><td>ADD</td><td>添加文件</td><td>向镜像添加文件。可以添加远程文件</td><td>可选</td></tr><tr><td>COPY</td><td>拷贝文件</td><td>从主机向镜像复制文件。</td><td>可选</td></tr><tr><td>CMD</td><td>执行命令</td><td>指定此镜像启动时默认执行命令。容器执行入口</td><td>可选</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>用于指定需要暴露的网络端口号。</td><td>可选</td></tr><tr><td>WORKDIR</td><td>指定路径</td><td>设定此镜像后续操作的默认工作目录。</td><td>可选</td></tr><tr><td>MAINTAINER</td><td>维护者</td><td>可用于提供作者、版本及气他备注信息。</td><td>可选</td></tr><tr><td>ENV</td><td>设定环境变量</td><td>用于在镜像中添加环境变量。</td><td>可选</td></tr><tr><td>ENTRYPOINT</td><td>容器入口</td><td>在镜像中设定默认执行的二进制程序。容器执行入口</td><td>可选</td></tr><tr><td>USER</td><td>指定用户</td><td>在镜像构建过程中，生成或者切换到另一个用户。</td><td>可选</td></tr><tr><td>VOLUME</td><td>mount point</td><td>向镜像中挂载一个卷组。</td><td>可选</td></tr></tbody></table><h3 id="3-3-镜像分层"><a href="#3-3-镜像分层" class="headerlink" title="3-3 镜像分层"></a>3-3 镜像分层</h3><blockquote><p>Dockerfile中的每一行都产生一个新层</p></blockquote><pre><code class="dockerfile">FROM alpine:latest        4dffsd5454wqMAINTAINER tyk766564616   fbdfasdfasfd554CMD echo &#39;hello docker&#39;   3df545dfad4a</code></pre><p>每个命令都是单独保存的一层。只有容器层是RW，镜像中的各层都是RO</p><p>分层的好处：假如有很多container或者很多的Image，相同的镜像层会复用共享。一定程度上减小了储存空间的使用，运行起来方便。</p><h2 id="第4章-存储"><a href="#第4章-存储" class="headerlink" title="第4章 存储"></a>第4章 存储</h2><blockquote><p>对volume进行介绍</p></blockquote><h3 id="4-1-volume介绍"><a href="#4-1-volume介绍" class="headerlink" title="4-1 volume介绍"></a>4-1 volume介绍</h3><blockquote><p>提供独立于容器之外的持久化存储</p></blockquote><p>应用场景：</p><blockquote><p>比如数据库，可以将数据存储在容器外的分卷。</p><p>可以提供容器跟容器之间的数据共享。</p></blockquote><h3 id="4-2-volume操作"><a href="#4-2-volume操作" class="headerlink" title="4-2 volume操作"></a>4-2 volume操作</h3><p>第一种形式：</p><blockquote><p>Docker虚拟路径挂载到容器里面的路径</p></blockquote><pre><code class="shell">docker run -v 容器内部地址 镜像名称</code></pre><pre><code class="shell"># 运行nginx容器，通过-v挂载一个卷组docker run -d --name nginx -v /usr/share/nginx/html nginx# 查看指定容器信息# docker inspect 容器名称docker inspect nginx# 查看Mounts节点下的Sources节点和Destination节点信息# 该容器把宿主机的Sources对应目录挂载到容器内部的Destination的目录地址cd Sources对应的目录路径# 修改index.html文件echo &quot;it&#39;s 2016&quot; &gt; index.html# 进入到容器内部# docker exec -it 容器名称 /bin/bashdocker exec -it nginx /bin/bash# cd Destination对应的路径路径# 查看index.html文件cat index.html# 打印出刚刚修改后的内容，即挂载成功，映射关系正确</code></pre><p>第二种形式：</p><blockquote><p>本地目录挂载到容器里面的路径</p></blockquote><pre><code class="shell">docker run -v $PWD/code:/var/www/html nginx</code></pre><pre><code class="shell">docker run -d -p 80:80 -v $PWD/html:/usr/share/nginx/html nginx# 查看本地文件的内容cat html/index.html# 进入到容器内部docker exec -it 容器名称 /bin/bash# 发现其内容和本地文件的内容一致，即映射关系正确cat /usr/share/nginx/html/index.html</code></pre><p>第三种形式</p><blockquote><p>创建数据卷容器，将其挂载到其他容器</p></blockquote><pre><code class="shell">docker run --volumes-from 卷容器ID</code></pre><p>好处：</p><blockquote><p>可以多个容器挂载一个数据容器，实现数据共享</p></blockquote><pre><code class="shell">mkdir data# 产生一个仅有数据的容器docker create -v $PWD/data:/var/mydata --name data_container ubuntu# 从另外一个容器挂载， 运行并直接进入容器内部docker run -it --volumes-from data_container ubuntu /bin/basemounttouch /var/mydatawhatever.txtexit# 查看本地data目录下是否有whatever.txt文件ls data</code></pre><h2 id="第5章-镜像仓库"><a href="#第5章-镜像仓库" class="headerlink" title="第5章 镜像仓库"></a>第5章 镜像仓库</h2><blockquote><p>registry介绍与实战</p></blockquote><h3 id="5-1-registry介绍"><a href="#5-1-registry介绍" class="headerlink" title="5-1 registry介绍"></a>5-1 registry介绍</h3><p>Docker相关术语：</p><table><thead><tr><th>English</th><th>中文</th></tr></thead><tbody><tr><td>host</td><td>宿主机</td></tr><tr><td>image</td><td>镜像</td></tr><tr><td>container</td><td>容器</td></tr><tr><td>registry</td><td>镜像仓库</td></tr><tr><td>daemon</td><td>守护程序</td></tr><tr><td>client</td><td>客户端</td></tr></tbody></table><p>Registry相关命令：</p><pre><code class="shell"># 从镜像仓库中搜索指定镜像docker search image_name# 从镜像仓库中拉取指定镜像docker pull image_name# 将本地镜像推送到镜像仓库docker push image_name</code></pre><p>国内的一些镜像仓库：</p><blockquote><p>daocloud<br>时速云<br>阿里云</p></blockquote><h3 id="5-2-registry实战"><a href="#5-2-registry实战" class="headerlink" title="5-2 registry实战"></a>5-2 registry实战</h3><pre><code class="shell"># 在镜像仓库中搜索whalesaydocker search whalesay# 从镜像仓库中拉取镜像docker/whalesay到本地docker pull docker/whalesay# 查看本地镜像信息docker images# 运行docker/whalesay镜像，并指定参数docker run docker/whalesay cowsay Docker so fun# 在push之前，需要登录。默认登录到docker hubdocker login# 依赖docker/whalesay镜像产生新的766564616/whalesay镜像（类似复制）docker tag docker/whalesay 766564616/whalesay# 将镜像766564616/whalesay推送到镜像仓库docker push 766564616/whalesay# 到dockerhub官方地址，查看到自己push的镜像# https://hub.docker.com/</code></pre><h2 id="第6章-多容器app"><a href="#第6章-多容器app" class="headerlink" title="第6章 多容器app"></a>第6章 多容器app</h2><blockquote><p>介绍多容器app与实例</p></blockquote><h3 id="6-1-compose介绍"><a href="#6-1-compose介绍" class="headerlink" title="6-1 compose介绍"></a>6-1 compose介绍</h3><p>多容器app</p><blockquote><p>编写文本文件，文件描述多容器APP的结构然后通过工具docker-compose把它拉起来</p></blockquote><blockquote><p>docker-compose是独立的软件</p></blockquote><p>docker-compose安装：</p><blockquote><p>Mac/Windows：自带</p><p>Linux：curl <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p></blockquote><h3 id="6-2-compose-install-linux"><a href="#6-2-compose-install-linux" class="headerlink" title="6-2 compose-install-linux"></a>6-2 compose-install-linux</h3><p><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a></p><pre><code class="shell"># 下载docker-compose包到/usr/local/bin/docker-composecurl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/docker-compose# 给/usr/local/bin/docker-compose授可执行权限chmod +x /usr/local/docker-compose    # 验证安装docker-compose --version</code></pre><pre><code class="shell">uname -s# Linux$ uname -m# x86_64</code></pre><h3 id="6-3-compose实战"><a href="#6-3-compose实战" class="headerlink" title="6-3 compose实战"></a>6-3 compose实战</h3><p>实战案例介绍</p><blockquote><p>app名称：ghost<br>是一个博客平台程序，安装之后，可自己写文章或别人发布<br>架构：nginx、ghost app、mysql<br>分别分为三个容器</p></blockquote><p>docker-compose.yml文件</p><pre><code class="yaml">ghost-app:   build: ghost  depends_on:     - db  ports:     - &quot;2368:2368&quot;nginx:   build: nginx  ports:     - &quot;80:80&quot;  depends_on:     - ghost-appdb:   images: &quot;mysql:5.7.15&quot;</code></pre><p>实战操作：</p><pre><code class="shell"># ghost根路径mkdir ghostcd ghost# 存放Dockerfile和配置文件用来构建镜像mkdir ghostmkdir nginx# 存放博客的数据mkdir data</code></pre><ol><li><p>ghost镜像构建</p><pre><code class="shell"># /ghost# ghost镜像构建cd ghosttouch Dockerfilevim Dockerfile...touch config.jsvim config.js...</code></pre><pre><code class="dockerfile">### Dockerfile #### 依赖ghost官方镜像FROM ghost# 拷贝本地配置文件到镜像中COPY ./config.js /var/lib/ghost/config.js# 声明暴露服务的端口EXPOSE 2368# 执行启动命令。ghost为node.js程序，所以使用npm命令CMD [&quot;npm&quot;,&quot;start&quot;,&quot;--production&quot;]</code></pre><pre><code class="javascript">&lt;!-- config.js --&gt;var path = require(&#39;path&#39;),config;config = {    production: {        url:&#39;http://mytestblog.com&#39;,        mail: {},        database: {            client: &#39;mysql&#39;,            connection: {                host: &#39;db&#39;,                user: &#39;ghost&#39;,                password: &#39;ghost&#39;,                database: &#39;ghost&#39;,                port: &#39;3306&#39;,                charset: &#39;utf8&#39;            },            debug: false        },        paths: {            contentPath: path.join(process.env.GHOST_CONTENT,&#39;/&#39;)        },        server: {            host: &#39;0.0.0.0&#39;,            port: &#39;2368&#39;        }    }};module.exports = config;</code></pre></li><li><p>NGINX镜像构建</p><pre><code class="shell"># /ghostcd nginxtouch Dockerfilevim Dockerfile...touch nginx.confvim nginx.conf...</code></pre><pre><code class="dockerfile">### Dockerfile #### 依赖nginx官方镜像FROM nginx# 拷贝本地配置文件到镜像中COPY nginx.conf /etc/nginx/nginx.conf# 声明暴露服务的端口EXPOSE 80</code></pre><pre><code class="nginx">### nginx.conf ###worker_processes 4;events {worker_connections 1024;}http {    server {        listen 80;        location / {            proxy_pass http://ghost-app:2368;        }    }}</code></pre></li><li><p>准备compose文件，用于描述整个系统的架构</p><pre><code class="shell"># /ghosttouch docker-compose.ymlvim docker-compose.yml</code></pre><pre><code class="yaml">### docker-compose.yml ###version: &#39;2&#39;networks:     ghost: services:     ghost-app:         build: ghost        networks:             - ghost        depends_on:             - db        ports:             - &quot;2368:2368&quot;    nginx:         build: nginx        networks:             - ghost        depends_on:             - ghost-app        ports:             - &quot;80:80&quot;    db:         image: &quot;mysql:5.7.15&quot;        networks:             - ghost        environment:             MYSQL_ROOT_PASSWORD: 123456            MYSQL_USER: ghost            MYSQL_PASSWORD: ghost        volumes:             - $PWD/data:/var/lib/mysql        ports:             - &quot;3306:3306&quot;</code></pre></li><li><p>拉起系统</p><pre><code class="shell"># /ghost# 启动docker-compose up -d# 关闭docker-compose stop# 删除docker-compose rm# 构建docker-compose build</code></pre></li><li><p>访问<a href="http://localhost、http://localhost/ghost" target="_blank" rel="noopener">http://localhost、http://localhost/ghost</a></p></li></ol><h3 id="6-4-章节回顾"><a href="#6-4-章节回顾" class="headerlink" title="6-4 章节回顾"></a>6-4 章节回顾</h3><p>docker-compose.yml常用命令：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>build</td><td>本地创建镜像</td></tr><tr><td>command</td><td>覆盖缺省命令</td></tr><tr><td>depends_on</td><td>连接容器，服务依赖</td></tr><tr><td>ports</td><td>暴露端口</td></tr><tr><td>volumes</td><td>挂载卷组</td></tr><tr><td>image</td><td>拉取镜像</td></tr></tbody></table><p>docker-compose命令：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>up</td><td>启动服务</td></tr><tr><td>stop</td><td>停止服务</td></tr><tr><td>rm</td><td>删除服务中的各个容器</td></tr><tr><td>logs</td><td>观察各个容器中的日志</td></tr><tr><td>ps</td><td>列出服务相关的容器</td></tr></tbody></table><h2 id="第7章-总结"><a href="#第7章-总结" class="headerlink" title="第7章 总结"></a>第7章 总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="7-1-课程总结"><a href="#7-1-课程总结" class="headerlink" title="7-1 课程总结"></a>7-1 课程总结</h3><blockquote><p>Docker介绍：容器、镜像<br>如何制作镜像<br>如何分享镜像<br>如何持久化容器数据<br>如何编排一个多容器的应用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>824-第一个docker化的java应用</title>
      <link href="/2019/06/21/824-docker-java/"/>
      <url>/2019/06/21/824-docker-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/824" target="_blank" rel="noopener">https://www.imooc.com/learn/824</a></p><p>简介：Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。学完本课程你将了解到什么是docker，docker的思想以及诸如镜像，仓库，容器等核心概念。你将学会怎样运行一个容器，如何搭建私有仓库，怎么写dockerfile以及怎样把自己的应用放到容器中运行。docker将会是你的IT路上一笔不小的财富。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>对docker有个简单的印象，了解课程的安排。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>docker解决企业大部分痛点：</p><blockquote><ol><li>快速的持续集成</li><li>服务的弹性伸缩 </li><li>部署简单，解放了运维 </li><li>为企业节省了机器资源</li></ol></blockquote><p>课程内容：</p><ul><li><p>什么是Docker?</p><p>对Docker的认识，Docker的历史，初步介绍</p></li><li><p>理解Docker</p><p>Docker的核心理论、思想，解决了什么实际问题</p></li><li><p>走进Docker</p><p>Docker的具体技术</p></li><li><p>HelloWorld</p></li><li><p>Nginx服务</p><p>Docker命令、Docker网络</p></li><li><p>Docker化的Java Web</p></li></ul><h3 id="1-2-什么是docker"><a href="#1-2-什么是docker" class="headerlink" title="1-2 什么是docker"></a>1-2 什么是docker</h3><p>Docker历史</p><ul><li>2010 dotCloud PAAS</li><li>2013 docker开源</li><li>2014.6 Docker 1.0</li><li>2014.7 C轮 $4000万</li><li>2015.4 D轮 $9500万</li><li>至今Docker 1.13</li></ul><p><a href="http://docker.com" target="_blank" rel="noopener">Docker官网</a></p><p>什么是Docker</p><blockquote><p>Docker是一个用来装应用的容器，就像被子可以装水，笔筒可以放笔，书包可以放书一样，可以把Hello World放在Docker里，可以把网站放在Docker里，可以把程序放在Docker里。</p></blockquote><ul><li>docker是世界领先的软件容器化平台（Docker is the world’s leading software containerization<br>platform）</li><li>docker公司开发，开源，托管在github上</li><li>跨平台，支持Windows、Macos、Linux</li></ul><h2 id="第2章-了解docker"><a href="#第2章-了解docker" class="headerlink" title="第2章 了解docker"></a>第2章 了解docker</h2><blockquote><p>用形象的类比说明docker的集装箱、标准化、隔离的思想。在用几个工作学习中碰到的问题说明docker解决了哪些问题。</p></blockquote><h3 id="2-1-docker思想"><a href="#2-1-docker思想" class="headerlink" title="2-1 docker思想"></a>2-1 docker思想</h3><ul><li><p>集装箱：容器</p><p>保证我们的程序放在任何地方都不会缺少东西</p></li><li><p>标准化</p><ul><li><p>运输方式</p><p>Docker运输程序有一个超级码头。A B两台电脑，A执行Docker命令把鲸鱼派过来把A的程序送到超级码头，在由B执行Docker命令由鲸鱼把程序从超级码头送过来</p></li><li><p>存储方式</p><p>不需要再关系拷贝过来的应用存在哪里 只需要在Docker 执行命令</p></li><li><p>API接口</p><p>Docker提供了一系列的RESTFUL API接口，包含了对Docker也就是对应用的控制，其中包括停止 查看 删除等等</p><p>只需要在Docker执行同样的命令 就可以控制所有的应用</p></li></ul></li><li><p>隔离：轻量级容器虚拟机技术</p><p>利用Linux内核LXC技术，能够非常快速地创建docker容器</p><p>最底层的技术实际上是一种Linux的一种内核的限制机制（LXC，Linux Container）。LXC是一种轻量级的容器虚拟化技术，最大效率的隔离了进程和资源，通过CGroup 、Namespace等限制隔离进程组所使用的物理资源，如CPU 、I/O 、Memory等等。</p><p>容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求</p></li></ul><h3 id="2-2-docker解决了什么问题"><a href="#2-2-docker解决了什么问题" class="headerlink" title="2-2 docker解决了什么问题"></a>2-2 docker解决了什么问题</h3><ol><li><p>我本地运行没问题啊。</p><p>一个Java Web程序要启动起来需要依赖什么？</p><ol><li><p>操作系统</p><p>调用了操作系统不一致的系统命令</p></li><li><p>JDK</p><p>JDK版本，如：JDK1.7编译的class文件在JDK1.6上运行</p></li><li><p>Tomcat</p><p>Tomcat版本，旧版本配置可能在新版本中不再支持</p></li><li><p>代码</p><p>比如代码引用了磁盘上（C盘）的一个文件，系统环境编码</p></li><li><p>配置文件</p><p>可能少了某些配置文件</p></li></ol><p>docker解决了运行环境不一致带来的问题。</p></li><li><p>系统好卡，哪个哥们又写死循环了。</p><p>docker的隔离性，使自己运行的程序不受其他程序的影响。</p></li><li><p>双11来了，服务器撑不住啦。</p><p>docker的标准化让快速扩展，弹性伸缩变得简单。</p></li></ol><h2 id="第3章-走进docker"><a href="#第3章-走进docker" class="headerlink" title="第3章 走进docker"></a>第3章 走进docker</h2><blockquote><p>结合上面的类比引出docker的核心技术：镜像、仓库和容器的概念，并分别深入讲解技术、原理。</p></blockquote><h3 id="3-1-docker核心技术"><a href="#3-1-docker核心技术" class="headerlink" title="3-1 docker核心技术"></a>3-1 docker核心技术</h3><p>核心概念</p><ul><li>镜像：集装箱</li><li>仓库：超级码头</li><li>容器：运行程序的地方</li></ul><p>docker运行程序的过程</p><ul><li>去仓库把镜像运到本地，用命令把镜像运行起来变成容器。</li></ul><p>分别讲解核心概念</p><ul><li>Build：构建镜像</li><li>Ship：运输镜像，从仓库和主机上运输</li><li>Run：运行的镜像，就是容器</li></ul><h3 id="3-2-docker镜像"><a href="#3-2-docker镜像" class="headerlink" title="3-2 docker镜像"></a>3-2 docker镜像</h3><ol><li><p>docker镜像就是image。从本质上来说镜像就是一系列的文件（包括应用程序的文件，也包括应用环境的文件）。镜像以联合文件系统分层的形式保存到本地；</p></li><li><p>docker镜像：（docker中的文件系统都是只读的）</p></li></ol><p>Docker文件保存存储格式？</p><blockquote><p>联合文件系统（Union FS），联合文件系统是一种分层的文件系统，它可以将不同的目录挂到同一个虚拟的文件系统下面。</p><p>联合文件系统可以通过这种方式实现文件的分层，比如test1可以看做是第一层，test2可以看做是第二层，每一层有每一层自己的文件，Docker镜像就是利用了这种分层的概念来实现了镜像存储。</p></blockquote><p>docker镜像的存储方式</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigviqm7j30eh0awaap.jpg" width="350" alt="Docker镜像"/><ul><li>最底层：操作系统的引导</li><li>上面一层：具体的Linux操作系统</li><li>上面一层：具体的软件，比如说JDK、Tomcat</li><li>上面一层：我们自己的应用代码</li><li>最上面一层：容器层</li></ul><h3 id="3-3-docker容器"><a href="#3-3-docker容器" class="headerlink" title="3-3 docker容器"></a>3-3 docker容器</h3><ol><li>docker的容器可理解为一个进程（可以将容器想象为一个虚拟机）</li><li>docker容器中除了Container层可写外，其他层都是只读的</li><li>镜像的各层都是可读的，如果想对可读层进行修改操作，那么本层内容会传到可写层，然后再进行修改操作；</li><li>当我们的应用进行文件查找是会从最顶层可写层查找（因为可读层内容都传到可写层），如果可写层没有相应数据才会去可读层查找</li><li>容器中Container层可以修改（即可写），但是在镜像中Container层是不可以修改的，这样也就保证了同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰。</li></ol><h3 id="3-4-docker仓库"><a href="#3-4-docker仓库" class="headerlink" title="3-4 docker仓库"></a>3-4 docker仓库</h3><p>构建镜像的目的</p><blockquote><p>是为了在其机器上运行镜像程序。</p></blockquote><p>仓库的作用</p><blockquote><p>为了在其他地方运行，我们就需要将构建的镜像传递到目的地才可以，仓库可以起到传输传递作用。</p></blockquote><p>传输过程</p><blockquote><p>先将构建的镜像传到docker仓库中，再由目的地去docker仓库将我们的镜像拉过去，这样就完成了传输过程。</p></blockquote><p>docker仓库</p><ul><li>hub.docker.com（国际）</li><li>c.163.com（国内）</li></ul><h2 id="第4章-docker安装"><a href="#第4章-docker安装" class="headerlink" title="第4章 docker安装"></a>第4章 docker安装</h2><blockquote><p>分别在三中平台上讲解docker的安装。同学可以选择自己的平台观看。</p></blockquote><h3 id="4-1-window安装docker"><a href="#4-1-window安装docker" class="headerlink" title="4-1 window安装docker"></a>4-1 window安装docker</h3><p><a href="https://hub.docker.com/?overlay=onboarding" target="_blank" rel="noopener">https://hub.docker.com/?overlay=onboarding</a></p><p>查看Docker版本：</p><pre><code class="shell">docker version</code></pre><h3 id="4-2-macos安装docker"><a href="#4-2-macos安装docker" class="headerlink" title="4-2 macos安装docker"></a>4-2 macos安装docker</h3><p><a href="https://hub.docker.com/?overlay=onboarding" target="_blank" rel="noopener">https://hub.docker.com/?overlay=onboarding</a></p><h3 id="4-3-linux安装docker"><a href="#4-3-linux安装docker" class="headerlink" title="4-3 linux安装docker"></a>4-3 linux安装docker</h3><ul><li><p>Redhat&amp;CentOS：<br>系统要求：64-bit OS and version 3.10</p></li><li><p>Ubuntu</p><p>系统要求：64-bit OS and version 3.10</p></li></ul><blockquote><p>docker是在Linux的Ubuntu系统开发的，所以在Ubuntu系统是docker的最理想运行系统。</p></blockquote><p>Redhat&amp;CentOS：</p><pre><code class="shell"># 检查内核版本uname -r# 切换到root用户sudo# 保证系统为最新版本yum update# 卸载旧版本yum remove docker docker-common docker-selinux docker-engine# 安装Dockeryum install -y docker# 查看是否安装成功yum list installed | grep docker# 启动docker服务systemclt start docker# 查看是否启动成功systemclt status docker</code></pre><p>Ubuntu：</p><pre><code class="shell"># 检查内核版本uname -r# 切换到root用户su# 保证系统为最新版本apt-get update# 安装Dockerapt-get install -y docker.io# 安装Docker最新版本curl -s https://get.docker.com|sh# 是否安装成功(Client、Server)docker version# 启动Docker俯卧撑service docker start</code></pre><h2 id="第5章-docker初体验"><a href="#第5章-docker初体验" class="headerlink" title="第5章 docker初体验"></a>第5章 docker初体验</h2><blockquote><p>第一个实例：用helloworld镜像带入，熟悉docker最基本的两个命令，拉取镜像和运行容器，并讲解背后运行逻辑。</p></blockquote><h3 id="5-1-第一个docker镜像"><a href="#5-1-第一个docker镜像" class="headerlink" title="5-1 第一个docker镜像"></a>5-1 第一个docker镜像</h3><ol><li><p>从docker远程的仓库拉取镜像到本地</p><pre><code class="shell">docker pull [OPTIONS] NAME [:TAG]</code></pre><p>注：</p><ul><li>NAME项是必填，代表需要拉取的镜像名称</li><li>[:TAG]是可选的，代表镜像的版本</li><li>[OPTIONS]代表拉取的镜像参数</li></ul><p>例如：拉取hello-world镜像命令：</p><pre><code class="shell">docker pull hello-world</code></pre></li><li><p>查看我们本机都有哪些镜像，也可以验证我们的pull是否执行成功</p><pre><code class="shell">docker images [OPTIONS] [REPOSITORY[:TAG]]</code></pre><p>注：</p><ul><li>[OPTIONS]是镜像的参数</li><li>[REPOSITORY[:TAG]]是镜像的名称和版本</li></ul></li></ol><h3 id="5-2-第一个docker容器"><a href="#5-2-第一个docker容器" class="headerlink" title="5-2 第一个docker容器"></a>5-2 第一个docker容器</h3><p>运行docker镜像命令</p><pre><code class="shell">docker run [OPTIONS] IMAGE[:TAG][COMMAND] [ARG…]</code></pre><p>注：</p><ul><li>NAME项是必填，代表运行的镜像名称</li><li>[COMMAND]代表镜像运行的时候需要执行什么命令</li><li>[ARG…]代表命令所依赖的参数</li><li>[OPTIONS]代表运行的时候选项</li></ul><p>例如：运行hello-world镜像命令：</p><pre><code class="shell">docker run hello-world</code></pre><p>docker client 执行一条命令，然后根据命令内容发送相应的请求到 docker host，docker host 解析该请求，会首先查询本地镜像仓库是否有对应的资源，假如没有，则向远程镜像中心拉取镜像放回本地，接着在执行该镜像，初始化为一个容器。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigws3xnj30mi0bvmy6.jpg"  width="500" alt="Docker初体验"/><ol><li><p>Client ：本机的docker执行命令的客户端</p></li><li><p>DOCKER_HOST：本机docker服务</p></li><li><p>Registry：docker远程仓库</p></li></ol><p>docker pull 流程：</p><ul><li>在Client主机发出docker pull执行命令到DOCKER_HOST主机docker服务的Docker daemon中，Docker daemon会先在本机中寻找是否有相应的镜像，如果存在不进行任何操作，否则会从docker的远程仓库Registry中将相应的镜像拉取到本地服务</li></ul><p>docker run 流程：</p><ul><li>在Client主机发出docker run执行命令到DOCKER_HOST主机docker服务的Docker daemon中，Docker daemon会先在本机中寻找是否有相应的镜像，如果不存在则会从docker的远程仓库Registry中将相应的镜像拉取到本地服务，然后通过一定方式将镜像运行起来变成docker的容器。</li></ul><h2 id="第6章-docker运行nginx静态网站"><a href="#第6章-docker运行nginx静态网站" class="headerlink" title="第6章 docker运行nginx静态网站"></a>第6章 docker运行nginx静态网站</h2><blockquote><p>第二个实例：从运行nginx镜像引出docker网络概念和docker的端口映射，最后运行nginx容器。</p></blockquote><h3 id="6-1-运行nginx镜像"><a href="#6-1-运行nginx镜像" class="headerlink" title="6-1 运行nginx镜像"></a>6-1 运行nginx镜像</h3><p>运行NGINX：</p><ul><li>持久运行的容器</li><li>前台挂机 &amp; 后台运行</li><li>进入容器内部</li></ul><p>常用命令：</p><pre><code class="shell"># 查找Docker的nginx镜像docker search nginx# 获取Docker的nginx镜像docker pull nginx# 查看run的帮助信息docker run --help# 以后台运行方式运行docker镜像docker run -d nginx# 查看正在运行的容器docker ps# 查看运行容器的内部信息docker exec# 查看容器指定容器ID（CONTAINER_ID）的信息docker exec -it CONTAINER_ID bash# 停止容器docker stop CONTAINER_ID</code></pre><h3 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6-2 docker网络"></a>6-2 docker网络</h3><blockquote><p>Docker使用了Linux的namespace技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Docker容器一般会分配一个独立的Network Namespace。</p></blockquote><p>docker网络：</p><ul><li><p>网络类型</p><ol><li><p>Bridge（桥接）：</p><p>docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</p></li><li><p>Host（主机）：</p><p>容器不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p></li><li><p>None（无网络）：</p><p>Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。docker将不会和外界的任何网络进行通讯。</p></li><li><p>container模式：</p><p>新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p></li></ol></li><li><p>端口映射</p><p>Bridge网络模式需要使用独立的Namespace，就需要容器内的端口可以在主机上访问，这就是端口映射。</p><p>Docker可以指定容器内的某个端口与容器所在主机的某个端口进行映射，此时访问主机的端口就是访问容器内的端口</p></li></ul><p>docker网络示意图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigwe5jlj30ll0arwfn.jpg"  width="350" alt="Docker网络"/><p>运行nginx镜像，并指定主机的端口：</p><pre><code class="shell">docker run -d -p 8080:80 nginx</code></pre><p>注：</p><ul><li>使用 –p 参数，冒号前面为主机端口，后面为容器端口。</li></ul><p>docker开放所有随机端口映射到容器上：</p><pre><code class="shell">Docker run -d -P nginx</code></pre><p>查看网络端口信息：</p><pre><code class="shell">netstart -na | grep 8080</code></pre><h2 id="第7章-第一个java-web应用"><a href="#第7章-第一个java-web应用" class="headerlink" title="第7章 第一个java web应用"></a>第7章 第一个java web应用</h2><blockquote><p>最后一个实例：创建自己的镜像，引出dockerfile，讲解基本的dockerfile语法。然后讲解私有仓库的搭建。最后分别在两台机器上演示docker的跨平台运行我们的java web项目。</p></blockquote><h3 id="7-1-制作自己的镜像"><a href="#7-1-制作自己的镜像" class="headerlink" title="7-1 制作自己的镜像"></a>7-1 制作自己的镜像</h3><p><a href="https://segmentfault.com/a/1190000009237581" target="_blank" rel="noopener">Linux_基于Docker快速搭建个人博客网站</a></p><p>制作自己的镜像：</p><ul><li><p>dockerfile</p><p>是由一系列命令和参数构成的脚本。这些命令应用于基础镜像并最终创建一个新的镜像，简化了从头到尾的流程并极大的简化了部署工作。</p></li><li><p>docker build</p><p>用于使用Dockerfile创建镜像。</p></li><li><p>Jpress: <a href="http://jpress.io/" target="_blank" rel="noopener">http://jpress.io/</a></p><p>开源的java web应用。</p></li></ul><p>制作 JAVA WEB应用：</p><blockquote><p>dockerFile是docker镜像的创建脚本文件，告诉docker按照文件里的流程去创建镜像</p></blockquote><ul><li><p>创建Dockerfile文件</p><pre><code class="dockerfile"># 创建的镜像继承自指定的tomcatfrom tomcat# 创建镜像人的信息，可不写MAINTAINER tyk 766564616@qq.com# COPY  [本地war包]  [指定的tomcat/webapps/下]COPY jpress.war /usr/local/tomcat/webapps</code></pre></li><li><p>构建镜像，并把镜像命名为jpress</p><pre><code class="shell"># 执行这个Dokerfile脚本文件docker build -t jpress:latest .</code></pre><p>注：</p><ul><li>-t：构建镜像的名字</li><li>.：dockerfile文件的目录，.代表当前目录下</li></ul></li></ul><h3 id="7-2-运行自己的容器"><a href="#7-2-运行自己的容器" class="headerlink" title="7-2 运行自己的容器"></a>7-2 运行自己的容器</h3><p>启动构建好的镜像：</p><pre><code class="shell">docker run -d -p 8888:8080 jpress</code></pre><p>查看端口是否被占用：</p><pre><code>netstat -na|grep 8888</code></pre><p>安装mysql：</p><pre><code>docker pull mysql</code></pre><p>创建数据库并启动mysql：</p><pre><code>docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jpress mysql</code></pre><p>配置jpress：</p><p>查看本机实际IP地址：</p><pre><code>ifconfig</code></pre><p>上传至dockerhub</p><pre><code class="shell"># 登录docker login -u 用户名 -p 密码# docker push [用户名]/[镜像名]:[版本]docker push 766564616/jpress:latest# 登出docker logout</code></pre><h2 id="第8章-课程总结"><a href="#第8章-课程总结" class="headerlink" title="第8章 课程总结"></a>第8章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="8-1-课程总结"><a href="#8-1-课程总结" class="headerlink" title="8-1 课程总结"></a>8-1 课程总结</h3><ul><li><p>思想：集装箱、标准化，隔离</p></li><li><p>镜像（BUILD）、容器（SHIP）、仓库（RUN）</p></li><li><p>docker命令pull，build，run，stop，restart，exec…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
