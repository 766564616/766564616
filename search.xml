<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>553-JDK11&amp;12 新特性解读</title>
      <link href="/imooc/553-jdk11&amp;12/"/>
      <url>/imooc/553-jdk11&amp;12/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/553" target="_blank" rel="noopener">https://www.imooc.com/learn/553</a></p><p>简介：Java 语言如今已被广泛应用到科技行业的各个领域，成为当前最热门的计算机语言之一。Java 语言版本更新速度很快，每个新版本都能或多或少的影响当前的开发模式。学习 Java 新版本的特性，能够更加清晰的了解 Java 未来的发展方向，以及梳理编程的思想。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>本章将介绍课程的整体内容、课程安排以及JDK 与 OpenJDK 的关系。</p></blockquote><h3 id="1-1-课程介绍-04-02"><a href="#1-1-课程介绍-04-02" class="headerlink" title="1-1 课程介绍 (04:02)"></a>1-1 课程介绍 (04:02)</h3><ul><li><p>OpenJDK与JDK的区别</p><p>通常所说的JDK是指SUN或者Oracle JDK，商业实现。开源只用于研究使用</p><p>OpenJDK是指开源项目，软件源安装的都是OpenJDK</p></li><li><p>多版本JDK的安装和配置</p></li><li><p>JDK11新特性介绍及演示</p></li><li><p>JDK12新特性介绍及演示</p></li></ul><h3 id="1-2-OpenJDK-与-JDK-的区别-x264-04-47"><a href="#1-2-OpenJDK-与-JDK-的区别-x264-04-47" class="headerlink" title="1-2 OpenJDK 与 JDK 的区别_x264 (04:47)"></a>1-2 OpenJDK 与 JDK 的区别_x264 (04:47)</h3><ul><li><p>OpenJDK与JDK之间的关系</p><p>OpenJDK是JDK的开放源代码版本</p></li><li><p>OpenJDK与JDK之间的区别</p><p><strong>授权协议不同</strong>、OpenJDK不包含部署功能、OpenJDK源代码不完整</p><p>部分源代码使用开源代码替换、OpenJDK只包含最精简的JDK、不能使用Java商标</p></li></ul><h3 id="1-3-初识-JDK11-和-JDK12-的新特性-x264-03-21"><a href="#1-3-初识-JDK11-和-JDK12-的新特性-x264-03-21" class="headerlink" title="1-3 初识 JDK11 和 JDK12 的新特性_x264 (03:21)"></a>1-3 初识 JDK11 和 JDK12 的新特性_x264 (03:21)</h3><ul><li><p>什么是JEP（Java Enhancement Proposals）</p></li><li><p>JEP发布地址</p><p>JDK11：<a href="http://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">http://openjdk.java.net/projects/jdk/11/</a></p><p>JDK12：<a href="http://openjdk.java.net/projects/jdk/12/" target="_blank" rel="noopener">http://openjdk.java.net/projects/jdk/12/</a></p></li><li><p>JDK11重要的新特性</p><p>JEP181:基于嵌套的访问控制、JEP309:动态类文件常量、JEP315:改进Aarch64内部函数</p><p>JEP321:标准HTTP客户端、JEP323:本地变量Lambda语法、JEP327:Unicode10</p><p>JEP330:启动单文件源代码程序、JEP333:可伸缩低延迟垃圾收集器</p></li><li><p>JDK11其他新特性</p><p>JEP318:无操作垃圾收集器、JEP320:移除JavaEE和CORBA模块、JEP324:Curve25519和448算法的密钥协议</p><p>JEP328:Flight Recorder、JEP329:ChaCha20和Poly1305加密算法、JEP331:低开销的Heap Profiling</p><p>JEP332:支持TLS1.3、JEP335:弃用Nashorn JavaScript引擎、JEP336:弃用Pack200工具和API</p></li><li><p>JDK12重要的新特性</p><p>JEP230:微基准测试、JEP325:增强的switch语句、JEP341:默认的类数据共享</p><p>JEP344:可中止的G1垃圾收集器、JEP346:G1归还未使用的内存</p></li><li><p>JDK12其他新特性</p><p>JEP189:低暂停的垃圾收集器-Shenandoah、JEP334:JVM常量API、JEP340:保留Aarch64端口</p></li></ul><h2 id="第2章-多版本-JDK-的安装和配置"><a href="#第2章-多版本-JDK-的安装和配置" class="headerlink" title="第2章 多版本 JDK 的安装和配置"></a>第2章 多版本 JDK 的安装和配置</h2><blockquote><p>本章将介绍 JDK11、12 的下载和安装，以及多版本 JDK 在一台机器上的配置，做到方便切换 JDK 版本。友情提示：安装和配置过程面向 Linux 和 Mac OS，Windows 系统可以参考下载资料中的相关文档。</p></blockquote><h3 id="2-1-安装-JDK11-和-JDK12-x264-06-47"><a href="#2-1-安装-JDK11-和-JDK12-x264-06-47" class="headerlink" title="2-1 安装 JDK11 和 JDK12_x264 (06:47)"></a>2-1 安装 JDK11 和 JDK12_x264 (06:47)</h3><ul><li><p>下载安装文件：<a href="http://jdk.java.net/archive/" target="_blank" rel="noopener">http://jdk.java.net/archive/</a></p><pre><code class="shell">wget https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_osx-x64_bin.tar.gzwget https://download.java.net/java/GA/jdk12.0.2/e482c34c86bd4bf8b56c0b35558996b9/10/GPL/openjdk-12.0.2_osx-x64_bin.tar.gz</code></pre><p>注：直接使用JDK14学习本课程，JDK8为默认的开发环境。</p></li><li><p>配置环境变量：JAVA_HONE和PATH</p><pre><code class="java">vim ~/.bash_profile</code></pre><pre><code class="shell">export JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home&quot;export PATH=$PATH:$JAVA_HOME/bin</code></pre></li><li><p>重新加载配置文件：source命令</p><pre><code class="shell">source ~/.bash_profile</code></pre></li><li><p>查看JDK版本信息：java -version</p></li></ul><h3 id="2-2-配置多版本-JDK-x264-06-40"><a href="#2-2-配置多版本-JDK-x264-06-40" class="headerlink" title="2-2 配置多版本 JDK_x264 (06:40)"></a>2-2 配置多版本 JDK_x264 (06:40)</h3><ul><li><p>设置多版本环境变量：JAVA_8_HOME、JAVA_11_HOME、JAVA_12_HOME</p><pre><code class="shell">export JAVA_8_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home&quot;export JAVA_14_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk-14.0.1.jdk/Contents/Home&quot;</code></pre></li><li><p>配置默认环境变量：JAVA_HOME</p><pre><code class="shell">export JAVA_HOME=$JAVA_8_HOMEexport PATH=$PATH:$JAVA_HOME/bin</code></pre></li><li><p>设置命令别名，动态切换JDK版本：alias</p><pre><code class="shell">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;alias jdk14=&quot;export JAVA_HOME=$JAVA_14_HOME&quot;</code></pre></li><li><p>查看JDK版本信息：java -version</p></li></ul><h2 id="第3章-JDK11-新特性介绍及演示"><a href="#第3章-JDK11-新特性介绍及演示" class="headerlink" title="第3章 JDK11 新特性介绍及演示"></a>第3章 JDK11 新特性介绍及演示</h2><blockquote><p>本章中将介绍 JDK11 中的新特性，部分核心特性会结合代码演示操作，帮助同学们更好的理解。</p></blockquote><h3 id="3-1-基于嵌套的访问控制-11-31"><a href="#3-1-基于嵌套的访问控制-11-31" class="headerlink" title="3-1 基于嵌套的访问控制 (11:31)"></a>3-1 基于嵌套的访问控制 (11:31)</h3><blockquote><p>JEP181:基于嵌套的访问控制</p></blockquote><p>摘要：在private、public、protected的基础上，JVM又提供了一种新的访问控制机制：Nest</p><p>目标：如果在一个类中嵌套了多个子类，那么子类中可以访问彼此的私有成员</p><p>代码实例：</p><pre><code class="java">public class NestAccessExample {    private static class X {        void test() throws Exception {            Y y = new Y();            y.y = 1; // 基于嵌套的访问控制            Field field = Y.class.getDeclaredField(&quot;y&quot;);            field.setInt(y, 2);        }    }    private static class Y {        private int y;    }    public static void main(String[] args) throws Exception {        new X().test();    }}</code></pre><p>JDK8报错：Exception in thread “main” java.lang.IllegalAccessException: Class com.tuyrk.jdk11.NestAccessExample “X can not access a member of class com.tuyrk.jdk11.NestAccessExample”Y with modifiers “private”</p><p>注：JDK11之前则需设置<code>field.setAccessible(true);</code>。JDK11的反射则可以访问源码级别的私有属性。</p><h3 id="3-2-动态类文件常量-09-11"><a href="#3-2-动态类文件常量-09-11" class="headerlink" title="3-2 动态类文件常量 (09:11)"></a>3-2 动态类文件常量 (09:11)</h3><blockquote><p>JEP309:动态类文件常量</p></blockquote><p>摘要：增加一个常量类型-CONSTANT_Dynamic</p><p>目标：降低开发新形式的可实现类文件约束带来的成本和干扰</p><p>代码实例：</p><pre><code class="java">public class DynamicTest {    private static void test() {        System.out.println(&quot;hello&quot;);    }    public static void main(String[] args) throws Throwable {        MethodHandles.Lookup lookup = MethodHandles.lookup();        MethodHandle mh = lookup.findStatic(DynamicTest.class, &quot;test&quot;, MethodType.methodType(void.class));        mh.invokeExact();    }}</code></pre><h3 id="3-3-改进-Aarch64-函数-06-50"><a href="#3-3-改进-Aarch64-函数-06-50" class="headerlink" title="3-3 改进 Aarch64 函数 (06:50)"></a>3-3 改进 Aarch64 函数 (06:50)</h3><blockquote><p>JEP315:改进Aarch64内联函数</p></blockquote><p>摘要：改进现有的字符串和数组函数，并在Aarch64处理器上为java.lang.Math sin、cos、log函数实现新的内联函数</p><p>目标：专用的CPU架构可提高应用程序的性能</p><p>代码实例：</p><pre><code class="java">private static void mathOnJdk11() {  long startTime = System.currentTimeMillis();  for (int i = 0; i &lt; 10_000_000; i++) {    Math.sin(i);    Math.cos(i);    Math.log(i);  }  long endTime = System.currentTimeMillis();  System.out.println(TimeUnit.NANOSECONDS.toNanos(endTime - startTime) + &quot;nanos&quot;);}</code></pre><p>JDK8：7201nanos</p><p>JDK11：761nanos</p><h3 id="3-4-标准-HTTP-客户端-11-47"><a href="#3-4-标准-HTTP-客户端-11-47" class="headerlink" title="3-4 标准 HTTP 客户端 (11:47)"></a>3-4 标准 HTTP 客户端 (11:47)</h3><blockquote><p>JEP321:标准HTTP客户端</p></blockquote><p>摘要：在JDK9中就已经引入了HTTPClient，不过一直处于孵化状态，到了JDK11，HTTPClient API结束了孵化状态，作为一个标准API提供在java.net.http包中。</p><p>目标：取代HttpURLConnection</p><p>缺点：</p><ol><li>HttpURLConnection在设计时考虑多种协议，但如今协议都不存在了</li><li>早于HTTP1.1，太抽象。</li><li>使用不友好，提供的API不符合常用的编程思想</li><li>只能以阻塞模式工作，严重问题。</li><li>难维护，使用超级少。 多用Apache HTTPClient</li></ol><p>代码实例：</p><ol><li><p>同步Get方法</p><pre><code class="java">private static void syncGet(String uri) throws Exception {  HttpClient client = HttpClient.newHttpClient();  HttpRequest request = HttpRequest.newBuilder().uri(URI.create(uri)).build();  HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());  System.out.println(response.statusCode());  System.out.println(response.body());}</code></pre></li><li><p>异步Get方法</p><pre><code class="java">private static void asyncGet(String uri) throws Exception {  HttpClient client = HttpClient.newHttpClient();  HttpRequest request = HttpRequest.newBuilder().uri(URI.create(uri)).build();  CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; future = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());  future.whenComplete((response, e) -&gt; {    if (e != null) {      e.printStackTrace();    } else {      System.out.println(response.statusCode());      System.out.println(response.body());    }  }).join();}</code></pre></li></ol><h3 id="3-5-Lambda-参数的本地变量语法-18-14"><a href="#3-5-Lambda-参数的本地变量语法-18-14" class="headerlink" title="3-5 Lambda 参数的本地变量语法 (18:14)"></a>3-5 Lambda 参数的本地变量语法 (18:14)</h3><blockquote><p>JEP323:Lambda参数的本地变量语法</p></blockquote><p>摘要：允许var在声明隐式类型的lambda表达式的形式参数时使用</p><p>目标：将隐式类型的lambda表达式中的形式参数声明的语法与局部变量声明的语法对齐</p><p>代码实例：</p><ol><li><p>Java8特性：lambda表达式语法</p><pre><code class="java">private static void lambdaInJava8() {  // 参数列表，-&gt;，函数体  new Thread(new Runnable() {    @Override    public void run() {      System.out.println(&quot;before java8&quot;);    }  }).start();  new Thread(() -&gt; System.out.println(&quot;in java8&quot;)).start();  List&lt;String&gt; list = Arrays.asList(&quot;java8&quot;, &quot;jdk8&quot;, &quot;1.8&quot;);  list.forEach(w -&gt; {    System.out.println(&quot;lambda in java8: &quot; + w);  });}</code></pre></li><li><p>Java10新特性，局部变量类型推断</p><blockquote><p>JDK10允许使用var关键字来定义变量：var i=10</p><ul><li><p>必须初始化，否则编译报错</p></li><li><p>一旦初始化完成过后类型就会确定，不能再赋予其他类型的值</p><p>即i不能赋值为“abc”或者2.0等非int类型的值）</p></li></ul></blockquote><pre><code class="java">private static void varInJava10() {  int var = 10;  var i = 10; // int  var str = &quot;java10&quot;; // String  var list = new ArrayList&lt;String&gt;(); // ArrayList&lt;String&gt;  var map = Map.of(1, &quot;a&quot;, 2, &quot;b&quot;); // Map&lt;Integer, String&gt;  for (var entry : map.entrySet()) {    System.out.println(entry);  }  // i = &quot;abc&quot;; // 和JavaScript中的var不同，不能赋值其他类型  // var a; // 必须初始化赋值}class ErrorUseVar {  // JDK10只能允许在局部变量中使用var  // var i = 10;  /*var f1(var str) {    return 10;  }*/}</code></pre></li><li><p>Java11新特性：Lambda表达式可以使用var来标识变量</p><pre><code class="java">private static void lambdaWithVarInJava11() {  List&lt;Integer&gt; nums = Arrays.asList(8, 7, 9);  nums.sort((@NotNull Integer s1, @NotNull Integer s2) -&gt; {    if (s1.equals(s2)) {      return 0;    }    return s1 &gt; s2 ? 1 : -1;  });  // 可以给lambda表达式添加注解  nums.sort((@NotNull var s1, @NotNull var s2) -&gt; {    if (s1.equals(s2)) {      return 0;    }    return s1 &gt; s2 ? 1 : -1;  });  nums.sort((s1, s2) -&gt; {    if (s1.equals(s2)) {      return 0;    }    return s1 &gt; s2 ? 1 : -1;  });  System.out.println(nums);}</code></pre><pre><code class="java">(var x, y) -&gt; x.process(y)         // Cannot mix &#39;var&#39; and &#39;no var&#39; in implicitly typed lambda expression(var x, int y) -&gt; x.process(y)     // Cannot mix &#39;var&#39; and manifest types in explicitly typed lambda expression</code></pre><pre><code class="java">// var x -&gt; x.foo() // error</code></pre></li></ol><h3 id="3-6-Unicode-10-03-13"><a href="#3-6-Unicode-10-03-13" class="headerlink" title="3-6 Unicode 10 (03:13)"></a>3-6 Unicode 10 (03:13)</h3><blockquote><p>JEP327:Unicode10</p></blockquote><p>摘要：升级现有的平台API，支持<a href="https://www.unicode.org/versions/Unicode10.0.0/" target="_blank" rel="noopener">Unicode10标准</a></p><p>目标：支持最新版本的Unicode，主要体现在以下类中：</p><blockquote><p>java.lang包：Character、String</p><p>java.awt.font包：NumericShaper</p><p>java.text包：Bidi、BreakIterator、Normalizer</p></blockquote><p>代码实例：</p><pre><code class="java">System.out.println(&quot;\uD83E\uDDDA&quot;); // 🧚System.out.println(&quot;\uD83E\uDD92&quot;); // 🦒System.out.println(&quot;\uD83E\uDD95&quot;); // 🦕System.out.println(&quot;\uD83E\uDDD9&quot;); // 🧙System.out.println(&quot;\uD83E\uDDDB&quot;); // 🧛System.out.println(&quot;\uD83E\uDD2E&quot;); // 🤮</code></pre><h3 id="3-7-启动单文件源代码程序-04-01"><a href="#3-7-启动单文件源代码程序-04-01" class="headerlink" title="3-7 启动单文件源代码程序 (04:01)"></a>3-7 启动单文件源代码程序 (04:01)</h3><blockquote><p>JEP330:启动单文件源代码程序</p></blockquote><p>摘要：增强Java启动程序以运行作为单个Java源代码文件提供的程序</p><p>目标：使用java HelloWorld.java运行源代码文件</p><p>代码实例：</p><pre><code class="shell">cd src/main/java/com/tuyrk/jdk11java Unicode10Example.java</code></pre><h3 id="3-8-可伸缩低延迟垃圾收集器（上）-09-28"><a href="#3-8-可伸缩低延迟垃圾收集器（上）-09-28" class="headerlink" title="3-8 可伸缩低延迟垃圾收集器（上） (09:28)"></a>3-8 可伸缩低延迟垃圾收集器（上） (09:28)</h3><blockquote><p>JEP333:可伸缩低延迟垃圾收集器</p></blockquote><p>摘要：Z垃圾收集器，也称为ZGC，是一个可伸缩低延迟的垃圾收集器</p><p>目标：（最核心）无论开了多大的堆内存（128G、2T），保证低于10ms的JVM停顿，远胜于前一代的G1</p><p>需要知道的知识点：垃圾回收、判断对象是否是垃圾的算法、回收垃圾对象内存的算法、垃圾收集器</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li><p>什么是垃圾回收</p><p>垃圾回收是Java虚拟机垃圾回收器提供的一种用于在空闲时间、不定时回收无任何对象引用的对象占据的内存空间的机制</p></li><li><p>针对垃圾回收的定义提出的一些思考与问题</p><p>引用：引用类型的数值代表的是另一块内存的起始地址</p><p>垃圾：无任何对象引用的对象</p><p>回收：清理垃圾占用的内存空间，而非对象本身</p><p>发生地点：一般为堆内存，因为大部分的对象都存储在堆内存中</p><p>发生时间：程序空间时间不定时回收</p></li></ul><h4 id="判断对象是否是垃圾的算法"><a href="#判断对象是否是垃圾的算法" class="headerlink" title="判断对象是否是垃圾的算法"></a>判断对象是否是垃圾的算法</h4><blockquote><p>垃圾回收算法两件必须做的基本工作：</p><ol><li>找到所有的存活对象</li><li>回收被无用对象占用的内存空间，使得该空间可被程序再次使用</li></ol></blockquote><ul><li><p><del>引用计数法</del></p><p>概念：堆中每个对象都有一个引用计数器。当一个对象被创建并初始化赋值后，该变量计数器设置为1。每当有一个地方引用它时，计数器就加1。当引用失效时(超过生命周期、被新值覆盖)，计数器就减1。任何引用计数为0的对象都可以被当做垃圾收集。</p><p>优点：引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利（OC的内存管理使用该算法）</p><p>缺点：难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。</p></li><li><p>根搜索算法、对象引用遍历</p><p>标记可达对象：JVM中用到的所有现代GC算法在回收前都会先找出所有仍存活的对象。根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看做一张图。下图所展示的JVM中的内存布局可以用来很好地阐释这一概念。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1r4ituq8j30ev05e40u.jpg" alt="根搜索算法" style="zoom:80%;" /><p>根集（ROOT Set）：正在执行的Java程序可以访问的引用变量的集合，包括：局部变量、参数、类变量。</p><p>GC根对象：虚拟机栈中引用的对象、方法中类,静态属性引用的对象、活跃的线程等</p><p>程序可以使用引用变量访问对象的属性和调用对象的方法</p><p>算法基本思路：</p><ol><li>通过GC ROOTS对象作为起始点，寻找对应的引用节点</li><li>找到引用节点后，从这些引用节点开始向下继续寻找引用节点</li><li>搜索所走过的路径，称为引用链</li><li>当一个对象到GC ROOTS没有任何引用链相连时就证明对象是不可用的</li></ol></li></ul><h4 id="回收垃圾对象内存的算法"><a href="#回收垃圾对象内存的算法" class="headerlink" title="回收垃圾对象内存的算法"></a>回收垃圾对象内存的算法</h4><ul><li><p>Tracing算法(Tracing Collector)或标记-清除算法</p><p>两个阶段：标记、清除。</p><p>首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象</p><p>标记过程：也即根搜索算法的判定垃圾收集的标记过程</p><p>优点：不需要进行对象的移动；仅对不存活的对象进行处理，在存活对象比较多的情况下是极为高效的</p><p>缺点：</p><ol><li>标记和清除的效率低；需要使用空闲列表记录所有的空闲区域以及大小，对空闲列表的管理会增加分配对象时的工作量。</li><li>标记-清除后会产生大量不连续的内存碎片，虽然空闲区域的大小是足够的，但是可能没有单一的区域能够满足分配所需的大小，便会分配失败并抛出OOM异常。</li></ol><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1rn0etemj30my085aco.jpg" alt="标记-清除算法" style="zoom:80%;" /></li><li><p>Compacting算法(Compacting Collector)或标记-整理算法</p><p>该方法不是直接对可回收对象进行清理，而是让所有对象向一端移动，然后清理掉边界以外的内存。增加句柄和句柄表实现。</p><p>优点：</p><ol><li>在整理之后，新对象的分配只需通过指针碰撞便可完成</li><li>空闲区域的位置是可知的，也没有内存碎片问题</li></ol><p>缺点：GC暂停的时间会增长，因为需要将所有的对象拷贝到新的内存，还要更新引用地址</p></li></ul>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1rnhwpdgj30lv08jdi9.jpg" alt="标记-整理算法" style="zoom:80%;" /><h3 id="3-9-可伸缩低延迟垃圾收集器（下）-07-48"><a href="#3-9-可伸缩低延迟垃圾收集器（下）-07-48" class="headerlink" title="3-9 可伸缩低延迟垃圾收集器（下） (07:48)"></a>3-9 可伸缩低延迟垃圾收集器（下） (07:48)</h3><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><ul><li><p>串行垃圾收集器（Serial Garbage Collector）</p><blockquote><p>通过持有并冻结所有应用程序的线程进行工作。</p><p>不适合服务器环境；适合简单的命令行程序、单CPU、新生代内存较小、暂停时间要求低的程序</p></blockquote><p>说明：它为单线程环境设计，只使用一个单独的线程进行垃圾回收。是client级别默认的GC方法</p><p>使用：通过JVM参数<code>-XX:+UseSerialGC</code>可以使用串行垃圾回收器</p></li><li><p>并行垃圾回收器（Parallel Garbage Collector）</p><blockquote><p>当执行垃圾回收时，也会冻结所有的应用程序线程</p><p>适用于多CPU、暂停时间较短的程序</p></blockquote><p>说明：它是JVM的默认垃圾回收器。使用多线程进行垃圾回收。</p><p>使用：可用<code>-XX:UseParallelGC</code>来强制指定，用<code>-XX:ParallelGCThreads=4</code>来制定线程数</p></li><li><p>并发标记扫描垃圾回收器（CMS Garbage Collector）</p><blockquote><p>相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果可以为了更好的程序性能而分配更多的CPU，那么相比并发垃圾回收器，并发标记扫描垃圾回收器是更好的选择。</p></blockquote><p>说明：并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程：</p><ol><li><p>当标记的引用对象在tenured区域</p></li><li><p>在进行垃圾回收的时候，堆内存的数据发生改变</p><p>使用：通过JVM参数<code>XX:+USeParNewGC</code>打开并发标记扫描垃圾回收器</p></li></ol></li><li><p>G1垃圾回收器（G1 Garbage Collector）</p><blockquote><p>G1垃圾回收器适用于堆内存很大的情况，它将堆内存分割为不同的区域，并且并发的对其进行垃圾回收。也可以在垃圾回收之后，对剩余的堆内存空间进行压缩</p></blockquote><p>说明：G1垃圾回收器是当今回收器技术发展最前沿的成果，它是一款面向服务端应用的回收器，它能充分利用多CPU、多核环境。因此它是一款并行与并发回收器，并且它能建立可预测的停顿时间模型</p><p>使用：通过JVM参数<code>-XX:+UseG1GC</code>使用G1垃圾回收器</p></li><li><p>ZGC的特性</p><p>所有阶段几乎都是并发执行的</p><p>像G1一样划分Region，但更加灵活</p><p>像G1一样会做Compacting压缩</p><p>单代</p></li><li><p>ZGC的工作过程</p><ol><li><p>初始停顿标记：Pause Mark Start</p><p>停顿JVM，标记ROOT对象，1,2,4三个对象被标记为live</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1txzytlbj30k505mgnb.jpg" alt="初始停顿标记" style="zoom:70%;" /></li><li><p>并发标记：Concurrent Mark</p><p>并发地递归标记其他对象，5和8也被标记为live</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1tyg7fgwj30ho05375p.jpg" alt="并发标记" style="zoom:80%;" /></li><li><p>移动对象：Relocate</p><p>对比发现3,6,7是过期对象，也就是中间的两个灰色region需要被压缩清理，所以陆续将4,5,8对象移动到最右边的新Region。移动过程中，有个forward table记录这种转向。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1tytb7hdj30hu06hdho.jpg" alt="移动对象" style="zoom:80%;" /></li><li><p>修正指针：Remap</p><p>最后将指针更新，指向新地址。上一个阶段的Remap，和下一个阶段的Mark是混搭在一起完成的，这样非常高效，省掉了重复遍历对象图的开销</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge1tz8qz9pj30ia06g40c.jpg" alt="修正指针" style="zoom:80%;" /></li></ol><p><a href="https://www.jianshu.com/p/2957b001645d" target="_blank" rel="noopener">CMS、G1、ZGC的堆内存实现区别</a></p></li></ul><h3 id="3-10-JDK11-中新增加的常用-API-18-45"><a href="#3-10-JDK11-中新增加的常用-API-18-45" class="headerlink" title="3-10 JDK11 中新增加的常用 API (18:45)"></a>3-10 JDK11 中新增加的常用 API (18:45)</h3><p>java.lang.String</p><pre><code class="java">strip() // 删除首尾空白符（包含中文空白符）stripLeading()stripTrailing()isBlank() // 是否为空或仅包含空白符（包含中文空白符）lines()repeat(int count) // 重复字符串</code></pre><p>java.nio.file.Files</p><pre><code class="java">writeString(Path path, CharSequence csq) // 向文件写入内容readString(Path path) // 读取文件内容</code></pre><p>java.util.List</p><pre><code class="java">List.of() // 获取集合，不可变list.toArray(String[]::new) // 创建String数组</code></pre><h3 id="3-11-JDK11-其他新特性-04-21"><a href="#3-11-JDK11-其他新特性-04-21" class="headerlink" title="3-11 JDK11 其他新特性 (04:21)"></a>3-11 JDK11 其他新特性 (04:21)</h3><h2 id="第4章-JDK12-新特性介绍及演示"><a href="#第4章-JDK12-新特性介绍及演示" class="headerlink" title="第4章 JDK12 新特性介绍及演示"></a>第4章 JDK12 新特性介绍及演示</h2><blockquote><p>本章将介绍 JDK12 中的新特性，部分核心特性会结合代码演示操作，帮助同学们更好的学习理解。</p></blockquote><h3 id="4-1-微基准测试-19-16"><a href="#4-1-微基准测试-19-16" class="headerlink" title="4-1 微基准测试 (19:16)"></a>4-1 微基准测试 (19:16)</h3><blockquote><p>JEP230:微基准测试</p></blockquote><p>摘要：Microbenchmark作为常规性能测试的一部分，在JDK源代码中添加一组基础的微基准测试</p><p>目标：可以基于Java Microbenchmark Harness（JMH）轻松测试JDK的性能</p><p>代码实例</p><blockquote><p>@Benchmark：方法级注解，表示当前方法需要进行基准测试<br>@Fork(2)：进程的个数<br>@Threads(8)：线程的个数<br>@BenchmarkMode(Mode.Throughput)：基准测试类型，吞吐量<br>@Warmup(iterations = 5)：预热轮数<br>@Measurement(iterations = 10, time = 5)：度量，基本测试参数。<br>@OutputTimeUnit(TimeUnit.MILLISECONDS)：测试结果的输出时间类型<br>@Setup：初始化，测试前的准备工作<br>@TearDown：清理，测试后的结束工作。资源回收</p></blockquote><p>JMH使用方法：测试字符串拼接的性能</p><pre><code class="java">@Fork(2)@Threads(8)@BenchmarkMode(Mode.Throughput)@Warmup(iterations = 5)@Measurement(iterations = 10, time = 5)@OutputTimeUnit(TimeUnit.MILLISECONDS)public class BenchmarkTest {    public static void main(String[] args) throws RunnerException {        Options options = new OptionsBuilder()                .include(BenchmarkTest.class.getSimpleName())                .build();        new Runner(options).run();    }    @Benchmark    public void testStringAdd() {        String a = &quot;&quot;;        for (int i = 0; i &lt; 10; i++) {            a += i;        }    }    @Benchmark    public void testStringAdds() {        String a = &quot;&quot; + &quot;1&quot; + &quot;2&quot; + &quot;3&quot; + &quot;4&quot; + &quot;5&quot; + &quot;6&quot; + &quot;7&quot; + &quot;8&quot; + &quot;9&quot;;    }    @Benchmark    public void testStringBuilderAdd() {        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 10; i++) {            sb.append(i);        }    }}</code></pre><pre><code>Benchmark                            Mode  Cnt         Score         Error   UnitsBenchmarkTest.testStringAdd         thrpt   20     22305.916 ±    2473.762  ops/msBenchmarkTest.testStringAdds        thrpt   20  11795913.631 ± 1105845.467  ops/msBenchmarkTest.testStringBuilderAdd  thrpt   20     86506.156 ±    3584.597  ops/ms</code></pre><h3 id="4-2-增强的-switch-语句-11-13"><a href="#4-2-增强的-switch-语句-11-13" class="headerlink" title="4-2 增强的 switch 语句 (11:13)"></a>4-2 增强的 switch 语句 (11:13)</h3><blockquote><p>JEP325:增强的switch语句</p></blockquote><p>摘要：扩展switch语句，使其可以用作语句或者表达式，并且“传统”或“简化”两种都可以使用</p><p>目标：简化switch语句的书写形式</p><p>代码实例</p><pre><code class="java">switch (Calendar.MONDAY) {  case Calendar.MONDAY -&gt; System.out.println(1);  case Calendar.SATURDAY -&gt; System.out.println(6);  default -&gt; System.out.println(0);}</code></pre><pre><code class="java">int result = switch (Calendar.MONDAY) {  case Calendar.MONDAY -&gt; 1;  case Calendar.SATURDAY -&gt; 6;  default -&gt; 0;};System.out.println(result);</code></pre><pre><code class="shell">java SwitchExample.javajavac --release 12 --enable-preview SwitchExample.javajava --enable-preview SwitchExample</code></pre><h3 id="4-3-默认的类数据共享-04-20"><a href="#4-3-默认的类数据共享-04-20" class="headerlink" title="4-3 默认的类数据共享 (04:20)"></a>4-3 默认的类数据共享 (04:20)</h3><blockquote><p>JEP341:默认的类数据共享</p></blockquote><p>摘要：在64位平台上使用默认类列表，增强了JDK生成的类共享（CDS），改善了开箱即用的启动时间</p><p>目标：取消了用户必需运行<code>-Xshare:dump</code>，才能使用CDS的功能</p><p>关于类数据共享：CDS（Class Data Sharing）通过将一组核心系统类装载到共享内存中，可以在多个JVM中共享这些类。减少内存占用和缩短JVM启动时间</p><h3 id="4-4-G1-垃圾收集器功能增强-14-33"><a href="#4-4-G1-垃圾收集器功能增强-14-33" class="headerlink" title="4-4 G1 垃圾收集器功能增强 (14:33)"></a>4-4 G1 垃圾收集器功能增强 (14:33)</h3><blockquote><p>JEP344\346:G1垃圾收集器的增强</p></blockquote><p>摘要：</p><ul><li>344：如果G1垃圾收集器有可能超过预期的暂停时间，则可以使用中止选项</li><li>346：如果应用程序活动非常低，G1应该在合理的时间段内释放未使用的Java堆内存</li></ul><p>目标：</p><ul><li>344：G1可以中止可选部分的回收已达到停顿时间目标</li><li>346：可以在空闲时自动将Java堆内存返还给操作系统</li></ul><p>G1垃圾收集器-什么是G1？</p><blockquote><p>Garbage-First Garbage Collector：面向大内存(数G、数10G)、多核系统收集器、软停顿目标、可预测停顿时间，目标替换CMS，在JDK1.9作为默认垃圾收集器</p></blockquote><p>G1垃圾收集器-堆内存结构</p><blockquote><ul><li><p>CMS：需要地址连续的内存空间</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge658yzk7bj30ni05yq56.jpg" alt="CMS堆内存结构" style="zoom:80%;" /></li><li><p>G1：逻辑连续的内存块</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge659sz6ewj30mw08qdis.jpg" alt="G1堆内存结构" style="zoom:80%;" /><p>Region的大小：使用<code>-XX:G1HeapRegionSize</code>指定，可选1,2,4,8,16,32M。</p><p>默认<code>MIN_REGION_SIZE(1024*1024)</code>、<code>MAX_REGION_SIZE(32*1024*1024)</code>、<code>TARGET_REGION_NUMBER(2048)</code></p></li></ul></blockquote><p>G1垃圾收集器-GC模式</p><blockquote><ul><li><p>young gc：年轻代的GC算法、拷贝到survivor region、晋升到old region</p></li><li><p>mixed gc：避免堆内存耗尽、不是old gc,而是young+old region、是部分,不是全部老年代</p><p>老年代占用的内存大小超过堆内存的阈值时会触发mixed gc</p></li><li><p>full gc：对象分配速度过快、old region被填满、单线程执行</p><p>对象内存分配过快，mixed gc来不及清理，导致old region被沾满会触发full gc</p></li></ul></blockquote><p>G1垃圾收集器-属性总结</p><blockquote><p>“服务器风格”的垃圾回收器：并行和并发、分代处理、紧凑内存(碎片整理)、预见性</p></blockquote><p>G1垃圾收集器-应用场景</p><blockquote><p>G1的应用场景：垃圾收集与应用线程并发执行、空闲内存压缩暂停时间短、可预测的GC暂停时间、不需要很大的Java堆</p></blockquote><h3 id="4-5-JDK12-其他新特性-03-17"><a href="#4-5-JDK12-其他新特性-03-17" class="headerlink" title="4-5 JDK12 其他新特性 (03:17)"></a>4-5 JDK12 其他新特性 (03:17)</h3><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>本章中首先对课程中介绍的 JDK11、12 进行总结说明，之后分析怎样去选择 JDK 的版本，最后给出学习 Java 相关的建议。</p></blockquote><h3 id="5-1-课程总结-05-50"><a href="#5-1-课程总结-05-50" class="headerlink" title="5-1 课程总结 (05:50)"></a>5-1 课程总结 (05:50)</h3><p>JDK11：ZGC、HttpClient、String</p><p>JDK12：G1增强、switch</p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1196-一课掌握Lambda表达式语法及应用</title>
      <link href="/imooc/1196-lambda/"/>
      <url>/imooc/1196-lambda/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.imooc.com/learn/1196" target="_blank" rel="noopener">http://www.imooc.com/learn/1196</a></p><p>简介：如何应对传统项目开发中遇到的代码冗余的问题？如何提升开发效率？如何精简代码？学会Lambda必不可少~ Lambda表达式是函数式编程思想的一种体现，本课程先讲解了Lambda表达式基本操作语法和底层原理，再结合Stream完成项目重构，帮助你夯实Lambda表达式基础，轻松应对工作和面试。另外，JDK8以后，源码中开始应用Lambda表达式，学习它对以后钻研源码非常重要。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>理清本课程学习目的，对lambda基础有简单的认识。</p></blockquote><h3 id="1-1-课程介绍-02-25"><a href="#1-1-课程介绍-02-25" class="headerlink" title="1-1 课程介绍 (02:25)"></a>1-1 课程介绍 (02:25)</h3><blockquote><ul><li>什么是lambda表达式</li><li>lambda表达式基础知识</li><li>lambda表达式高级扩展</li></ul></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdk97i0rdaj312v0jfgq1.jpg" alt="课程介绍" style="zoom:30%;" /><h2 id="第2章-Java为什么引入Lambda表达式"><a href="#第2章-Java为什么引入Lambda表达式" class="headerlink" title="第2章 Java为什么引入Lambda表达式"></a>第2章 Java为什么引入Lambda表达式</h2><blockquote><p>从实际问题入手，介绍lambda表达对于程序优化带来的好处</p></blockquote><h3 id="2-1-为什么引入Lambda表达式-08-44"><a href="#2-1-为什么引入Lambda表达式-08-44" class="headerlink" title="2-1 为什么引入Lambda表达式 (08:44)"></a>2-1 为什么引入Lambda表达式 (08:44)</h3><p>内容介绍</p><blockquote><ul><li>什么是Lambda</li><li>Model Code As Data</li><li>功能接口设计及优化</li><li>为什么要使用Lambda表达式</li></ul></blockquote><p>什么是Lambda</p><blockquote><ul><li>Lambda表达式也被称为箭头函数、匿名函数、闭包</li><li>Lambda表达式体现的是轻量级函数式编程思想</li><li><code>-&gt;</code>符号是Lambda表达式核心操作符号，符号左侧是操作参数，符号右侧是操作表达式</li><li>JDK8新特性</li></ul></blockquote><p>Model Code as Data</p><blockquote><ul><li>Model Code as Data，编码及数据，尽可能轻量级的将代码封装为数据</li><li>解决方案：接口&amp;实现类（匿名内部类）</li><li>存在问题：语法冗余、this关键字、变量捕获、数据控制等</li></ul></blockquote><p>项目问题：功能接口的设计及优化</p><blockquote><p>需求环境：线程类的创建<br>解决方案：匿名内部类实现<br>解决方案：Lambda表达式实现</p></blockquote><ol><li><p>传统模式下，新线程的创建</p><pre><code class="java">new Thread(new Runnable() {    @Override    public void run() {        System.out.println(&quot;threading...&quot; + Thread.currentThread().getId());    }}).start();</code></pre></li><li><p>JDK8新特性，Lambda表达式优化线程模式</p><pre><code class="java">new Thread(() -&gt; {  System.out.println(&quot;lambda threading...&quot; + Thread.currentThread().getId());}).start();</code></pre></li></ol><p>为什么要使用Lambda表达式</p><blockquote><ul><li>他不是解决未知问题的新技术</li><li>对现有解决方案的语义化优化</li><li>需要根据实际需求考虑性能问题</li></ul></blockquote><h2 id="第3章-Lambda表达式的基础知识"><a href="#第3章-Lambda表达式的基础知识" class="headerlink" title="第3章 Lambda表达式的基础知识"></a>第3章 Lambda表达式的基础知识</h2><blockquote><p>什么是函数式接口、Lambda表达式的基础语法、方法重载与Lambda表达式以及底层构建原理。</p></blockquote><h3 id="3-1-函数式接口概述和定义-05-19"><a href="#3-1-函数式接口概述和定义-05-19" class="headerlink" title="3-1 函数式接口概述和定义 (05:19)"></a>3-1 函数式接口概述和定义 (05:19)</h3><p>内容介绍</p><blockquote><ul><li>函数式接口的概念和使用方式</li><li>Lambda语法及使用</li><li>Lambda表达式运行原理</li></ul></blockquote><p>函数是接口（function interface）</p><blockquote><ul><li>函数式接口，就是Java类型系统中的接口</li><li>函数式接口，是只包含一个接口方法的特殊接口</li><li>语义化检测注解：<code>@FunctionalInterface</code></li></ul></blockquote><ol><li><p>用户身份认证标记接口</p><pre><code class="java">@FunctionalInterfacepublic interface IUserCredential {  /**   * 通过用户账号，验证用户身份信息的接口   *   * @param username 要验证的用户账号   * @return 返回身份信息[系统管理员、用户管理员、普通用户]   */  String verifyUser(String username);}</code></pre></li><li><p>消息传输格式化转换接口</p><pre><code class="java">@FunctionalInterfacepublic interface IMessageFormat {  /**   * 消息转换方法   *   * @param message 要转换的消息   * @param format  转换的格式[xml/json]   * @return 返回转换后的数据   */  String format(String message, String format);}</code></pre></li></ol><h3 id="3-2-默认方法和静态方法-09-16"><a href="#3-2-默认方法和静态方法-09-16" class="headerlink" title="3-2 默认方法和静态方法 (09:16)"></a>3-2 默认方法和静态方法 (09:16)</h3><blockquote><ul><li>默认接口方法</li><li>静态接口方法</li><li>来自Object继承的方法</li></ul></blockquote><ol><li><p>用户身份认证标记接口</p><pre><code class="java">@FunctionalInterfacepublic interface IUserCredential {  // 通过用户账号，验证用户身份信息的接口  String verifyUser(String username);  // boolean test();  @Override  String toString();  default String getCredential(String username) {    // 模拟方法    if (&quot;admin&quot;.equals(username)) {      return &quot;admin + 系统管理员用户&quot;;    } else if (&quot;manager&quot;.equals(username)) {      return &quot;manager + 用户管理员用户&quot;;    }    return &quot;commons + 普通会员用户&quot;;  }}</code></pre><pre><code class="java">public class UserCredentialImpl implements IUserCredential {  @Override  public String verifyUser(String username) {    if (&quot;admin&quot;.equals(username)) {      return &quot;系统管理员&quot;;    } else if (&quot;manager&quot;.equals(username)) {      return &quot;用户管理员&quot;;    }    return &quot;普通会员&quot;;  }}</code></pre></li><li><p>消息传输格式化转换接口</p><pre><code class="java">@FunctionalInterfacepublic interface IMessageFormat {  // 消息转换方法  String format(String message, String format);  // 消息合法性验证方法  static boolean verifyMessage(String msg) {    return msg != null;  }}</code></pre><pre><code class="java">public class MessageFormatImpl implements IMessageFormat {  @Override  public String format(String message, String format) {    System.out.println(&quot;消息转换...&quot;);    return message;  }}</code></pre></li><li><p>测试类</p><pre><code class="java">public static void main(String[] args) {  IUserCredential ic = new UserCredentialImpl();  System.out.println(ic.verifyUser(&quot;admin&quot;));  System.out.println(ic.getCredential(&quot;admin&quot;));  String msg = &quot;hello world&quot;;  if (IMessageFormat.verifyMessage(msg)) {    IMessageFormat format = new MessageFormatImpl();    System.out.println(format.format(&quot;hello&quot;, &quot;json&quot;));  }}</code></pre></li></ol><h3 id="3-3-Lambda表达式和函数式接口的关系-04-21"><a href="#3-3-Lambda表达式和函数式接口的关系-04-21" class="headerlink" title="3-3 Lambda表达式和函数式接口的关系 (04:21)"></a>3-3 Lambda表达式和函数式接口的关系 (04:21)</h3><p>函数式接口(function interface)</p><blockquote><ul><li>函数式接口，只包含一个操作方法</li><li>Lambda表达式，只能操作一个方法</li><li>Java中的Lambda表达式核心就是一个函数式接口</li></ul></blockquote><ol><li><p>匿名内部类，实现接口的抽象方法</p><pre><code class="java">IUserCredential ic2 = new IUserCredential() {  @Override  public String verifyUser(String username) {    return &quot;admin&quot;.equals(username) ? &quot;管理员&quot; : &quot;会员&quot;;  }};System.out.println(ic2.verifyUser(&quot;manager&quot;));System.out.println(ic2.verifyUser(&quot;admin&quot;));</code></pre></li><li><p>Lambda表达式，针对函数式接口的简单实现</p><pre><code class="java">IUserCredential ic3 = (username) -&gt; {  return &quot;admin&quot;.equals(username) ? &quot;lbd管理员&quot; : &quot;lbd会员&quot;;};System.out.println(ic3.verifyUser(&quot;manager&quot;));System.out.println(ic3.verifyUser(&quot;admin&quot;));</code></pre></li></ol><h3 id="3-4-jdk中常见的函数式接口-14-23"><a href="#3-4-jdk中常见的函数式接口-14-23" class="headerlink" title="3-4 jdk中常见的函数式接口 (14:23)"></a>3-4 jdk中常见的函数式接口 (14:23)</h3><p>Java类型系统内建函数式接口</p><blockquote><ul><li>java.lang.Runable</li><li>Java.lang.Comparable</li><li>java.lang.Comparator</li><li>java.io.FileFilter</li></ul></blockquote><p>JDK8提供了java.util.function包，提供了常用的函数式功能接口</p><table><thead><tr><th>接口</th><th>功能</th></tr></thead><tbody><tr><td>Predicate</td><td>接收参数T对象，返回一个boolean类型结果</td></tr><tr><td>Consumer</td><td>接收参数T对象，没有返回值</td></tr><tr><td>Function</td><td>接收参数T对象，返回R对象</td></tr><tr><td>Supplier</td><td>不接受任何参数，直接通过get()获取指定类型的对象</td></tr><tr><td>UnaryOperator</td><td>接收参数T对象，执行业务处理后，返回更新后的T对象</td></tr><tr><td>BinaryOperator</td><td>接收两个T对象，执行业务处理后，返回一个T对象</td></tr></tbody></table><ol><li><p>java.util.function.Predicate<T></p><p>接收参数对象T，返回一个boolean类型结果</p><pre><code class="java">Predicate&lt;String&gt; pre = (String username) -&gt; {  return &quot;admin&quot;.equals(username);};System.out.println(pre.test(&quot;manager&quot;));System.out.println(pre.test(&quot;admin&quot;));</code></pre></li><li><p>java.util.function.Comsumer<T></p><p>接收参数对象T，不返回结果</p><pre><code class="java">Consumer&lt;String&gt; con = (String message) -&gt; {  System.out.println(&quot;要发送的消息：&quot; + message);  System.out.println(&quot;消息发送完成&quot;);};con.accept(&quot;hello world&quot;);con.accept(&quot;lambda expression&quot;);</code></pre></li><li><p>java.util.function.Function&lt;T, R&gt;</p><p>接收参数对象T，返回结果对象R</p><pre><code class="java">Function&lt;String, Integer&gt; fun = (String gender) -&gt; {  return &quot;male&quot;.equals(gender) ? 1 : 0;};System.out.println(fun.apply(&quot;male&quot;));System.out.println(fun.apply(&quot;female&quot;));</code></pre></li><li><p>java.util.function.Supplier<T></p><p>不需要接收参数，提供T对象的创建工厂</p><pre><code class="java">Supplier&lt;String&gt; sup = () -&gt; {  return UUID.randomUUID().toString();};System.out.println(sup.get());System.out.println(sup.get());System.out.println(sup.get());</code></pre></li><li><p>java.util.function.UnaryOperator<T></p><p>接收参数对象T，返回结果对象T</p><pre><code class="java">UnaryOperator&lt;String&gt; uo = (String img) -&gt; {  img += &quot;[100x200]&quot;;  return img;};System.out.println(uo.apply(&quot;原图--&quot;));</code></pre></li><li><p>java.util.functionBinaryOperator<T></p><p>接收两个T对象，返回一个T对象结果</p><pre><code class="java">BinaryOperator&lt;Integer&gt; bo = (Integer i1, Integer i2) -&gt; {  return i1 &gt; i2 ? i1 : i2;};System.out.println(bo.apply(12, 13));</code></pre></li></ol><h3 id="3-5-Lambda表达式基本语法-10-17"><a href="#3-5-Lambda表达式基本语法-10-17" class="headerlink" title="3-5 Lambda表达式基本语法 (10:17)"></a>3-5 Lambda表达式基本语法 (10:17)</h3><blockquote><ul><li>Lambda表达式基本语法</li><li>带参数的Lambda表达式</li><li>带返回值的Lambda表达式</li></ul></blockquote><p>Lambda表达式的基本语法</p><ol><li><p>声明：就是和Lambda表达式绑定的接口类型</p></li><li><p>参数：包含在一对圆括号中，和绑定的接口中的抽象方法中的参数个数及顺序一致</p></li><li><p>操作符：-&gt;</p></li><li><p>执行代码块：包含在一对大括号中，出现在操作符号的右侧</p><pre><code>[接口声明] = (参数) -&gt; {指定代码块}</code></pre></li></ol><blockquote><ol><li>lambda表达式，必须和接口进行绑定</li><li>lambda表达式的参数，可以附带0个到n个参数，括号中的参数类型可以不用指定，JVM在运行时会自动根据绑定的抽象方法中的参数进行推导</li><li>lambda表达式的返回值，如果代码块只有一行，并且没有大括号，不用写return关键字，单行代码的执行结果会自动返回。如果添加了大括号，或者有多行代码，必须通过return关键字返回执行结果</li></ol></blockquote><ol><li><p>没有参数，没有返回值的Lambda表达式</p><pre><code class="java">interface ILambda1 {  void test();}</code></pre><pre><code class="java">ILambda1 i1 = () -&gt; {  System.out.println(&quot;hello lambda&quot;);  System.out.println(&quot;welcome to lambda&quot;);};i1.test();ILambda1 i12 = () -&gt; System.out.println(&quot;hello&quot;);i12.test();</code></pre></li><li><p>带有参数，没有返回值的Lambda表达式</p><pre><code class="java">interface ILambda2 {  void test(String name, int age);}</code></pre><pre><code class="java">ILambda2 i2 = (String name, int age) -&gt; {  System.out.println(name + &quot; age: my year&#39;s old is &quot; + age);};i2.test(&quot;jerry&quot;, 18);ILambda2 i22 = (name, age) -&gt; {  System.out.println(name + &quot; age: my year&#39;s old is &quot; + age);};i22.test(&quot;tom&quot;, 22);</code></pre></li><li><p>带有参数，带有返回值的Lambda表达式</p><pre><code class="java">interface ILambda3 {  int test(int x, int y);}</code></pre><pre><code class="java">ILambda3 i3 = (x, y) -&gt; {  int z = x + y;  return z;};System.out.println(i3.test(11, 22));ILambda3 i32 = (x, y) -&gt; x + y;System.out.println(i32.test(100, 200));ILambda3 i33 = Integer::sum;System.out.println(i33.test(23, 32));</code></pre></li></ol><h3 id="3-6-变量捕获-变量的访问操作-06-17"><a href="#3-6-变量捕获-变量的访问操作-06-17" class="headerlink" title="3-6 变量捕获-变量的访问操作 (06:17)"></a>3-6 变量捕获-变量的访问操作 (06:17)</h3><blockquote><ul><li>匿名内部类中的变量捕获</li><li>Lambda表达式中的变量捕获</li></ul></blockquote><ol><li><p>匿名内部类型中对于变量的访问</p><pre><code class="java">public void testInnerClass() {  String s2 = &quot;局部变量&quot;;  new Thread(new Runnable() {    String s3 = &quot;内部变量&quot;;    @Override    public void run() {      // 1. 访问全局变量      // System.out.println(this.s1); // this关键字~表示的是当前内部类型的对象      System.out.println(s1);      // 2. 局部变量的访问      System.out.println(s2);      // s2 = &quot;hello&quot;; // 不能对局部变量进行数据的修改[final]      // 3. 内部变量的访问      System.out.println(s3);      System.out.println(this.s3);    }  }).start();}</code></pre></li><li><p>Lambda表达式变量捕获</p><pre><code class="java">public void testLambda() {  String s2 = &quot;局部变量Lambda&quot;;  new Thread(() -&gt; {    String s3 = &quot;内部变量Lambda&quot;;    // 1. 访问全局变量    System.out.println(this.s1); // this关键字~表示的是所属方法所在类型的对象    // 2. 访问局部变量    System.out.println(s2);    // s2 = &quot;hello&quot;; // 不能进行数据修改，默认推导变量的修饰符：final    // 3. 访问内部变量    System.out.println(s3);    s3 = &quot;lambda内部变量直接修改&quot;;    System.out.println(s3);  }).start();}</code></pre></li></ol><p>总结：Lambda表达式中的变量操作优化了匿名内部类中的this关键字，不再单独建立对象作用域，表达式本身就是所属对象类型的一部分，在语法语义上使用更加简洁</p><h3 id="3-7-Lambda表达式类型检查-07-18"><a href="#3-7-Lambda表达式类型检查-07-18" class="headerlink" title="3-7 Lambda表达式类型检查 (07:18)"></a>3-7 Lambda表达式类型检查 (07:18)</h3><blockquote><ul><li>表达式类型检查</li><li>参数类型检查</li></ul></blockquote><ol><li><p>接口</p><pre><code class="java">@FunctionalInterfaceinterface MyInterface&lt;T, R&gt; {  R strategy(T t, R r);}</code></pre></li><li><p>测试方法</p><pre><code class="java">public static void test(MyInterface&lt;String, List&gt; inter) {  List list = inter.strategy(&quot;hello&quot;, new ArrayList());  System.out.println(list);}</code></pre></li><li><p>调用方法</p><ul><li><p>匿名内部类</p><pre><code class="java">test(new MyInterface&lt;String, List&gt;() {  @Override  public List strategy(String s, List list) {    list.add(s);    return list;  }});</code></pre></li><li><p>Lambda表达式</p><pre><code class="java">test((x, y) -&gt; {  y.add(x);  return y;});</code></pre></li></ul></li></ol><ul><li><p>表达式类型检查</p><pre><code> (x, y) -&gt; {...} ==&gt; test(param) ==&gt; param = MyInterface ==&gt; lambda表达式 ==&gt; MyInterface类型</code></pre><p> Lambda表达式的类型检查：Lambda表达式<code>(x, y) =&gt; {...}</code>，当将它交给test作为param参数时，JVM会推导param是Interface类型的参数，所以当前的Lambda表达式就属于MyInterface类型。MyInterface接口就是Lambda表达式的目标类型(target typing)</p></li><li><p>参数类型检查</p><pre><code> (x, y) -&gt; {...} ==&gt; MyInterface(T t, R r) ==&gt; MyInterface&lt;String, List&gt; inter ==&gt; T=String, R=List ==&gt; lambda ==&gt; (x, y) == strategy(T t, R r) ==&gt; x=T=String, y=R=List</code></pre></li></ul><h3 id="3-8-方法重载和Lambda表达式-05-00"><a href="#3-8-方法重载和Lambda表达式-05-00" class="headerlink" title="3-8 方法重载和Lambda表达式 (05:00)"></a>3-8 方法重载和Lambda表达式 (05:00)</h3><blockquote><ul><li>Java类型系统中的方法重载</li><li>方法重载的实现</li><li>当方法重载遇上Lambda表达式</li></ul></blockquote><ol><li><p>接口方法</p><pre><code class="java">interface Param1 {  void outInfo(String info);}</code></pre><pre><code class="java">interface Param2 {  void outInfo(String info);}</code></pre></li><li><p>定义重载方法</p><pre><code class="java">public class App38 {  public void lambdaMethod(Param1 param) {    param.outInfo(&quot;hello param1 lambda&quot;);  }  public void lambdaMethod(Param2 param) {    param.outInfo(&quot;hello param2 lambda&quot;);  }}</code></pre></li><li><p>方法调用</p><pre><code class="java">App38 app38 = new App38();app38.lambdaMethod(new Param1() {  @Override  public void outInfo(String info) {    System.out.println(info);  }});app38.lambdaMethod(new Param2() {  @Override  public void outInfo(String info) {    System.out.println(info);  }});app38.lambdaMethod((Param2) (info) -&gt; {  System.out.println(info);});app38.lambdaMethod((Param2) System.out::println);</code></pre><pre><code>lambda表达式存在类型检查 =&gt; 自动推导lambda表达式的目标类型lambdaMethod() =&gt; 方法 =&gt; 重载方法        =&gt; Param1 函数式接口        =&gt; Param2 函数式接口       调用方法 =&gt; 传递Lambda表达式 =&gt; 自动推导 =&gt; Param1 | Param2</code></pre></li></ol><h3 id="3-9-Lmabda表达式底层构建原理-06-19"><a href="#3-9-Lmabda表达式底层构建原理-06-19" class="headerlink" title="3-9 Lmabda表达式底层构建原理 (06:19)"></a>3-9 Lmabda表达式底层构建原理 (06:19)</h3><blockquote><ul><li>Lambda表达式底层解析运行原理</li><li>Lambda表达式在JVM底层解析成私有静态方法和匿名内部类型</li><li>通过实现接口的匿名内部类型中接口方法调用静态实现方法，完成Lambda表达式的执行</li></ul></blockquote><ol><li><p>源码</p><pre><code class="java">public class App39 {  public static void main(String[] args) {    IMarkUp mu = (message) -&gt; System.out.println(message);    mu.markUp(&quot;Lambda!&quot;);  }}interface IMarkUp {  void markUp(String msg);}</code></pre></li><li><p>编译源代码</p><pre><code class="shell">javac App39.java</code></pre></li><li><p>反编译查看编译后的代码</p><pre><code class="shell">javap -p App39</code></pre><pre><code class="java">public class App39 {  public App39();  public static void main(java.lang.String[]);  private static void lambda$main$0(java.lang.String);}</code></pre></li><li><p>查看底层详细编译过程</p><pre><code class="shell">java -Djdk.internal.lambda.dumpProxyClasses App39</code></pre><pre><code class="shell">javap -p App39\$\$Lambda\$1</code></pre><pre><code class="java">final class App39$$Lambda$1 implements IMarkUp {  private App39$$Lambda$1();  public void markUp(java.lang.String);}</code></pre></li><li><p>最终运行源码</p><pre><code class="java">public class App39 {  public static void main(String[] args) {    new App39$$Lambda$1().markUp(&quot;Lambda!&quot;);  }  private static void lambda$main$0(java.lang.String message){    System.out.println(message);  }  final class App39$$Lambda$1 implements IMarkUp {    private App39$$Lambda$1() { }    public void markUp(java.lang.String msg) {      App39.lambda$main$0(msg);    }  }}interface IMarkUp {  void markUp(String msg);}</code></pre></li></ol><h2 id="第4章-Lambda表达式在集合中的运用"><a href="#第4章-Lambda表达式在集合中的运用" class="headerlink" title="第4章 Lambda表达式在集合中的运用"></a>第4章 Lambda表达式在集合中的运用</h2><blockquote><p>介绍方法引用、Java Stream 如何操作集合及底层原理。</p></blockquote><h3 id="4-1-方法引用-12-19"><a href="#4-1-方法引用-12-19" class="headerlink" title="4-1 方法引用 (12:19)"></a>4-1 方法引用 (12:19)</h3><blockquote><ul><li>方法引用</li><li>Stream API</li><li>Stream操作原理</li><li>操作集合元素</li></ul></blockquote><p>Lambda表达式方法引用</p><blockquote><ul><li>方法引用是结合Lambda表达式的一种语法特性</li><li>静态方法引用、实例方法引用、构造方法引用</li></ul></blockquote><ol><li><p>Person类型</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorclass Person {  private String name;// 姓名  private String gender;// 性别  private int age;//年龄  // 静态方法  public static int compareByAge(Person p1, Person p2) {    return p1.getAge() - p2.getAge();  }  // 实例方法  public int compareByName(Person p1, Person p2) {    return p1.getName().hashCode() - p2.getName().hashCode();  }}@FunctionalInterfaceinterface IPerson {  // 抽象方法：通过指定类型的构造方法初始化对象数据  Person initPerson(String name, String gender, int age);}</code></pre></li><li><p>存储Person对象的列表</p><pre><code class="java">List&lt;Person&gt; personList = new ArrayList&lt;&gt;();personList.add(new Person(&quot;tom&quot;, &quot;男&quot;, 16));personList.add(new Person(&quot;jerry&quot;, &quot;女&quot;, 15));personList.add(new Person(&quot;shuke&quot;, &quot;男&quot;, 30));personList.add(new Person(&quot;beita&quot;, &quot;女&quot;, 26));personList.add(new Person(&quot;damu&quot;, &quot;男&quot;, 32));</code></pre></li><li><p>进行排序</p><ul><li><p>匿名内部类实现方式</p><pre><code class="java">Collections.sort(personList, new Comparator&lt;Person&gt;() {  @Override  public int compare(Person o1, Person o2) {    return o1.getAge() - o2.getAge();  }});</code></pre></li><li><p>Lambda表达式实现方式</p><pre><code class="java">Collections.sort(personList, (o1, o2) -&gt; {  return o1.getAge() - o2.getAge();});</code></pre></li><li><p>静态方法引用</p><pre><code class="java">Collections.sort(personList, Person::compareByAge);</code></pre></li><li><p>实例方法引用</p><pre><code class="java">Person p = new Person();Collections.sort(personList, p::compareByName);</code></pre></li><li><p>构造方法引用：绑定函数式接口</p><pre><code class="java">IPerson ip = Person::new;Person person = ip.initPerson(&quot;jerry&quot;, &quot;男&quot;, 22);</code></pre></li></ul></li></ol><p>总结：</p><ol><li><p>静态方法引用的使用</p><p>类型名称.方法名称() =&gt; 类型名称::静态方法名称</p></li><li><p>实例方法引用的使用</p><p>创建类型对应的一个对象 =&gt; 对象应用::实例方法名称</p></li><li><p>构造方法引用：绑定函数式接口</p><p>需要有全参构造方法</p></li></ol><h3 id="4-2-Stream概述-05-16"><a href="#4-2-Stream概述-05-16" class="headerlink" title="4-2 Stream概述 (05:16)"></a>4-2 Stream概述 (05:16)</h3><blockquote><ul><li>什么是Stream</li><li>Stream的作用</li></ul></blockquote><ol><li><p>添加测试数据：存储多个账号的列表</p><pre><code class="java">List&lt;String&gt; accounts = new ArrayList&lt;&gt;();accounts.add(&quot;tom&quot;);accounts.add(&quot;jerry&quot;);accounts.add(&quot;beita&quot;);accounts.add(&quot;shuke&quot;);accounts.add(&quot;damu&quot;);</code></pre></li><li><p>业务要求：长度大于等于5的有效账号</p><ul><li><p>foreach循环</p><pre><code class="java">for (String account : accounts) {  if (account.length() &gt;= 5) {    System.out.println(&quot;有效账号：&quot; + account);  }}</code></pre></li><li><p>迭代方式进行操作</p><pre><code class="java">Iterator&lt;String&gt; it = accounts.iterator();while (it.hasNext()) {  String account = it.next();  if (account.length() &gt;= 5) {    System.out.println(&quot;it有效账号：&quot; + account);  }}</code></pre></li><li><p>Stream结合Lambda表达式，完成业务处理</p><pre><code class="java">List validAccounts = accounts.stream().filter(s -&gt; s.length() &gt;= 5).collect(Collectors.toList());System.out.println(validAccounts);</code></pre></li></ul></li></ol><h3 id="4-3-Stream-API-09-27"><a href="#4-3-Stream-API-09-27" class="headerlink" title="4-3 Stream API (09:27)"></a>4-3 Stream API (09:27)</h3><blockquote><ul><li>Stream聚合操作</li><li>API：intermediate中间/记录操作【无状态|有状态】</li><li>API：terminal终结/结束操作【非短路|短路】</li></ul></blockquote><ol><li><p>聚合操作</p></li><li><p>Stream的处理流程</p><p>数据源=&gt;数据转换=&gt;获取结果</p></li><li><p>获取Stream对象</p><ol><li><p>从集合或者数组中获取[**]</p><pre><code class="java">collection.stream(); // accounts.stream()collection.parallelStream();Arrays.stream(T t);</code></pre></li><li><p>BufferReader</p><pre><code class="java">java.io.bufferReader.lines();</code></pre></li><li><p>静态工厂</p><pre><code class="java">java.util.stream.IntStream.range();java.nio.file.Files.walk();</code></pre></li><li><p>自定义构建</p><pre><code class="java">java.util.Spliterator;</code></pre></li><li><p>更多方式</p><pre><code class="java">random.ints();pattern.splitAsStream();</code></pre></li></ol></li><li><p>中间操作API{intermediate}</p><p>操作结果是一个Stream，中间操作可以有一个或多个连续的中间操作。</p><p>需要注意的是，中间操作只是记录操作方式，不作具体执行，直到结束操作发生时，才做数据的最终执行</p><p>中间操作就是业务逻辑处理</p><p>中间操作过程：</p><ul><li><p>无状态：数据处理时，不受前置中间操作的影响</p><pre><code class="java">map/filter/peek/parallel/sequential/unorderd</code></pre></li><li><p>有状态：数据处理时，受到前置中间操作的影响</p><pre><code class="java">distinct/sorted/limit/skip</code></pre></li></ul></li><li><p>终结操作|结束操作{terminal}</p><p>需要注意：一个Stream对象，只能有一个terminal操作。这个操作一旦发生就会真实处理数据，生成对应的处理结果</p><p>终结操作：</p><ul><li><p>非短路操作：当前的Stream对象必须处理完集合中所有数据，才能得到处理结果</p><pre><code class="java">forEach/forEachOrdered/toArray/reduce/collect/min/max/count/iterator</code></pre></li><li><p>短路操作（Short-circuiting）：当前的Stream对象在处理过程中，一旦满足某个条件，就可以得到结果</p><pre><code class="java">anyMatch/allMatch/noneMatch/findFirst/findAny等</code></pre><p>适用场景：无限大的Stream =&gt; 有限大的Stream</p></li></ul></li></ol><h3 id="4-4-Stream操作集合中的数据-上-13-55"><a href="#4-4-Stream操作集合中的数据-上-13-55" class="headerlink" title="4-4 Stream操作集合中的数据-上 (13:55)"></a>4-4 Stream操作集合中的数据-上 (13:55)</h3><blockquote><ul><li>类型转换：其他类型（创建/获取） =&gt; Stream对象</li><li>类型转换：Stream对象 =&gt; 其他类型</li><li>Stream常见的API操作</li></ul></blockquote><ol><li><p>批量数据 =&gt; Stream对象</p><ul><li><p>多个数据</p><pre><code class="java">Stream&lt;String&gt; stream1 = Stream.of(&quot;admin&quot;, &quot;tom&quot;, &quot;damu&quot;);</code></pre></li><li><p>数组</p><pre><code class="java">String[] strArrays = {&quot;xueqi&quot;, &quot;biyao&quot;};Stream&lt;String&gt; stream2 = Arrays.stream(strArrays);</code></pre></li><li><p>列表</p><pre><code class="java">List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;少林&quot;);list.add(&quot;武当&quot;);list.add(&quot;青城&quot;);list.add(&quot;崆峒&quot;);list.add(&quot;峨眉&quot;);Stream&lt;String&gt; stream3 = list.stream();</code></pre></li><li><p>集合</p><pre><code class="java">Set&lt;String&gt; set = new HashSet&lt;&gt;();set.add(&quot;少林罗汉拳&quot;);set.add(&quot;武当长拳&quot;);set.add(&quot;青城剑法&quot;);Stream&lt;String&gt; stream4 = set.stream();</code></pre></li><li><p>Map</p><pre><code class="java">Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();map.put(&quot;tom&quot;, 1000);map.put(&quot;jerry&quot;, 1200);map.put(&quot;shuke&quot;, 1000);Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream5 = map.entrySet().stream();</code></pre></li></ul></li><li><p>Stream对象对于基本数据类型的功能封装</p><ul><li><p>int/long/double</p><pre><code class="java">IntStream.of(new int[]{10, 20, 30}).forEach(System.out::println);IntStream.of(10, 20, 30).forEach(System.out::println);IntStream.range(1, 5).forEach(System.out::println);IntStream.rangeClosed(1, 5).forEachOrdered(System.out::println);</code></pre></li></ul></li><li><p>Stream对象 =&gt; 转换得到指定的数据类型</p><ul><li><p>数组</p><pre><code class="java">String[] array1 = stream1.toArray(String[]::new); // [admin, tom, damu]</code></pre></li><li><p>字符串</p><pre><code class="java">String str1 = stream1.collect(Collectors.joining()); // admintomdamuString str2 = stream1.collect(Collectors.joining(&quot; &quot;)); // admin tom damuString str3 = stream1.collect(Collectors.joining(&quot;,&quot;, &quot;^&quot;, &quot;$&quot;)); // ^admin,tom,damu$</code></pre></li><li><p>列表</p><pre><code class="java">List&lt;String&gt; lists = stream1.collect(Collectors.toList()); // [admin, tom, damu]</code></pre></li><li><p>集合</p><pre><code class="java">Set&lt;String&gt; sets = stream1.collect(Collectors.toSet()); // [tom, admin, damu]</code></pre></li><li><p>Map</p><pre><code class="java">Map&lt;String, String&gt; maps = stream1.collect(Collectors.toMap(x -&gt; x, y -&gt; &quot;value:&quot; + y)); // {tom=value:tom, admin=value:admin, damu=value:damu}</code></pre></li></ul></li></ol><h3 id="4-5-Stream操作集合中的数据-下-13-29"><a href="#4-5-Stream操作集合中的数据-下-13-29" class="headerlink" title="4-5 Stream操作集合中的数据-下 (13:29)"></a>4-5 Stream操作集合中的数据-下 (13:29)</h3><ol start="4"><li><p>Stream中常见的API操作</p><pre><code class="java">List&lt;String&gt; accountList = new ArrayList&lt;&gt;();accountList.add(&quot;songjiang&quot;);accountList.add(&quot;lujunyi&quot;);accountList.add(&quot;wuyong&quot;);accountList.add(&quot;linchong&quot;);accountList.add(&quot;luzhishen&quot;);accountList.add(&quot;likui&quot;);accountList.add(&quot;wusong&quot;);</code></pre><ul><li><p>map() 中间操作，map()方法接收一个Functional接口</p><pre><code class="java">accountList = accountList.stream().map(x -&gt; &quot;梁山好汉：&quot; + x).collect(Collectors.toList()); // 在每个名字前添加&quot;梁山好汉&quot;</code></pre></li><li><p>filter() 添加过滤条件，过滤符合条件的用户</p><pre><code class="java">accountList = accountList.stream().filter(x -&gt; x.length() &gt; 5).collect(Collectors.toList()); // 过滤名字长度大于5的名字</code></pre></li><li><p>forEach增强型循环</p><pre><code class="java">accountList.forEach(x -&gt; System.out.println(&quot;forEach:&quot; + x));</code></pre></li><li><p>peek()中间操作，迭代数据完成数据的依次处理过程</p><pre><code class="java">accountList.stream()                .peek(x -&gt; System.out.println(&quot;peek 1:&quot; + x))                .peek(x -&gt; System.out.println(&quot;peek 2:&quot; + x))                .forEach(x -&gt; System.out.println(&quot;forEach:&quot; + x));</code></pre></li></ul></li><li><p>Stream中对于数字运算的支持</p><pre><code class="java">List&lt;Integer&gt; intList = new ArrayList&lt;&gt;();intList.add(20);intList.add(19);intList.add(7);intList.add(8);intList.add(86);intList.add(11);intList.add(3);intList.add(20);</code></pre><ul><li><p>skip()中间操作，有状态，跳过部分数据</p><pre><code class="java">intList.stream().skip(3).forEach(System.out::println); // 8 86 11 3 20</code></pre></li><li><p>limit()中间操作，有状态，限制输出数据量</p><pre><code class="java">intList.stream().skip(3).limit(2).forEach(System.out::println); // 8 86</code></pre></li><li><p>distinct()中间操作，有状态，剔除重复的数据</p><pre><code class="java">intList.stream().distinct().forEach(System.out::println);</code></pre></li><li><p>sorted()中间操作，有状态，排序。一般在skip/limit或者filter之后进行</p></li><li><p>max()获取最大值</p><pre><code class="java">// Optional&lt;Integer&gt; max = intList.stream().max((x, y) -&gt; x - y);Optional&lt;Integer&gt; max = intList.stream().max(Comparator.comparingInt(x -&gt; x));System.out.println(max.get()); // 86</code></pre></li><li><p>min()获取最小值</p></li><li><p>reduce()合并处理数据</p><pre><code class="java">// Optional&lt;Integer&gt; reduce = intList.stream().reduce((sum, x) -&gt; sum + x);Optional&lt;Integer&gt; reduce = intList.stream().reduce(Integer::sum);System.out.println(reduce.get()); // 174</code></pre></li></ul></li></ol><h2 id="第5章-Lambda表达式在实际生产中的应用"><a href="#第5章-Lambda表达式在实际生产中的应用" class="headerlink" title="第5章 Lambda表达式在实际生产中的应用"></a>第5章 Lambda表达式在实际生产中的应用</h2><blockquote><p>手把手使用lambda表达式对一个项目进行重构，分析性能问题、线程安全问题。最后给课程做一个总结。</p></blockquote><h3 id="5-1-Lambda表达式重构项目-14-06"><a href="#5-1-Lambda表达式重构项目-14-06" class="headerlink" title="5-1 Lambda表达式重构项目 (14:06)"></a>5-1 Lambda表达式重构项目 (14:06)</h3><ol><li><p>ORM查询策略接口</p><pre><code class="java">@FunctionalInterfacepublic interface IStrategy&lt;T&gt; {  /**   * 测试方法   *   * @param t 要测试的对象   * @return 返回测试结果   */  boolean test(T t);}</code></pre></li><li><p>按照指定策略查询数据</p><pre><code class="java">@Overridepublic List&lt;Employee&gt; findByStrategy(IStrategy strategy) {  List&lt;Employee&gt; tempList = new ArrayList&lt;&gt;();  for (Employee employee : LIST) {    if (strategy.test(employee)) {      tempList.add(employee);    }  }  return tempList;}</code></pre></li><li><p>根据职员名称获取职员数据</p><pre><code class="java">public List&lt;Employee&gt; getEmployeeByName(String name) {  return empDAO.findByStrategy((IStrategy&lt;Employee&gt;) employee -&gt; employee.getEmpName().contains(name));}</code></pre></li></ol><p>Lambda表达式-代码重构</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdvx5g9jrtj30nm0aojuh.jpg" alt="Lambda表达式-代码重构" style="zoom:80%;" /><h3 id="5-2-Lambda和Stream性能问题-16-26"><a href="#5-2-Lambda和Stream性能问题-16-26" class="headerlink" title="5-2 Lambda和Stream性能问题 (16:26)"></a>5-2 Lambda和Stream性能问题 (16:26)</h3><ol><li><p>基本数据类型：整型</p><pre><code class="java">List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 1000000; i++) {  integerList.add(random.nextInt());}// 1) Stream 64ms// 2) parallelStream 5ms// 3) 普通for循环 14ms// 4) 普通foreach循环 12ms// 5) 增强型for循环 11ms// 6) 迭代器 11ms</code></pre><ul><li><p>Stream</p><pre><code class="java">public static int testStream(List&lt;Integer&gt; list) {  return list.stream().max(Integer::compare).orElse(0);}</code></pre></li><li><p>parallelStream</p><pre><code class="java">public static int testParallelStream(List&lt;Integer&gt; list) {  return list.parallelStream().max(Integer::compare).orElse(0);}</code></pre></li><li><p>普通for循环</p><pre><code class="java">public static int testForLoop(List&lt;Integer&gt; list) {  int max = Integer.MIN_VALUE;  for (int i = 0; i &lt; list.size(); i++) {    Integer current = list.get(i);    if (current &gt; max) {      max = current;    }  }  return max;}</code></pre></li><li><p>普通foreach循环</p><pre><code class="java">public static int testForEach(List&lt;Integer&gt; list) {  int max = Integer.MIN_VALUE;  for (Integer current : list) {    if (current &gt; max) {      max = current;    }  }  return max;}</code></pre></li><li><p>增强型for循环</p><pre><code class="java">public static int testStrongLoop(List&lt;Integer&gt; list) {  final int[] max = {Integer.MIN_VALUE};  list.forEach(current -&gt; {    if (current &gt; max[0]) {      max[0] = current;    }  });  return max[0];}</code></pre></li><li><p>迭代器</p><pre><code class="java">public static int testIterator(List&lt;Integer&gt; list) {  int max = Integer.MIN_VALUE;  Iterator&lt;Integer&gt; it = list.iterator();  while (it.hasNext()) {    Integer current = it.next();    if (current &gt; max) {      max = current;    }  }  return max;}</code></pre></li></ul></li><li><p>复杂数据类型：对象</p><pre><code class="java">@Data@AllArgsConstructorclass Product {    private String name; // 名称    private Integer stock; //库存    private Integer hot; //热度}</code></pre><pre><code class="java">List&lt;Product&gt; productList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 1_000_000; i++) {  productList.add(new Product(&quot;pro_&quot; + i, i, random.nextInt()));}// 1) Stream 92ms// 2) parallelStream 30ms// 3) 普通for循环 16ms// 4) 普通foreach循环 17ms// 5) 增强型for循环 12ms// 6) 迭代器 16ms</code></pre><ul><li><p>Stream</p><pre><code class="java">public static Product testProductStream(List&lt;Product&gt; list) {  return list.stream().max(Comparator.comparingInt(Product::getHot)).orElse(null);}</code></pre></li><li><p>parallelStream</p><pre><code class="java">public static Product testProductParallelStream(List&lt;Product&gt; list) {  return list.parallelStream().max(Comparator.comparingInt(Product::getHot)).orElse(null);}</code></pre></li><li><p>普通for循环</p><pre><code class="java">public static Product testProductForLoop(List&lt;Product&gt; list) {  Product maxHot = list.get(0);  for (int i = 0; i &lt; list.size(); i++) {    Product current = list.get(i);    if (current.getHot() &gt; maxHot.getHot()) {      maxHot = current;    }  }  return maxHot;}</code></pre></li><li><p>普通foreach循环</p><pre><code class="java">public static Product testProductForEach(List&lt;Product&gt; list) {  Product maxHot = list.get(0);  for (Product current : list) {    if (current.getHot() &gt; maxHot.getHot()) {      maxHot = current;    }  }  return maxHot;}</code></pre></li><li><p>增强型for循环</p><pre><code class="java">public static Product testProductStrongLoop(List&lt;Product&gt; list) {  final Product[] maxHot = {list.get(0)};  list.forEach(current -&gt; {    if (current.getHot() &gt; maxHot[0].getHot()) {      maxHot[0] = current;    }  });  return maxHot[0];}</code></pre></li><li><p>迭代器</p><pre><code class="java">public static Product testProductIterator(List&lt;Product&gt; list) {  Product maxHot = list.get(0);  Iterator&lt;Product&gt; it = list.iterator();  while (it.hasNext()) {    Product current = it.next();    if (current.getHot() &gt; maxHot.getHot()) {      maxHot = current;    }  }  return maxHot;}</code></pre></li></ul></li></ol><h3 id="5-3-线程安全问题-06-53"><a href="#5-3-线程安全问题-06-53" class="headerlink" title="5-3 线程安全问题 (06:53)"></a>5-3 线程安全问题 (06:53)</h3><p>Stream并行运行原理</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gdvzx33xcpj30lr0b2754.jpg" alt="Stream并行运行原理" style="zoom:80%;" /><pre><code class="java">List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 1000; i++) {  list1.add(i);}System.out.println(list1.size());</code></pre><ul><li><p>串行Stream</p><pre><code class="java">List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();list1.forEach(list2::add);System.out.println(list2.size());</code></pre></li><li><p>并行Stream，线程不安全</p><pre><code class="java">List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();list1.parallelStream().forEach(list3::add);System.out.println(list3.size());</code></pre></li><li><p>解决并行Stream线程安全问题</p><pre><code class="java">List&lt;Integer&gt; list4 = list1.parallelStream().collect(Collectors.toList());System.out.println(list4.size());</code></pre></li></ul><h3 id="5-4-课程总结-00-59"><a href="#5-4-课程总结-00-59" class="headerlink" title="5-4 课程总结 (00:59)"></a>5-4 课程总结 (00:59)</h3><blockquote><ul><li>Lambda表达式</li><li>Stream对象，批量数据处理增强</li><li>项目代码重构和并发性能问题</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-大咖精彩内容荟萃</title>
      <link href="/imooc/1297-MQ-Kafka/05-wonderful-content/"/>
      <url>/imooc/1297-MQ-Kafka/05-wonderful-content/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="5-1-【风间影月】缓存穿透的解决方案落地实例"><a href="#5-1-【风间影月】缓存穿透的解决方案落地实例" class="headerlink" title="5-1 【风间影月】缓存穿透的解决方案落地实例"></a>5-1 【风间影月】缓存穿透的解决方案落地实例</h2><blockquote><p>用户通过查询条件参数请求API，不论查询结果是否为空，都应将参数值与其对应的查询结果放入到Redis缓存中。当参数对应的结果集在数据库中发生变化时，也应立即修改Redis缓存中的值</p></blockquote><h2 id="5-2-【凌波微步】事务补偿机制原理解析"><a href="#5-2-【凌波微步】事务补偿机制原理解析" class="headerlink" title="5-2 【凌波微步】事务补偿机制原理解析"></a>5-2 【凌波微步】事务补偿机制原理解析</h2><p>什么是事务补偿机制？</p><blockquote><p>针对每个操作，都要注册一个与其对应的补偿（撤销）操作。在执行失败时，调用补偿操作，撤销之前的操作</p></blockquote><p>优缺点：</p><blockquote><ul><li>优点：逻辑清晰、流程简单</li><li>缺点：数据一致性比XA还要差，可能出错的点比较多</li><li>TCC属于应用层的一种补偿方式，程序员需要写大量代码</li></ul></blockquote><h2 id="5-3-【姚半仙】技术路线VS管理路线，该认真考虑一下职业发展问题"><a href="#5-3-【姚半仙】技术路线VS管理路线，该认真考虑一下职业发展问题" class="headerlink" title="5-3 【姚半仙】技术路线VS管理路线，该认真考虑一下职业发展问题"></a>5-3 【姚半仙】技术路线VS管理路线，该认真考虑一下职业发展问题</h2><p>技术路线VS管理路线</p><blockquote><p>目标明确、职位模型、刻意强化</p></blockquote><p>架构领域</p><blockquote><p>了解业务、关注行业发展、Big Picture</p></blockquote><blockquote><p>新技术、业务思考、落地能力</p></blockquote><h2 id="5-4-【张飞扬】容器技术众多，该如何技术选型？"><a href="#5-4-【张飞扬】容器技术众多，该如何技术选型？" class="headerlink" title="5-4 【张飞扬】容器技术众多，该如何技术选型？"></a>5-4 【张飞扬】容器技术众多，该如何技术选型？</h2><h2 id="5-5-【大目】性能调优目标概述与我的四板斧分享"><a href="#5-5-【大目】性能调优目标概述与我的四板斧分享" class="headerlink" title="5-5 【大目】性能调优目标概述与我的四板斧分享"></a>5-5 【大目】性能调优目标概述与我的四板斧分享</h2><blockquote><p>借助监控预防问题、发现问题<br>借助工具定位问题<br>定期复盘，防止同类问题再现<br>定好规范，一定程度上规避问题</p></blockquote><blockquote><p>应用性能调优、JVM调优、数据库调优、架构调优、操作系统调优</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Kafka海量日志收集系统架构设计(watcher)</title>
      <link href="/imooc/1297-MQ-Kafka/04-12-watcher-base/"/>
      <url>/imooc/1297-MQ-Kafka/04-12-watcher-base/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="一、watcher-基础语法"><a href="#一、watcher-基础语法" class="headerlink" title="一、watcher 基础语法"></a>一、watcher 基础语法</h2><ol><li><h3 id="Xpack-Watchs基本使用："><a href="#Xpack-Watchs基本使用：" class="headerlink" title="Xpack-Watchs基本使用："></a>Xpack-Watchs基本使用：</h3><blockquote><p>创建一个watcher,比如定义一个trigger 每个10s钟看一下input里的数据</p></blockquote><pre><code class="shell">PUT _xpack/watcher/watch/school_watcher</code></pre><pre><code class="json">{  &quot;trigger&quot;: {    &quot;schedule&quot;: {      &quot;interval&quot;: &quot;10s&quot;    }  },  // 查看任务信息  &quot;input&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        // 监控具体索引        &quot;indices&quot;: [&quot;school*&quot;],        // body里面具体些搜索语句        &quot;body&quot;: {          &quot;size&quot;: 0,          &quot;query&quot;: {            &quot;match&quot;: {              // 比如索引里面name 有 hello 则进行报警              &quot;name&quot;: &quot;hello&quot;            }          }        }      }    }  },  // 对于上面的查询结果进行比较：  &quot;condition&quot;: {    // compare进行比较    &quot;compare&quot;: {      // 上面的query查询的结果会放入到ctx.payload中：      // 比如获取 ctx.payload.hits.total  ctx.payload._shards.total 等等      &quot;ctx.payload.hits.total&quot;: {        &quot;gt&quot;: 0      }    }  },  // transform作用：重新查询出文档内容赋值给ctx.payload  &quot;transform&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        &quot;indices&quot;: [&quot;school*&quot;],        &quot;body&quot;: {          &quot;size&quot;: 10,          &quot;query&quot;: {            &quot;match&quot;: {              &quot;name&quot;: &quot;hello&quot;            }          }        }      }    }  },  // 根据上面的查询、比较结果，执行actions里面定义的动作（定义多种报警类型）  &quot;actions&quot;: {    // 报警名字    &quot;log_hello&quot;: {      // 防止报警风暴： 设置阈值 15m内曾经报警过, 则不报警      &quot;throttle_period&quot;: &quot;15m&quot;,      // 报警方式：logging、mail、http等      &quot;logging&quot;: {        // 报警具体内容：使用 {{ 查询参数 }} 进行赋值：        &quot;text&quot;: &quot;Found {{ctx.payload.hits.total}} hello in the school&quot;      }    }  }}</code></pre></li><li><h3 id="ctx-payload取值规范："><a href="#ctx-payload取值规范：" class="headerlink" title="ctx.payload取值规范："></a>ctx.payload取值规范：</h3><ul><li><p>比如我们进行search搜索school里面name=zhangsan的数据：</p><pre><code class="shell">GET school/_search</code></pre><pre><code class="json">{  &quot;query&quot;: {    &quot;match&quot;: {      &quot;name&quot;: &quot;zhangsan&quot;    }  }}</code></pre><p>查询结果如下：</p><pre><code class="json">{  &quot;took&quot;: 14,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: {    &quot;total&quot;: 2,    &quot;successful&quot;: 2,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  },  &quot;hits&quot;: {    &quot;total&quot;: 1,    &quot;max_score&quot;: 1.5404451,    &quot;hits&quot;: [      {        &quot;_index&quot;: &quot;school&quot;,        &quot;_type&quot;: &quot;student&quot;,        &quot;_id&quot;: &quot;1&quot;,        &quot;_score&quot;: 1.5404451,        &quot;_source&quot;: {          &quot;name&quot;: &quot;zhangsan&quot;,          &quot;age&quot;: 25,          &quot;course&quot;: &quot;elasticsearch&quot;,          &quot;study_date&quot;: &quot;2018-06-15T20:30:50&quot;,          &quot;mark&quot;: &quot;today is a good day&quot;        }      }    ]  }}</code></pre><p>表示查询：ctx.payload结果集：</p><pre><code>{{#ctx.payload.hits.hits}} {{_source.name}} {{_source.course}} {{/ctx.payload.hits.hits}}</code></pre></li><li><p>比如我们进行search搜索school，并采用聚合的方式来查询terms course数据：</p><pre><code class="shell">GET school/_search</code></pre><pre><code class="json">{  &quot;size&quot; : 0,   &quot;aggs&quot; : {    &quot;myterms&quot; : {      &quot;terms&quot; : {        &quot;field&quot; : &quot;course&quot;,        &quot;size&quot; : 10      }    }  }}</code></pre><p>查询结果：</p><pre><code class="json">{  &quot;took&quot;: 11,  &quot;timed_out&quot;: false,  &quot;_shards&quot;: {    &quot;total&quot;: 2,    &quot;successful&quot;: 2,    &quot;skipped&quot;: 0,    &quot;failed&quot;: 0  },  &quot;hits&quot;: {    &quot;total&quot;: 10,    &quot;max_score&quot;: 0,    &quot;hits&quot;: []  },  &quot;aggregations&quot;: {    &quot;myterms&quot;: {      &quot;doc_count_error_upper_bound&quot;: 0,      &quot;sum_other_doc_count&quot;: 0,      &quot;buckets&quot;: [        {          &quot;key&quot;: &quot;elasticsearch&quot;,          &quot;doc_count&quot;: 7        },        {          &quot;key&quot;: &quot;good&quot;,          &quot;doc_count&quot;: 1        },        {          &quot;key&quot;: &quot;spring&quot;,          &quot;doc_count&quot;: 1        },        {          &quot;key&quot;: &quot;spring elasticsearch&quot;,          &quot;doc_count&quot;: 1        }      ]    }  }}</code></pre><p>payload取值使用：现在想取得上面的hits.hits里面的数据内容，就可以使用如下方式：</p><blockquote><p>表示查询：ctx.payload结果集：</p><pre><code>{{#ctx.payload.aggregations.aggsname.buckets}} {{key}} {{doc_count}} {{/ctx.payload.aggregations.aggsname.buckets}}</code></pre><p>针对这里内容就是：</p><pre><code>{{#ctx.payload.aggregations.myterms.buckets}} {{key}} {{doc_count}} {{/ctx.payload.aggregations.myterms.buckets}}</code></pre></blockquote></li></ul></li><li><h3 id="watcher-API使用："><a href="#watcher-API使用：" class="headerlink" title="watcher API使用："></a>watcher API使用：</h3><ul><li><p>查看一个watcher</p><pre><code class="shell">GET _xpack/watcher/watch/school_watcher</code></pre></li><li><p>删除一个watcher</p><pre><code class="shell">DELETE _xpack/watcher/watch/school_watcher</code></pre></li><li><p>执行watcher</p><pre><code class="shell">POST _xpack/watcher/watch/school_watcher/_execute</code></pre></li><li><p>查看执行结果</p><pre><code class="shell">GET /.watcher-history*/_search?pretty</code></pre><pre><code class="json">{  &quot;sort&quot; : [    { &quot;result.execution_time&quot; : &quot;desc&quot; }  ],  &quot;query&quot;: {    &quot;match&quot;: {      &quot;watch_id&quot;: &quot;school_watcher&quot;    }  }}</code></pre></li></ul></li><li><h3 id="triggers的几种类型"><a href="#triggers的几种类型" class="headerlink" title="triggers的几种类型"></a>triggers的几种类型</h3><blockquote><p>hourly、daily、weekly、monthly、yearly、cron、interval</p></blockquote><ul><li><p>hourly：每小时执行</p><blockquote><p>例如：12:00, 12:15, 12:30, 12:45, 1:00, 1:15</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;hourly&quot; : { &quot;minute&quot; : [ 0, 15, 30, 45 ] }    }  }}</code></pre></li><li><p>daily：每天执行</p><blockquote><p>每天00:00, 12:00, and 17:00</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;daily&quot; : { &quot;at&quot; : [ &quot;midnight&quot;, &quot;noon&quot;, &quot;17:00&quot; ] }    }  }}</code></pre><blockquote><p>每天00:00, 00:30, 12:00, 12:30, 17:00 and 17:30</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;daily&quot; : {        &quot;at&quot; {          &quot;hour&quot; : [ 0, 12, 17 ],          &quot;minute&quot; : [0, 30]        }      }    }  }}</code></pre></li><li><p>weekly：指定星期几</p><blockquote><p>周二12:00,周五17:00</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;weekly&quot; : [        { &quot;on&quot; : &quot;tuesday&quot;, &quot;at&quot; : &quot;noon&quot; },        { &quot;on&quot; : &quot;friday&quot;, &quot;at&quot; : &quot;17:00&quot; }      ]    }  }}</code></pre><blockquote><p>周二、周五的17：00</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;weekly&quot; : {        &quot;on&quot; : [ &quot;tuesday&quot;, &quot;friday&quot; ],        &quot;at&quot; : [ &quot;noon&quot;, &quot;17:00&quot; ]      }    }  }}</code></pre></li><li><p>monthly：指定每月哪天执行</p><blockquote><p>每月10号中午、每月20号17:00</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;monthly&quot; : [        { &quot;on&quot; : 10, &quot;at&quot; : &quot;noon&quot; },        { &quot;on&quot; : 20, &quot;at&quot; : &quot;17:00&quot; }      ]    }  }}</code></pre><blockquote><p>每月10号、20号的00:00,12:00</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;monthly&quot; : {        &quot;on&quot; : [ 10, 20 ],        &quot;at&quot; : [ &quot;midnight&quot;, &quot;noon&quot; ]      }    }  }}</code></pre></li><li><p>yearly-指定月、日、时</p><blockquote><p>每年的1月10日12:00,每年的7月20日17:00</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;yearly&quot; : [        { &quot;in&quot; : &quot;january&quot;, &quot;on&quot; : 10, &quot;at&quot; : &quot;noon&quot; },        { &quot;in&quot; : &quot;july&quot;, &quot;on&quot; : 20, &quot;at&quot; : &quot;17:00&quot; }      ]    }  }}</code></pre><blockquote><p>每年1月10日，1月20日，12月10日，12月20日的12:00,00:00</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;yearly&quot; : {        &quot;in&quot; : [ &quot;jan&quot;, &quot;dec&quot; ],        &quot;on&quot; : [ 10, 20 ],        &quot;at&quot; : [ &quot;midnight&quot;, &quot;noon&quot; ]      }    }  }}</code></pre></li><li><p>cron-表达式</p><blockquote><p><seconds> <minutes> <hours> <day_of_month> <month> <day_of_week> [year]</p></blockquote><pre><code class="shell">0 5 9 * * ?0 0-5 9 * * ?0 0/15 9 * * ?</code></pre></li><li><p>interval-周期的</p><blockquote><p>间隔单位：s:秒、m:分钟、h:小时、d:天、w:星期</p></blockquote></li></ul></li><li><p>input的几种类型：</p><blockquote><p>Simple、Search、HTTP、Chain</p></blockquote><ul><li><p>Simple Input-静态数据</p><blockquote><p>每天12点触发</p></blockquote><pre><code class="json">{  &quot;trigger&quot; : {    &quot;schedule&quot; : {      &quot;daily&quot; : { &quot;at&quot; : &quot;noon&quot; }    }  },  &quot;input&quot; : {    &quot;simple&quot; : {      &quot;name&quot; : &quot;John&quot;    }  },  &quot;actions&quot; : {    &quot;reminder_email&quot; : {      &quot;email&quot; : {        &quot;to&quot; : &quot;to@host.domain&quot;,        &quot;subject&quot; : &quot;Reminder&quot;,        &quot;body&quot; : &quot;Dear {{ctx.payload.name}}, by the time you read these lines, I&#39;ll be gone&quot;      }    }  }}</code></pre></li><li><p>Search-搜索</p><pre><code class="json">{  &quot;input&quot; : {    &quot;search&quot; : {      &quot;request&quot; : {        &quot;indices&quot; : [ &quot;logs&quot; ],        &quot;body&quot; : {          &quot;query&quot; : { &quot;match_all&quot; : {} }        }      }    }  },  &quot;condition&quot; : {    &quot;compare&quot; : { &quot;ctx.payload.hits.total&quot; : { &quot;gt&quot; : 5 }}  }    ...}</code></pre></li><li><p>Http-请求</p><blockquote><p>request.host<br>request.port<br>request.path<br>request.headers<br>request.params<br>request.url：request.scheme, request.host, request.port and request.params<br>request.method：head、get、post、put、delete<br>request.auth<br>request.body<br>request.proxy.host<br>request.proxy.port<br>request.connection_timeout<br>request.read_timeout<br>response_content_type：json, yaml and text<br>extract</p></blockquote><blockquote><p>get请求</p></blockquote><pre><code class="json">{  &quot;input&quot; : {    &quot;http&quot; : {      &quot;request&quot; : {        &quot;host&quot; : &quot;example.com&quot;,        &quot;port&quot; : 9200,        &quot;path&quot; : &quot;/idx/_search&quot;      }    }  }}</code></pre><blockquote><p>含有body体内容</p></blockquote><pre><code class="json">{  &quot;input&quot; : {    &quot;http&quot; : {      &quot;request&quot; : {        &quot;host&quot; : &quot;host.domain&quot;,        &quot;port&quot; : 9200,        &quot;path&quot; : &quot;/idx/_search&quot;,        &quot;body&quot; :  &quot;{&quot;query&quot; :  {  &quot;match&quot; : { &quot;category&quot; : &quot;event&quot;}}}&quot;      }    }  }}</code></pre><blockquote><p>含有参数的</p></blockquote><pre><code class="json">{  &quot;input&quot; : {    &quot;http&quot; : {      &quot;request&quot; : {        &quot;host&quot; : &quot;host.domain&quot;,        &quot;port&quot; : &quot;9200&quot;,        &quot;path&quot; : &quot;/_cluster/stats&quot;,        &quot;params&quot; : {          &quot;human&quot; : &quot;true&quot;         }      }    }  }}</code></pre><blockquote><p>含有用户密码</p></blockquote><pre><code class="json">{  &quot;input&quot; : {    &quot;http&quot; : {      &quot;request&quot; : {        &quot;host&quot; : &quot;host.domain&quot;,        &quot;port&quot; : &quot;9200&quot;,        &quot;path&quot; : &quot;/myservice&quot;,        &quot;auth&quot; : {          &quot;basic&quot; : {            &quot;username&quot; : &quot;user&quot;,            &quot;password&quot; : &quot;pass&quot;          }        }      }    }  }}</code></pre><blockquote><p>直接请求url的</p></blockquote><pre><code class="json">{  &quot;input&quot; : {    &quot;http&quot; : {      &quot;request&quot; : {        &quot;url&quot; : &quot;http://api.openweathermap.org/data/2.5/weather&quot;,        &quot;params&quot; : {          &quot;lat&quot; : &quot;52.374031&quot;,          &quot;lon&quot; : &quot;4.88969&quot;,          &quot;appid&quot; : &quot;&lt;your openweathermap appid&gt;&quot;        }      }    }  }}</code></pre></li><li><p>Chain-input-同时设置多个input，串行</p><pre><code class="json">{  &quot;input&quot; : {    &quot;chain&quot; : {      &quot;inputs&quot; : [         // 第一步input        {          &quot;first&quot; : {            &quot;simple&quot; : { &quot;path&quot; : &quot;/_search&quot; }          }        },        // 第二步input （可以去使用第一步input返回的结果）        {          &quot;second&quot; : {            &quot;http&quot; : {              &quot;request&quot; : {                &quot;host&quot; : &quot;localhost&quot;,                &quot;port&quot; : 9200,                &quot;path&quot; : &quot;{{ctx.payload.first.path}}&quot;               }            }          }        }      ]    }  }}</code></pre></li></ul></li><li><h3 id="condition条件设置"><a href="#condition条件设置" class="headerlink" title="condition条件设置"></a>condition条件设置</h3><blockquote><p>如果condition条件返回true，则会触发action。如果返回 false，则就停止，不执行action</p></blockquote><ul><li><p>Always Condition</p><pre><code class="json">&quot;condition&quot; : {  &quot;always&quot; : {}}</code></pre></li><li><p>Never Condition</p><pre><code class="json">&quot;condition&quot; : {  &quot;never&quot; : {}}</code></pre></li><li><p>Compare Condition （和查询结果进行比较の语法如下：）</p><blockquote><p>eq、not_eq、gt、gte、lt、lte</p></blockquote><ul><li><p>比如错误条数超过了5条进行报警、响应长时间超过多少毫秒进行报警等</p><pre><code class="json">{  &quot;condition&quot; : {    &quot;compare&quot; : {      &quot;ctx.payload.hits.total&quot; : {         &quot;gte&quot; : 5       }    }  }}</code></pre></li></ul><blockquote><p>&lt;{expression}&gt; 正则表达式，使用 &lt;&gt; 中写正则表达式</p></blockquote><ul><li><p>比如 当前时间 - 5分钟 进行比较，如下：</p><pre><code class="json">{  &quot;condition&quot; : {    &quot;compare&quot; : {      &quot;ctx.execution_time&quot; : {        &quot;gte&quot; : &quot;&lt;{now-5m}&gt;&quot;      }    }  }}</code></pre></li></ul><blockquote>imooc/1297-MQ-Kafka/04-12-watcher-base/ 比较，这个就是最开始的示例里面的获取参数方式，如下：</blockquote><pre><code class="json">{  &quot;condition&quot; : {    &quot;compare&quot; : {      &quot;ctx.payload.aggregations.status.buckets.error.doc_count&quot; : {        &quot;not_eq&quot; : &quot;{{ctx.payload.aggregations.handled.buckets.true.doc_count}}&quot;      }    }  }}</code></pre></li><li><p>Array Compare Condition 数组比较</p><blockquote><p>比如当前的doc_count大于25 就进行报警</p></blockquote><pre><code class="json">{  &quot;condition&quot;: {    &quot;array_compare&quot;: {      &quot;ctx.payload.aggregations.top_tweeters.buckets&quot; : {         &quot;path&quot;: &quot;doc_count&quot; ,        &quot;gte&quot;: {           &quot;value&quot;: 25,         }      }    }  }}</code></pre></li><li><p>Script Condition 脚本方式</p><pre><code class="json">{  &quot;input&quot; : {    &quot;search&quot; : {      &quot;indices&quot; : &quot;log-events&quot;,      &quot;body&quot; : {        &quot;size&quot; : 0,        &quot;query&quot; : { &quot;match&quot; : { &quot;status&quot; : &quot;error&quot; } }      }    }  },  &quot;condition&quot; : {    &quot;script&quot; : {      // 当前返回的条数是否大于阈值，进行报警      &quot;inline&quot; : &quot;return ctx.payload.hits.total &gt; threshold&quot;,      &quot;params&quot; : {      &quot;threshold&quot; : 5    }  }}</code></pre></li></ul></li><li><h3 id="Action-触发器"><a href="#Action-触发器" class="headerlink" title="Action 触发器"></a>Action 触发器</h3><ul><li><p>Email Action–发送邮件 </p><blockquote><p>如果使用发送邮件的报警，则需要在elasticsearch.yml中配置发送邮件服务的信息</p></blockquote><pre><code class="yaml">xpack.notification.email:   default_account: gmail_account   account:     gmail_account:         profile: gmail         smtp:             auth: true             starttls.enable: true             host: smtp.gmail.com             port: 587             user: &lt;username&gt;             password: &lt;password&gt;     outlook_account:         profile: outlook         smtp:             auth: true             starttls.enable: true             host: smtp-mail.outlook.com             port: 587             user: &lt;username&gt;             password: &lt;password&gt;:       exchange_account:         profile: outlook         email_defaults:             from: &lt;email address of service account&gt;          smtp:             auth: true             starttls.enable: true             host: &lt;your exchange server&gt;             port: 587             user: &lt;email address of service account&gt;              password: &lt;password&gt;</code></pre><ul><li><p>发送邮件</p><pre><code class="json">&quot;actions&quot; : {  // actions名字  &quot;send_email&quot; : {     &quot;email&quot; : {       &quot;to&quot; : &quot;&#39;Recipient Name &lt;recipient@example.com&gt;&#39;&quot;,       // &quot;to&quot; : [&#39;Personal Name &lt;user1@host.domain&gt;&#39;, &#39;user2@host.domain&#39;],       &quot;subject&quot; : &quot;Watcher Notification&quot;,       &quot;body&quot; : &quot;{{ctx.payload.hits.total}} error logs found&quot;     }  }}</code></pre></li><li><p>发送含有附件信息的邮件</p><pre><code class="json">&quot;actions&quot; : {  &quot;email_admin&quot; : {    &quot;email&quot;: {      &quot;to&quot;: &quot;&#39;John Doe &lt;john.doe@example.com&gt;&#39;&quot;,      &quot;attachments&quot; : {        // 附件方式        &quot;my_image.png&quot; : {           &quot;http&quot; : {             &quot;content_type&quot; : &quot;image.png&quot;,            &quot;request&quot; : {              &quot;url&quot;: &quot;http://example.org/foo/my-image.png&quot;             }          }        },        // xpack reporting插件生成方式：        &quot;dashboard.pdf&quot; : {          &quot;reporting&quot; : {            &quot;url&quot;: &quot;http://example.org:5601/api/reporting/generate/dashboard/Error-Monitoring&quot;          }        },        // 自定义附件        &quot;data.yml&quot; : {          &quot;data&quot; : {            &quot;format&quot; : &quot;yaml&quot;           }        }      }    }  }}</code></pre></li></ul></li><li><p>Webhook Action，发送一个http请求</p><ul><li><p>发送github的issue</p><pre><code class="json">&quot;actions&quot; : {  &quot;create_github_issue&quot; : {    // 因为发邮件到达率不是特别高，所以可以使用外部的接口调用方式    // 比如这里调用url为外部的手机短信接口进行发送     &quot;webhook&quot; : {      // 请求方式      &quot;method&quot; : &quot;POST&quot;,      // 外部请求地址      &quot;url&quot; : &quot;https://api.github.com/repos/&lt;owner&gt;/&lt;repo&gt;/issues&quot;,      // 请求报文      &quot;body&quot; : {        &quot;title&quot;: &quot;Found errors in &#39;contact.html&#39;&quot;,        &quot;body&quot;: &quot;Found {{ctx.payload.hits.total}} errors in the last 5 minutes&quot;,        &quot;assignee&quot;: &quot;web-admin&quot;,        &quot;labels&quot;: [ &quot;bug&quot;, &quot;sev2&quot; ]      },      // 用户名密码      &quot;auth&quot; : {        &quot;basic&quot; : {          &quot;username&quot; : &quot;&lt;username&gt;&quot;,           &quot;password&quot; : &quot;&lt;password&gt;&quot;        }      }    }  }}</code></pre></li><li><p>带有url参数的请求</p><pre><code class="json">&quot;actions&quot; : {  &quot;my_webhook&quot; : {    &quot;webhook&quot; : {      &quot;method&quot; : &quot;POST&quot;,      &quot;host&quot; : &quot;mylisteningserver&quot;,      &quot;port&quot; : 9200,      &quot;path&quot;: &quot;:/alert&quot;,      &quot;params&quot; : {        &quot;watch_id&quot; : &quot;{{ctx.watch_id}}&quot;       }    }  }}</code></pre></li><li><p>自定义header</p><pre><code class="json">&quot;actions&quot; : {  &quot;my_webhook&quot; : {    &quot;webhook&quot; : {      &quot;method&quot; : &quot;POST&quot;,      &quot;host&quot; : &quot;mylisteningserver&quot;,      &quot;port&quot; : 9200,      &quot;path&quot;: &quot;:/alert/{{ctx.watch_id}}&quot;,      &quot;headers&quot; : {        &quot;Content-Type&quot; : &quot;application/yaml&quot;       },      &quot;body&quot; : &quot;count: {{ctx.payload.hits.total}}&quot;    }  }}</code></pre></li></ul></li><li><p>Index Action–创建索引文档</p><pre><code class="json">&quot;actions&quot; : {  &quot;index_payload&quot; : {     &quot;index&quot; : {      &quot;index&quot; : &quot;my-index&quot;,       &quot;doc_type&quot; : &quot;my-type&quot;,       &quot;doc_id&quot;: &quot;my-id&quot;     }  }}</code></pre></li><li><p>Logging Action–记录日志</p><blockquote><p>level：error, warn, info, debug and trace</p><p>日志种类：</p><ul><li>category：xpack.watcher.actions.logging</li></ul></blockquote><pre><code class="json">&quot;actions&quot; : {  &quot;log&quot; : {     &quot;transform&quot; : {  },     // 日志报警    &quot;logging&quot; : {      &quot;text&quot; : &quot;executed at {{ctx.execution_time}}&quot;,      // 日志级别      &quot;level&quot;: &quot;info&quot;    }  }}</code></pre></li><li><p>Jira Action 与jira集成</p></li><li><p>HipChat Action</p></li><li><p>Slack Action</p></li><li><p>PagerDuty Action</p></li></ul></li><li><h3 id="使用接口的形式创建一个watcher-进行模拟："><a href="#使用接口的形式创建一个watcher-进行模拟：" class="headerlink" title="使用接口的形式创建一个watcher, 进行模拟："></a>使用接口的形式创建一个watcher, 进行模拟：</h3><ul><li><p>执watcher脚本：</p><ul><li><p>查询school</p><pre><code class="shell">GET school/student/_search</code></pre><pre><code class="json">{  &quot;query&quot;: {    &quot;match_all&quot;:{}  }}</code></pre></li><li><p>创建school_watcher</p><pre><code class="shell">PUT _xpack/watcher/watch/school_watcher</code></pre><pre><code class="json">{  &quot;trigger&quot;: {    &quot;schedule&quot;: {      &quot;interval&quot;: &quot;10s&quot;    }  },  &quot;input&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        &quot;indices&quot;: [&quot;school*&quot;],        &quot;body&quot;: {          &quot;size&quot;: 0,          &quot;query&quot;: {            &quot;match&quot;: {              &quot;name&quot;: &quot;hello&quot;            }          }        }      }    }  },  &quot;condition&quot;: {    &quot;compare&quot;: {      &quot;ctx.payload.hits.total&quot;: {        &quot;gt&quot;: 0      }    }  },  &quot;transform&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        &quot;indices&quot;: [&quot;school*&quot;],        &quot;body&quot;: {          &quot;size&quot;: 10,          &quot;query&quot;: {            &quot;match&quot;: {              &quot;name&quot;: &quot;hello&quot;            }          }        }      }    }  },  &quot;actions&quot;: {    &quot;log_hello&quot;: {      &quot;throttle_period&quot;: &quot;15m&quot;,      &quot;logging&quot;: {        &quot;text&quot;: &quot;Found {{ctx.payload.hits.total}} hello in the school&quot;      }    }  }}</code></pre></li><li><p>查看watcher执行结果</p><pre><code class="shell">GET /.watcher-history*/_search?pretty</code></pre><pre><code class="json">{  &quot;sort&quot; : [    { &quot;result.execution_time&quot; : &quot;desc&quot; }  ],  &quot;query&quot;: {    &quot;match&quot;: {      &quot;watch_id&quot;: &quot;school_watcher&quot;    }  }}</code></pre></li><li><p>进行数据测试：</p><pre><code class="json">POST /school/student</code></pre><pre><code class="json">{  &quot;name&quot;: &quot;hello&quot;,  &quot;age&quot;: 18,  &quot;course&quot;: &quot;elasticsearch&quot;,  &quot;study_date&quot;: &quot;2018-08-20T20:30:50&quot;,  &quot;mark&quot;: &quot;take care day day&quot;}</code></pre></li></ul></li><li><p>可视化操作watcher，可以启用、禁用、添加修改、删除watcher</p><blockquote><p>watch使用文章：<a href="https://www.cnblogs.com/reboot51/p/8328720.html" target="_blank" rel="noopener">https://www.cnblogs.com/reboot51/p/8328720.html</a></p></blockquote></li></ul></li></ol><h2 id="二、watcher使用："><a href="#二、watcher使用：" class="headerlink" title="二、watcher使用："></a>二、watcher使用：</h2><blockquote><p>创建一个watcher,比如定义一个trigger 每个10s钟看一下input里的数据</p></blockquote><pre><code class="shell">PUT _xpack/watcher/watch/applog_error_watcher</code></pre><pre><code class="json">{  &quot;trigger&quot;: {    &quot;schedule&quot;: {      &quot;interval&quot;: &quot;10s&quot;    }  },  &quot;input&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        &quot;indices&quot;: [&quot;javalog-app-*&quot;],        &quot;body&quot;: {          &quot;size&quot;: 0,          &quot;query&quot;: {            &quot;match&quot;: {              &quot;level&quot;: &quot;ERROR&quot;            }          }        }      }    }  },  &quot;condition&quot;: {    &quot;compare&quot;: {      &quot;ctx.payload.hits.total&quot;: {        &quot;gt&quot;: 0      }    }  },  &quot;transform&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        &quot;indices&quot;: [&quot;javalog-app-*&quot;],        &quot;body&quot;: {          &quot;size&quot;: 10,          &quot;query&quot;: {            &quot;match&quot;: {              &quot;name&quot;: &quot;hello&quot;            }          }        }      }    }  },  &quot;actions&quot;: {    &quot;test_error&quot;: {      &quot;throttle_period&quot;: &quot;1m&quot;,      &quot;webhook&quot; : {        &quot;method&quot; : &quot;POST&quot;,        &quot;url&quot; : &quot;http://192.168.11.32:8001/watch&quot;,        &quot;body&quot; : &quot;{        &quot;title&quot;: &quot;异常错误告警&quot;,        &quot;traceId&quot;: &quot;{{#ctx.payload.hits.hits}} {{_source.traceId}} {{/ctx.payload.hits.hits}}&quot;,         &quot;spanId&quot; : &quot;{{#ctx.payload.hits.hits}} {{_source.spanId}} {{/ctx.payload.hits.hits}}&quot;,        &quot;level&quot;:&quot;告警级别P1&quot;,        &quot;body&quot;: &quot;{{#ctx.payload.hits.hits}} {{_source.messageInfo}} {{/ctx.payload.hits.hits}}&quot;      }    }  }}</code></pre><pre><code>{{#ctx.payload.hits.hits}} {{_source.traceId}} {{/ctx.payload.hits.hits}}{{#ctx.payload.hits.hits}} {{_source.spanId}} {{/ctx.payload.hits.hits}}{{#ctx.payload.hits.hits}} {{_source.messageInfo}} {{/ctx.payload.hits.hits}}</code></pre><ul><li><p>查询error</p><pre><code class="shell">GET javalog-app-2019.01.24/_search</code></pre><pre><code class="json">{  &quot;query&quot;: {    &quot;match&quot;: {      &quot;level.keyword&quot;: &quot;ERROR&quot;    }  }}</code></pre></li><li><p>查看一个watcher</p><pre><code class="shell">GET _xpack/watcher/watch/applog_error_watcher</code></pre></li><li><p>删除一个watcher</p><pre><code class="shell">DELETE _xpack/watcher/watch/applog_error_watcher</code></pre></li><li><p>执行watcher</p><pre><code class="shell">POST _xpack/watcher/watch/applog_error_watcher/_execute</code></pre></li><li><p>查看执行结果</p><pre><code class="shell">GET /.watcher-history*/_search?pretty</code></pre><pre><code class="json">{  &quot;sort&quot; : [    { &quot;result.execution_time&quot; : &quot;desc&quot; }  ],  &quot;query&quot;: {    &quot;match&quot;: {      &quot;watch_id&quot;: &quot;applog_error_watcher&quot;    }  }}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Kafka海量日志收集系统架构设计(logstash)</title>
      <link href="/imooc/1297-MQ-Kafka/04-06-logstash-base/"/>
      <url>/imooc/1297-MQ-Kafka/04-06-logstash-base/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="logstash基础语法与使用"><a href="#logstash基础语法与使用" class="headerlink" title="logstash基础语法与使用"></a>logstash基础语法与使用</h2><h3 id="1-logstash安装："><a href="#1-logstash安装：" class="headerlink" title="1. logstash安装："></a>1. logstash安装：</h3><ol><li><p>Mac安装</p><pre><code class="shell">brew install logstash</code></pre></li><li><p>conf下配置文件说明</p><blockquote><p>logstash配置：config/logstash.yml</p><p>JVM虚拟机配置：config/jvm.options</p><p>日志配置：log4j2.properties</p><p>启动配置：config/startup.options</p></blockquote><ul><li><p>logstash配置说明</p><pre><code class="shell"># config/logstash.yml--path.config #  或 –f。logstash启动时使用的配置文件--configtest # 或 –t。测试 Logstash 读取到的配置文件语法是否能正常解析--log或-l：# 日志输出存储位置--pipeline.workers # 或 –w。运行 filter 和 output 的 pipeline 线程数量。默认是 CPU 核数。增加workers工作线程数可以有效提升logstash性能--pipeline.batch.size # 或 –b。每个 Logstash pipeline 线程，在执行具体的 filter 和 output 函数之前，最多能累积的日志条数--pipeline.batch.delay # 或 –u。每个 Logstash pipeline 线程，在打包批量日志的时候，最多等待几毫秒。--verbose：# 输出调试日志--debug：# 输出更多的调试日志</code></pre></li><li><p>启动配置，比如启动时的java位置、LS的home等</p><pre><code class="shell"># config/startup.options</code></pre></li></ul></li><li><p>启动logstash</p><pre><code class="shell">logstash -f script/logstash-script.conf</code></pre></li></ol><pre><code class="shell">## 数据收集目录：/usr/local/logstash-6.6.0/data## 插件目录：/usr/local/logstash-6.6.0/vendor/bundle/jruby/1.9/gems## 查看插件命令：/usr/local/logstash-6.6.0/bin/logstash-plugin list## 更新插件命令：/usr/local/logstash-6.6.0/bin/logstash-plugin update logstash-xxxx-xxxxx## 安装插件命令：/usr/local/logstash-6.6.0/bin/logstash-plugin install logstash-xxxx-xxxxx## 插件地址： https://github.com/logstash-plugins</code></pre><h3 id="2-logstash语法与基本使用"><a href="#2-logstash语法与基本使用" class="headerlink" title="2. logstash语法与基本使用"></a>2. logstash语法与基本使用</h3><ol><li><p>Logstash设计了自己的DSL包括有区域，注释，数据类型(布尔值，字符串，数值，数组，哈希)，条件判断字段引用等。</p></li><li><p>Logstash用{}来定义区域。区域内可以包括插件区域定义，你可以在一个区域内定义多个插件。插件区域内则可以定义键值对设置。</p></li><li><p>格式、语法、使用方式：</p><pre><code class="shell"># 注释.input {  ...}filter {  ...}output {  ...}</code></pre><pre><code class="shell">## 两个input设置：input {  file {    path =&gt; &quot;/var/log/messages&quot;    type =&gt; &quot;syslog&quot;  }  file {    path =&gt; &quot;/var/log/apache/access.log&quot;    type =&gt; &quot;apache&quot;  }}</code></pre><pre><code class="shell">## 数据类型：## bool类型debug =&gt; true## string类型host =&gt; &quot;hostname&quot;## number类型port =&gt; 6789## array or list类型path =&gt; [&quot;/var/log/message&quot;,&quot;/var/log/*.log&quot;]## hash类型match =&gt; {    &quot;field1&quot; =&gt; &quot;value1&quot;    &quot;field2&quot; =&gt; &quot;value2&quot;}## codec类型codec =&gt; &quot;json&quot;##字段引用方式：{    &quot;agent&quot;:  &quot;Mozilla/5.0  (compatible;  MSIE  9.0)&quot;,    &quot;ip&quot;:  &quot;192.168.24.44&quot;,    &quot;request&quot;:  &quot;/index.html&quot;    &quot;response&quot;:  {        &quot;status&quot;:  200,        &quot;bytes&quot;:  52353    },    &quot;ua&quot;:  {        &quot;os&quot;:  &quot;Windows  7&quot;    }}##获取字段值：[response][status][ua][os]</code></pre><pre><code class="shell">## 条件判断condition：if EXPRESSION {  ...} else if EXPRESSION {  ...} else {  ...}==(等于), !=(不等于), &lt;(小于), &gt;(大于), &lt;=(小于等于), &gt;=(大于等于), =~(匹配正则), !~（不匹配正则）in(包含), not in(不包含), and(与), or(或), nand(非与), xor(非或)()(复合表达式), !()(对复合表达式结果取反)</code></pre><pre><code class="shell">## 使用环境变量（缺失报错）:input {     tcp {         port =&gt; &quot;${TCP_PORT}&quot;     } }## 使用环境变量（缺失使用默认值）：input {     tcp {         port =&gt; &quot;${TCP_PORT:54321}&quot;     } }</code></pre></li><li><p>logstash例子：</p><pre><code class="shell">## input 从标准输入流：input { stdin { } }## 输入数据之后 如何进行处理：filter {  ## grok：解析元数据插件,这里从input输入进来的所有数据默认都会存放到 &quot;message&quot; 字段中  ## grok提供很多正则表达式，地址为：http://grokdebug.herokuapp.com/patterns  ## 比如：%{COMBINEDAPACHELOG} 表示其中一种正则表达式 Apache的表达式  grok {    match =&gt; { &quot;message&quot; =&gt; &quot;%{COMBINEDAPACHELOG}&quot; }  }  ## date：日期格式化  date {    match =&gt; [ &quot;timestamp&quot; , &quot;dd/MMM/yyyy:HH:mm:ss Z&quot; ]  }}## output 从标准输出流：output {  elasticsearch { hosts =&gt; [&quot;192.168.11.35:9200&quot;] }  stdout { codec =&gt; rubydebug }}</code></pre></li><li><p>file插件使用：</p><pre><code class="shell">## file插件input {    file {        path =&gt; [&quot;/var/log/*.log&quot;, &quot;/var/log/message&quot;]        type =&gt; &quot;system&quot;        start_position =&gt; &quot;beginning&quot;    }}## 其他参数：discover_interval ## 表示每隔多久检测一下文件，默认15秒exclude ## 表示排除那些文件close_older ## 文件超过多长时间没有更新，就关闭监听 默认3600signore_older ## 每次检查文件列表 如果有一个文件 最后修改时间超过这个值 那么就忽略文件 86400ssincedb_path ## sincedb保存文件的位置，默认存在home下（/dev/null）sincedb_write_interval ## 每隔多久去记录一次 默认15秒stat_interval ## 每隔多久查询一次文件状态 默认1秒start_position ## 从头开始读取或者从结尾开始读取</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Kafka海量日志收集系统架构设计</title>
      <link href="/imooc/1297-MQ-Kafka/04-kafka-log-collect/"/>
      <url>/imooc/1297-MQ-Kafka/04-kafka-log-collect/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="4-1-Kafka海量日志收集实战-架构设计讲解"><a href="#4-1-Kafka海量日志收集实战-架构设计讲解" class="headerlink" title="4-1 Kafka海量日志收集实战_架构设计讲解"></a>4-1 Kafka海量日志收集实战_架构设计讲解</h2><ul><li><p>ELK技术栈的架构示意图</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd9oxf1cp9j312y0hf75w.jpg" alt="ELK技术栈的架构示意图" style="zoom:80%;" /><blockquote><p>Kafka做缓冲，为Broker；Filebeat为Producer；Logstash为Comsumer</p></blockquote></li><li><p>海量日志收集实战架构设计图</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd9oyc8rbkj318g0al0uf.jpg" alt="海量日志收集实战架构设计图" style="zoom:80%;" /></li></ul><h2 id="4-2-Kafka海量日志收集实战-log4j2日志输出实战-1"><a href="#4-2-Kafka海量日志收集实战-log4j2日志输出实战-1" class="headerlink" title="4-2 Kafka海量日志收集实战_log4j2日志输出实战-1"></a>4-2 Kafka海量日志收集实战_log4j2日志输出实战-1</h2><p>Log4j2：日志输出、日志分级、日志过滤、MDC线程变量</p><ol><li><p>Maven配置</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;            &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.lmax&lt;/groupId&gt;    &lt;artifactId&gt;disruptor&lt;/artifactId&gt;    &lt;version&gt;3.3.4&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>application.yml</p><pre><code class="yaml">spring:  application:    name: kafka=log-collect  http:    encoding:      charset: utf-8  jackson:    date-format: yyyy-MM-dd HH:mm:ss    time-zone: GMT+8    default-property-inclusion: non_null</code></pre></li><li><p>IndexController</p><pre><code class="java">@Slf4j@RestController(&quot;index&quot;)public class IndexController {    @GetMapping(&quot;&quot;)    public String index(){        log.info(&quot;我是一条info日志.&quot;);        log.warn(&quot;我是一条warn日志.&quot;);        log.error(&quot;我是一条error日志.&quot;);        return &quot;idx&quot;;    }}</code></pre></li><li><p>log4j2.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;Configuration status=&quot;INFO&quot; schema=&quot;Log4J-V2.0.xsd&quot; monitorInterval=&quot;600&quot;&gt;    &lt;Properties&gt;        &lt;Property name=&quot;LOG_HOME&quot;&gt;logs&lt;/Property&gt;        &lt;Property name=&quot;FILE_NAME&quot;&gt;kafka-log-collect&lt;/Property&gt;        &lt;Property name=&quot;patternLayout&quot;&gt;[%d{yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZZ}] [%level{length=5}] [%thread-%tid] [%logger] [%X{hostName}] [%X{ip}] [%X{applicationName}] [%F, %L, %C, %M] [%m] ## &#39;%ex&#39;%n&lt;/Property&gt;    &lt;/Properties&gt;    &lt;Appenders&gt;        &lt;Console name=&quot;CONSOLE&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;${patternLayout}&quot;/&gt;        &lt;/Console&gt;        &lt;!--全量日志--&gt;        &lt;RollingRandomAccessFile name=&quot;appAppender&quot; fileName=&quot;${LOG_HOME}/app-${FILE_NAME}.log&quot; filePattern=&quot;${LOG_HOME}/app-${FILE_NAME}-%d{yyyy-MM-dd}-%i.log&quot;&gt;            &lt;PatternLayout pattern=&quot;${patternLayout}&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;500M&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;        &lt;!--错误日志,warn级别以上--&gt;        &lt;RollingRandomAccessFile name=&quot;errorAppender&quot; fileName=&quot;${LOG_HOME}/error-${FILE_NAME}.log&quot; filePattern=&quot;${LOG_HOME}/error-${FILE_NAME}-%d{yyyy-MM-dd}-%i.log&quot;&gt;            &lt;PatternLayout pattern=&quot;${patternLayout}&quot;/&gt;            &lt;Filters&gt;                &lt;ThresholdFilter level=&quot;warn&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;            &lt;/Filters&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy interval=&quot;1&quot;/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;500M&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;    &lt;/Appenders&gt;    &lt;Loggers&gt;        &lt;!--业务相关 异步logger--&gt;        &lt;AsyncLogger name=&quot;com.tuyrk.*&quot; level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;appAppender&quot;/&gt;        &lt;/AsyncLogger&gt;        &lt;AsyncLogger name=&quot;com.tuyrk.*&quot; level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;            &lt;AppenderRef ref=&quot;errorAppender&quot;/&gt;        &lt;/AsyncLogger&gt;        &lt;Root level=&quot;info&quot;&gt;            &lt;Appender-ref ref=&quot;CONSOLE&quot;/&gt;            &lt;Appender-ref ref=&quot;appAppender&quot;/&gt;            &lt;Appender-ref ref=&quot;errorAppender&quot;/&gt;        &lt;/Root&gt;    &lt;/Loggers&gt;&lt;/Configuration&gt;</code></pre></li></ol><h2 id="4-3-Kafka海量日志收集实战-log4j2日志输出实战-2"><a href="#4-3-Kafka海量日志收集实战-log4j2日志输出实战-2" class="headerlink" title="4-3 Kafka海量日志收集实战_log4j2日志输出实战-2"></a>4-3 Kafka海量日志收集实战_log4j2日志输出实战-2</h2><pre><code class="java">@Componentpublic class InputMDC implements EnvironmentAware {    private static Environment environment;    @Override    public void setEnvironment(Environment environment) {        InputMDC.environment = environment;    }    public static void putMDC() {        MDC.put(&quot;hostName&quot;, NetUtils.getLocalHostname());        MDC.put(&quot;ip&quot;, NetUtils.getMacAddressString());        MDC.put(&quot;applicationName&quot;, environment.getProperty(&quot;spring.application.name&quot;));    }}</code></pre><pre><code class="java">@Slf4j@RestController@RequestMapping(&quot;index&quot;)public class IndexController {    @GetMapping(&quot;err&quot;)    public String err() {        InputMDC.putMDC();        try {            int a = 1 / 0;        } catch (Exception e) {            log.error(&quot;算术异常&quot;, e);        }        return &quot;err&quot;;    }}</code></pre><pre><code>http://localhost:8081/kafka/indexhttp://localhost:8081/kafka/index/err</code></pre><h2 id="4-4-Kafka海量日志收集实战-filebeat日志收集实战-1"><a href="#4-4-Kafka海量日志收集实战-filebeat日志收集实战-1" class="headerlink" title="4-4 Kafka海量日志收集实战_filebeat日志收集实战-1"></a>4-4 Kafka海量日志收集实战_filebeat日志收集实战-1</h2><p>FileBeat：安装入门、配置文件、对接Kafka、实战应用</p><ol><li><p>filebeat安装</p><pre><code class="shell">brew install filebeat</code></pre></li><li><p>配置filebeat，可以参考filebeat.full.yml（指定配置文件位置来启动filebeat）</p><pre><code class="shell">vim ~/Develop/1297-kafka/src/main/resources/filebeat.yml</code></pre><pre><code class="yaml">filebeat.prospectors:- input_type: log  paths: # 日志路径    ## app-服务名称.log，为什么写死？防止发生轮转抓取历史数据    - /Users/tuyuankun/Develop/1297-kafka/logs/app-kafka-log-collect.log  # 定义写入ES时的_type值  document_type: &quot;app-log&quot;  multiline:    # pattern: &#39;^\s*(\d{4}|\d{2})\-(\d{2}|[a-zA-Z]{3})\-(\d{2}|\d{4})&#39; # 指定匹配的表达式（配置）    pattern: &#39;^\[&#39;      # 指定配置的表达式（匹配以&quot;{开头的字符串）    nagate: true        # 是否匹配到    match: after        # 合并到上一行的末尾    max_lines: 2000     # 最大的行数    timeout: 2s         # 如果在规定时间没有新的日志事件就不等待后面的日志，把已收集到的就推送到其他地方  fields:    logbiz: kafka-log-collect   # 应用名称    logtopic: app-kafka-log-collect # 按服务划分用作kafka topic    evn: dev- input_type: log  paths: # 日志路径    - /Users/tuyuankun/Develop/1297-kafka/logs/error-kafka-log-collect.log  document_type: &quot;error-log&quot;  multiline:    # pattern: &#39;^\s*(\d{4}|\d{2})\-(\d{2}|[a-zA-Z]{3})\-(\d{2}|\d{4})&#39; # 指定匹配的表达式（配置）    pattern: &#39;^\[&#39;      # 指定配置的表达式（匹配以&quot;{开头的字符串）    nagate: true        # 是否匹配到    match: after        # 合并到上一行的末尾    max_lines: 2000     # 最大的行数    timeout: 2s         # 如果在规定时间没有新的日志事件就不等待后面的日志，把已收集到的就推送到其他地方  fields:    logbiz: kafka-log-collect   # 应用名称    logtopic: error-kafka-log-collect # 按服务划分用作kafka topic    evn: devoutput.kafka:  enabled: true  hosts: [&quot;localhost:9092&quot;]  topic: &#39;%{[fields.logtopic]}&#39;  partition.hash:    reachable_only: true  compression: gzip  max_message_bytes: 1000000  required_acks: 1logging.to_files: true</code></pre></li><li><p>检查配置是否正确</p><pre><code class="shell">filebeat test config ~/Develop/1297-kafka/src/main/resources/filebeat.yml# Config OK</code></pre></li><li><p>启动filebeat</p><pre><code class="shell">filebeat -c ~/Develop/1297-kafka/src/main/resources/filebeat.ymlps -ef | grep filebeat</code></pre></li></ol><blockquote><p><strong>注</strong>：</p><ol><li><p>在启动filebeat前先启动项目、zookeeper、kafka、创建topic</p></li><li><p>filebeat启动日志：<code>cat /usr/local/var/log/filebeat/filebeat</code></p></li><li><p>错误：ERROR    fileset/modules.go:95    Not loading modules. Module directory not found: /usr/local/Cellar/filebeat/6.2.4/module</p><p>解决方案：将<code>/usr/local/etc/filebeat/module</code>复制到<code>/usr/local/Cellar/filebeat/6.2.4/module</code>。（<strong>brew安装真是坑</strong>）</p></li><li><p>日志路径<code>paths</code>不能写作<code>~/Develop/1297-kafka/logs/app-kafka-log-collect.log</code>，须写作<code>/Users/tuyuankun/Develop/1297-kafka/logs/app-kafka-log-collect.log</code></p></li></ol></blockquote><h2 id="4-5-Kafka海量日志收集实战-filebeat日志收集实战-2"><a href="#4-5-Kafka海量日志收集实战-filebeat日志收集实战-2" class="headerlink" title="4-5 Kafka海量日志收集实战_filebeat日志收集实战-2"></a>4-5 Kafka海量日志收集实战_filebeat日志收集实战-2</h2><ol><li><p>查看topic情况</p><pre><code class="shell">kafka-topics --zookeeper localhost:2181 --describe --topic app-kafka-log-collect</code></pre></li><li><p>查看kafka是否有数据</p><pre><code class="shell"># 查看kafka配置文件的log.dirs属性，即获取kafka日志文件夹路径cat /usr/local/etc/kafka/server.properties # log.dirs=/usr/local/var/lib/kafka-logs# 进入partition对应的文件夹下查看cd /usr/local/var/lib/kafka-logs/app-kafka-log-collect-0/</code></pre></li></ol><h2 id="4-6-附：logstash基础语法与使用"><a href="#4-6-附：logstash基础语法与使用" class="headerlink" title="4-6 附：logstash基础语法与使用"></a>4-6 附：<a href="04-06-logstash-base.md">logstash基础语法与使用</a></h2><p>安装ElasticSearch、Kibana、Logstash（官网安装方法）</p><pre><code class="shell">brew tap elastic/tapbrew install elastic/tap/elasticsearch-fullbrew install elastic/tap/kibana-fullbrew install elastic/tap/logstash-full</code></pre><p>注：</p><ol><li><p>不要使用<code>brew install elasticsearch</code>安装，因为此方法安装了oss版，而不能使用oss版</p></li><li><p>错误：<code>Error opening log file &#39;logs/gc.log&#39;: No such file or directory</code></p><p>解决方案：手动在<code>/usr/local/var/homebrew/linked/elasticsearch-full/libexec</code>创建<code>logs</code>目录</p></li></ol><h2 id="4-7-Kafka海量日志收集实战-logstash日志过滤实战-1"><a href="#4-7-Kafka海量日志收集实战-logstash日志过滤实战-1" class="headerlink" title="4-7 Kafka海量日志收集实战_logstash日志过滤实战-1"></a>4-7 Kafka海量日志收集实战_logstash日志过滤实战-1</h2><p>logstash：安装入门、ELK环境搭建、基础语法、实战应用</p><pre><code class="shell">## logstash-script.conf## multiline 插件也可以用于其他类似的堆栈式信息，比如，Linux的内核日志input {  kafka {    ## app-log-服务名称    topics_pattern =&gt; &quot;app-kafka-log-.*&quot; ## 接收哪些topic下的消息    bootstrap_servers =&gt; &quot;localhost:9092&quot; ## kafka server    codec =&gt; json    consumer_threads =&gt; 1 ## 增加consumer的并行消费线程数，一个partition对应一个consumer_thread    decorate_events =&gt; true    # auto_offset_rest =&gt; &quot;latest&quot;    group_id =&gt; &quot;app-kafka-log-group&quot; ## kafka组  }  kafka {    ## error-log-服务名称    topics_pattern =&gt; &quot;error-kafka-log-.*&quot;    bootstrap_servers =&gt; &quot;localhost:9092&quot;    codec =&gt; json    consumer_threads =&gt; 4    decorate_events =&gt; true    # auto_offset_rest =&gt; &quot;latest&quot;    group_id =&gt; &quot;error-kafka-log-group&quot;  }}filter {  ## 时区转换  ruby {    code =&gt; &quot;event.set(&#39;index_time&#39;, event.timestamp.time.localtime.strftime(&#39;%Y.%m.%d&#39;))&quot;  }  if &quot;app-kafka-log-collect&quot; in [fields][logtopic] { ## `[fields][logtopic]`为filebeat配置文件`filebeat.yml`的属性    grok {      ## 表达式      match =&gt; [&quot;message&quot;, &quot;\[%{NOTSPACE:currentDateTime}\] \[%{NOTSPACE:level}\] \[%{NOTSPACE:thread-id}\] \[%{NOTSPACE:class}\] \[%{DATA:hostName}\] \[%{DATA:ip}\] \[%{DATA:applicationName}\] \[%{DATA:location}\] \[%{DATA:messageInfo}\] ## (\&#39;\&#39;|%{QUOTEDSTRING:throwable})&quot;]    }  }  if &quot;error-kafka-log-collect&quot; in [fields][logtopic] {    grok {      ## 表达式      match =&gt; [&quot;message&quot;, &quot;\[%{NOTSPACE:currentDateTime}\] \[%{NOTSPACE:level}\] \[%{NOTSPACE:thread-id}\] \[%{NOTSPACE:class}\] \[%{DATA:hostName}\] \[%{DATA:ip}\] \[%{DATA:applicationName}\] \[%{DATA:location}\] \[%{DATA:messageInfo}\] ## (\&#39;\&#39;|%{QUOTEDSTRING:throwable})&quot;]    }  }}## 测试输出到控制台output {  stdout {codec =&gt; rubydebug}}</code></pre><h2 id="4-8-Kafka海量日志收集实战-logstash日志过滤实战-2"><a href="#4-8-Kafka海量日志收集实战-logstash日志过滤实战-2" class="headerlink" title="4-8 Kafka海量日志收集实战_logstash日志过滤实战-2"></a>4-8 Kafka海量日志收集实战_logstash日志过滤实战-2</h2><p>启动logstash</p><pre><code class="shell">logstash -f ~/Develop/1297-kafka/src/main/resources/logstash-script.conf</code></pre><h2 id="4-9-Kafka海量日志收集实战-elasticsearch-amp-kibana存储可视化实战"><a href="#4-9-Kafka海量日志收集实战-elasticsearch-amp-kibana存储可视化实战" class="headerlink" title="4-9 Kafka海量日志收集实战_elasticsearch&amp;kibana存储可视化实战"></a>4-9 Kafka海量日志收集实战_elasticsearch&amp;kibana存储可视化实战</h2><ol><li><p>Kafka高吞吐量核心实战-日志持久化、可视化</p><blockquote><ul><li>Elasticsearch索引创建周期、命名规范选择</li><li>Kibana控制台应用、可视化日志</li></ul></blockquote></li><li><p>Kafka高吞吐量核心实战-监控告警</p><blockquote><p>Watcher作用介绍基本使用=&gt;Watcher API详解=&gt;Watcher实战应用监控告警</p></blockquote></li></ol><h3 id="ElasticSearch设置密码"><a href="#ElasticSearch设置密码" class="headerlink" title="ElasticSearch设置密码"></a>ElasticSearch设置密码</h3><blockquote><p>7.3版本已经可以免费使用x-pack设置账号和密码，且无需安装x-pack</p></blockquote><ol><li><p>生成证书</p><pre><code class="shell">cd /usr/local/var/homebrew/linked/elasticsearch-full/libexecelasticsearch-certutil cert -out config/elastic-certificates.p12 -pass &quot;&quot;</code></pre></li><li><p>添加xpack配置</p><pre><code class="shell">vim /usr/local/Cellar/elasticsearch-full/7.6.2/libexec/config/elasticsearch.yml</code></pre><pre><code class="yaml">xpack.security.enabled: truexpack.security.transport.ssl.enabled: truexpack.security.transport.ssl.verification_mode: certificatexpack.security.transport.ssl.keystore.path: elastic-certificates.p12xpack.security.transport.ssl.truststore.path: elastic-certificates.p12</code></pre></li><li><p>启动ElasticSearch，并新开一个终端生成账号密码</p><pre><code class="shell">elasticsearch# 自动生成默认用户和密码elasticsearch-setup-passwords auto# 手动生成密码,elastic用户是超级管理员elasticsearch-setup-passwords interactive</code></pre></li><li><p>验证。打开主页,输入账号密码</p><pre><code>http://127.0.0.1:9200/</code></pre></li><li><p>修改密码</p><pre><code class="shell">curl -H &quot;Content-Type: application/json&quot; -XPUT -u elastic:rpZaWNQcXSdjnpQqAtUE &#39;http://localhost:9200/_xpack/security/user/elastic/_password&#39; -d &#39;{&quot;password&quot; : &quot;123456&quot;}&#39;</code></pre><ul><li><code>elastic:rpZaWNQcXSdjnpQqAtUE</code>：用户名:旧密码</li><li><code>123456</code>：新密码</li></ul></li></ol><ul><li><p>修改Kibana配置文件</p><pre><code class="shell">vim /usr/local/etc/kibana/kibana.yml</code></pre><pre><code class="yaml">elasticsearch.username: &quot;elastic&quot;elasticsearch.password: &quot;123456&quot;</code></pre></li><li><p>启动ElasticSearch、Kibana</p><pre><code class="shell">elasticsearchkibana</code></pre></li><li><p>打开地址访问Kibana</p><pre><code>http://127.0.0.1:5601/</code></pre></li></ul><pre><code class="shell">## logstash-script.conf## elasticsearchoutput {  if &quot;app-kafka-log-collect&quot; in [fields][logtopic] {    ## es插件    elasticsearch {      # es服务地址      hosts =&gt; [&quot;localhost:9200&quot;]      # 用户名密码      user =&gt; &quot;elastic&quot;      password =&gt; &quot;123456&quot;      ## 索引名，+号开头的，就会自动认为后面是时间格式：      ## javalog-app-server-2019.01.23      index =&gt; &quot;app-log-%{[fields][logbiz]}-%{index_time}&quot;      ## 是否嗅探集群ip：一般设置true；http://localhost:9200/_nodes/http?pretty      ## 通过嗅探机制进行es集群负载均衡发日志消息      sniffing =&gt; true      ## logstash默认自带一个mapping模板，进行模板覆盖      template_overwrite =&gt; true    }  }  if &quot;error-kafka-log-collect&quot; in [fields][logtopic] {    elasticsearch {      hosts =&gt; [&quot;localhost:9200&quot;]      user =&gt; &quot;elastic&quot;      password =&gt; &quot;123456&quot;      index =&gt; &quot;error-log-%{[fields][logbiz]}-%{index_time}&quot;      sniffing =&gt; true      template_overwrite =&gt; true    }  }}</code></pre><h2 id="4-10-Kafka海量日志收集实战-watcher监控告警实战-1"><a href="#4-10-Kafka海量日志收集实战-watcher监控告警实战-1" class="headerlink" title="4-10 Kafka海量日志收集实战_watcher监控告警实战-1"></a>4-10 Kafka海量日志收集实战_watcher监控告警实战-1</h2><pre><code class="java">@Datapublic class AccurateWatcherMessage {    private String title;    private String application;    private String level;    private String body;    private String executionTime;}</code></pre><pre><code class="java">@PostMapping(&quot;accurateWatch&quot;)public String accurateWatch(AccurateWatcherMessage accurateWatcherMessage) {    System.out.println(&quot;-------警告内容-------&quot; + accurateWatcherMessage);    return &quot;is watched&quot; + accurateWatcherMessage;}</code></pre><h2 id="4-11-Kafka海量日志收集实战-watcher监控告警实战-2"><a href="#4-11-Kafka海量日志收集实战-watcher监控告警实战-2" class="headerlink" title="4-11 Kafka海量日志收集实战_watcher监控告警实战-2"></a>4-11 Kafka海量日志收集实战_watcher监控告警实战-2</h2><ol><li><p>创建Watcher之前手动指定创建模板</p><pre><code class="json">// PUT _template/error-log-{  &quot;template&quot;: &quot;error-log-*&quot;,  &quot;order&quot;: 0,  &quot;settings&quot;: {    &quot;index&quot;: {      &quot;refresh_interval&quot;: &quot;5s&quot;    }  },  &quot;mappings&quot;: {    &quot;dynamic_templates&quot;: [      {        &quot;message_field&quot;: {          &quot;match_mapping_type&quot;: &quot;string&quot;,          &quot;path_match&quot;: &quot;message&quot;,          &quot;mapping&quot;: {            &quot;norms&quot;: false,            &quot;type&quot;: &quot;text&quot;,            &quot;analyzer&quot;: &quot;ik_max_word&quot;,            &quot;search_analyzer&quot;: &quot;ik_max_word&quot;          }        }      },      {        &quot;throwable_field&quot;: {          &quot;match_mapping_type&quot;: &quot;string&quot;,          &quot;path_match&quot;: &quot;throwable&quot;,          &quot;mapping&quot;: {            &quot;norms&quot;: false,            &quot;type&quot;: &quot;text&quot;,            &quot;analyzer&quot;: &quot;ik_max_word&quot;,            &quot;search_analyzer&quot;: &quot;ik_max_word&quot;          }        }      },      {        &quot;string_field&quot;: {          &quot;match_mapping_type&quot;: &quot;string&quot;,          &quot;path_match&quot;: &quot;*&quot;,          &quot;mapping&quot;: {            &quot;norms&quot;: false,            &quot;type&quot;: &quot;text&quot;,            &quot;analyzer&quot;: &quot;ik_max_word&quot;,            &quot;search_analyzer&quot;: &quot;ik_max_word&quot;,            &quot;fields&quot;: {              &quot;keyword&quot;: {                &quot;type&quot;: &quot;keyword&quot;              }            }          }        }      }    ],    &quot;properties&quot;: {      &quot;hostName&quot;: {        &quot;type&quot;: &quot;keyword&quot;      },      &quot;ip&quot;: {        &quot;type&quot;: &quot;ip&quot;      },      &quot;level&quot;: {        &quot;type&quot;: &quot;keyword&quot;      },      &quot;currentDateTime&quot;: {        &quot;type&quot;: &quot;date&quot;      }    }  }}</code></pre></li><li><p>创建一个Watcher，比如定义一个trigger，每5秒钟看一下input里的数据</p><pre><code class="json">// PUT _xpack/watcher/watch/error_log_collector_watcher{  &quot;trigger&quot;: {    &quot;schedule&quot;: {      &quot;interval&quot;: &quot;5s&quot;    }  },  &quot;input&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        &quot;indices&quot;: [&quot;&lt;error-log-{now+8h/d}&gt;&quot;],        &quot;body&quot;: {          &quot;size&quot;: 0,          &quot;query&quot;: {            &quot;bool&quot;: {              &quot;must&quot;: [                {                  &quot;term&quot;: {&quot;level&quot;: &quot;ERROR&quot;}                }              ],              &quot;filter&quot;: {                &quot;range&quot;: {                  &quot;currentDateTime&quot;: {                    &quot;gt&quot;: &quot;now-30s&quot;, &quot;lt&quot;: &quot;now&quot;                  }                }              }            }          }        }      }    }  },  &quot;condition&quot;: {    &quot;compare&quot;: {      &quot;ctx.payload.hits.total&quot;: {        &quot;gt&quot;: 0      }    }  },  &quot;transform&quot;: {    &quot;search&quot;: {      &quot;request&quot;: {        &quot;indices&quot;: [&quot;error-log-{now+8h/d}&quot;],        &quot;body&quot;: {          &quot;size&quot;: 1,          &quot;query&quot;: {            &quot;bool&quot;: {              &quot;must&quot;: [                {                  &quot;term&quot;: {&quot;level&quot;: &quot;ERROR&quot;}                }              ],              &quot;filter&quot;: {                &quot;range&quot;: {                  &quot;currentDateTime&quot;: {                    &quot;gt&quot;: &quot;now-30s&quot;, &quot;lt&quot;: &quot;now&quot;                  }                }              }            }          },          &quot;sort&quot;: [            {              &quot;currentDateTime&quot;: {                &quot;order&quot;: &quot;desc&quot;              }            }          ]        }      }    }  },  &quot;actions&quot;: {    &quot;test_error&quot;: {      &quot;webhook&quot;: {        &quot;method&quot;: &quot;POST&quot;,        &quot;url&quot;: &quot;http://localhost:8081/kafka/index/accurateWatch&quot;,        &quot;body&quot;: &quot;{\&quot;title\&quot;: \&quot;异常错误告警\&quot;, \&quot;applicationName\&quot;: \&quot;{{#ctx.payload.hits.hits}}{{_source.applicationName}}{{/ctx.payload.hits.hits}}\&quot;, \&quot;level\&quot;: \&quot;告警级别P1\&quot;, \&quot;body\&quot;: \&quot;{{#ctx.payload.hits.hits}}{{_source.messageInfo}}{{/ctx.payload.hits.hits}}\&quot;, \&quot;executionTime\&quot;: \&quot;{{#ctx.payload.hits.hits}}{{_source.currentDateTime}}{{/ctx.payload.hits.hits}}\&quot;}&quot;      }    }  }}</code></pre></li><li><p>创建index pattern</p></li></ol><h2 id="4-12-附：watcher-基础语法与使用"><a href="#4-12-附：watcher-基础语法与使用" class="headerlink" title="4-12 附：watcher 基础语法与使用"></a>4-12 <a href="04-12-watcher-base.md">附：watcher 基础语法与使用</a></h2><h2 id="4-13-总结与复习"><a href="#4-13-总结与复习" class="headerlink" title="4-13 总结与复习"></a>4-13 总结与复习</h2><blockquote><p>HI ，小伙伴们！本章节我们已经对Kafka技术有了一个全面的认识，通过学习Kafka的基础API使用，到与SpringBoot整合应用，再延伸到ELK技术栈实现日志输出（Log4j2）、数据抓取（Filebeat）、数据转储（Kafka Broker）；再到Logstash消费，然后Sink到Elasticsearch平台，通过Kibana进行展示，最后在使用Xpack-Watcher进行对日志的监控告警。全链路的讲解了Kafka 与 ELK之间的关系与海量日志实战应用，接下来我们来进行复习！</p></blockquote><ul><li><p>Kafka基础知识总结</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgpvphseej30vi0jm0v6.jpg" alt="Kafka基础知识总结" style="zoom:100%;" /></li><li><p>ELK技术栈架构图</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgpvo51fuj30oz0avwfh.jpg" alt="ELK技术栈架构图" style="zoom:100%;" /></li><li><p>ELK实战流程图</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdgpvoziiij30q207dgmq.jpg" alt="ELK实战流程图" style="zoom:100%;" /><p>启动命令</p><pre><code class="shell">zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties # 启动zookeeperkafka-server-start /usr/local/etc/kafka/server.properties # 启动kafkafilebeat -c ~/Develop/1297-kafka/src/main/resources/filebeat.yml # 启动filebeatelasticsearch # 启动ElasticSearchkibana # 启动Kibanalogstash -f ~/Develop/1297-kafka/src/main/resources/logstash-script.conf # 启动logstash</code></pre></li></ul><h2 id="4-14-作业练习"><a href="#4-14-作业练习" class="headerlink" title="4-14 作业练习"></a>4-14 作业练习</h2><blockquote><p>在这里，我们历经千辛万苦终于搞定了复杂的MQ架构设计与落地；无论是RabbitMQ还是Kafka，都是业界非常主流的MQ技术（消息中间件），接下来就是作业时间！</p></blockquote><ul><li><p><strong>作业一：</strong> 请对比一下RabbitMQ 和 Kafka 各自的特点与优势，列出重要的区别点。</p></li><li><p><strong>作业二：</strong> 对于ELK海量日志收集，还有一个非常关键的问题，就是我们收集上来的日志应该如何处理、分析？请列出几点你觉得日志可以做的事情，充分发挥出想象力！（提示：比如做QPS的接口统计）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-项目实战-header组件开发</title>
      <link href="/imooc/74-vue-sell-1/06-header-component/"/>
      <url>/imooc/74-vue-sell-1/06-header-component/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="6-1-Vue-resource应用（上）"><a href="#6-1-Vue-resource应用（上）" class="headerlink" title="6-1 Vue-resource应用（上）"></a>6-1 Vue-resource应用（上）</h2><p>vue-resource：<a href="https://github.com/pagekit/vue-resource" target="_blank" rel="noopener">https://github.com/pagekit/vue-resource</a></p><pre><code class="json">/* package.json */&quot;dependencies&quot;: {  &quot;vue-resource&quot;: &quot;^1.0.1&quot;}</code></pre><pre><code class="javascript">/* main.js */import VueResource from &#39;vue-resource&#39;Vue.use(VueResource)</code></pre><h2 id="6-2-Vue-resource应用（下）"><a href="#6-2-Vue-resource应用（下）" class="headerlink" title="6-2 Vue-resource应用（下）"></a>6-2 Vue-resource应用（下）</h2><pre><code class="javascript">/* App.vue */const ERR_OK = 0export default {  data () {    return {      seller: {}    }  },  created () {    this.$http.get(&#39;/api/seller&#39;).then((response) =&gt; {      response = response.body      if (response.errno === ERR_OK) {        this.seller = response.data      }    })  },}</code></pre><h2 id="6-3-外部组件（1）"><a href="#6-3-外部组件（1）" class="headerlink" title="6-3 外部组件（1）"></a>6-3 外部组件（1）</h2><pre><code class="vue">&lt;v-header :seller=&quot;seller&quot;&gt;&lt;/v-header&gt;</code></pre><pre><code class="vue">&lt;!-- header.vue --&gt;&lt;template&gt;  &lt;div class=&quot;header&quot;&gt;    &lt;div class=&quot;content-wrapper&quot;&gt;      &lt;div class=&quot;avatar&quot;&gt;        &lt;img width=&quot;64&quot; height=&quot;64&quot; :src=&quot;seller.avatar&quot;&gt;      &lt;/div&gt;      &lt;div class=&quot;content&quot;&gt;        &lt;div class=&quot;title&quot;&gt;          &lt;span class=&quot;brand&quot;&gt;&lt;/span&gt;          &lt;span class=&quot;name&quot;&gt;{{seller.name}}&lt;/span&gt;        &lt;/div&gt;        &lt;div class=&quot;description&quot;&gt;          {{seller.description}}/{{seller.deliveryTime}}分钟送达        &lt;/div&gt;        &lt;div v-if=&quot;seller.supports&quot; class=&quot;support&quot;&gt;          &lt;span class=&quot;icon&quot;&gt;&lt;/span&gt;          &lt;span class=&quot;text&quot;&gt;{{seller.supports[0].description}}&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;bulletin-wrapper&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt;  export default {    props: {      seller: {        type: Object      }    }  }&lt;/script&gt;</code></pre><h2 id="6-4-外部组件（2）"><a href="#6-4-外部组件（2）" class="headerlink" title="6-4 外部组件（2）"></a>6-4 外部组件（2）</h2><pre><code class="stylus">/* mixin.styl */bg-image($url)  background-image url($url + &quot;@2x.png&quot;)  @media (-webkit-min-device-pixel-retio: 3),(min-device-pixel-retio: 3)    background-image url($url + &quot;@3x.png&quot;)</code></pre><p>通过@import引入CSS库不能使用alias，只有通过import引入JS库才能使用alias</p><pre><code class="vue">&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;  @import &quot;../../common/stylus/mixin.styl&quot;  .header    color #ffffff    background #000000    .content-wrapper      padding 24px 12px 18px 24px      font-size 0      .avatar        display inline-block      .content        display inline-block        margin-left 16px        font-size 14px        .title          margin 2px 0 8px 0          .brand            display inline-block            vertical-align top // 垂直顶部对齐            width 30px            height 18px            bg-image(&#39;brand&#39;)            background-size 30px 18px            background-repeat no-repeat          .name            margin-left 6px            font-size 16px            line-height 18px            font-weight bold // 字体加粗&lt;/style&gt;</code></pre><pre><code class="stylus">/* base.styl */body, html  line-height 1  font-weight 200  font-family &quot;PingFang SC&quot;, &quot;STHeitiSC-Light&quot;, &quot;Helvetica-Light&quot;, &quot;Arial&quot;, &quot;SansSerif&quot;</code></pre><h2 id="6-5-外部组件（3）"><a href="#6-5-外部组件（3）" class="headerlink" title="6-5 外部组件（3）"></a>6-5 外部组件（3）</h2><p>活动图标</p><pre><code class="vue">&lt;span class=&quot;icon&quot; :class=&quot;classMap[seller.supports[0].type]&quot;&gt;&lt;/span&gt;</code></pre><pre><code class="vue">created () {  this.classMap = [&#39;decrease&#39;, &#39;discount&#39;, &#39;special&#39;, &#39;invoice&#39;, &#39;guarantee&#39;]}</code></pre><h2 id="6-6-外部组件（4）"><a href="#6-6-外部组件（4）" class="headerlink" title="6-6 外部组件（4）"></a>6-6 外部组件（4）</h2><p>活动内容</p><pre><code class="vue">&lt;div v-if=&quot;seller.supports&quot; class=&quot;support-count&quot;&gt;  &lt;span class=&quot;count&quot;&gt;{{seller.supports.length}}个&lt;/span&gt;  &lt;i class=&quot;icon-keyboard_arrow_right&quot;&gt;&lt;/i&gt;&lt;/div&gt;</code></pre><h2 id="6-7-外部组件（5）"><a href="#6-7-外部组件（5）" class="headerlink" title="6-7 外部组件（5）"></a>6-7 外部组件（5）</h2><p>公告</p><pre><code class="vue">&lt;div class=&quot;bulletin-wrapper&quot;&gt;  &lt;span class=&quot;bulletin-title&quot;&gt;&lt;/span&gt;&lt;span class=&quot;bulletin-text&quot;&gt;{{seller.bulletin}}&lt;/span&gt;  &lt;i class=&quot;icon-keyboard_arrow_right&quot;&gt;&lt;/i&gt;&lt;/div&gt;</code></pre><p>文字内容超过部分则使用”…”表示</p><pre><code class="vue">white-space nowrapoverflow hiddentext-overflow ellipsis</code></pre><h2 id="6-8-外部组件（6）"><a href="#6-8-外部组件（6）" class="headerlink" title="6-8 外部组件（6）"></a>6-8 外部组件（6）</h2><p>背景图</p><pre><code class="vue">&lt;div class=&quot;background&quot;&gt;  &lt;img :src=&quot;seller.avatar&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="vue">.background  position absolute  top 0  left 0  width 100%  height 100%  z-index -1  filter blur(10px) // 滤镜产生模糊效果</code></pre><h2 id="6-9-详情弹层页（1）-实现弹出层"><a href="#6-9-详情弹层页（1）-实现弹出层" class="headerlink" title="6-9 详情弹层页（1）- 实现弹出层"></a>6-9 详情弹层页（1）- 实现弹出层</h2><pre><code class="vue">&lt;div v-show=&quot;detailShow&quot; class=&quot;detail&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="vue">.detail  position fixed  top 0  left 0  z-index 100  width 100%  height 100%  overflow auto  background rgba(7, 17, 27, 0.8)</code></pre><pre><code class="vue">data () {  return {    detailShow: false  }},methods: {  fnShowDetail () {    this.detailShow = true  }}</code></pre><h2 id="6-10-详情弹层页（2）-CSS-Sticky-footer"><a href="#6-10-详情弹层页（2）-CSS-Sticky-footer" class="headerlink" title="6-10 详情弹层页（2）- CSS Sticky footer"></a>6-10 详情弹层页（2）- CSS Sticky footer</h2><p><a href="https://www.w3cplus.com/css3/css-secrets/sticky-footers.html" target="_blank" rel="noopener">CSS秘密花园： Sticky footers</a></p><pre><code class="stylus">// base.styl.clearfix  display inline-block  &amp;:after    display block    content &quot;.&quot;    height 0    line-height 0    clear both    visibility hidden</code></pre><pre><code class="vue">&lt;div v-show=&quot;detailShow&quot; class=&quot;detail&quot;&gt;  &lt;div class=&quot;detail-wrapper clearfix&quot;&gt;    &lt;div class=&quot;detail-main&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;detail-close&quot;&gt;    &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="stylus">.detail-wrapper  width 100%  min-height 100%  .detail-main    margin-top 64px    padding-bottom 64px.detail-close  position relative  width 32px  height  32px  margin -64px auto 0 auto  clear both  font-size 32px</code></pre><h2 id="6-11-详情弹层页（3）-star组件抽象（上）"><a href="#6-11-详情弹层页（3）-star组件抽象（上）" class="headerlink" title="6-11 详情弹层页（3）- star组件抽象（上）"></a>6-11 详情弹层页（3）- star组件抽象（上）</h2><h2 id="6-12-详情弹层页（3）-star组件抽象（下）"><a href="#6-12-详情弹层页（3）-star组件抽象（下）" class="headerlink" title="6-12 详情弹层页（3）- star组件抽象（下）"></a>6-12 详情弹层页（3）- star组件抽象（下）</h2><h2 id="6-13-详情弹层页（4）-star组件使用"><a href="#6-13-详情弹层页（4）-star组件使用" class="headerlink" title="6-13 详情弹层页（4）- star组件使用"></a>6-13 详情弹层页（4）- star组件使用</h2><h2 id="6-14-详情弹层页（5）-小标题自适应经典flex布局实现"><a href="#6-14-详情弹层页（5）-小标题自适应经典flex布局实现" class="headerlink" title="6-14 详情弹层页（5）- 小标题自适应经典flex布局实现"></a>6-14 详情弹层页（5）- 小标题自适应经典flex布局实现</h2><h2 id="6-15-详情弹层页（6）-header剩余组件实现（上）"><a href="#6-15-详情弹层页（6）-header剩余组件实现（上）" class="headerlink" title="6-15 详情弹层页（6）- header剩余组件实现（上）"></a>6-15 详情弹层页（6）- header剩余组件实现（上）</h2><h2 id="6-16-详情弹层页（6）-header剩余组件实现（下）"><a href="#6-16-详情弹层页（6）-header剩余组件实现（下）" class="headerlink" title="6-16 详情弹层页（6）- header剩余组件实现（下）"></a>6-16 详情弹层页（6）- header剩余组件实现（下）</h2>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 74-Vue.js2.5+cube-ui重构饿了么App(一期) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Kafka急速入门与实战(核心API)</title>
      <link href="/imooc/1297-MQ-Kafka/03-03-kafka-api/"/>
      <url>/imooc/1297-MQ-Kafka/03-03-kafka-api/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h3 id="kafka环境安装"><a href="#kafka环境安装" class="headerlink" title="kafka环境安装"></a>kafka环境安装</h3><p>上一节课我们已经对kafka的基本概念、核心思想有了一定的了解和认知，并且掌握了kafka在实际工作中的一些主要的应用场景。那么接下来，我们就一起快速进入kafka的安装吧。</p><ul><li><p>kafka下载地址：<a href="http://kafka.apache.org/downloads.html" target="_blank" rel="noopener">http://kafka.apache.org/downloads.html</a></p></li><li><p>kafka安装步骤：首先kafka安装需要依赖与zookeeper，所以小伙伴们先准备好zookeeper环境（三个节点即可），然后我们来一起构建kafka broker。</p><pre><code class="shell">brew install zookeeper # 安装zookeeperbrew install kafka # 安装kafkazookeeper-server-start /usr/local/etc/kafka/zookeeper.properties # 启动zookeeperkafka-server-start /usr/local/etc/kafka/server.properties # 启动kafka</code></pre></li></ul><h3 id="kafka常用命令"><a href="#kafka常用命令" class="headerlink" title="kafka常用命令"></a>kafka常用命令</h3><p>我们接下来一起了解几个非常重要的命令，通过这些命令我们对kafka topic partition 进行查看和操作。</p><ul><li><p>常用命令：</p><ol><li><p><strong>创建topic主题命令</strong>：（创建名为test的topic， 1个分区分别存放数据，数据备份总共1份）</p><pre><code class="shell">kafka-topics --zookeeper localhost:2181 --create --topic tuyrk-kafka-topic --partitions 1  --replication-factor 1</code></pre><blockquote><p> –zookeeper 为zk服务列表</p><p> –create 命令后 –topic 为创建topic 并指定 topic name</p><p> –partitions 为指定分区数量</p><p> –replication-factor 为指定副本集数量</p></blockquote></li><li><p><strong>查看topic列表命令</strong>：</p><pre><code class="shell">kafka-topics --zookeeper localhost:2181 --list</code></pre></li><li><p>kafka命令发送数据：（然后我们就可以编写数据发送出去了）</p><pre><code class="shell">kafka-console-producer --broker-list localhost:9092 --topic tuyrk-kafka-topic</code></pre></li><li><p>kafka命令接受数据：（然后我们就可以看到消费的信息了）</p><pre><code class="shell">kafka-console-consumer --bootstrap-server localhost:9092 --topic tuyrk-kafka-topic --from-beginning</code></pre></li><li><p>删除topic命令：</p><pre><code class="shell">kafka-topics.sh --zookeeper localhost:2181 --delete --topic tuyrk-kafka-topic</code></pre></li><li><p>kafka查看消费进度：（当我们需要查看一个消费者组的消费进度时，则使用下面的命令）</p><pre><code class="shell">kafka-consumer-groups --bootstrap-server localhost:9092 --describe --group tuyrk-kafka-groupkafka-topics --zookeeper localhost:2181 --describe --topic tuyrk-kafka-topic</code></pre><blockquote><p><code>--describe --group</code> 为订阅组， 后面指定 group name</p></blockquote></li></ol></li></ul><h3 id="急速入门"><a href="#急速入门" class="headerlink" title="急速入门"></a>急速入门</h3><p>下面我们一起使用kafka最基本的API来对kafka进行操作！</p><ul><li><p>kafka依赖包：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>kafka生产者：</p><pre><code class="java">package com.tuyrk.kafka.introduce;import com.alibaba.fastjson.JSON;import lombok.extern.slf4j.Slf4j;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.ProducerRecord;import org.apache.kafka.common.serialization.StringSerializer;import java.util.Properties;@Slf4jpublic class CollectKafkaProducer {    // 创建一个kafka生产者    private final KafkaProducer&lt;String, String&gt; producer;    // 定义一个成员变量为topic    private final String topic;    // 初始化kafka的配置文件和实例：Properties &amp; KafkaProducer    public CollectKafkaProducer(String topic) {        Properties props = new Properties();        // 配置broker地址        props.put(&quot;bootstrap.servers&quot;, &quot;192.168.11.51:9092&quot;);        // 定义一个 client.id        props.put(&quot;client.id&quot;, &quot;demo-producer-test&quot;);        /// 其他配置项：        /*props.put(&quot;batch.size&quot;, 16384);            //16KB -&gt; 满足16KB发送批量消息        props.put(&quot;linger.ms&quot;, 10);            //10ms -&gt; 满足10ms时间间隔发送批量消息        props.put(&quot;buffer.memory&quot;, 33554432);     //32M -&gt; 缓存提性能*/        // kafka 序列化配置：        props.put(&quot;key.serializer&quot;, StringSerializer.class.getName());        props.put(&quot;value.serializer&quot;, StringSerializer.class.getName());        // 创建 KafkaProducer 与 接收 topic        this.producer = new KafkaProducer&lt;&gt;(props);        this.topic = topic;    }    // 发送消息 （同步或者异步）    public void send(Object message, boolean syncSend) throws InterruptedException {        try {            // 同步发送            if (syncSend) {                producer.send(new ProducerRecord&lt;&gt;(topic, JSON.toJSONString(message)));            }            // 异步发送（callback实现回调监听）            else {                producer.send(new ProducerRecord&lt;&gt;(topic, JSON.toJSONString(message)),                        (recordMetadata, e) -&gt; {                            if (e != null) {                                log.error(&quot;Unable to write to Kafka in CollectKafkaProducer [{}] exception: {}&quot;, topic, e);                            }                        });            }        } catch (Exception e) {}    }    // 关闭producer    public void close() {        producer.close();    }    // 测试函数    public static void main(String[] args) throws InterruptedException {        String topic = &quot;tuyrk-kafka-topic&quot;;        CollectKafkaProducer collectKafkaProducer = new CollectKafkaProducer(topic);        for (int i = 0; i &lt; 10; i++) {            User user = new User();            user.setId(i + &quot;&quot;);            user.setName(&quot;张三&quot;);            collectKafkaProducer.send(user, true);        }        Thread.sleep(Integer.MAX_VALUE);    }}</code></pre></li><li><p>kafka消费者：</p><pre><code class="java">package com.tuyrk.kafka.introduce;import lombok.extern.slf4j.Slf4j;import org.apache.kafka.clients.consumer.*;import org.apache.kafka.common.TopicPartition;import org.apache.kafka.common.serialization.StringDeserializer;import java.util.Collections;import java.util.List;import java.util.Properties;@Slf4jpublic class CollectKafkaConsumer {    // 定义消费者实例    private final KafkaConsumer&lt;String, String&gt; consumer;    // 定义消费主题    private final String topic;    // 消费者初始化    public CollectKafkaConsumer(String topic) {        Properties props = new Properties();        // 消费者的zookeeper 地址配置        props.put(&quot;zookeeper.connect&quot;, &quot;192.168.11.111:2181&quot;);        // 消费者的broker 地址配置        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;192.168.11.51:9092&quot;);        // 消费者组定义        props.put(ConsumerConfig.GROUP_ID_CONFIG, &quot;demo-group-id&quot;);        // 是否自动提交（auto commit，一般生产环境均设置为false，则为手工确认）        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, &quot;false&quot;);        // 自动提交配置项        // props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, &quot;1000&quot;);        // 消费进度（位置 offset）重要设置: latest,earliest        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);        // 超时时间配置        props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, &quot;30000&quot;);        // kafka序列化配置        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class.getName());        // 创建consumer对象 &amp; 赋值topic        consumer = new KafkaConsumer&lt;&gt;(props);        this.topic = topic;        // 订阅消费主题        consumer.subscribe(Collections.singletonList(topic));    }    // 循环拉取消息并进行消费，手工ACK方式    private void receive(KafkaConsumer&lt;String, String&gt; consumer) {        while (true) {            //     拉取结果集(拉取超时时间为1秒)            ConsumerRecords&lt;String, String&gt; records = consumer.poll(1000);            //  拉取结果集后获取具体消息的主题名称 分区位置 消息数量            for (TopicPartition partition : records.partitions()) {                List&lt;ConsumerRecord&lt;String, String&gt;&gt; partitionRecords = records.records(partition);                String topic = partition.topic();                int size = partitionRecords.size();                log.info(&quot;获取topic:{},分区位置:{},消息数为:{}&quot;, topic, partition.partition(), size);                // 分别对每个partition进行处理                for (ConsumerRecord&lt;String, String&gt; partitionRecord : partitionRecords) {                    log.error(&quot;-----&gt; value: {}&quot;, partitionRecord.value());                    long offset = partitionRecord.offset() + 1;                    // consumer.commitSync(); // 这种提交会自动获取partition 和 offset                    // 这种是显示提交partition 和 offset 进度                    consumer.commitSync(Collections.singletonMap(partition,                            new OffsetAndMetadata(offset)));                    log.info(&quot;同步成功, topic: {}, 提交的 offset: {} &quot;, topic, offset);                }            }        }    }    // 测试函数    public static void main(String[] args) {        String topic = &quot;tuyrk-kafka-topic&quot;;        CollectKafkaConsumer collectKafkaConsumer = new CollectKafkaConsumer(topic);        collectKafkaConsumer.receive(collectKafkaConsumer.consumer);    }}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Kafka急速入门与实战(概念)</title>
      <link href="/imooc/1297-MQ-Kafka/03-02-kafka-concept/"/>
      <url>/imooc/1297-MQ-Kafka/03-02-kafka-concept/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h3 id="Kafka的主要特点"><a href="#Kafka的主要特点" class="headerlink" title="Kafka的主要特点"></a>Kafka的主要特点</h3><p>Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务，它主要用于处理活跃的流式数据。</p><ul><li>kafka的主要特点：<ul><li>同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。</li><li>可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。</li><li>分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。</li><li>消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。</li><li>支持online和offline的场景。</li></ul></li></ul><h3 id="Kafka的架构"><a href="#Kafka的架构" class="headerlink" title="Kafka的架构"></a>Kafka的架构</h3><p>Kafka的整体架构非常简单，是显式分布式架构，producer、broker（kafka）和consumer都可以有多个。Producer，consumer实现Kafka注册的接口，数据从producer发送到broker，broker承担一个中间缓存和分发的作用。broker分发注册到系统中的consumer。broker的作用类似于缓存，即活跃的数据和离线处理系统之间的缓存。客户端和服务器端的通信，是基于简单，高性能，且与编程语言无关的TCP协议。</p><ul><li>基本概念：<ul><li>Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。</li><li>Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li><li>Message：消息，是通信的基本单位，每个producer可以向一个topic（主题）发布一些消息。</li><li>Producers：消息和数据生产者，向Kafka的一个topic发布消息的过程叫做producers。</li><li>Consumers：消息和数据消费者，订阅topics并处理其发布的消息的过程叫做consumers。</li><li>Broker：缓存代理，Kafka集群中的一台或多台服务器统称为broker。</li></ul></li><li>发送消息的流程：<ul><li>Producer根据指定的partition方法（round-robin、hash等），将消息发布到指定topic的partition里面</li><li>kafka集群接收到Producer发过来的消息后，将其持久化到硬盘，并保留消息指定时长（可配置），而不关注消息是否被消费。</li><li>Consumer从kafka集群pull数据，并控制获取消息的offset</li></ul></li></ul><h3 id="kafka的优秀设计"><a href="#kafka的优秀设计" class="headerlink" title="kafka的优秀设计"></a>kafka的优秀设计</h3><p>接下来我们从kafka的吞吐量、负载均衡、消息拉取、扩展性来说一说kafka的优秀设计。</p><ol><li><p>高吞吐是kafka需要实现的核心目标之一，为此kafka做了以下一些设计：</p><ul><li><p>内存访问：直接使用 linux 文件系统的cache，来高效缓存数据，对数据进行读取和写入。</p></li><li><p>数据磁盘持久化：消息不在内存中cache，直接写入到磁盘，充分利用磁盘的顺序读写性能。</p></li><li><p>zero-copy：减少IO操作步骤</p><blockquote><p>采用linux Zero-Copy提高发送性能。传统的数据发送需要发送4次上下文切换，采用sendfile系统调用之后，数据直接在内核态交换，系统上下文切换减少为2次。根据测试结果，可以提高60%的数据发送性能。Zero-Copy详细的技术细节可以参考：<a href="https://www.ibm.com/developerworks/linux/library/j-zerocopy/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/linux/library/j-zerocopy/</a></p></blockquote></li><li><p>对消息的处理：</p><blockquote><p>支持数据批量发送</p><p>支持数据压缩机制</p></blockquote></li><li><p>主题分区：</p><blockquote><p>Topic划分为多个partition，提高生产/消费端处理消息的parallelism（并行度），数据在磁盘上存取代价为O(1)。kafka以topic来进行消息管理，每个topic包含多个part（ition），每个part对应一个逻辑log，有多个segment组成。每个segment中存储多条消息，消息id由其逻辑位置决定，即从消息id可直接定位到消息的存储位置，避免id到位置的额外映射。每个part在内存中对应一个index，记录每个segment中的第一条消息偏移。发布者发到某个topic的消息会被均匀的分布到多个part上（随机或根据用户指定的回调函数进行分布），broker收到发布消息往对应part的最后一个segment上添加该消息，当某个segment上的消息条数达到配置值或消息发布时间超过阈值时，segment上的消息会被flush到磁盘，只有flush到磁盘上的消息订阅者才能订阅到，segment达到一定的大小后将不会再往该segment写数据，broker会创建新的segment。</p></blockquote></li></ul></li><li><p>负载均衡：</p><blockquote><ul><li><p>producer根据用户指定的算法，将消息发送到指定的partition</p></li><li><p>存在多个partiiton，每个partition有自己的replica，每个replica分布在不同的Broker节点上</p></li><li><p>多个partition需要选取出lead partition，lead partition负责读写，并由zookeeper负责fail over</p></li><li><p>通过zookeeper管理broker与consumer的动态加入与离开</p></li></ul></blockquote></li><li><p>消息的拉取：</p><blockquote><ul><li>简化kafka设计（由于kafka broker会持久化数据，broker没有内存压力，因此，consumer非常适合采取pull的方式消费数据）</li><li>consumer根据消费能力自主控制消息拉取速度</li><li>consumer根据自身情况自主选择消费模式，例如批量，重复消费，从尾端开始消费等</li></ul></blockquote></li><li><p>可扩展性</p><blockquote><p>当需要增加broker结点时，新增的broker会向zookeeper注册，而producer及consumer会根据注册在zookeeper上的watcher感知这些变化，并及时作出调整。</p></blockquote></li></ol><h3 id="Kafka的应用场景"><a href="#Kafka的应用场景" class="headerlink" title="Kafka的应用场景"></a>Kafka的应用场景</h3><p>接下来，我们和小伙伴一起探讨一些kafka在实际工作中的一些重要应用场景，帮助小伙伴在以后的学习和工作里能够合理的运用kafka中间件服务于业务和架构设计。</p><ul><li><p>消息队列</p><blockquote><p>比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案。消息系统一般吞吐量相对较低，但是需要更小的端到端延时，并常常依赖于Kafka提供的强大的持久性保障。在这个领域，Kafka足以媲美传统消息系统，如ActiveMQ或RabbitMQ。</p></blockquote></li><li><p>行为跟踪</p><blockquote><p>Kafka的另一个应用场景是跟踪用户浏览页面、搜索及其他行为，以发布-订阅的模式实时记录到对应的topic里。那么这些结果被订阅者拿到后，就可以做进一步的实时处理，或实时监控，或放到hadoop/离线数据仓库里处理。</p></blockquote></li><li><p>元信息监控</p><blockquote><p>作为操作记录的监控模块来使用，即汇集记录一些操作信息，可以理解为运维性质的数据监控吧。</p></blockquote></li><li><p>日志收集</p><blockquote><p>日志收集方面，其实开源产品有很多，包括Scribe、Apache Flume。很多人使用Kafka代替日志聚合（log aggregation）。日志聚合一般来说是从服务器上收集日志文件，然后放到一个集中的位置（文件服务器或HDFS）进行处理。然而Kafka忽略掉文件的细节，将其更清晰地抽象成一个个日志或事件的消息流。这就让Kafka处理过程延迟更低，更容易支持多数据源和分布式数据处理。比起以日志为中心的系统比如Scribe或者Flume来说，Kafka提供同样高效的性能和因为复制导致的更高的耐用性保证，以及更低的端到端延迟。</p></blockquote></li><li><p>流处理</p><blockquote><p>这个场景可能比较多，也很好理解。保存收集流数据，以提供之后对接的Storm或其他流式计算框架进行处理。很多用户会将那些从原始topic来的数据进行阶段性处理，汇总，扩充或者以其他的方式转换到新的topic下再继续后面的处理。例如一个文章推荐的处理流程，可能是先从RSS数据源中抓取文章的内容，然后将其丢入一个叫做“文章”的topic中；后续操作可能是需要对这个内容进行清理，比如回复正常数据或者删除重复数据，最后再将内容匹配的结果返还给用户。这就在一个独立的topic之外，产生了一系列的实时数据处理的流程。Strom和Samza是非常著名的实现这种类型数据转换的框架。</p></blockquote></li><li><p>事件源</p><blockquote><p>事件源是一种应用程序设计的方式，该方式的状态转移被记录为按时间顺序排序的记录序列。Kafka可以存储大量的日志数据，这使得它成为一个对这种方式的应用来说绝佳的后台。比如动态汇总（News feed）</p></blockquote></li><li><p>持久性日志（commit log）</p><blockquote><p>Kafka可以为一种外部的持久性日志的分布式系统提供服务。这种日志可以在节点间备份数据，并为故障节点数据回复提供一种重新同步的机制。Kafka中日志压缩功能为这种用法提供了条件。在这种用法中，Kafka类似于Apache BookKeeper项目。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Kafka急速入门与实战</title>
      <link href="/imooc/1297-MQ-Kafka/03-kafka/"/>
      <url>/imooc/1297-MQ-Kafka/03-kafka/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="3-1-本章导航"><a href="#3-1-本章导航" class="headerlink" title="3-1 本章导航"></a>3-1 本章导航</h2><blockquote><ul><li>Kafka核心概念&amp;设计&amp;应用场景</li><li>Kafka环境搭建&amp;急速入门</li><li>与SpringBoot整合实战</li><li>Kafka高吞吐量核心实战-日志收集设计</li><li>Kafka高吞吐量核心实战-日志输出（日志组件输出log4j2）</li><li>Kafka高吞吐量核心实战-日志收集（FileBeat）</li><li>Kafka高吞吐量核心实战-日志过滤（logstash）</li><li>Kafka高吞吐量核心实战-日志持久化（ElasticSearch）</li><li>Kafka高吞吐量核心实战-日志可视化（Kibana）</li><li>分布式日志收集、链路跟踪、监控告警平台架构讲解</li></ul></blockquote><h2 id="3-2-kafka核心概念与应用场景"><a href="#3-2-kafka核心概念与应用场景" class="headerlink" title="3-2 kafka核心概念与应用场景"></a>3-2 <a href="03-02-kafka-concept.md">kafka核心概念与应用场景</a></h2><h2 id="3-3-kafka急速入门与核心API解析"><a href="#3-3-kafka急速入门与核心API解析" class="headerlink" title="3-3 kafka急速入门与核心API解析"></a>3-3 <a href="03-03-kafka-api.md">kafka急速入门与核心API解析</a></h2><h2 id="3-4-Kafka与springboot整合-生产者讲解"><a href="#3-4-Kafka与springboot整合-生产者讲解" class="headerlink" title="3-4 Kafka与springboot整合_生产者讲解"></a>3-4 Kafka与springboot整合_生产者讲解</h2><p>SpringBoot2.x整合Kafka步骤</p><blockquote><ol><li>Maven配置</li><li>application.properties</li><li>创建KafkaTemplate对象</li><li>@KafkaListener监听消息</li></ol></blockquote><h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><pre><code class="yml">server:  servlet:    context-path: /kafka  port: 8080## SpringBoot 整合 Kafkaspring:  kafka:    bootstrap-servers: localhost:9002    producer:      retries: 0 # kafka producer发送消息失败时的重试次数      batch-size: 16384 # 批量发送数据的配置      # kafka消息的序列化配置      key-serializer: org.apache.kafka.common.serialization.StringSerializer      value-serializer: org.apache.kafka.common.serialization.StringSerializer      acks: 1 # kafka生产端最重要的选项，可靠性投递的配置项</code></pre><blockquote><ul><li><p>acks=0：生产者在成功写入消息之前，不会等待任何来自服务器的相应</p></li><li><p>acks=1：只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应</p></li><li><p>acks=-1/ALL：分区leader必须等待消息被成功写入到所有的ISR副本（同步副本）中,才认为producer请求成功。这种方案提供最高的消息持久性保证，但是理论上吞吐率也是最差的</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd8xjbkqfcj30ju06fdfy.jpg" alt="Acks请求" style="zoom:80%;" /></li></ul></blockquote><h3 id="创建KafkaTemplate对象"><a href="#创建KafkaTemplate对象" class="headerlink" title="创建KafkaTemplate对象"></a>创建KafkaTemplate对象</h3><pre><code class="java">@Slf4j@Componentpublic class KafkaProducerService {    @Resource    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;    public void sendMessage(String topic, String message) {        ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; future = kafkaTemplate.send(topic, message);        future.addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() {            @Override            public void onFailure(Throwable throwable) {                log.error(&quot;发送消息失败：{}&quot;, throwable.getMessage());            }            @Override            public void onSuccess(SendResult&lt;String, String&gt; stringObjectSendResult) {                log.info(&quot;发送消息成功：{}&quot;, stringObjectSendResult.toString());            }        });    }}</code></pre><h2 id="3-5-Kafka与springboot整合-消费者讲解"><a href="#3-5-Kafka与springboot整合-消费者讲解" class="headerlink" title="3-5 Kafka与springboot整合_消费者讲解"></a>3-5 Kafka与springboot整合_消费者讲解</h2><h3 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h3><pre><code class="yaml">## SpringBoot 整合 Kafkaspring:  kafka:    bootstrap-servers: localhost:9002    consumer:      enable-auto-commit: false # consumer消息的签收机制：手工签收      auto-offset-reset: earliest # 在偏移量无效的情况下，消费者将从起始位置读取分区的记录      # kafka消息的序列化配置      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer    listener:      ack-mode: manual # 手工签收      concurrency: 5 # 并行度</code></pre><blockquote><p>auto-offset-reset属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该做何处理：</p><ul><li>latest（默认值）：在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）</li><li>earliest：在偏移量无效的情况下，消费者将从起始位置读取分区的记录</li></ul></blockquote><h3 id="KafkaListener监听消息"><a href="#KafkaListener监听消息" class="headerlink" title="@KafkaListener监听消息"></a>@KafkaListener监听消息</h3><pre><code class="java">@Slf4j@Componentpublic class KafkaConsumerService {    @KafkaListener(groupId = &quot;tuyrk-kafka-group&quot;, topics = {&quot;tuyrk-kafka-topic&quot;})    public void onMessage(ConsumerRecord&lt;String, String&gt; record, Acknowledgment acknowledgment, Consumer&lt;?, ?&gt; consumer) {        log.info(&quot;消费端接收消息：{}&quot;, record.value());        // 手工签收机制        acknowledgment.acknowledge();    }}</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="java">@Autowiredprivate KafkaProducerService kafkaProducerService;@Testpublic void send() throws InterruptedException {  String topic = &quot;tuyrk-kafka-topic&quot;;  for (int i = 1; i &lt;= 1000; i++) {    kafkaProducerService.sendMessage(topic, &quot;hello kafka&quot; + i);    Thread.sleep(5);  }  Thread.sleep(Integer.MAX_VALUE);}</code></pre><blockquote><p>Partition与Consumer一对一关系。如果Partition有10个，而Consumer有20个，则有10个Consumer是没有用的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-消息中间件（MQ）认知提升(RocketMQ)</title>
      <link href="/imooc/1297-MQ-Kafka/02-6-rocket-mq/"/>
      <url>/imooc/1297-MQ-Kafka/02-6-rocket-mq/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><ol><li><h3 id="初识-RocketMQ"><a href="#初识-RocketMQ" class="headerlink" title="初识 RocketMQ"></a>初识 RocketMQ</h3></li></ol><p>RocketMQ是一款分布式、队列模型的消息中间件，由阿里巴巴自主研发的一款适用于高并发、高可靠性、海量数据场景的消息中间件。早期开源2.x版本名为MetaQ；15年迭代3.x版本，更名为RocketMQ，16年开始贡献到Apache，经过1年多的孵化，最终成为Apache顶级的开源项目，更新非常频繁，社区活跃度也非常高；目前最新版本为4.5.1-release版本（2019-7-20日前）。RocketMQ参考借鉴了优秀的开源消息中间件Apache Kafka（这也是我们后面课程中重点要讲解的内容哦），其消息的路由、存储、集群划分都借鉴了Kafka优秀的设计思路，并结合自身的 “双十一” 场景进行了合理的扩展和API丰富。</p><ol start="2"><li><h3 id="优秀的能力与支持"><a href="#优秀的能力与支持" class="headerlink" title="优秀的能力与支持"></a>优秀的能力与支持</h3></li></ol><p>接下来我们一起来看一下RocketMQ优秀的能力吧 ~</p><ul><li>支持集群模型、负载均衡、水平扩展能力</li><li>亿级别的消息堆积能力</li><li>采用零拷贝的原理、顺序写盘、随机读（索引文件）</li><li>丰富的API使用</li><li>代码优秀，底层通信框架采用Netty NIO框架</li><li>NameServer 代替 Zookeeper</li><li>强调集群无单点，可扩展，任意一点高可用，水平可扩展</li><li>消息失败重试机制、消息可查询</li><li>开源社区活跃度、是否足够成熟（经过双十一考验）</li></ul><ol start="3"><li><h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3></li></ol><p>任何一种技术框架，都有 “她” 的专有名词，在你刚开始接触 “她” 的时候，一定要了解 “她” 的专业术语，这样能够更快速、更高效的和 “她” 愉快的玩耍…</p><ul><li>Producer：消息生产者，负责产生消息，一般由业务系统负责产生消息。</li><li>Consumer：消息消费者，负责消费消息，一般是后台系统负责异步消费。</li><li>Push Consumer：Consumer的一种，需要向Consumer对象注册监听。</li><li>Pull Consumer：Consumer的一种，需要主动请求Broker拉取消息。</li><li>Producer Group：生产者集合，一般用于发送一类消息。</li><li>Consumer Group：消费者集合，一般用于接受一类消息进行消费。</li><li>Broker ： MQ消息服务（中转角色，用于消息存储与生产消费转发）。</li></ul><ol start="4"><li><h3 id="RocketMQ核心源码包及功能说明"><a href="#RocketMQ核心源码包及功能说明" class="headerlink" title="RocketMQ核心源码包及功能说明"></a>RocketMQ核心源码包及功能说明</h3></li></ol><p>如下图所示，我们要带小伙伴们一起来看看RocketMQ源码包的组成，这样更方便我们日后对他有一个深入的学习。<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6hc1xm3cj309h07c0u5.jpg" alt="图片描述" style="zoom:80%;" /><br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6hcsl5srj309g07mwfr.jpg" alt="图片描述" style="zoom:80%;" /></p><ul><li>rocketmq-broker 主要的业务逻辑，消息收发，主从同步, pagecache</li><li>rocketmq-client 客户端接口，比如生产者和消费者</li><li>rocketmq-common 公用数据结构等等</li><li>rocketmq-distribution 编译模块，编译输出等</li><li>rocketmq-example 示例，比如生产者和消费者</li><li>rocketmq-fliter 进行Broker过滤的不感兴趣的消息传输，减小带宽压力</li><li>rocketmq-logappender、rocketmq-logging日志相关</li><li>rocketmq-namesrv Namesrv服务，用于服务协调</li><li>rocketmq-openmessaging 对外提供服务</li><li>rocketmq-remoting 远程调用接口，封装Netty底层通信</li><li>rocketmq-srvutil 提供一些公用的工具方法，比如解析命令行参数</li><li>rocketmq-store 消息存储核心包</li><li>rocketmq-test 提供一些测试代码包</li><li>rocketmq-tools 管理工具，比如有名的mqadmin工具</li></ul><ol start="5"><li><h3 id="集群架构模型"><a href="#集群架构模型" class="headerlink" title="集群架构模型"></a>集群架构模型</h3></li></ol><p>RocketMQ为我们提供了丰富的集群架构模型，包括单点模式、主从模式、双主模式、以及生产上使用最多的双主双从模式（或者说多主多从模式），在这里我们仅介绍一下经典的双主双从集群模型，如下图所示：<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6hdgedwtj30nq0alac3.jpg" alt="图片描述" style="zoom:100%;" /></p><ul><li>Producer集群就是生产者集群（他们在同一个生产者组 Producer Group）</li><li>Consumer集群就是消费者集群（他们在同一个消费者组 Consumer Group）</li><li>NameServer集群作为超轻量级的配置中心，只做集群元数据存储和心跳工作，不必保障节点间数据强一致性，也就是说NameServer集群是一个多机热备的概念。</li><li>对于Broker而言，通常Master与Slave为一组服务，他们互为主从节点，通过NameServer与外部的Client端暴露统一的集群入口。Broker就是消息存储的核心MQ服务了。</li></ul><ol start="6"><li><h3 id="集群架构思考"><a href="#集群架构思考" class="headerlink" title="集群架构思考"></a>集群架构思考</h3></li></ol><p>RocketMQ作为国内顶级的消息中间件，其性能主要依赖于天然的分布式Topic/Queue，并且其内存与磁盘都会存储消息数据，借鉴了Kafka的 “空中接力” 概念（这个我们后面学习Kafka的时候会详细的说明），所谓 “空中接力” 就是指数据不一定要落地，RocketMQ提供了同步/异步双写、同步/异步复制的特性。在真正的生产环境中应该选择符合自己业务的配置。下面针对于RocketMQ的高性能及其瓶颈在这里加以说明：</p><ul><li>架构思考：<ul><li>RocketMQ目前本人在公司内部实际生产环境采用8M-8S的集群架构（8主8从）硬件单点Master为32C，96G内存，500G的SSD</li><li>其主要瓶颈最终会落在IOPS上面，当高峰期来临的时候，磁盘读写能力是主要的性能瓶颈，每秒收发消息IOPS达到10W+ 消息，这也是公司内部主要的可靠性消息中间件</li><li>在很多时候，我们的业务会有一些非核心的消息投递，后续会进行消息中间件的业务拆分，把不重要的消息（可以允许消息丢失、非可靠性投递的消息）采用Kafka的异步发送机制，借助Kafka强大的吞吐量和消息堆积能力来做业务的分流（当然RocketMQ的性能也足够好）。</li><li>为什么瓶颈在IOPS? 根本原因还是因为云环境导致的问题，云环境的SSD物理存储显然和自建机房SSD会有不小的差距，这一点我们无论是从数据库的磁盘性能、还是搜索服务（ElasticSearch）的磁盘性能，都能给出准确的瓶颈点，单机IOPS达到1万左右就是云存储SSD的性能瓶颈，这个也解释了 “木桶短板原理” 的效应，在真正的生产中，CPU的工作主要在等待IO操作，高并发下 CPU资源接近极限，但是IOPS还是达不到我们想要的效果。</li></ul></li></ul><ol start="7"><li><h3 id="本节知识点回顾"><a href="#本节知识点回顾" class="headerlink" title="本节知识点回顾"></a>本节知识点回顾</h3></li></ol><p>Hi，小伙伴们，本节课我们通过简要的图文学习，带大家快速的过了一下RocketMQ，那么小伙伴们记住一定要在脑海里建立知识的结构体系，并串联起来！无论是现在，还是说未来，本神都希望小伙伴要按照下面的步骤进行回忆和复习：</p><ol><li>RocketMQ的前世今生 ？</li><li>RocketMQ的专业术语？</li><li>RocketMQ源码包的组成？</li><li>RocketMQ的集群架构模型</li><li>RocketMQ在真正生产环境中面临的瓶颈点以及解决方案</li></ol><ol start="8"><li><h3 id="补充课外资料"><a href="#补充课外资料" class="headerlink" title="补充课外资料"></a>补充课外资料</h3></li></ol><p>为了方便爱学习的小伙伴们，本神特意加餐一波，提供RocketMQ的官方文档和相关软件包，以及对应的代码示例，辅助小伙伴们更好掌握RocketMQ。另外本神还在慕课网上的一门课程详细的讲解了RocketMQ的各个知识点以及实战应用，有想深入学习的小伙伴可以学习共勉。</p><ol><li>官方文档</li><li>RocketMQ4.3.0版本（Linux平台）</li><li>RocketMQ代码示例</li><li>慕课网实战课程《RocketMQ核心技术精讲与高并发抗压实战》传送门：<a href="https://coding.imooc.com/class/292.html" target="_blank" rel="noopener">https://coding.imooc.com/class/292.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-消息中间件（MQ）认知提升(ActiveMQ)</title>
      <link href="/imooc/1297-MQ-Kafka/02-4-active-mq/"/>
      <url>/imooc/1297-MQ-Kafka/02-4-active-mq/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><ol><li><h3 id="初识-JMS-与其专业术语"><a href="#初识-JMS-与其专业术语" class="headerlink" title="初识 JMS 与其专业术语"></a>初识 JMS 与其专业术语</h3></li></ol><p>小伙伴们大家好，现在我们和大家一起了解一下古老而又神秘的消息中间件”ActiveMQ”。首先，说起ActiveMQ，就必须先聊聊JMS（Java Message Service）规范，也就是Java消息服务，它定义了Java中访问消息中间件的接口的规范。在这里注意哦，JMS只是接口，并没有给予实现，实现JMS接口的消息中间件称为 “JMS Provider”，目前知名的开源 MOM （Message Oriented Middleware，也就是消息中间件）系统包括Apache的ActiveMQ、RocketMQ、Kafka，以及RabbitMQ，可以说他们都 “基本遵循” 或 “参考” JMS规范，都有自己的特点和优势。</p><ul><li>专业术语<ul><li>JMS（Java Message Service）：实现JMS 接口的消息中间件；</li><li>Provider（MessageProvider）：消息的生产者；</li><li>Consumer（MessageConsumer）：消息的消费者；</li><li>PTP（Point to Point）：即点对点的消息模型，这也是非常经典的模型；</li><li>Pub / Sub（Publish/Subscribe）：，即发布/订阅的消息模型；</li><li>Queue：队列目标，也就是我们常说的消息队列，一般都是会真正的进行物理存储；</li><li>Topic：主题目标；</li><li>ConnectionFactory：连接工厂，JMS 用它创建连接；</li><li>Connection：JMS 客户端到JMS Provider 的连接；</li><li>Destination：消息的目的地；</li><li>Session：会话，一个发送或接收消息的线程（这里Session可以类比Mybatis的Session）；</li></ul></li><li>JMS 消息格式定义：<ul><li>StreamMessage 原始值的数据流</li><li>MapMessage 一套名称/值对</li><li>TextMessage 一个字符串对象</li><li>BytesMessage 一个未解释字节的数据流</li><li>ObjectMessage 一个序列化的Java对象</li></ul></li></ul><ol start="2"><li><h3 id="了解ActiveMQ"><a href="#了解ActiveMQ" class="headerlink" title="了解ActiveMQ"></a>了解ActiveMQ</h3></li></ol><p>ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在早些年的 “J2EE应用” 时期扮演着特殊的地位，可以说那个年代ActiveMQ在业界应用最广泛，当然如果现在想要有更强大的性能和海量数据处理能力，ActiveMQ还需要不断的升级版本，不断的提升性能和架构设计的重构。</p><p>就算现在我们 80% 以上的业务我们使用ActiveMQ已经足够满足需求，其丰富的API、多种集群构建模式使得他成为业界老牌消息中间件，在中小型企业中应用广泛！</p><p>当然如果你想针对大规模、高并发应用服务做消息中间件技术选型，譬如淘宝、京东这种大型的电商网站，尤其是双11这种特殊时间，ActiveMQ可能就显得力不从心了，当然我们这里后续还会和大家介绍其他非常优秀的MOM咯。</p><ol start="3"><li><h3 id="消息投递模式"><a href="#消息投递模式" class="headerlink" title="消息投递模式"></a>消息投递模式</h3></li></ol><p>废话不多说，我们首先要了解JMS规范里最经典的两种消息投递模式，即 “点对点” 与 “发布订阅”。</p><ul><li>点对点：生产者向队列投递一条消息，只有一个消费者能够监听得到这条消息（PTP)，下图所示：<img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6gy68hfcj30ih0bdwf0.jpg" alt="图片描述" style="zoom:80%;" /></li><li>发布订阅：生产者向队列投递一条消息，所有监听该队列的消费者都能够监听得到这条消息（P/S)，下图所示：<img src="https://climg.mukewang.com/5df83de108523a3005910364.jpg" alt="图片描述" style="zoom:80%;" /></li></ul><ol start="4"><li><h3 id="ActiveMQ各项指标"><a href="#ActiveMQ各项指标" class="headerlink" title="ActiveMQ各项指标"></a>ActiveMQ各项指标</h3></li></ol><p>衡量一个MOM，我们主要从三方面考虑即可，即服务性能、存储堆积能力、可扩展性。</p><ul><li>服务性能<ul><li>ActiveMQ的性能一般，在早期传统行业为王的时代还是比较流行的，但现如今面对高并发、大数据的业务场景，往往力不从心！</li></ul></li><li>数据存储<ul><li>默认采用kahadb存储（索引文件形式存储），也可以使用高性能的google leveldb（内存数据库存储）， 或者可以使用MySql、Oracle进程消息存储（关系型数据库存储）。</li></ul></li><li>集群架构<ul><li>ActiveMQ 可以与zookeeper进行构建 主备集群模型，并且多套的主备模型直接可以采用Network的方式构建分布式集群。</li></ul></li></ul><ol start="5"><li><h3 id="ActiveMQ集群架构模式"><a href="#ActiveMQ集群架构模式" class="headerlink" title="ActiveMQ集群架构模式"></a>ActiveMQ集群架构模式</h3></li></ol><p>ActiveMQ最经典的两种集群架构模式，Master-Slave 、Network 集群模式！</p><ul><li><p>Master-Slave：</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6gz6u17fj309w084q36.jpg" alt="图片描述" style="zoom:100%;" /></li><li><p>Master-Slave：顾名思义，就是主从方式，当然这里要理解为主备的方式，也就是双机热备机制；Master Slave 背后的想法是，消息被复制到slave broker，因此即使master broker遇到了像硬件故障之类的错误，你也可以立即切换到slave broker而不丢失任何消息。 Master Slave是目前ActiveMQ推荐的高可靠性和容错的解决方案。</p></li><li><p>架构思考：Master-Slave集群模型的关键点：</p><ul><li>上图（Master-Slave）绿色的为主节点，灰色的则为备份节点，这两个节点都是运行状态的。</li><li>zookeeper的作用就是为了当绿色的主节点宕机时，进行及时切换到备份的灰色节点上去，使其进行主从角色的互换，用于实现高可用性的方案。</li><li>Master-Slave集群模型的缺点也显而易见，就是不能做到分布式的topic、queue，当消息量巨大时，我们的MQ集群压力过大，没办法满足分布式的需求。</li></ul></li><li><p>Network：<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6h6eoxn0j30ed08l0te.jpg" alt="图片描述"></p></li><li><p>Network：这里可以理解为网络通信方式，也可以说叫Network of brokers。这种方式真正解决了分布式消息存储和故障转移、broker切换的问题。可以理解消息会进行均衡；从ActiveMQ1.1版本起，ActiveMQ支持networks of brokers。它支持分布式的queues和topics。一个broker会相同对待所有的订阅（subscription）：不管他们是来自本地的客户连接，还是来自远程broker，它都会递送有关的消息拷贝到每个订阅。远程broker得到这个消息拷贝后，会依次把它递送到其内部的本地连接上。</p></li><li><p>架构思考：Network集群模型的关键点： </p><ul><li><p>首先，这种方案需要两套或多套（Master-Slave）的集群模型才可以搞定，部署非常麻烦，需要两套或多套集群直接相互交叉配置，相互间能够感知到彼此的存在。下面我给出一段XML配置，简单来说就是在ActiveMQ的配置文件里要进行多套（Master-Slave）之间的 networkConnector配置工作：</p><pre><code class="xml">&lt;broker brokerName=&quot;receiver&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt;     &lt;transportConnectors&gt;         &lt;transportConnector uri=&quot;tcp://localhost:62002&quot;/&gt;     &lt;/transportConnectors&gt;     &lt;networkConnectors&gt;        &lt;networkConnector               uri=&quot;static:( tcp://localhost:61616,tcp://remotehost:61616)&quot;/&gt;     &lt;/networkConnectors&gt;&lt;/broker&gt;</code></pre></li><li><p>其次，Network虽然解决了分布式消息队列这个难题，但是还有很多潜在的问题，最典型的就是资源浪费问题，并且也可能达不到所预期的效果；通常采用Master-Slave模型是传统型互联网公司的首选，作为互联网公司往往会选择开箱即用的消息中间件，从运维、部署、使用各个方面都要优于ActiveMQ，当然ActiveMQ毕竟是 “老牌传统强Q”，Apache的顶级项目之一，目前正在进行新版本的重构（对于5.X版本）与落地，下一代 “Artemis代理”，也可以理解为 “6.X”；有兴趣的小伙伴可以关注一下官网，传送门如下：<a href="https://activemq.apache.org/" target="_blank" rel="noopener">https://activemq.apache.org/</a></p></li></ul></li></ul><ol start="6"><li><h3 id="本节知识点回顾"><a href="#本节知识点回顾" class="headerlink" title="本节知识点回顾"></a>本节知识点回顾</h3></li></ol><p>Hi，小伙伴们，本节课我们通过简要的图文学习，带大家快速的过了一下ActiveMQ，那么小伙伴们记住一定要在脑海里建立知识的结构体系，并串联起来！无论是现在，还是说未来，本神都希望小伙伴要按照下面的步骤进行回忆和复习：</p><ol><li><p>什么是JMS？</p></li><li><p>JMS的规范有哪些，分别代表什么含义?</p></li><li><p>ActiveMQ的历史背景</p></li><li><p>关于消息的投递模式（PTP、P/S）</p></li><li><p>ActiveMQ的各项指标</p></li><li><p>ActiveMQ的集群架构模型（Master-Slave、Network）</p></li><li><h3 id="补充课外资料"><a href="#补充课外资料" class="headerlink" title="补充课外资料"></a>补充课外资料</h3></li></ol><p>为了方便爱学习的小伙伴，本神特意加餐一波，提供官方文档手册、还有相关部署软件包，以及私人珍藏代码(DEMO)，用来辅助小伙伴们对ActiveMQ有一个更深入的认知哦！不谢</p><ol><li>官方JMS文档</li><li>ActiveMQ（5.x）服务包（Windows平台）</li><li>ActiveMQ代码示例</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-消息中间件（MQ）认知提升</title>
      <link href="/imooc/1297-MQ-Kafka/02-mq-cognition/"/>
      <url>/imooc/1297-MQ-Kafka/02-mq-cognition/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="2-1-本章概述（Kafka）"><a href="#2-1-本章概述（Kafka）" class="headerlink" title="2-1 本章概述（Kafka）"></a>2-1 本章概述（Kafka）</h2><blockquote><p>RabbitMQ、Apache Kafka</p></blockquote><p>课程目录</p><blockquote><p>分布式消息队列（MQ）认知提升<br>RabbitMQ实战<br>RabbitMQ可靠性投递基础组件封装<br>Kafka应用实战<br>Kafka高吞吐量日志收集实战<br>架构思考：分布式日志、跟踪、告警、分析平台</p></blockquote><p>本章目录</p><blockquote><p>业界主流的分布式消息队列（MQ）与技术选型</p><p>ActiveMQ特性原理与集群</p><p>RabbitMQ特性原理与集群架构解析</p><p>RocketMQ特性原理与集群架构</p><p>Kafka特性原理与集群架构解析</p></blockquote><h2 id="2-2-消息中间件（MQ）的应用场景与性能衡量指标是什么？"><a href="#2-2-消息中间件（MQ）的应用场景与性能衡量指标是什么？" class="headerlink" title="2-2 消息中间件（MQ）的应用场景与性能衡量指标是什么？"></a>2-2 消息中间件（MQ）的应用场景与性能衡量指标是什么？</h2><p>分布式消息队列（MQ）应用<strong>场景</strong></p><blockquote><p>服务解耦、削峰填谷、异步化缓冲</p></blockquote><p>分布式消息队列（MQ）应用<strong>思考点</strong></p><blockquote><p><strong>生产端可靠性投递</strong>、<strong>消费端幂等</strong>、高可用性、低延迟、可靠性、堆积能力、扩展性</p></blockquote><h2 id="2-3-消息中间件（MQ）的技术选型关注点有哪些？"><a href="#2-3-消息中间件（MQ）的技术选型关注点有哪些？" class="headerlink" title="2-3 消息中间件（MQ）的技术选型关注点有哪些？"></a>2-3 消息中间件（MQ）的技术选型关注点有哪些？</h2><p>业界主流的分布式消息队列（MQ）</p><blockquote><p>ActiveMQ、RabbitMQ、RocketMQ、Kafka</p></blockquote><p>如何进行技术选型？</p><blockquote><ul><li>各个MQ的性能、优缺点、相应的业务场景</li><li>集群架构模式，分布式、可扩展、高可用、可维护性</li><li>综合成本问题，人员成本</li><li>未来的方向、规划、思考</li></ul></blockquote><h2 id="2-4-ActiveMQ消息中间件集群架构与原理解析"><a href="#2-4-ActiveMQ消息中间件集群架构与原理解析" class="headerlink" title="2-4 ActiveMQ消息中间件集群架构与原理解析"></a>2-4 <a href="02-4-active-mq.md">ActiveMQ消息中间件集群架构与原理解析</a></h2><h2 id="2-5-RabbitMQ消息中间件集群架构模型与原理解析"><a href="#2-5-RabbitMQ消息中间件集群架构模型与原理解析" class="headerlink" title="2-5 RabbitMQ消息中间件集群架构模型与原理解析"></a>2-5 RabbitMQ消息中间件集群架构模型与原理解析</h2><p>RabbitMQ四种集群架构</p><blockquote><p>主备模式、远程模式、镜像模式、多活模式</p></blockquote><h3 id="主备模式"><a href="#主备模式" class="headerlink" title="主备模式"></a>主备模式</h3><blockquote><p>Warren（兔子窝），一个主/备方案（主节点如果挂了，从节点提供服务，使用Haproxy。和ActiveMQ利用Zookeeper做主备一样）</p></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6hy31xptj30ik0j4q41.jpg" alt="image-20200325213115561" style="zoom:40%;" /><p>主备模式-HaProxy配置</p><pre><code class="shell">listen rabbitmq_master # 主备模式集群的名字bind 0.0.0.0:5672 #配置TCP模式mode tcp #简单的轮询balance roundrobin #主节点server bhz76 192.168.11.76:5672 check inter 5000 rise 2 fall 2server bhz77 192.168.11.77:5672 backup check inter 5000 rise 2 fall 2 #备用节点</code></pre><h3 id="远程模式（不常用）"><a href="#远程模式（不常用）" class="headerlink" title="远程模式（不常用）"></a>远程模式（不常用）</h3><blockquote><ul><li>远距离通信和复制，可以实现双活的一种模式，简称Shovel模式</li><li>Shovel就是可以把消息进行不同数据中心的复制工作，可以跨地域的让两个MQ集群互联</li></ul><p><strong>使用不多</strong>，可靠性有待提高，配置也非常麻烦。</p></blockquote><p>Shovel架构模型</p><blockquote><p>在使用了Shovel插件后，模型变成了近端同步确认，远端异步确认的方式，大大提高了订单确认速度，并且还能保证可靠性</p></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd72j4e246j30gt0aa74i.jpg" alt="Shovel架构模型" style="zoom:80%;" /><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd72jxp99lj30ko0azjrz.jpg" alt="Shovel集群的拓扑图" style="zoom:80%;" /><p>Shovel集群配置步骤</p><blockquote><ol><li><p>Step1：启动RabbitMQ插件</p><pre><code class="shell">rabbitmq-plugins enable amqp_clientrabbitmq-plugins enable rabbitmq_shovel</code></pre></li><li><p>Step2：创建rabbitmq.config</p><pre><code class="shell">touch /etc/rabbitmq/rabbitmq.config</code></pre></li><li><p>Step3：添加配置见rabbitmq.config</p></li><li><p>Step4：源与目的地服务器使用相同的配置文件(rabbitmq.config)</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd6m5i4uekj30lk0f0mza.jpg" alt="rabbitmq.config" style="zoom:80%;" /></li></ol></blockquote><h3 id="镜像模式（常用）"><a href="#镜像模式（常用）" class="headerlink" title="镜像模式（常用）"></a>镜像模式（常用）</h3><blockquote><ul><li>集群模式非常经典的就是Mirror镜像模式，保证100%数据不丢失。</li><li>在实际工作中用的最多，并且实现集群非常简单，一般互联网大厂都会构建这种镜像集群</li></ul></blockquote><p>Mirror镜像队列</p><blockquote><p>高可靠、数据同步、3节点</p><p>目的是为了保证rabbitmq数据的高可靠性解决方案，主要就是实现数据的同步，一般来讲是2-3个实现数据同步（对于100%数据可靠性解决方案一般是3个节点）</p></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd72txmzvxj30wr0kidiy.jpg" alt="RabbitMQ集群架构图" style="zoom:60%;" /><h3 id="多活模式"><a href="#多活模式" class="headerlink" title="多活模式"></a>多活模式</h3><blockquote><ul><li>这种模式也是实现异地数据复制的主流模式，因为Shovel模式配置比较复杂，所以一般来说实现异地集群都是使用这种双活或者多活模型来实现的</li><li>这种模型需要依赖RabbitMQ的<strong>federation插件</strong>，可以实现持续的,可靠的AMQP数据通信，多活模式实际配置与应用非常简单</li><li>RabbitMQ部署架构采用双中心模式（多中心），那么在两套（或多套）数据中心中各部署一套RabbitMQ集群，各中心的RabbitMQ服务除了需要为业务提供正常的消息服务外，中心之间还需要实现部分队列消息共享</li></ul></blockquote><p>多活集群架构图</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7mi68wfvj315a0iljtz.jpg" alt="多活集群架构图" style="zoom:40%;" /><p>多活模式-Federation插件</p><blockquote><ul><li><p>Federation插件是一个不需要构件Cluster，而在Brokers之间传输消息的高性能插件，Federation插件可以在Brokers或者Cluster之间传输消息，连接的双方可以使用不同的users和virtual hosts，双方也可以使用版本不同的RabbitMQ和Erlang。Federation插件使用AMQP协议通信，可以接受不连续的传输</p></li><li><p>Federation Exchange，可以看成Downstream从Upstream主动拉取消息，但并不是拉取所有消息，必须是在Downstream上已经明确定义Bindings关系的Exchange，也就是有实际的物理Queue来接受消息，才会从Upstream拉取消息到Downstream。使用AMQP协议实施代理间通信，Downstream会将绑定关系组合在一起，绑定/接触绑定命令将发送到Upstream交换机。因此，Federation Exchange只接收具有订阅的消息</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7mrb9hm6j30zb0cfq3y.jpg" alt="Federation插件" style="zoom:50%;" /></li></ul></blockquote><h2 id="2-6-RocketMQ消息中间件集群架构与原理解析"><a href="#2-6-RocketMQ消息中间件集群架构与原理解析" class="headerlink" title="2-6 RocketMQ消息中间件集群架构与原理解析"></a>2-6 <a href="02-6-rocket-mq.md">RocketMQ消息中间件集群架构与原理解析</a></h2><h2 id="2-7-Kafka消息中间件高性能原因分析"><a href="#2-7-Kafka消息中间件高性能原因分析" class="headerlink" title="2-7 Kafka消息中间件高性能原因分析"></a>2-7 Kafka消息中间件高性能原因分析</h2><p>Kafka介绍</p><blockquote><ul><li>Kafka是LinkedIn开源的分布式消息系统，目前归属于Apache顶级项目</li><li>Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输</li><li>0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务</li></ul></blockquote><p>Kafka有哪些特点</p><blockquote><p>分布式、跨平台、实时性、伸缩性</p></blockquote><p>Kafka高性能的原因是什么？</p><blockquote><ul><li>顺序写，Page Cache空中接力，高效读写</li><li>高性能、高吞吐</li><li>后台异步、主动Flush</li><li>预读策略IO调度</li></ul></blockquote><h2 id="2-8-Kafka高性能核心pageCache与zeroCopy原理解析"><a href="#2-8-Kafka高性能核心pageCache与zeroCopy原理解析" class="headerlink" title="2-8 Kafka高性能核心pageCache与zeroCopy原理解析"></a>2-8 Kafka高性能核心pageCache与zeroCopy原理解析</h2><p>Page Cache页面缓存：</p><blockquote><p>Page Cache是操作系统实现的主要的磁盘缓存的机制，以此来减少对磁盘IO的操作，对磁盘IO访问特别频繁会影响操作系统的性能。<strong>把磁盘中的数据缓存到内存中，把对磁盘的访问变成对内存的访问。</strong></p></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7nlcb8vxj30t90ld0uk.jpg" alt="Page Cache的过程" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7o5dbyirj30tw0lawg0.jpg" alt="ZeroCopy" style="zoom:50%;" /><p>思考：将一个消息发送给10个消费者，两种模式分别需要copy多少次数据？</p><blockquote><p>传统模式<code>4*10</code>次，零拷贝<code>1+1*10</code>次</p></blockquote><h2 id="2-9-Kafka消息中间件集群模型讲解"><a href="#2-9-Kafka消息中间件集群模型讲解" class="headerlink" title="2-9 Kafka消息中间件集群模型讲解"></a>2-9 Kafka消息中间件集群模型讲解</h2><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7ob5wsqlj30y30d3my4.jpg" alt="Kafka集群模式" style="zoom:35%;" /><h2 id="2-10-本章总结"><a href="#2-10-本章总结" class="headerlink" title="2-10 本章总结"></a>2-10 本章总结</h2><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd7oc8xymsj31260nqwij.jpg" alt="图片描述" style="zoom:100%;" />]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-《Java架构师成长体系课程》导学</title>
      <link href="/imooc/1297-MQ-Kafka/01-guiding/"/>
      <url>/imooc/1297-MQ-Kafka/01-guiding/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-课程导学"><a href="#1-1-课程导学" class="headerlink" title="1-1 课程导学"></a>1-1 课程导学</h2><blockquote><p>服务架构：单体&gt;&gt;集群&gt;&gt;分布式&gt;&gt;微服务&gt;&gt;容器化</p><p>目标：高可用、高并发、高性能</p><p>技术栈：SpringBoot、MyBatis、Redis、Nginx、ElasticSearch搜索引擎、FastDFS文件存储、分布式会话、单点登录、RabbitMQ消息队列、Kafka消息队列、MyCat、Sharding-JDBC、分布式锁设计、分布式全局ID设计、分布式事务和数据一致性、接口幂等性设计、分布式限流、SpringCloud G版微服务、Docker、K8S、容器弹性扩缩容、Netty、JVM性能调优、MySQL性能调优、应用程序性能调优、Tomcat性能调优、Linux性能调优、架构调优</p></blockquote><p>课程安排</p><blockquote><p>阶段一：单体项目开发与上线（1~5周）</p><p>阶段二：从单体到高可用集群演进（6~8周）</p><p>阶段三：逐个击破分布式核心问题（9~17周）</p><p>阶段四：SpringCloud G版微服务（18~25周）</p><p>阶段五：Docker，K8S容器化（26~30周）</p><p>阶段六：Netty与性能调优（31~40周）</p></blockquote><ol><li><p>阶段一：单体项目开发与上线（1~5周）</p><blockquote><p>第1周：万丈高楼，地基首要</p><p>第2周：分类，推荐，搜索，评价，购物车开发</p><p>第3周：收货地址，订单，支付，定时任务开发</p><p>第4周：用户中心，订单/评价管理开发</p><p>第5周：云服务器部署上线</p></blockquote></li><li><p>阶段二：从单体到高可用集群演进（6~8周）</p><blockquote><p>第6周：LVS+Keepalived+Nginx实现高可用集群</p><p>第7周：主从复制高可用Redis集群</p><p>第8周：Redis缓存雪崩，穿透</p></blockquote></li><li><p>阶段三：逐个击破分布式核心问题（9~17周）</p><blockquote><p>第9周：分布式会话与单点登录SSO</p><p>第10周：分布式搜索引擎-ElasticSearch</p><p>第11周：分布式文件系统-FastDFS+阿里OSS</p><p>第12周：分布式消息队列-RabbitMQ</p><p>第13周：分布式消息队列-Kafka</p><p>第14周：分布式锁</p><p>第15周：读写分离、分库分表-MyCat和Sharding-JDBC</p><p>第16周：分布式全局唯一主键ID、分布式事务和事务一致性</p><p>第17周：分布式接口幂等性，分布式限流</p></blockquote></li><li><p>阶段四：SpringCloud G版微服务（18~25周）</p><blockquote><p>第18周：微服务架构认知、微服务治理-Eureka</p><p>第19周：负载均衡-Ribbon、服务通信与调用-Feign</p><p>第20周：服务容错-Hystrix</p><p>第21周：分布式配置中心-Config</p><p>第22周：消息总线-Bus、服务网关-Gateway</p><p>第23周：服务调用链追踪-Sleuth、消息驱动-Stream</p><p>第24周：微服务下Sentinel流量防卫兵</p><p>第25周：服务治理的另一条路-Dubbo</p></blockquote></li><li><p>阶段五：Docker，K8S容器化（26~30周）</p><blockquote><p>第26周：服务容器化-Docker</p><p>第27周：容器技术-Cloud Foundry</p><p>第28周：容器编排-Mesos+Marathon</p><p>第29周：容器编排-K8S</p><p>第30周：容器弹性扩缩容架构思路</p></blockquote></li><li><p>阶段六：Netty与性能调优（31~40周）</p><blockquote><p>第31周：高性能网络通信基石-Netty入门与提高</p><p>第32周：高性能网络通信基石-Netty最佳实战</p><p>第33周：基于Netty打造自己的RPC通信框架-1</p><p>第34周：基于Netty打造自己的RPC通信框架-2</p><p>第35周：应用监控与调优-工具篇</p><p>第36周：应用监控与调优-技巧与实战篇</p><p>第37周：JVM性能调优-工具篇</p><p>第38周：JVM性能调优-实战篇</p><p>第39周：数据库监控与调优</p><p>第40周：Linux调优与架构调优</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00-目录</title>
      <link href="/imooc/1297-MQ-Kafka/00-catalog/"/>
      <url>/imooc/1297-MQ-Kafka/00-catalog/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><blockquote><p><a href="https://class.imooc.com/course/1297" target="_blank" rel="noopener">https://class.imooc.com/course/1297</a></p></blockquote><h2 id="第1章-Day01-《Java架构师成长体系课程》导学"><a href="#第1章-Day01-《Java架构师成长体系课程》导学" class="headerlink" title="第1章 Day01:《Java架构师成长体系课程》导学"></a>第1章 Day01:《Java架构师成长体系课程》导学</h2><ul><li>1-1 课程导学</li></ul><h2 id="第2章-Day01-消息中间件（MQ）认知提升"><a href="#第2章-Day01-消息中间件（MQ）认知提升" class="headerlink" title="第2章 Day01 消息中间件（MQ）认知提升"></a>第2章 Day01 消息中间件（MQ）认知提升</h2><ul><li>2-1 本章概述（Kafka）</li><li>2-2 消息中间件（MQ）的应用场景与性能衡量指标是什么？</li><li>2-3 消息中间件（MQ）的技术选型关注点有哪些？</li><li>2-4 ActiveMQ消息中间件集群架构与原理解析</li><li>2-5 RabbitMQ消息中间件集群架构模型与原理解析</li><li>2-6 RocketMQ消息中间件集群架构与原理解析</li><li>2-7 Kafka消息中间件高性能原因分析</li><li>2-8 Kafka高性能核心pageCache与zeroCopy原理解析</li><li>2-9 Kafka消息中间件集群模型讲解</li><li>2-10 本章总结</li></ul><h2 id="第3章-Day02-Kafka急速入门与实战"><a href="#第3章-Day02-Kafka急速入门与实战" class="headerlink" title="第3章 Day02 Kafka急速入门与实战"></a>第3章 Day02 Kafka急速入门与实战</h2><ul><li>3-1 本章导航</li><li>3-2 kafka核心概念与应用场景</li><li>3-3 kafka急速入门与核心API解析</li><li>3-4 Kafka与springboot整合_生产者讲解</li><li>3-5 Kafka与springboot整合_消费者讲解</li></ul><h2 id="第4章-Day03-Day04-Kafka海量日志收集系统架构设计"><a href="#第4章-Day03-Day04-Kafka海量日志收集系统架构设计" class="headerlink" title="第4章 Day03~Day04 Kafka海量日志收集系统架构设计"></a>第4章 Day03~Day04 Kafka海量日志收集系统架构设计</h2><ul><li>4-1 Kafka海量日志收集实战_架构设计讲解</li><li>4-2 Kafka海量日志收集实战_log4j2日志输出实战-1</li><li>4-3 Kafka海量日志收集实战_log4j2日志输出实战-2</li><li>4-4 Kafka海量日志收集实战_filebeat日志收集实战-1</li><li>4-5 Kafka海量日志收集实战_filebeat日志收集实战-2</li><li>4-6 附：logstash基础语法与使用</li><li>4-7 Kafka海量日志收集实战_logstash日志过滤实战-1</li><li>4-8 Kafka海量日志收集实战_logstash日志过滤实战-2</li><li>4-9 Kafka海量日志收集实战_elasticsearch&amp;kibana存储可视化实战</li><li>4-10 Kafka海量日志收集实战_watcher监控告警实战-1</li><li>4-11 Kafka海量日志收集实战_watcher监控告警实战-2</li><li>4-12 附：watcher 基础语法与使用</li><li>4-13 总结与复习</li><li>4-14 作业练习</li></ul><h2 id="第5章-【选看】大咖精彩内容荟萃"><a href="#第5章-【选看】大咖精彩内容荟萃" class="headerlink" title="第5章 【选看】大咖精彩内容荟萃"></a>第5章 【选看】大咖精彩内容荟萃</h2><ul><li>5-1 【风间影月】缓存穿透的解决方案落地实例</li><li>5-2 【凌波微步】事务补偿机制原理解析</li><li>5-3 【姚半仙】技术路线VS管理路线，该认真考虑一下职业发展问题了</li><li>5-4 【张飞扬】容器技术众多，该如何技术选型？</li><li>5-5 【大目】性能调优目标概述与我的四板斧分享</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式消息队列-Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-项目实战-页面骨架开发</title>
      <link href="/imooc/74-vue-sell-1/05-page-skeleton/"/>
      <url>/imooc/74-vue-sell-1/05-page-skeleton/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="5-1-组件拆分（上）"><a href="#5-1-组件拆分（上）" class="headerlink" title="5-1 组件拆分（上）"></a>5-1 组件拆分（上）</h2><pre><code class="json">// .eslintrc.js&#39;semi&#39;:[&#39;error&#39;,&#39;always&#39;] // eslint强制语句有分号&#39;indent&#39;: 0 // 取消indent设置</code></pre><pre><code class="html">&lt;!--index.html--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/css/reset.css&quot;/&gt;</code></pre><pre><code class="javascript">/* eslint-disable no-new */ // eslint跳过no-new检查</code></pre><h2 id="5-2-组件拆分（中）"><a href="#5-2-组件拆分（中）" class="headerlink" title="5-2 组件拆分（中）"></a>5-2 组件拆分（中）</h2><pre><code class="json">&quot;stylus&quot;: &quot;0.52.4&quot;,&quot;stylus-loader&quot;: &quot;^2.5.0&quot;,</code></pre><pre><code class="vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;v-header&gt;&lt;/v-header&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import header from &#39;./components/header/header&#39;;  export default {    components: {      &#39;v-header&#39;: header    }  };&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;header&quot;&gt;    I&#39;m header  &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt;  export default {  };&lt;/script&gt;&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;&lt;/style&gt;</code></pre><h2 id="5-3-组件拆分（下）"><a href="#5-3-组件拆分（下）" class="headerlink" title="5-3 组件拆分（下）"></a>5-3 组件拆分（下）</h2><p>flex布局</p><pre><code class="vue">&lt;div class=&quot;tab&quot;&gt;  &lt;div class=&quot;tab-item&quot;&gt;商品&lt;/div&gt;  &lt;div class=&quot;tab-item&quot;&gt;评论&lt;/div&gt;  &lt;div class=&quot;tab-item&quot;&gt;商家&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="vue">&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;  #app    .tab      display flex      width 100%      height 40px      line-height 40px      .tab-item        flex 1        text-align center&lt;/style&gt;</code></pre><h2 id="5-4-Vue-router-上"><a href="#5-4-Vue-router-上" class="headerlink" title="5-4 Vue-router(上)"></a>5-4 Vue-router(上)</h2><pre><code class="json">/* package.json */&quot;dependencies&quot;: {  &quot;vue-router&quot;: &quot;^0.7.13&quot;},</code></pre><pre><code class="shell">npm install</code></pre><pre><code class="vue">&lt;div class=&quot;tab&quot;&gt;  &lt;div class=&quot;tab-item&quot;&gt;    &lt;a v-link=&quot;{path:&#39;/goods&#39;}&quot;&gt;商品&lt;/a&gt;  &lt;/div&gt;  &lt;div class=&quot;tab-item&quot;&gt;    &lt;a v-link=&quot;{path:&#39;/ratings&#39;}&quot;&gt;评论&lt;/a&gt;  &lt;/div&gt;  &lt;div class=&quot;tab-item&quot;&gt;    &lt;a v-link=&quot;{path:&#39;/seller&#39;}&quot;&gt;商家&lt;/a&gt;  &lt;/div&gt;&lt;/div&gt;&lt;router-view&gt;&lt;/router-view&gt;</code></pre><pre><code class="javascript">/* main.js */import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;import App from &#39;./App&#39;import goods from &#39;components/goods/goods&#39;import ratings from &#39;components/ratings/ratings&#39;import seller from &#39;components/seller/seller&#39;Vue.use(VueRouter)let app = Vue.extend(App)let router = new VueRouter()router.map({  &#39;/goods&#39;: {    component: goods  },  &#39;/ratings&#39;: {    component: ratings  },  &#39;/seller&#39;: {    component: seller  }})router.start(app, &#39;#app&#39;)</code></pre><h2 id="5-5-Vue-router-下"><a href="#5-5-Vue-router-下" class="headerlink" title="5-5 Vue-router(下)"></a>5-5 Vue-router(下)</h2><pre><code class="javascript">/* main.js */router.go(&#39;/goods&#39;) // 路由直接跳到/goods页</code></pre><pre><code class="vue">&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;  .tab    .tab-item      &amp; &gt; a // &amp;表示父级元素        display block // 填满父级元素                text-decoration: none;// 去除文本a标签下划线        font-size 14px        color rgb(77,85,93)        &amp;.active // 父级元素有active类,则应用一下CSS          color rgb(240, 20, 20)&lt;/style&gt;</code></pre><blockquote><p>CSS书写规范：布局、宽高等写在前，字体颜色重绘不影响布局的写在后</p></blockquote><pre><code class="javascript">/* main.js */let router = new VueRouter({  linkActiveClass: &#39;active&#39;})</code></pre><h2 id="5-6-1像素border实现"><a href="#5-6-1像素border实现" class="headerlink" title="5-6 1像素border实现"></a>5-6 1像素border实现</h2><p>手机的1像素为物理2像素，所以在电脑上是1像素，则在手机上为2像素</p><blockquote><p>手机访问电脑服务项目地址：手机电脑同时连接内网WiFi，电脑查看IP，将IP的服务地址发送到手机端即可访问</p></blockquote><pre><code class="stylus">/* mixin.styl */border-1px($color)  position relative  &amp;:after    display block    position absolute    left 0    bottom 0    width 100%    border-top 1px solid $color    content &#39; &#39;</code></pre><pre><code class="stylus">/* base.styl */@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5)  .border-1px    &amp;::after      -webkit-transform scaleY(0.7)      transform scaleY(0.7)@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2)  .border-1px    &amp;::after      -webkit-transform scaleY(0.5)      transform scaleY(0.5)</code></pre><pre><code class="stylus">/* index.styl */@import &quot;./base.styl&quot;@import &quot;./icon.styl&quot;@import &quot;./mixin.styl&quot;</code></pre><pre><code class="javascript">/* main.js */import &#39;common/stylus/index.styl&#39;</code></pre><pre><code class="vue">&lt;div class=&quot;tab border-1px&quot;&gt;&lt;/div&gt;&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;  @import &quot;common/stylus/mixin.styl&quot;  .tab    // border-bottom 1px solid rgba(7, 17, 27, 0.1)    border-1px(rgba(7, 17, 27, 0.1))&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 74-Vue.js2.5+cube-ui重构饿了么App(一期) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-项目实战-准备工作</title>
      <link href="/imooc/74-vue-sell-1/04-preparation/"/>
      <url>/imooc/74-vue-sell-1/04-preparation/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="4-1-需求分析"><a href="#4-1-需求分析" class="headerlink" title="4-1 需求分析"></a>4-1 需求分析</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd4r2u5ws9j30pm08tgmg.jpg" alt="外卖APP商家页面"></p><h2 id="4-2-项目资源准备"><a href="#4-2-项目资源准备" class="headerlink" title="4-2 项目资源准备"></a>4-2 项目资源准备</h2><p>DPR（Device Pixel Ratio）：设备像素比</p><blockquote><p>window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。</p><p>公式表示就是：window.devicePixelRatio = 物理像素 / dips</p></blockquote><p><a href="https://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/" target="_blank" rel="noopener">设备像素比devicePixelRatio简单介绍</a></p><p>可以通过meta viewport的值判断代码运行在什么DPI的手机上</p><p>SVG：矢量图片，可以伸缩，转换为图标字体</p><h2 id="4-3-图标字体制作"><a href="#4-3-图标字体制作" class="headerlink" title="4-3 图标字体制作"></a>4-3 图标字体制作</h2><p><a href="https://icomoon.io/" target="_blank" rel="noopener">https://icomoon.io/</a></p><h2 id="4-4-项目目录设计"><a href="#4-4-项目目录设计" class="headerlink" title="4-4 项目目录设计"></a>4-4 项目目录设计</h2><blockquote><p>src：项目源码文件<br>    assets<br>    common<br>        fonts：图标字体文件<br>        js<br>        stylus：CSS预处理器，less,sass差不多<br>    components：组件文件<br>        Hello.vue<br>    App.vue：页面的实例文件<br>    main.js：入口文件</p></blockquote><p>stylus文件需要去除CSS文件中的”{“、”}”、”;”</p><h2 id="4-5-mock数据（模拟后台数据）"><a href="#4-5-mock数据（模拟后台数据）" class="headerlink" title="4-5 mock数据（模拟后台数据）"></a>4-5 mock数据（模拟后台数据）</h2><p>data.json</p><ol><li><p>使用data.json来mock后端数据</p><pre><code class="javascript">// dev-server.jsvar appData = require(&#39;../data.json&#39;);var seller = appData.seller;var goods = appData.goods;var ratings = appData.ratings;let apiRoutes = express.Router();apiRoutes.get(&#39;/seller&#39;, function (req, res) {  res.json({    errno: 0,    data: seller  });});apiRoutes.get(&#39;/goods&#39;,function (req,res) {  res.json({    errno: 0,    data: goods  });});apiRoutes.get(&#39;/ratings&#39;,function (req,res) {  res.json({    errno: 0,    data: ratings  });});app.use(&#39;/api&#39;, apiRoutes);</code></pre></li><li><p>访问地址</p><p><a href="http://localhost:8080/api/seller" target="_blank" rel="noopener">http://localhost:8080/api/seller</a></p><p><a href="http://localhost:8080/api/goods" target="_blank" rel="noopener">http://localhost:8080/api/goods</a></p><p><a href="http://localhost:8080/api/ratings" target="_blank" rel="noopener">http://localhost:8080/api/ratings</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 74-Vue.js2.5+cube-ui重构饿了么App(一期) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Vue-cli 开启 Vuejs 项目</title>
      <link href="/imooc/74-vue-sell-1/03-vue-cli/"/>
      <url>/imooc/74-vue-sell-1/03-vue-cli/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="3-1-Vue-cli介绍"><a href="#3-1-Vue-cli介绍" class="headerlink" title="3-1 Vue-cli介绍"></a>3-1 Vue-cli介绍</h2><p>Vue-cli是Vue的脚手架工具</p><blockquote><p>目录结构、本地调试、代码部署、热加载、单元测试</p></blockquote><p>官网：<a href="https://cli.vuejs.org/" target="_blank" rel="noopener">https://cli.vuejs.org/</a></p><h2 id="3-2-Vue-cli安装"><a href="#3-2-Vue-cli安装" class="headerlink" title="3-2 Vue-cli安装"></a>3-2 Vue-cli安装</h2><pre><code class="shell">node -v # 查看node版本sudo npm install -g vue-cli # 安装vue-clivuevue list # 列出可使用模板vue init webpack sell # 创建项目cd sell # 进入项目主目录npm install # 安装插件npm run dev # 运行项目</code></pre><h2 id="3-3-项目运行"><a href="#3-3-项目运行" class="headerlink" title="3-3 项目运行"></a>3-3 项目运行</h2><ol><li>创建.vue文件：template、script、style</li><li>export default一个对象</li><li>import引用，components注册</li><li>使用标签</li></ol><h2 id="3-4-项目文件介绍"><a href="#3-4-项目文件介绍" class="headerlink" title="3-4 项目文件介绍"></a>3-4 项目文件介绍</h2><blockquote><p>build：webpack配置<br>config：webpack配置<br>node_modules：npm install安装的依赖代码库<br>src：项目源码<br>    assets<br>    components<br>    App.vue<br>    main.js<br>static：第三方静态资源<br>test：测试<br>.babelrc：ES6转ES5的配置<br>.editorconfig：编译器配置<br>.eslintignore：忽略语法检查的目录文件<br>.eslintrc.js：eslint的配置文件<br>.gitignore：git仓库忽略提交的文件、目录<br>index.html：入口HTML文件<br>package.json：项目配置文件<br>README.md：项目描述文件</p></blockquote><h2 id="3-5-webpack打包（上）"><a href="#3-5-webpack打包（上）" class="headerlink" title="3-5 webpack打包（上）"></a>3-5 webpack打包（上）</h2><p>webpack：前端构件工具</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd2q0yiid4j31o00u0qcn.jpg" alt="webpack" style="zoom:30%;" /><p>package.json</p><pre><code class="json">&quot;dev&quot;: &quot;node build/dev-server.js&quot;</code></pre><p>dev-server.js</p><pre><code class="json">var webpackConfig = process.env.NODE_ENV === &#39;testing&#39;  ? require(&#39;./webpack.prod.conf&#39;)  : require(&#39;./webpack.dev.conf&#39;)</code></pre><p>webpack.dev.conf.js</p><pre><code class="json">var baseWebpackConfig = require(&#39;./webpack.base.conf&#39;)</code></pre><p>webpack.base.conf.js</p><p>utils.js</p><h2 id="3-6-webpack打包（中）"><a href="#3-6-webpack打包（中）" class="headerlink" title="3-6 webpack打包（中）"></a>3-6 webpack打包（中）</h2><h2 id="3-7-webpack打包（下）"><a href="#3-7-webpack打包（下）" class="headerlink" title="3-7 webpack打包（下）"></a>3-7 webpack打包（下）</h2>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 74-Vue.js2.5+cube-ui重构饿了么App(一期) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-Vuejs介绍</title>
      <link href="/imooc/74-vue-sell-1/02-introduce/"/>
      <url>/imooc/74-vue-sell-1/02-introduce/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="2-1-Vuejs介绍-近年来前端开发趋势"><a href="#2-1-Vuejs介绍-近年来前端开发趋势" class="headerlink" title="2-1 Vuejs介绍-近年来前端开发趋势"></a>2-1 Vuejs介绍-近年来前端开发趋势</h2><blockquote><p>旧浏览器逐渐淘汰，移动端需求增加<br>前端交互越来越多，功能越来越复杂<br>架构从传统后端MVC向REST API+前端<code>MV*</code>迁移</p><p><code>MV*</code>:MVC、MVP、MVVM</p></blockquote><h2 id="2-2-Vuejs介绍-MVVM框架"><a href="#2-2-Vuejs介绍-MVVM框架" class="headerlink" title="2-2 Vuejs介绍-MVVM框架"></a>2-2 Vuejs介绍-MVVM框架</h2><p>MVVM框架</p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1mzx6m3mj30kr07rgny.jpg" alt="MVVM框架" style="zoom:60%;" /><p>数据双向绑定：当数据发生变化，ViewModel能够观察到数据变化，并通知到对应视图做自动更新；而当用户操作视图，ViewModel也能够监听到视图的变化，然后通知数据做改动。</p><blockquote><p>针对具有复杂交互逻辑的前端应用<br>提供基础的架构抽象<br>通过AJAX数据持久化，保证前端用户体验</p></blockquote><p>MVVM：Angular.js、React.js、Vue.js</p><h2 id="2-3-Vuejs介绍-什么是Vuejs及Vuejs生态"><a href="#2-3-Vuejs介绍-什么是Vuejs及Vuejs生态" class="headerlink" title="2-3 Vuejs介绍-什么是Vuejs及Vuejs生态"></a>2-3 Vuejs介绍-什么是Vuejs及Vuejs生态</h2><p>什么是Vue.js</p><blockquote><p>轻量级MVVM框架<br>数据驱动+组件化的前端开发<br>GitHub超过25k的star数，社区完善</p></blockquote><p>官网：<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">https://cn.vuejs.org/</a></p><h2 id="2-4-Vuejs介绍-对比Angular、React"><a href="#2-4-Vuejs介绍-对比Angular、React" class="headerlink" title="2-4 Vuejs介绍-对比Angular、React"></a>2-4 Vuejs介绍-对比Angular、React</h2><blockquote><p>Vue.js更轻量，gzip后大小只有20k+，angular56k，react44k</p><p>Vue.js更易上手，学习曲线平稳</p><p>吸取两家之长，借鉴了angular的指令和react的组件化</p></blockquote><h2 id="2-5-Vuejs介绍-Vuejs核心思想"><a href="#2-5-Vuejs介绍-Vuejs核心思想" class="headerlink" title="2-5 Vuejs介绍-Vuejs核心思想"></a>2-5 Vuejs介绍-Vuejs核心思想</h2><blockquote><p>数据驱动<br>组件化</p></blockquote><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><blockquote><p>DOM是数据的一种自然映射</p></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1nlz7bvej30fa07lwek.jpg" alt="MVVM框架示意图" style="zoom:60%;" /><p>数据响应原理</p><blockquote><p>数据(Model)改变驱动视图（View）自动更新</p></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1nr37rx9j30he08oaa5.jpg" alt="数据响应原理" style="zoom:60%;" /><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><blockquote><p>扩展HTML元素，封装可重用的代码</p></blockquote><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gd1nthvv98j30ho06djrd.jpg" alt="DOM树与ViewModel树" style="zoom:60%;" /><p>组件设计原则</p><blockquote><p>页面上每个独立的可视/可交互区域视为一个组件<br>每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护<br>页面不过是组件的容器，组件可以嵌套自由组合形成完整的页面</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 74-Vue.js2.5+cube-ui重构饿了么App(一期) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-课程简介</title>
      <link href="/imooc/74-vue-sell-1/01-synopsis/"/>
      <url>/imooc/74-vue-sell-1/01-synopsis/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="1-1-课程简介"><a href="#1-1-课程简介" class="headerlink" title="1-1 课程简介"></a>1-1 课程简介</h2><p>Vue.js：当前最火的MVVM框架</p><blockquote><p>轻量、简洁、高效、数据驱动、组件化</p></blockquote><p>开发流程：需求分析-脚手架工具-数据mock-架构设计-代码编写-自测-编译打包</p><p>功能技术分析</p><blockquote><ul><li><p>vue-resource：后端数据交互</p></li><li><p>vue-router：前端路由</p></li><li><p>第三方JS库better-scroll</p></li><li><p>最大程度组件化</p></li><li><p>HTML5的LocalStorage</p></li><li><p>图标字体的使用</p></li><li><p>移动端1像素边框</p></li><li><p>CSS sticky footer布局</p></li><li><p>flex弹性布局</p></li></ul></blockquote><h2 id="1-2-课程安排"><a href="#1-2-课程安排" class="headerlink" title="1-2 课程安排"></a>1-2 课程安排</h2><p>学习目标：</p><blockquote><ul><li>掌握Vue.js在实战中的运用</li><li>学会使用Vue.js完整地开发移动端APP</li><li>学会组件化、模块化的开发方式</li></ul></blockquote><p>学习内容：</p><blockquote><ul><li>Vue.js框架介绍</li><li>Vue-cli脚手架 搭建基本代码框架</li><li>vue-router 官方插件管理路由</li><li>vue-resource Ajax通信</li><li>Webpack 构建工具</li><li>ES6+eslint eslint:es6代码风格检查工具</li></ul></blockquote><p>工程化、组件化、模块化</p><p>移动端常用开发技巧</p><blockquote><ul><li>flex弹性布局</li><li>CSS stickyfooter</li><li>的交互设计</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 74-Vue.js2.5+cube-ui重构饿了么App(一期) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00-章节目录</title>
      <link href="/imooc/74-vue-sell-1/00-catalog/"/>
      <url>/imooc/74-vue-sell-1/00-catalog/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="第01章-课程简介（一期）"><a href="#第01章-课程简介（一期）" class="headerlink" title="第01章 课程简介（一期）"></a>第01章 课程简介（一期）</h2><blockquote><p>介绍课程的学习目标和学习内容。</p></blockquote><ul><li>1-1 课程简介</li><li>1-2 课程安排</li></ul><h2 id="第02章-Vuejs介绍（一期）"><a href="#第02章-Vuejs介绍（一期）" class="headerlink" title="第02章 Vuejs介绍（一期）"></a>第02章 Vuejs介绍（一期）</h2><blockquote><p>从前端开发趋势分析开始，引入 MVVM 开发框架和 Vue.js，接着对比流行框架Angular 和 React，最后详细介绍 Vue.js 的核心思想-数据驱动和组件化。</p></blockquote><ul><li>2-1 Vuejs介绍-近年来前端开发趋势</li><li>2-2 Vuejs介绍-MVVM框架</li><li>2-3 Vuejs介绍-什么是Vuejs及Vuejs生态</li><li>2-4 Vuejs介绍-对比Angular、React</li><li>2-5 Vuejs介绍-Vuejs核心思想</li></ul><h2 id="第03章-Vue-cli-开启-Vuejs-项目（一期）"><a href="#第03章-Vue-cli-开启-Vuejs-项目（一期）" class="headerlink" title="第03章 Vue-cli 开启 Vuejs 项目（一期）"></a>第03章 Vue-cli 开启 Vuejs 项目（一期）</h2><blockquote><p>介绍 Vue 项目的脚手架，如何安装，对脚手架生成的目录文件做介绍，介绍 Vue 组件的编写方法，最后运行 demo 项目并介绍 webpack 构建脚本来说明 demo 的运行原理。</p></blockquote><ul><li>3-1 Vue-cli介绍</li><li>3-2 Vue-cli安装</li><li>3-3 项目运行</li><li>3-4 项目文件介绍</li><li>3-5 webpack打包（上）</li><li>3-6 webpack打包（中）</li><li>3-7 webpack打包（下）</li></ul><h2 id="第04章-项目实战-准备工作（一期）"><a href="#第04章-项目实战-准备工作（一期）" class="headerlink" title="第04章 项目实战-准备工作（一期）"></a>第04章 项目实战-准备工作（一期）</h2><blockquote><p>分析外卖 APP 商家页面的需求，准备图片资源，利用 icon-moon 把 svg 制作成图标字体，对代码的目录结构设计，最后 mock 测试数据。</p></blockquote><ul><li>4-1 需求分析</li><li>4-2 项目资源准备</li><li>4-3 图标字体制作</li><li>4-4 项目目录设计</li><li>4-5 mock数据（模拟后台数据）</li></ul><h2 id="第05章-项目实战-页面骨架开发（一期）"><a href="#第05章-项目实战-页面骨架开发（一期）" class="headerlink" title="第05章 项目实战-页面骨架开发（一期）"></a>第05章 项目实战-页面骨架开发（一期）</h2><blockquote><p>设计页面的骨架，拆分组件，商品、评论和商家详情页利用 Vue-router 做切换，最后还介绍了 flex 弹性布局以及移动端 1 像素 border 实现的小技巧。</p></blockquote><ul><li>5-1 组件拆分（上）</li><li>5-2 组件拆分（中）</li><li>5-3 组件拆分（下）</li><li>5-4 Vue-router(上)</li><li>5-5 Vue-router(下)</li><li>5-6 1像素border实现</li></ul><h2 id="第06章-项目实战-header组件开发（一期）"><a href="#第06章-项目实战-header组件开发（一期）" class="headerlink" title="第06章 项目实战-header组件开发（一期）"></a>第06章 项目实战-header组件开发（一期）</h2><blockquote><p>编写 header 头部组件，应用 Vue-resource 从服务端读取数据，介绍如何在 Vue.js 中使用过渡动画，如何编写 css sticky footer 布局，如何从需求中抽象出 star 星星组件。</p></blockquote><ul><li>6-1 Vue-resource应用（上）</li><li>6-2 Vue-resource应用（下）</li><li>6-3 外部组件（1）</li><li>6-4 外部组件（2）</li><li>6-5 外部组件（3）</li><li>6-6 外部组件（4）</li><li>6-7 外部组件（5）</li><li>6-8 外部组件（6）</li><li>6-9 详情弹层页（1）- 实现弹出层</li><li>6-10 详情弹层页（2）- CSS Sticky footer</li><li>6-11 详情弹层页（3）- star组件抽象（上）</li><li>6-12 详情弹层页（3）- star组件抽象（下）</li><li>6-13 详情弹层页（4）- star组件使用</li><li>6-14 详情弹层页（5）- 小标题自适应经典flex布局实现</li><li>6-15 详情弹层页（6）- header剩余组件实现（上）</li><li>6-16 详情弹层页（6）- header剩余组件实现（下）</li></ul><h2 id="第07章-项目实战-goods-商品列表页开发（一期）"><a href="#第07章-项目实战-goods-商品列表页开发（一期）" class="headerlink" title="第07章 项目实战-goods 商品列表页开发（一期）"></a>第07章 项目实战-goods 商品列表页开发（一期）</h2><blockquote><p>编写 goods 商品组件，包括它的子组件 shopcart 购物车。介绍了如何在 Vue.js 应用第三方 JS 插件 better-scroll实现列表滚动，并配合 Vue.js 的计算属性来实现左右列表的联动。应用了自定义 Vue.js 过渡动画实现了购物车的飞入动画效果，介绍了在 Vue.js中父子组件如何通讯。…</p></blockquote><ul><li>7-1 布局编写</li><li>7-2 左侧menu布局</li><li>7-3 右侧食品列表布局（1）</li><li>7-4 右侧食品列表布局（2）</li><li>7-5 右侧食品列表布局（3）</li><li>7-6 better-scroll运用（1）</li><li>7-7 better-scroll运用（2）</li><li>7-8 better-scroll运用（3）</li><li>7-9 shopcart购物车组件（1）</li><li>7-10 shopcart购物车组件（2）</li><li>7-11 shopcart购物车组件（3）</li><li>7-12 shopcart购物车组件（4）</li><li>7-13 shopcart购物车组件（5）</li><li>7-14 shopcart购物车组件（6）</li><li>7-15 cartcontrol组件（1）</li><li>7-16 cartcontrol组件（2）</li><li>7-17 cartcontrol组件（3）</li><li>7-18 购物车小球动画实现（1）</li><li>7-19 购物车小球动画实现（2）</li><li>7-20 购物车小球动画实现（3）</li><li>7-21 购物车详情页实现（1）</li><li>7-22 购物车详情页实现（2）</li><li>7-23 购物车详情页实现（3）</li><li>7-24 购物车详情页实现（4）</li></ul><h2 id="第08章-项目实战-food-商品详情页实现（一期）"><a href="#第08章-项目实战-food-商品详情页实现（一期）" class="headerlink" title="第08章 项目实战-food 商品详情页实现（一期）"></a>第08章 项目实战-food 商品详情页实现（一期）</h2><blockquote><p>编写 food 商品详情页组件，介绍了图片占位的技巧，并从需求中抽象出的 split 分隔组件和 ratingselect 评论组件，实现自定义过滤器 datefilter。</p></blockquote><ul><li>8-1 商品详情页实现（1）</li><li>8-2 商品详情页实现（2）</li><li>8-3 商品详情页实现（3）</li><li>8-4 商品详情页实现（4）</li><li>8-5 商品详情页实现（5）</li><li>8-6 split组件实现</li><li>8-7 ratingselect组件（1）</li><li>8-8 ratingselect组件（2）</li><li>8-9 ratingselect组件（3）</li><li>8-10 ratingselect组件（4）</li><li>8-11 ratingselect组件（5）</li><li>8-12 评价列表（1）</li><li>8-13 评价列表（2）</li><li>8-14 评价列表（3）</li><li>8-15 评价列表（4）</li><li>8-16 评价列表（5）</li><li>8-17 评价列表（6）</li></ul><h2 id="第09章-项目实战-ratings评价列表页实现（一期）"><a href="#第09章-项目实战-ratings评价列表页实现（一期）" class="headerlink" title="第09章 项目实战-ratings评价列表页实现（一期）"></a>第09章 项目实战-ratings评价列表页实现（一期）</h2><blockquote><p>编写 ratings 评价列表页，感受在 Vue.js 中复用组件的好处，实现快速开发。</p></blockquote><ul><li>9-1 ratings组件开发-overview开发（1）</li><li>9-2 ratings组件开发-overview开发（2）</li><li>9-3 ratings组件开发-overview开发（3）</li><li>9-4 ratings组件开发-评价列表（1）</li><li>9-5 ratings组件开发-评价列表（2）</li><li>9-6 ratings组件开发-评价列表（3）</li></ul><h2 id="第10章-项目实战-seller-商家详情页实现（一期）"><a href="#第10章-项目实战-seller-商家详情页实现（一期）" class="headerlink" title="第10章 项目实战-seller 商家详情页实现（一期）"></a>第10章 项目实战-seller 商家详情页实现（一期）</h2><blockquote><p>编写 seller 商家详情页，实现一套通用移动端数据存取方案，以及对项目做一些体验上的优化。</p></blockquote><ul><li>10-1 seller组件开发-overview开发（1）</li><li>10-2 seller组件开发-overview开发（2）</li><li>10-3 seller组件开发-公告与活动开发（1）</li><li>10-4 seller组件开发-公告与活动开发（2）</li><li>10-5 seller组件开发-BScroll应用</li><li>10-6 seller组件开发-商家实景图</li><li>10-7 seller组件开发-商家信息</li><li>10-8 seller组件开发-收藏商家（1）</li><li>10-9 seller组件开发-收藏商家（2）</li><li>10-10 seller组件开发-收藏商家</li><li>10-11 seller组件开发-体验优化</li></ul><h2 id="第11章-项目实战-项目编译打包（一期）"><a href="#第11章-项目实战-项目编译打包（一期）" class="headerlink" title="第11章 项目实战-项目编译打包（一期）"></a>第11章 项目实战-项目编译打包（一期）</h2><blockquote><p>上线前的最后一步，编译打包Vue.js 项目。介绍了 webpack 编译时的配置，如何利用node.js 开启一个server本地调试。</p></blockquote><ul><li>11-1 webpack配置介绍</li><li>11-2 nodejs调试</li></ul><h2 id="第12章-课程总结（一期）"><a href="#第12章-课程总结（一期）" class="headerlink" title="第12章 课程总结（一期）"></a>第12章 课程总结（一期）</h2><blockquote><p>对课程做总结，并列出了课程所提到的主要知识点的链接，作为课程的延伸学习。</p></blockquote><ul><li>12-1 课程总结</li></ul><h2 id="第13章-项目从-vue-js1-0-向-2-0-升级（一期）"><a href="#第13章-项目从-vue-js1-0-向-2-0-升级（一期）" class="headerlink" title="第13章 项目从 vue.js1.0 向 2.0 升级（一期）"></a>第13章 项目从 vue.js1.0 向 2.0 升级（一期）</h2><blockquote><p>本章节把项目从1.0向2.0升级向大家做了简要的介绍。</p></blockquote><ul><li>13-1 1.0升级2.0 配置文件修改</li><li>13-2 1.0升级2.0 源码修改（上）</li><li>13-3 1.0升级2.0 源码修改（下）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 74-Vue.js2.5+cube-ui重构饿了么App(一期) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-模式宗师养成宝典之Java版</title>
      <link href="/imooc/18-java-mode/"/>
      <url>/imooc/18-java-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><blockquote><p>对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题</p></blockquote><ol><li><a href="https://www.tuyrk.cn/imooc/112-singleton-mode">模式的秘密—单例模式</a></li><li><a href="https://www.tuyrk.cn/imooc/261-factory-mode">模式的秘密—工厂模式</a></li></ol><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><blockquote><p>如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等，因此对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点</p></blockquote><ol start="3"><li><a href="https://www.tuyrk.cn/imooc/214-proxy-mode">模式的秘密—代理模式</a></li><li><a href="https://www.tuyrk.cn/imooc/146-adapter-mode">模式的秘密—适配器模式</a></li></ol><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><blockquote><p>如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高</p></blockquote><ol start="5"><li><a href="https://www.tuyrk.cn/imooc/415-observer-mode">观察者模式</a></li><li><a href="https://www.tuyrk.cn/imooc/257-responsibility-mode">模式的秘密—责任链模式</a></li><li><a href="https://www.tuyrk.cn/imooc/165-strategy-mode">模式的秘密–策略模式</a></li><li><a href="https://www.tuyrk.cn/imooc/145-template-mode">模式的秘密—模板方法模式</a></li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol start="9"><li><a href="https://www.tuyrk.cn/imooc/1180-decorator-mode">装饰者模式</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1180-装饰者模式</title>
      <link href="/imooc/1180-decorator-mode/"/>
      <url>/imooc/1180-decorator-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="https://www.imooc.com/learn/1180" target="_blank" rel="noopener">https://www.imooc.com/learn/1180</a></p><p>简介：装饰者模式是java23种设计模式之一， 英文叫Decorator Pattern，又叫装饰者模式。 装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。 它是通过创建一个包装对象，也就是装饰来包裹真实的对象 改变了传统继承增强对象功能所带来的弊端</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>本章对本课程所学内容进行介绍。</p></blockquote><h3 id="1-1-装饰者模式的简介-03-02"><a href="#1-1-装饰者模式的简介-03-02" class="headerlink" title="1-1 装饰者模式的简介 (03:02)"></a>1-1 装饰者模式的简介 (03:02)</h3><p>课程大纲</p><blockquote><p>为什么要使用装饰者模式<br>装饰者模式的概念及适应环境<br>装饰者模式的结构<br>装饰者模式的实例演示<br>装饰者模式的优缺点<br>总结</p></blockquote><h2 id="第2章-装饰者模式概念"><a href="#第2章-装饰者模式概念" class="headerlink" title="第2章 装饰者模式概念"></a>第2章 装饰者模式概念</h2><blockquote><p>本章介绍如何使用装饰者模式，以及装饰者模式的概念和适应环境。</p></blockquote><h3 id="2-1-为什么要使用装饰者模式-06-11"><a href="#2-1-为什么要使用装饰者模式-06-11" class="headerlink" title="2-1 为什么要使用装饰者模式 (06:11)"></a>2-1 为什么要使用装饰者模式 (06:11)</h3><p>老王豆浆案例：</p><blockquote><p>老王豆浆配方：纯豆浆、红糖、红豆、牛奶、鸡蛋<br>豆浆由纯豆浆和其他辅料混合而成，新增辅料则可以多出很多种组合（一种组合一个子类），此时则会出现类爆炸的情况，导致程序非常臃肿。<br>解决方案：一种辅料一个子类，子类之间可以相互组合搭配。</p></blockquote><h3 id="2-2-装饰者模式的概念及适应环境-03-52"><a href="#2-2-装饰者模式的概念及适应环境-03-52" class="headerlink" title="2-2 装饰者模式的概念及适应环境 (03:52)"></a>2-2 装饰者模式的概念及适应环境 (03:52)</h3><p>装饰者模式的概念</p><blockquote><p>装饰者模式又名包装模式。动态的给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类的方式更为灵活。</p></blockquote><p>装饰者模式的适应场景</p><blockquote><ul><li>以动态的方式给对象添加职责</li><li>处理那些可以撤销的职责</li><li>当采用生成子类的方法进行扩充时，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数量爆炸性增长（老王豆浆案例）</li></ul></blockquote><p>问题：</p><ol><li><p>继承与装饰者模式有什么区别？</p></li><li><p>在哪种场景使用继承，在哪种场景使用装饰者模式</p></li></ol><h2 id="第3章-装饰者模式结构"><a href="#第3章-装饰者模式结构" class="headerlink" title="第3章 装饰者模式结构"></a>第3章 装饰者模式结构</h2><blockquote><p>本章介绍装饰者模式的结构。</p></blockquote><h3 id="3-1-装饰者模式的组成部分-07-35"><a href="#3-1-装饰者模式的组成部分-07-35" class="headerlink" title="3-1 装饰者模式的组成部分 (07:35)"></a>3-1 装饰者模式的组成部分 (07:35)</h3><p>装饰者模式的结构</p><ol><li>抽象组件（Component）：给出一个抽象接口，以规范准备接收附加责任的对象</li><li>被装饰者（ConcreteComponent）：Component的具体实现，也就是我们要装饰的具体对象</li><li>装饰者组件（Decorator）：持有组件（Component）对象的实例引用，该类的职责就是为了装饰具体组件对象，定义的基类。</li><li>具体装饰（ConcreteDecorator）：负责给构件对象装饰附加的功能。</li></ol><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakmgrtweuj30n80hpjs8.jpg" alt="装饰者模式类图" style="zoom:40%;" /><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakmip2qglj30nc0hqdg7.jpg" alt="装饰者模式实例" style="zoom:35%;" /><h2 id="第4章-装饰者模式的简单入门"><a href="#第4章-装饰者模式的简单入门" class="headerlink" title="第4章 装饰者模式的简单入门"></a>第4章 装饰者模式的简单入门</h2><blockquote><p>本章介绍装饰者模式入门。</p></blockquote><h3 id="4-1-装饰者模式简单入门-23-09"><a href="#4-1-装饰者模式简单入门-23-09" class="headerlink" title="4-1 装饰者模式简单入门 (23:09)"></a>4-1 装饰者模式简单入门 (23:09)</h3><ol><li><p>抽象组件-饮品</p><pre><code class="java">public interface Drink {    // 饮品价格    double money();    // 饮品品种描述    String desc();}</code></pre></li><li><p>被装饰者-豆浆</p><pre><code class="java">public class Soya implements Drink {    @Override    public double money() {        return 5D;    }    @Override    public String desc() {        return &quot;纯豆浆&quot;;    }}</code></pre></li><li><p>装饰者组件-装饰器</p><blockquote><ol><li>抽象类</li><li>实现抽象组件接口</li><li>持有抽象接口的引用</li></ol></blockquote><pre><code class="java">public abstract class Decorator implements Drink {    // 定义私有的饮品接口引用    private Drink drink;    public Decorator(Drink drink) {        this.drink = drink;    }    @Override    public double money() {        return drink.money();    }    @Override    public String desc() {        return drink.desc();    }}</code></pre></li><li><p>具体装饰-红豆</p><pre><code class="java">public class RedBean extends Decorator {    public RedBean(Drink drink) {        super(drink);    }    @Override    public double money() {        return super.money() + 3.2;    }    @Override    public String desc() {        return super.desc() + &quot;+红豆&quot;;    }}</code></pre></li><li><p>具体装饰-鸡蛋</p><pre><code class="java">public class Egg extends Decorator {    public Egg(Drink drink) {        super(drink);    }    @Override    public double money() {        return super.money() + 3.9;    }    @Override    public String desc() {        return super.desc() + &quot;+鸡蛋&quot;;    }}</code></pre></li><li><p>具体装饰-糖</p><pre><code class="java">public class Sugar extends Decorator {    public Sugar(Drink drink) {        super(drink);    }    @Override    public double money() {        return super.money() + 2.1;    }    @Override    public String desc() {        return super.desc() + &quot;+糖&quot;;    }}</code></pre></li><li><p>装饰者模式测试类</p><pre><code class="java">public class DecoratorTest {    public static void main(String[] args) {        // 开始搭配        // 创建豆浆对象        Drink soya = new Soya();        System.out.println(soya.money());        System.out.println(soya.desc());        // 向纯豆浆中加入红豆        Drink redBeanSoya = new RedBean(soya);        System.out.println(redBeanSoya.money());        System.out.println(redBeanSoya.desc());        // 向红豆豆浆中加入鸡蛋        Drink redBeanSoyaEgg = new Egg(redBeanSoya);        System.out.println(redBeanSoyaEgg.money());        System.out.println(redBeanSoyaEgg.desc());        // 需要糖豆浆        Drink sugarSoya = new Sugar(soya);        System.out.println(sugarSoya.money());        System.out.println(sugarSoya.desc());    }}</code></pre></li></ol><p>当有新的辅料品种时（新增具体装饰）：</p><ol><li><p>具体装饰-西瓜</p><pre><code class="java">public class Watermelon extends Decorator {    public Watermelon(Drink drink) {        super(drink);    }    @Override    public double money() {        return super.money() + 4.0;    }    @Override    public String desc() {        return super.desc() + &quot;+西瓜&quot;;    }}</code></pre></li><li><p>新增具体装饰-创建西瓜对象</p><pre><code class="java">Watermelon watermelonSugarSoya = new Watermelon(sugarSoya);System.out.println(watermelonSugarSoya.money());System.out.println(watermelonSugarSoya.desc());</code></pre></li></ol><p>当有新的产品时（新增被装饰者）：</p><ol><li><p>被装饰者-果汁</p><pre><code class="java">public class Fruit implements Drink {    @Override    public double money() {        return 6D;    }    @Override    public String desc() {        return &quot;果汁&quot;;    }}</code></pre></li><li><p>新增被装饰者-搭配果汁</p><pre><code class="java">Drink fruit = new Fruit();System.out.println(fruit.money());System.out.println(fruit.desc());Drink eggFruit = new Egg(fruit);System.out.println(eggFruit.money());System.out.println(eggFruit.desc());</code></pre></li></ol><h2 id="第5章-装饰者模式的真实应用"><a href="#第5章-装饰者模式的真实应用" class="headerlink" title="第5章 装饰者模式的真实应用"></a>第5章 装饰者模式的真实应用</h2><blockquote><p>本章介绍装饰者模式的真实应用，包括场景分析和如何解决乱码问题。</p></blockquote><h3 id="5-1-装饰者模式真实场景案例分析-04-44"><a href="#5-1-装饰者模式真实场景案例分析-04-44" class="headerlink" title="5-1 装饰者模式真实场景案例分析 (04:44)"></a>5-1 装饰者模式真实场景案例分析 (04:44)</h3><p>真实场景案例分析：解决乱码问题</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gakpwx8z5bj30yk0ih0u1.jpg" alt="客户端服务器乱码问题" style="zoom:35%;" /><h3 id="5-2-乱码产生原因以及普通解决方式-20-02"><a href="#5-2-乱码产生原因以及普通解决方式-20-02" class="headerlink" title="5-2 乱码产生原因以及普通解决方式 (20:02)"></a>5-2 乱码产生原因以及普通解决方式 (20:02)</h3><ol><li><p>在pom.xml添加maven依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置项目参数</p><pre><code class="properties"># application.propertiesspring.http.encoding.charset=ISO-8859-1# freemarker静态资源配置spring.freemarker.charset=UTF-8spring.freemarker.suffix=.html</code></pre></li><li><p>实现form表单</p><pre><code class="html">&lt;!--templates/html/form.html--&gt;&lt;form action=&quot;/code&quot; method=&quot;post&quot;&gt;    姓名:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt;    爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;抽烟&quot;/&gt;抽烟        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;喝酒&quot;/&gt;喝酒        &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;烫头&quot;/&gt;烫头&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre></li><li><pre><code class="java">@Controller@RequestMapping(&quot;/&quot;)public class CodeController {    @GetMapping(&quot;form&quot;)    public String form() {        return &quot;html/form&quot;;    }    @PostMapping(&quot;code&quot;)    public String code(HttpServletRequest request) {        // 获取姓名        String username = request.getParameter(&quot;username&quot;);        System.out.println(username);// ç¥ç§çå°å²å²        // 获取爱好        String[] hobbies = request.getParameterValues(&quot;hobby&quot;);        System.out.println(Arrays.toString(hobbies));// [æ½ç, åé, ç«å¤´]        return &quot;&quot;;    }}</code></pre></li></ol><p>解决乱码普通方式</p><ol><li><p>通过getBytes获取ISO-8859-1的byte，再进行转码UTF-8</p><p>编码转换工具类</p><pre><code class="java">public class CodeUtil {    /**     * ISO-8859-1转UTF-8编码     *     * @param codename 需要进行转码的字符串     * @return 转码后的字符串     */    public static String newCode(String codename) {        byte[] bytes = codename.getBytes(StandardCharsets.ISO_8859_1);        return new String(bytes, StandardCharsets.UTF_8);    }}</code></pre><pre><code class="java">System.out.println(CodeUtil.newCode(username));// 神秘的小岛岛for (String hobby : hobbies) {    System.out.println(CodeUtil.newCode(hobby));// 抽烟, 喝酒, 烫头}</code></pre></li></ol><h3 id="5-3-装饰者模式解决乱码问题-16-05"><a href="#5-3-装饰者模式解决乱码问题-16-05" class="headerlink" title="5-3 装饰者模式解决乱码问题 (16:05)"></a>5-3 装饰者模式解决乱码问题 (16:05)</h3><ol><li><p>抽象组件：ServletRequest</p></li><li><p>被装饰者：HttpServletRequest</p></li><li><p>装饰者组件（装饰器）：Decorators</p><blockquote><p>需要继承模板类</p></blockquote><pre><code class="java">public class Decorators extends HttpServletRequestWrapper {    // 持有接口的引用    HttpServletRequest request;    public Decorators(HttpServletRequest request) {        super(request);        this.request = request;    }    @Override    public String getParameter(String name) {        return super.getParameter(name);    }    @Override    public String[] getParameterValues(String name) {        return super.getParameterValues(name);    }}</code></pre></li><li><p>具体装饰-getParameter</p><blockquote><p>需要继承装饰器的类</p></blockquote><pre><code class="java">public class Parameter extends Decorators {    public Parameter(HttpServletRequest request) {        super(request);    }    // 对getParameter进行增强    @Override    public String getParameter(String name) {        String value = super.getParameter(name);        // 解决乱码        byte[] bytes = value.getBytes(StandardCharsets.ISO_8859_1);        return new String(bytes, StandardCharsets.UTF_8);    }}</code></pre></li><li><p>具体装饰-getParameterValues</p><pre><code class="java">public class ParameterValues extends Decorators {    public ParameterValues(HttpServletRequest request) {        super(request);    }    // 对getParameterValues进行增强    @Override    public String[] getParameterValues(String name) {        String[] values = super.getParameterValues(name);        for (int i = 0; i &lt; values.length; i++) {            byte[] bytes = values[i].getBytes(StandardCharsets.ISO_8859_1);            values[i] = new String(bytes, StandardCharsets.UTF_8);        }        return values;    }}</code></pre></li><li><p>编码转换Filter</p><pre><code class="java">@WebFilter(filterName = &quot;code&quot;, urlPatterns = &quot;/code&quot;)public class CodeFilter implements Filter {    @Override    public void init(FilterConfig filterConfig) throws ServletException {    }    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletRequest codeRequest = new Parameter(new ParameterValues(request));        filterChain.doFilter(codeRequest, servletResponse);    }    @Override    public void destroy() {    }}</code></pre></li><li><p>在启动类Application.java添加<code>@ServletComponentScan</code>注解</p></li></ol><h3 id="5-4-装饰者模式的优化写法-07-53"><a href="#5-4-装饰者模式的优化写法-07-53" class="headerlink" title="5-4 装饰者模式的优化写法 (07:53)"></a>5-4 装饰者模式的优化写法 (07:53)</h3><p>由解决编码案例可以得出：装饰者模式功能可拆卸</p><ol><li><p>具体装饰</p><pre><code class="java">public class NewDecorator extends HttpServletRequestWrapper {    // 持有接口的引用    private HttpServletRequest request;    public NewDecorator(HttpServletRequest request) {        super(request);        this.request = request;    }    // 对getParameter进行增强    @Override    public String getParameter(String name) {        String value = super.getParameter(name);        byte[] bytes = value.getBytes(StandardCharsets.ISO_8859_1);        return new String(bytes, StandardCharsets.UTF_8);    }    // 对getParameterValues进行增强    @Override    public String[] getParameterValues(String name) {        String[] values = super.getParameterValues(name);        for (int i = 0; i &lt; values.length; i++) {            byte[] bytes = values[i].getBytes(StandardCharsets.ISO_8859_1);            values[i] = new String(bytes, StandardCharsets.UTF_8);        }        return values;    }}</code></pre></li><li><p>编码转换doFilter()方法</p><pre><code class="java">public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {    HttpServletRequest request = (HttpServletRequest) servletRequest;    // 简化方式    HttpServletRequest codeRequest = new NewDecorator(request);    filterChain.doFilter(codeRequest, servletResponse);}</code></pre></li></ol><h3 id="5-5-io流中的装饰者模式的简单介绍-06-30"><a href="#5-5-io流中的装饰者模式的简单介绍-06-30" class="headerlink" title="5-5 io流中的装饰者模式的简单介绍 (06:30)"></a>5-5 io流中的装饰者模式的简单介绍 (06:30)</h3><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1galmv0frywj31q20ri109.jpg" alt="Java IO流" style="zoom:30%;" /><p>Java中IO流的装饰者模式</p><blockquote><p>BufferedInputStream较FileInputStream读取速度快。</p></blockquote><pre><code class="java">// 构件抽象路径File file = new File(&quot;aaa.txt&quot;);// 公共file实例构件aaa.txt文件FileInputStream fis = new FileInputStream(file);// 使用缓冲输入流BufferedInputStream bis = new BufferedInputStream(fis);</code></pre><h2 id="第6章-装饰者模式优缺点及课程总结"><a href="#第6章-装饰者模式优缺点及课程总结" class="headerlink" title="第6章 装饰者模式优缺点及课程总结"></a>第6章 装饰者模式优缺点及课程总结</h2><blockquote><p>本章介绍装饰者模式的优缺点，并对课程内容进行总结。</p></blockquote><h3 id="6-1-装饰者模式的优缺点-03-10"><a href="#6-1-装饰者模式的优缺点-03-10" class="headerlink" title="6-1 装饰者模式的优缺点 (03:10)"></a>6-1 装饰者模式的优缺点 (03:10)</h3><p>优点：</p><ul><li>目的在于扩展对象的功能。装饰者模式提供比继承更好的灵活性<br>装饰是动态的，运行时可以修改的；继承是静态的，编译期便已确定好</li><li>通过使用不同的装饰类及对它们的排列组合，可以创造出许多不同行为的组合</li></ul><p>缺点：</p><ul><li>产生new很多的小对象，大量的小对象会占用内存</li><li>组合方式很多，很容易出错</li></ul><h3 id="6-2-装饰者模式的总结-02-47"><a href="#6-2-装饰者模式的总结-02-47" class="headerlink" title="6-2 装饰者模式的总结 (02:47)"></a>6-2 装饰者模式的总结 (02:47)</h3><ul><li>熟悉装饰者模式的结构<br>抽象组件、被装饰者、装饰器、具体装饰</li><li>了解装饰者模式在何种场景使用<br>对一个对象进行增强、功能自由组合搭配</li><li>了解装饰者模式的优缺点</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>145-模式的秘密---模板方法模式</title>
      <link href="/imooc/145-template-mode/"/>
      <url>/imooc/145-template-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="http://www.imooc.com/learn/145" target="_blank" rel="noopener">http://www.imooc.com/learn/145</a></p><p>简介：模板方法模式是在日常开发中使用最为广泛的设计模式之一。通过本视频，你可以了解什么是模板方法模式，如何用 Java 语言实现模板方法模式。@Arthur 将用简单生动的例子带你领略模板方法模式的真意，最后还将用实际的行业案例告诉你模板方法模式的强大功能。</p></blockquote><p>@[TOC]</p><h2 id="第1章-模板方法模式初探"><a href="#第1章-模板方法模式初探" class="headerlink" title="第1章 模板方法模式初探"></a>第1章 模板方法模式初探</h2><blockquote><p>本章通过实际生活中的例子引出模板方法模式的定义，通过咖啡与茶的故事，带领大家进入模板方法的世界</p></blockquote><h3 id="1-1-什么是模板方法模式-09-36"><a href="#1-1-什么是模板方法模式-09-36" class="headerlink" title="1-1 什么是模板方法模式 (09:36)"></a>1-1 什么是模板方法模式 (09:36)</h3><p>内容介绍</p><blockquote><p>什么是模板方法模式<br>如何实现模板方法模式<br>模板方法模式的特点<br>模板方法模式在项目中的应用</p></blockquote><p>模板方法模式</p><blockquote><p>模板方法模式定义了一个操作的算法框架，而将一些步骤延迟到子类中实现，使得子类可以在不改变一个算法结构的同时就重新定义该算法的某些特定步骤。</p></blockquote><p>案例介绍：提神饮料的配置模板</p><blockquote><ol><li>把水煮沸（boil water）</li><li>泡饮料（brew）</li><li>把饮料倒进杯子（pour in cup）</li><li>加调味料（add condiments）</li></ol></blockquote><h2 id="第2章-模板方法模式的代码实现"><a href="#第2章-模板方法模式的代码实现" class="headerlink" title="第2章 模板方法模式的代码实现"></a>第2章 模板方法模式的代码实现</h2><blockquote><p>本章通过 Java 代码具体演示了模板方法模式的实现</p></blockquote><h3 id="2-1-用抽象基类定义框架-08-17"><a href="#2-1-用抽象基类定义框架-08-17" class="headerlink" title="2-1 用抽象基类定义框架 (08:17)"></a>2-1 用抽象基类定义框架 (08:17)</h3><p>代码编写</p><ol><li><p>抽象基类，为所有子类提供一个算法框架。提神饮料</p><pre><code class="java">public abstract class RefreshBeverage {    // 制备饮料的模板方法    // 封装了所有子类共同遵循的算法框架    public final void prepareBeverageTemplate() {        // 步骤一：将水煮沸        boilWater();        // 步骤二：泡制饮料        brew();        // 步骤三：将饮料倒入杯中        pourInCup();        // 步骤四：加入调味料        addCondiments();    }    // 基本方法，将水煮沸    private void boilWater() {        System.out.println(&quot;将水煮沸&quot;);    }    // 抽象的基本方法，泡制饮料    protected abstract void brew();    // 基本方法，将饮料倒入杯中    private void pourInCup() {        System.out.println(&quot;将饮料倒入杯中&quot;);    }    // 抽象的基本方法，加入调味料    protected abstract void addCondiments();}</code></pre></li></ol><h3 id="2-2-具体子类实现延迟步骤-08-31"><a href="#2-2-具体子类实现延迟步骤-08-31" class="headerlink" title="2-2 具体子类实现延迟步骤 (08:31)"></a>2-2 具体子类实现延迟步骤 (08:31)</h3><ol><li><p>具体子类，提供了咖啡的具体实现</p><pre><code class="java">public class Coffee extends RefreshBeverage {    @Override    protected void brew() {        System.out.println(&quot;用沸水冲泡咖啡&quot;);    }    @Override    protected void addCondiments() {        System.out.println(&quot;加入糖和牛奶&quot;);    }}</code></pre></li><li><p>具体子类，提供了制备茶的具体实现</p><pre><code class="java">public class Tea extends RefreshBeverage {    @Override    protected void brew() {        System.out.println(&quot;用80度的热水浸泡茶叶5分钟&quot;);    }    @Override    protected void addCondiments() {        System.out.println(&quot;加入柠檬&quot;);    }}</code></pre></li><li><p>测试类</p><pre><code class="java">public class RefreshReverageTest {    public static void main(String[] args) {        System.out.println(&quot;制备咖啡...&quot;);        RefreshBeverage coffee = new Coffee();        coffee.prepareBeverageTemplate();        System.out.println(&quot;咖啡好了！&quot;);        System.out.println(&quot;================&quot;);        System.out.println(&quot;制备茶...&quot;);        RefreshBeverage tea = new Tea();        tea.prepareBeverageTemplate();        System.out.println(&quot;茶好了！&quot;);    }}</code></pre></li></ol><h3 id="2-3-钩子使子类更灵活-06-47"><a href="#2-3-钩子使子类更灵活-06-47" class="headerlink" title="2-3 钩子使子类更灵活 (06:47)"></a>2-3 钩子使子类更灵活 (06:47)</h3><p>业务场景</p><blockquote><p>目前的提神饮料的步骤是固定的，当有些人不需要加入调味料时，使用钩子方法进行个性化扩展</p></blockquote><p>代码编写</p><ol><li><p>抽象基类，为所有子类提供一个算法框架。提神饮料</p><pre><code class="java">public abstract class RefreshBeverage {    // 制备饮料的模板方法    // 封装了所有子类共同遵循的算法框架    public final void prepareBeverageTemplate() {        // 步骤一：将水煮沸        boilWater();        // 步骤二：泡制饮料        brew();        // 步骤三：将饮料倒入杯中        pourInCup();        // 步骤四：加入调味料        if (isCustomerWantsCondiments()) {            addCondiments();        }    }    // hook方法（钩子函数）提供一个默认或空的实现，具体的子类可以自行决定是否挂钩以及如何挂钩    // 询问用户是否加入调料    protected boolean isCustomerWantsCondiments() {        return true;// 默认需要加入调味料    }    // 基本方法，将水煮沸    protected void boilWater() {        System.out.println(&quot;将水煮沸&quot;);    }    // 抽象的基本方法，泡制饮料    protected abstract void brew();    // 基本方法，将饮料倒入杯中    private void pourInCup() {        System.out.println(&quot;将饮料倒入杯中&quot;);    }    // 抽象的基本方法，加入调味料    protected abstract void addCondiments();}</code></pre></li><li><p>具体子类，提供了制备茶的具体实现</p><pre><code class="java">public class Tea extends RefreshBeverage {    // 子类通过覆盖的形式选择挂载钩子函数    @Override    protected boolean isCustomerWantsCondiments() {        return false;    }    @Override    protected void brew() {        System.out.println(&quot;用80度的热水浸泡茶叶5分钟&quot;);    }    @Override    protected void addCondiments() {        System.out.println(&quot;加入柠檬&quot;);    }}</code></pre></li></ol><h2 id="第3章-模板方法模式总结"><a href="#第3章-模板方法模式总结" class="headerlink" title="第3章 模板方法模式总结"></a>第3章 模板方法模式总结</h2><blockquote><p>本章总结了模板方法模式的实现要素，介绍了模板方法模式在行业中的应用案例。</p></blockquote><h3 id="3-1-模板方法模式总结-10-12"><a href="#3-1-模板方法模式总结-10-12" class="headerlink" title="3-1 模板方法模式总结 (10:12)"></a>3-1 模板方法模式总结 (10:12)</h3><p>模板方法模式的实现要素分析</p><blockquote><p>抽象基类</p><ol><li><p>基本方法：对各种具体子类而言是相同，具有共性的步骤</p></li><li><p>抽象方法：只知道具体原则，而不知道实现细节，需要延迟到子类实现的步骤</p></li><li><p>钩子方法：在基类中提供了一个默认或空的实现，子类可通过覆盖的形式选择挂载钩子函数</p></li><li><p>模板方法：Template方法（final），将基本方法、抽象方法、钩子方法按照业务逻辑的要求，汇总而成一个模板方法。<br>一定要声明为final，以防止被子类复写。子类可替换父类中的可变逻辑，但不能改变整体逻辑结构</p></li></ol><p>具体子类</p><ol><li>实现基类中的抽象方法：以提供个性化的、具体的、独特的实现</li><li>覆盖钩子方法：更加个性化的影响模板方法局部的行为</li></ol></blockquote><p>模板方法模式的实现要素</p><blockquote><p>准备一个抽象类，将部分逻辑以具体方法的形式实现，然后声明一些抽象方法交由子类实现剩余逻辑，用钩子方法给与子类更大的灵活性。最后将方法汇总构成一个不可改变的模板方法。</p></blockquote><p>模板方法模式的适用场景</p><blockquote><ol><li>算法或操作遵循相似的逻辑</li><li>重构时（把相同的代码抽取到父类中）</li><li>重要、复杂的算法，核心算法设计为模板算法</li></ol></blockquote><p>模板方法模式的优点</p><blockquote><p>封装性好：封装了一个算法的框架，将算法的具体步骤封装成一个通用的模板方法<br>复用性好：抽取共性的方式，大部分代码在父类实现，个性化逻辑由子类实现<br>屏蔽细节：很多共性作为私有方法在抽象基类中实现，对子类屏蔽了很多细节<br>便于维护：好的复用性可以减少代码框架的设计，支持更好灵活的业务变更</p></blockquote><p>模板方法模式的缺点</p><blockquote><p>Java单继承。一个类只能继承于一个父类<br>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大</p></blockquote><h3 id="3-2-行业案例分享-03-34"><a href="#3-2-行业案例分享-03-34" class="headerlink" title="3-2 行业案例分享 (03:34)"></a>3-2 行业案例分享 (03:34)</h3><p>大型系统的日志分析处理</p><ul><li><p>种类繁多数据巨大的日志</p></li><li><p>抽取共性</p></li><li><p>获得规律</p><ol><li>获得文件：抽象基类</li><li>打开文件：抽象基类</li><li>读取日志结构：抽象基类</li><li><em>处理单行日志</em>：个性化需求，延迟到子类实现</li><li>清理工作：抽象基类</li></ol><p>钩子函数：<code>beforeProcessOneFile();</code>、<code>afterProcessOneFile();</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>165-模式的秘密---策略模式</title>
      <link href="/imooc/165-strategy-mode/"/>
      <url>/imooc/165-strategy-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="http://www.imooc.com/learn/165" target="_blank" rel="noopener">http://www.imooc.com/learn/165</a></p><p>简介：策略模式是在日常开发中使用最为广泛的设计模式之一。在本视频中，@Arthur 将用简单生动的例子带你领略策略模式的真意、如何用 Java 语言实现策略模式、最后还将用实际的行业案例告诉你策略模式的强大功能。小伙伴们，还等什么呢，快来加入学习吧！！</p></blockquote><p>@[TOC]</p><h2 id="第1章-引子：什么是策略模式"><a href="#第1章-引子：什么是策略模式" class="headerlink" title="第1章 引子：什么是策略模式"></a>第1章 引子：什么是策略模式</h2><blockquote><p>本章通过分析字处理软件处理排版和在线购物支付的场景，引入策略模式的概念。针对概念设计了一个虚拟的应用，分析应用需求。</p></blockquote><h3 id="1-1-策略模式简介-06-27"><a href="#1-1-策略模式简介-06-27" class="headerlink" title="1-1 策略模式简介 (06:27)"></a>1-1 策略模式简介 (06:27)</h3><p>课程大纲</p><blockquote><p>什么是策略模式<br>策略模式如何实现<br>策略模式总结篇：适用场景、优缺点<br>实例案例分享</p></blockquote><p>日常生活中的策略</p><blockquote><p>Word文档中的排版布局方式<br>购物支付过程中选择支付渠道</p></blockquote><p>案例示意图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadlrfqla3j319i0pknmh.jpg" alt="案例示意图" style="zoom:35%;" /><p>策略模式的定义</p><blockquote><p>策略模式将可变的部分从程序中抽象分离成算法接口，在该接口下分别封装一系列算法实现，并使他们可以相互替换，从而导致客户端程序独立于算法的改变。</p></blockquote><h2 id="第2章-光荣与梦想——鸭子应用：策略模式的实现"><a href="#第2章-光荣与梦想——鸭子应用：策略模式的实现" class="headerlink" title="第2章 光荣与梦想——鸭子应用：策略模式的实现"></a>第2章 光荣与梦想——鸭子应用：策略模式的实现</h2><blockquote><p>通过代码的编写，剖析策略模式的实现</p></blockquote><h3 id="2-1-光荣与梦想：模拟应用背景介绍-02-49"><a href="#2-1-光荣与梦想：模拟应用背景介绍-02-49" class="headerlink" title="2-1 光荣与梦想：模拟应用背景介绍 (02:49)"></a>2-1 光荣与梦想：模拟应用背景介绍 (02:49)</h3><p>模拟应用背景</p><blockquote><p>通过代码来实现策略模式，通过开发与重构虚拟应用。使用策略模式实现：在不变更代码框架的前提下，通过开发与重构，使用策略模式，不断拥抱需求的变化，从而满足客户需求</p></blockquote><p>项目背景：鸭子应用</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadlyz4j7yj31dy0kpk8w.jpg" alt="项目背景：鸭子应用" style="zoom:30%;" /><h3 id="2-2-求索之路：鸭子如何才能飞-07-05"><a href="#2-2-求索之路：鸭子如何才能飞-07-05" class="headerlink" title="2-2 求索之路：鸭子如何才能飞 (07:05)"></a>2-2 求索之路：鸭子如何才能飞 (07:05)</h3><blockquote><p>原有功能</p></blockquote><p>代码编写</p><ol><li><p>超类，所有的鸭子都要继承此类。抽象了鸭子的行为：显示和鸣叫</p><pre><code class="java">public abstract class Duck {    // 鸭子发出叫声。通用行为，由超类实现    public void quack() {        System.out.println(&quot;嘎嘎嘎...&quot;);    }    // 显示鸭子的外观。鸭子的外观各不相同，声明为abstract，由子类实现    public abstract void display();}</code></pre></li><li><p>绿头鸭</p><pre><code class="java">public class MallardDuck extends Duck {    @Override    public void display() {        System.out.println(&quot;我的头是绿色的&quot;);    }}</code></pre></li><li><p>红头鸭</p><pre><code class="java">public class RedHeadDuck extends Duck {    @Override    public void display() {        System.out.println(&quot;我的头是红色的&quot;);    }}</code></pre></li></ol><h3 id="2-3-柳暗花明：策略让鸭子飞上天-07-13"><a href="#2-3-柳暗花明：策略让鸭子飞上天-07-13" class="headerlink" title="2-3 柳暗花明：策略让鸭子飞上天 (07:13)"></a>2-3 柳暗花明：策略让鸭子飞上天 (07:13)</h3><p>什么是组合</p><blockquote><p><strong>在类中增加一个私有域，引用另一个已有的类的实例，通过调用引用实例的方法从而获得新的功能，这种设计被称作组合（或复合）</strong></p></blockquote><p>在原有功能的基础上新增飞行的功能</p><ol><li><p>继承。在父类中提供实现方法，子类通过继承获得父类中的飞行行为</p><pre><code class="java">public void fly(){    System.out.println(&quot;用翅膀飞行&quot;);}</code></pre><p>优点：简单易用，已有应用可以快速添加飞行的能力</p><p>缺点：粗暴丑陋，不具有灵活性，对未来变更支持差</p></li><li><p>抽象方法。在父类中提供抽象方法，强迫子类是自己的飞行行为</p><pre><code class="java">public abstract void fly();</code></pre><p>优点：足够灵活。不会忘记复写代码</p><p>缺点：每个子类都要实现一遍代码，即使是相同的行为也不例外。代码重复，没有复用代码。如果有一个BUG，修改相当麻烦。</p><p><strong>继承是重用代码的利器，但继承并不总是最好的工具</strong></p></li><li><p>组合。将飞行行为抽象为接口，在父类中持有该接口，并由该接口代理飞行行为</p><pre><code class="java">public interface FlyingStrategy {    void performFly();}</code></pre><pre><code class="java">private FlyingStrategy flyingStrategy;public void fly() {    flyingStrategy.performFly();}</code></pre><p>优点：足够灵活。复用代码，更易于维护</p><p>缺点：策略类会增多，所有策略类都需要对外暴露</p><p>Favor composition over inheritance<br><strong>复合优先于继承</strong>/<strong>多用组合，少用继承</strong></p></li></ol><h3 id="2-4-脚踏实地：用代码放飞鸭子-07-00"><a href="#2-4-脚踏实地：用代码放飞鸭子-07-00" class="headerlink" title="2-4 脚踏实地：用代码放飞鸭子 (07:00)"></a>2-4 脚踏实地：用代码放飞鸭子 (07:00)</h3><blockquote><p>添加策略接口，实现鸭子飞行</p></blockquote><p>代码编写</p><ol><li><p>策略接口，实现鸭子的飞行行为</p><pre><code class="java">public interface FlyingStrategy {    // 飞行行为的方法    void performFly();}</code></pre></li><li><p>实现鸭子的飞行行为，用翅膀飞行的类</p><pre><code class="java">public class FlyWithWin implements FlyingStrategy {    @Override    public void performFly() {        System.out.println(&quot;振翅高飞&quot;);    }}</code></pre></li><li><p>超类，所有的鸭子都要继承此类。抽象了鸭子的行为：显示和鸣叫</p><pre><code class="java">@Datapublic abstract class Duck {    // 鸭子发出叫声，通用行为，由超类实现    public void quack() {        System.out.println(&quot;嘎嘎嘎...&quot;);    }    // 显示鸭子的外观，鸭子的外观各不相同，声明为abstract，由子类实现    public abstract void display();    /*=====新增代码实现飞行功能=====*/    // 组合进飞行的策略接口    private FlyingStrategy flyingStrategy;    // 鸭子的飞行功能    public void fly() {        // 由飞行策略接口执行飞行的动作        flyingStrategy.performFly();    }}</code></pre></li><li><p>绿头鸭。传入飞行策略</p><pre><code class="java">public class MallardDuck extends Duck {    public MallardDuck() {        super.setFlyingStrategy(new FlyWithWin());    }    @Override    public void display() {        System.out.println(&quot;我的头是绿色的&quot;);    }}</code></pre></li><li><p>红头鸭。传入飞行策略</p><pre><code class="java">public class RedHeadDuck extends Duck {    public RedHeadDuck() {        super.setFlyingStrategy(new FlyWithWin());    }    @Override    public void display() {        System.out.println(&quot;我的头是红色的&quot;);    }}</code></pre></li><li><p>测试类</p><pre><code class="java">public class DuckTest {    public static void main(String[] args) {        // Duck duck = new MallardDuck();        // Duck duck = new RedHeadDuck();        Duck duck = new SpaceDuck();        duck.display();        duck.quack();        duck.fly();    }}</code></pre></li></ol><h3 id="2-5-拥抱变化：用策略模式提供高复用性代码-06-53"><a href="#2-5-拥抱变化：用策略模式提供高复用性代码-06-53" class="headerlink" title="2-5 拥抱变化：用策略模式提供高复用性代码 (06:53)"></a>2-5 拥抱变化：用策略模式提供高复用性代码 (06:53)</h3><blockquote><p>复用代码，新增策略方式</p></blockquote><p>业务场景</p><blockquote><p>需要增加橡胶鸭、大黄鸭，它们都有一个共同的特点，不会飞行。<br>不会飞也是一种飞行行为，所以可以通过良好的抽象复用代码</p></blockquote><p>代码编写</p><ol><li><p>实现鸭子的飞行行为，不会飞行的策略类</p><pre><code class="java">public class FlyNoWay implements FlyingStrategy {    @Override    public void performFly() {        System.out.println(&quot;我不会飞行！&quot;);    }}</code></pre></li><li><p>橡胶鸭</p><pre><code class="java">public class RubberDuck extends Duck {    public RubberDuck() {        super.setFlyingStrategy(new FlyNoWay());    }    @Override    public void display() {        System.out.println(&quot;我全身发黄，嘴巴很红&quot;);    }    @Override    public void quack() {        System.out.println(&quot;嘎~嘎~嘎~&quot;);    }}</code></pre></li><li><p>大黄鸭</p><pre><code class="java">public class BigYellowDuck extends Duck {    public BigYellowDuck() {        super.setFlyingStrategy(new FlyNoWay());    }    @Override    public void display() {        System.out.println(&quot;我身体很大，全身黄黄&quot;);    }}</code></pre></li><li><p>测试类</p><pre><code class="java">public class DuckTest {    public static void main(String[] args) {        // Duck duck = new RubberDuck();        Duck duck = new BigYellowDuck();        duck.display();        duck.quack();        duck.fly();    }}</code></pre></li></ol><h3 id="2-6-万变不离其宗：向宇宙进军-04-33"><a href="#2-6-万变不离其宗：向宇宙进军-04-33" class="headerlink" title="2-6 万变不离其宗：向宇宙进军 (04:33)"></a>2-6 万变不离其宗：向宇宙进军 (04:33)</h3><blockquote><p> 新增策略方式</p></blockquote><p>业务场景</p><blockquote><p>现在又需增加太空鸭，太空鸭不能自己飞行，需要借助先进的科学技术。</p></blockquote><p>代码编写</p><ol><li><p>实现鸭子的飞行行为，使用火箭飞行策略类</p><pre><code class="java">public class FlyWithRocket implements FlyingStrategy {    @Override    public void performFly() {        System.out.println(&quot;用火箭在太空遨游&quot;);    }}</code></pre></li><li><p>太空鸭</p><pre><code class="java">public class SpaceDuck extends Duck {    public SpaceDuck() {        super();        super.setFlyingStrategy(new FlyWithRocket());    }    @Override    public void display() {        System.out.println(&quot;我头戴宇航盔&quot;);    }    @Override    public void quack() {        System.out.println(&quot;我通过无线电与你通信&quot;);    }}</code></pre></li><li><p>测试类</p><pre><code class="java">public class DuckTest {    public static void main(String[] args) {        Duck duck = null;        duck = new SpaceDuck();        duck.display();        duck.quack();        duck.fly();    }}</code></pre></li></ol><h2 id="第3章-总结篇"><a href="#第3章-总结篇" class="headerlink" title="第3章 总结篇"></a>第3章 总结篇</h2><blockquote><p>本章在概念引入和代码实战的基础上，结合代码中的细节总结了策略模实现要素，适用场景，优缺点。最后通过一个行业案例分享，介绍了实际工作中的策略模式应用。</p></blockquote><h3 id="3-1-知识点总结-06-37"><a href="#3-1-知识点总结-06-37" class="headerlink" title="3-1 知识点总结 (06:37)"></a>3-1 知识点总结 (06:37)</h3><p>策略模式中的设计原则</p><blockquote><p>找出应用中需要变化的部分，把他们独立出来，不要和那些不需要变化的代码混在一起<br>面向接口编程，而不是面向实现编程<br>多用组合，少用继承</p></blockquote><p>策略模式的实现</p><blockquote><p>通过分离变化得出的策略接口Strategy<br>Strategy接口的实现类<br>客户程序中有一个Strategy<br>在客户程序中选择和组装正确的Strategy实现类</p></blockquote><p>策略模式优点</p><blockquote><p>使用了组合，使架构更加灵活<br>富有弹性，可以较好的应对变化（开闭原则）<br>更好的代码复用性（相对于继承）<br>消除大量的条件语句</p></blockquote><p>策略模式缺点</p><blockquote><p>客户代码需要了解每个策略实现的细节<br>增加了对象的数目</p></blockquote><p>策略模式的适用场景</p><blockquote><p>许多相关的类仅仅是行为差异<br>运行时选取不同的算法变体<br>通过条件语句在多个分支中选择其中一个</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>257-模式的秘密---责任链模式</title>
      <link href="/imooc/257-responsibility-mode/"/>
      <url>/imooc/257-responsibility-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="http://www.imooc.com/learn/257" target="_blank" rel="noopener">http://www.imooc.com/learn/257</a></p><p>简介：责任链模式在我们日常开发工作中随处可见，但却并不一定唯你所熟知。通过本视频，你可以了解什么是责任链模式，如何用 Java 语言实现策略模式。 作者将用简单生动的例子带你认识责任链模式的，通过学习，理解模式学习的要义。</p></blockquote><p>@[TOC]</p><h2 id="第1章-什么是责任链模式"><a href="#第1章-什么是责任链模式" class="headerlink" title="第1章 什么是责任链模式"></a>第1章 什么是责任链模式</h2><blockquote><p>本章通过分析击鼓传花和购房折扣申请场景，引入责任链模式的概念。针对概念设计了一个虚拟的应用，分析应用需求。</p></blockquote><h3 id="1-1-什么是责任链模式-10-12"><a href="#1-1-什么是责任链模式-10-12" class="headerlink" title="1-1 什么是责任链模式 (10:12)"></a>1-1 什么是责任链模式 (10:12)</h3><p>课程大纲</p><blockquote><p>什么是责任链模式<br>如何实现责任链模式<br>责任链模式如何解耦<br>责任链模式的应用</p></blockquote><p>案例：售楼案例</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacg5tmqv7j310m0ew43e.jpg" alt="案例：售楼案例" style="zoom:35%;" /><p>责任链模式定义</p><blockquote><p>责任链模式将接收者对象连成一条链，并在该链上传递请求，直到有一个接收者对象处理它。通过让更多对象有机会处理请求，避免请求发送者和接收者之间的耦合。</p></blockquote><p>责任链模式类图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacg7av0mhj30uc0fg0vb.jpg" alt="责任链模式类图" style="zoom:45%;" /><blockquote><p>在责任链模式中，作为请求接收者的多个对象通过对其后继的引用而连接起来形成一条链。请求在这条链上传递，直到链上某一个接收者处理这个请求。每个接收者都可以选择自行处理请求或是向后继传递请求。</p></blockquote><h2 id="第2章-有求必应的销售队伍：怎样实现责任链模式"><a href="#第2章-有求必应的销售队伍：怎样实现责任链模式" class="headerlink" title="第2章 有求必应的销售队伍：怎样实现责任链模式"></a>第2章 有求必应的销售队伍：怎样实现责任链模式</h2><blockquote><p>通过代码的编写责任链模式的实现</p></blockquote><h3 id="2-1-有求必应的销售团队-08-33"><a href="#2-1-有求必应的销售团队-08-33" class="headerlink" title="2-1 有求必应的销售团队 (08:33)"></a>2-1 有求必应的销售团队 (08:33)</h3><p>不同的角色拥有不同的折扣权限</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacgbaggkqj30wu0e6agx.jpg" alt="不同的角色拥有不同的折扣权限" style="zoom:40%;" /><p>代码编写</p><ol><li><p>价格处理人，负责处理客户折扣申请</p><pre><code class="java">@Datapublic abstract class PriceHandler {    // 责任链的直接后继，用于传递请求    protected PriceHandler successor;    // 处理折扣申请    public abstract void processDiscount(float discount);    // 创建PriceHandler的工厂方法    public static PriceHandler createPriceHandler() {        // 创建对象        PriceHandler sales = new Sales();        PriceHandler manager = new Manager();        PriceHandler director = new Director();        PriceHandler vp = new VicePresident();        PriceHandler ceo = new CEO();        // 指定直接后继        sales.setSuccessor(manager);        manager.setSuccessor(director);        director.setSuccessor(vp);        vp.setSuccessor(ceo);        // 返回销售人员        return sales;    }}</code></pre></li><li><p>销售，可以批准5%以内的折扣</p><pre><code class="java">public class Sales extends PriceHandler {    @Override    public void processDiscount(float discount) {        if (discount &lt;= 0.05) {            System.out.format(&quot;%s批准了折扣：%.2f%n&quot;, this.getClass().getName(), discount);        } else {            successor.processDiscount(discount);        }    }}</code></pre></li><li><p>销售经理，可以批准30%以内的折扣</p><pre><code class="java">public class Manager extends PriceHandler {    @Override    public void processDiscount(float discount) {        if (discount &lt;= 0.3) {            System.out.format(&quot;%s批准了折扣：%.2f%n&quot;, this.getClass().getName(), discount);        } else {            successor.processDiscount(discount);        }    }}</code></pre></li><li><p>销售总监，可以批准40%以内的折扣</p><pre><code class="java">public class Director extends PriceHandler {    @Override    public void processDiscount(float discount) {        if (discount &lt;= 0.4) {            System.out.format(&quot;%s批准了折扣：%.2f%n&quot;, this.getClass().getName(), discount);        } else {            successor.processDiscount(discount);        }    }}</code></pre></li><li><p>销售副总裁，可以批准50%以内的折扣</p><pre><code class="java">public class VicePresident extends PriceHandler {    @Override    public void processDiscount(float discount) {        if (discount &lt;= 0.5) {            System.out.format(&quot;%s批准了折扣：%.2f%n&quot;, this.getClass().getName(), discount);        } else {            successor.processDiscount(discount);        }    }}</code></pre></li><li><p>CEO，可以批准55%以内的折扣。折扣超过55%就拒绝申请</p><pre><code class="java">public class CEO extends PriceHandler {    @Override    public void processDiscount(float discount) {        if (discount &lt;= 0.55) {            System.out.format(&quot;%s批准了折扣：%.2f%n&quot;, this.getClass().getName(), discount);        } else {            System.out.format(&quot;%s拒绝了折扣：%.2f%n&quot;, this.getClass().getName(), discount);        }    }}</code></pre></li></ol><h3 id="2-2-千姿百态的客户请求-10-43"><a href="#2-2-千姿百态的客户请求-10-43" class="headerlink" title="2-2 千姿百态的客户请求 (10:43)"></a>2-2 千姿百态的客户请求 (10:43)</h3><ol><li><p>客户，请求折扣</p><pre><code class="java">@Datapublic class Customer {    private PriceHandler priceHandler;    public void requestDiscount(float discount) {        priceHandler.processDiscount(discount);    }}</code></pre></li><li><p>测试类，客户发起折扣请求</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Customer customer = new Customer();        customer.setPriceHandler(PriceHandler.createPriceHandler());        Random random = new Random();        IntStream.rangeClosed(1, 100).forEach(i -&gt; {            System.out.print(i + &quot;:&quot;);            customer.requestDiscount(random.nextFloat());        });    }}</code></pre></li></ol><h3 id="2-3-不管怎么变折扣你得批-08-33"><a href="#2-3-不管怎么变折扣你得批-08-33" class="headerlink" title="2-3 不管怎么变折扣你得批 (08:33)"></a>2-3 不管怎么变折扣你得批 (08:33)</h3><blockquote><p>向责任链中添加新的处理对象</p></blockquote><p>代码编写</p><ol><li><p>销售小组长，可以批准15%以内的折扣</p><pre><code class="java">public class Lead extends PriceHandler {    @Override    public void processDiscount(float discount) {        if (discount &lt;= 0.15) {            System.out.format(&quot;%s批准了折扣：%.2f%n&quot;, this.getClass().getName(), discount);        } else {            successor.processDiscount(discount);        }    }}</code></pre></li><li><p>创建PriceHandler的工厂类</p><p>工厂方法的实质不在于它的传入参数，而在于它的返回结果。从行为上返回一个抽象的对象，而非一个具体的对象。</p><pre><code class="java">public class PriceHandlerFactory {    public static PriceHandler createPriceHandler() {        // 创建对象        PriceHandler sales = new Sales();        PriceHandler lead = new Lead();        PriceHandler manager = new Manager();        PriceHandler director = new Director();        PriceHandler vp = new VicePresident();        PriceHandler ceo = new CEO();        // 指定直接后继        sales.setSuccessor(lead);        lead.setSuccessor(manager);        manager.setSuccessor(director);        director.setSuccessor(vp);        vp.setSuccessor(ceo);        // 返回销售人员        return sales;    }}</code></pre></li><li><p>测试类，客户发起折扣请求</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Customer customer = new Customer();        customer.setPriceHandler(PriceHandlerFactory.createPriceHandler());        Random random = new Random();        IntStream.rangeClosed(1, 100).forEach(i -&gt; {            System.out.print(i + &quot;:&quot;);            customer.requestDiscount(random.nextFloat());        });    }}</code></pre></li></ol><p>扩展：OO设计原则</p><h2 id="第3章-剖析责任链模式"><a href="#第3章-剖析责任链模式" class="headerlink" title="第3章 剖析责任链模式"></a>第3章 剖析责任链模式</h2><blockquote><p>本章在概念引入和代码实战的基础上，剖析责任链的特点，分析责任链如何实现解耦。</p></blockquote><h3 id="3-1-剖析责任链模式-08-08"><a href="#3-1-剖析责任链模式-08-08" class="headerlink" title="3-1 剖析责任链模式 (08:08)"></a>3-1 剖析责任链模式 (08:08)</h3><p>利于解耦</p><blockquote><p>发出请求的客户端并不知道链上的哪一个接收者会处理这个请求，从而实现了客户端和接收者之间的解耦。</p></blockquote><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gachln072nj30js09mabb.jpg" alt="责任链模式" style="zoom:50%;" /><p>责任链模式缺点</p><blockquote><ol><li>时间：在单个Handler对象的时间很短，但是在遍历整条链时会花费较长的时间</li><li>内存：在创建整条链时，会创建很多类，导致内存增加，成为性能衰减点。</li></ol></blockquote><h2 id="第4章-责任链模式的实际应用"><a href="#第4章-责任链模式的实际应用" class="headerlink" title="第4章 责任链模式的实际应用"></a>第4章 责任链模式的实际应用</h2><blockquote><p>介绍责任链模式在实际中的使用情况</p></blockquote><h3 id="4-1-责任链模式的应用-06-46"><a href="#4-1-责任链模式的应用-06-46" class="headerlink" title="4-1 责任链模式的应用 (06:46)"></a>4-1 责任链模式的应用 (06:46)</h3><ol><li><p>Java的异常机制：Exception Handing</p><blockquote><p>异常是请求，调用栈中的每一级是一个Handler，这些栈中Handler共同构建成一个责任链，栈顶元素就是上一级元素的直接后继</p></blockquote><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gachwvq1raj30ou0bwgqc.jpg" alt="Java的异常机制" style="zoom:50%;" /></li><li><p>JavaScript的事件模型：JavaScript Event Model</p><blockquote><p>每一个dom节点都是一个Handler，当点击<code>&lt;td&gt;</code>节点时，它所对应的父节点就是该Handler的直接后继，这个Handler可以选择在自己的层级处理掉点击事件，也可以选择不处理，直接向后继传递</p></blockquote><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaci0b82oqj30mk0gedm4.jpg" alt="JavaScript的事件模型" style="zoom:50%;" /></li><li><p>JavaWeb开发过滤器链：FilterChain in Web</p><p>如：编码Filter</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaci2t2rvsj30qe0aegn7.jpg" alt="编码Filter" style="zoom:35%;" /><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaci3ny42nj30gy0ckwhc.jpg" alt="FilterChain in Web" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaci6jdsoej30q209g76i.jpg" alt="FilterChain in Web" style="zoom:50%;" /><p>在<code>doFilter()</code>方法尾部调用<code>filterChain.doFilter()</code>，将request对象向下传递，避免链条中断。</p></li><li><p>Spring Security安全框架</p><p>在Spring Security中通过很多Filter类构成了一条链条来处理HTTP请求，从而为应用提供了认证与授权的服务</p></li></ol><p>一点体会</p><blockquote><p>将设计模式的思想与OO（Object Oriented）原则相关联<br>在设计模式中发现OO原则可以加深理解和记忆<br>最重要的是要去<strong>理解模式如何使我们去应对变化</strong><br>如何让我们能够用一种抽象的方式来编程</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ORACLE分页查询SQL语句</title>
      <link href="/sql/paging-query-sql/"/>
      <url>/sql/paging-query-sql/</url>
      
        <content type="html"><![CDATA[<ol><li><p>无ORDER BY排序的写法。(效率最高)</p><blockquote><p>经过测试，此方法成本最低，只嵌套一层，速度最快！即使查询的数据量再大，也几乎不受影响，速度依然！</p></blockquote><pre><code class="sql">SELECT *FROM (SELECT ROWNUM AS rowno, t.*      FROM emp t      WHERE hire_date BETWEEN TO_DATE (&#39;20060501&#39;, &#39;yyyymmdd&#39;)                      AND TO_DATE (&#39;20060731&#39;, &#39;yyyymmdd&#39;)      AND ROWNUM &lt;= 20) table_aliasWHERE table_alias.rowno &gt;= 10;</code></pre></li><li><p>有ORDER BY排序的写法。(效率较高)</p><blockquote><p>(经过测试，此方法随着查询范围的扩大，速度也会越来越慢哦！)</p></blockquote><pre><code class="sql">SELECT *FROM (SELECT tt.*, ROWNUM AS rowno      FROM (SELECT t.*            FROM emp t            WHERE hire_date BETWEEN TO_DATE (&#39;20060501&#39;, &#39;yyyymmdd&#39;)                            AND TO_DATE (&#39;20060731&#39;, &#39;yyyymmdd&#39;)            ORDER BY create_time DESC, emp_no) tt         ) table_aliasWHERE table_alias.rowno &gt;= 10AND table_alias.rowno &lt;= 20;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>415-观察者模式</title>
      <link href="/imooc/415-observer-mode/"/>
      <url>/imooc/415-observer-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="http://www.imooc.com/learn/415" target="_blank" rel="noopener">http://www.imooc.com/learn/415</a></p><p>简介：本课程通过一个天气预报的发布和订阅案例，来讲解观察者模式在Java项目中的应用。主要包括观察者模式的结构，观察者模式的两种实现方式推模型和拉模型，以及何时使用观察者模式等内容。</p></blockquote><p>@[TOC]</p><h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h2><blockquote><p>本章首先介绍了课程的学习内容和观察者的概念，然后介绍了一个应用观察者模式的场景，该场景将作为案例贯穿整个课程。</p></blockquote><h3 id="1-1-课程简介-07-29"><a href="#1-1-课程简介-07-29" class="headerlink" title="1-1 课程简介 (07:29)"></a>1-1 课程简介 (07:29)</h3><p>观察者模式的定义</p><blockquote><p>定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><p>案例流程图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5usfsg9uj30xq0h8k0e.jpg" alt="观察者模式流程图" style="zoom:35%;" /><h2 id="第2章-观察者模式实战"><a href="#第2章-观察者模式实战" class="headerlink" title="第2章 观察者模式实战"></a>第2章 观察者模式实战</h2><blockquote><p>本章介绍观察者模式的结构，以及如何用通用代码实现第一章给出的场景问题。</p></blockquote><h3 id="2-1-观察者模式的结构和说明-02-00"><a href="#2-1-观察者模式的结构和说明-02-00" class="headerlink" title="2-1 观察者模式的结构和说明 (02:00)"></a>2-1 观察者模式的结构和说明 (02:00)</h3><p>观察者模式结构</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5uyn7ge2j312w09qgrf.jpg" alt="观察者模式结构" style="zoom:35%;" /><p>观察者模式类图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5uzsfjttj30pc0fwjyz.jpg" alt="观察者模式类图" style="zoom:40%;" /><p>ConcreteSubject是Subject接口的实现类<br>ConcreteObserver是Observer接口的实现类</p><h3 id="2-2-学习观察者模式通用代码-14-25"><a href="#2-2-学习观察者模式通用代码-14-25" class="headerlink" title="2-2 学习观察者模式通用代码 (14:25)"></a>2-2 学习观察者模式通用代码 (14:25)</h3><p>实现步骤</p><blockquote><ol><li>目标对象的定义</li><li>具体的目标对象的定义</li><li>观察者的接口定义</li><li>观察者的具体实现</li></ol></blockquote><p>代码编写：</p><ol><li><p>目标类，目标对象Subject.java</p><blockquote><p>它知道观察它的观察者，并提供注册（添加）和删除观察者的接口</p></blockquote><pre><code class="java">public class Subject {    // 用来保存注册的观察者对象    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();    // 增加观察者    public void attach(Observer observer) {        observers.add(observer);    }    // 删除集合中指定的观察者    public void detach(Observer observer) {        observers.remove(observer);    }    // 通知所有注册的观察者对象    protected void notifyObserver() {        observers.forEach(observer -&gt; observer.update(this));    }}</code></pre></li><li><p>观察者接口Observer.java</p><blockquote><p>定义一个更新的接口给那些在目标对象发生改变的时候被通知的对象</p></blockquote><pre><code class="java">public interface Observer {    /**     * 更新的接口     *     * @param subject 传入的目标对象，方便获取相应的目标对象的状态     */    void update(Subject subject);}</code></pre></li><li><p>具体的目标对象ConcreteSubject.java</p><blockquote><p>负责把有关状态存入到相应的观察者对象中</p></blockquote><pre><code class="java">@Getterpublic class ConcreteSubject extends Subject {    // 目标对象的状态    private String subjectState;    public void setSubjectState(String subjectState) {        this.subjectState = subjectState;        // 当状态发生改变时，通知观察者        this.notifyObserver();    }}</code></pre></li><li><p>具体的观察者对象ConcreteObserver.java</p><blockquote><p>实现更新的方法，使自身的状态和目标的状态保持一致</p></blockquote><pre><code class="java">@Getterpublic class ConcreteObserver implements Observer {    // 观察者的状态    private String observerState;    /**     * 获取目标类的状态，同步到观察者的状态中     *     * @param subject 传入的目标对象，方便获取相应的目标对象的状态     */    @Override    public void update(Subject subject) {        observerState = ((ConcreteSubject) subject).getSubjectState();    }}</code></pre></li></ol><h3 id="2-3-改造通用代码解决场景问题-18-14"><a href="#2-3-改造通用代码解决场景问题-18-14" class="headerlink" title="2-3 改造通用代码解决场景问题 (18:14)"></a>2-3 改造通用代码解决场景问题 (18:14)</h3><blockquote><p>订阅天气</p></blockquote><p>代码编写：</p><ol><li><p>管理订阅者列表WeatherSubject.java</p><pre><code class="java">public class WeatherSubject {    // 订阅者列表    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();    // 把订阅天气的人增加到订阅者列表中    public void attach(Observer observer) {        observers.add(observer);    }    // 删除集合中的指定订阅天气的人    public void detach(Observer observer) {        observers.remove(observer);    }    // 通知所有已经订阅天气的人    protected void notifyObserver() {        observers.forEach(observer -&gt; observer.update(this));    }}</code></pre></li><li><p>观察者接口Observer.java</p><blockquote><p>定义一个更新的接口，给那些在目标对象发生改变的时候被通知的对象</p></blockquote><pre><code class="java">public interface Observer {    /**     * 更新的接口     *     * @param subject 传入的目标对象，方便获取相应的目标对象的状态     */    void update(WeatherSubject subject);}</code></pre></li><li><p>具体的目标对象ConcreteWeatherSubject.java</p><blockquote><p>负责把有关状态存入到相应的观察者对象中</p></blockquote><pre><code class="java">@Getterpublic class ConcreteWeatherSubject extends WeatherSubject {    // 获取天气的内容信息    private String weatherContent;    public void setWeatherContent(String weatherContent) {        this.weatherContent = weatherContent;        // 内容有了，说明天气更新了，通知所有订阅的人        this.notifyObserver();    }}</code></pre></li><li><p>具体的观察者对象ConcreteObserver.java</p><blockquote><p>实现更新的方法，使自身的状态和目标的状态保持一致</p></blockquote><pre><code class="java">@Datapublic class ConcreteObserver implements Observer {    // 观察者的名称，是谁收到了这个信息    private String observerName;    // 天气的内容信息，这个消息从目标处获取    private String weatherContent;    // 提醒的内容，不同的观察者提醒不同的内容    private String remindThing;    /**     * 获取目标类的状态，同步到观察者的对象中     *     * @param subject 传入的目标对象，方便获取相应的目标对象的状态     */    @Override    public void update(WeatherSubject subject) {        this.weatherContent = ((ConcreteWeatherSubject) subject).getWeatherContent();        System.out.println(observerName + &quot;收到了天气信息：&quot; + weatherContent + &quot;，准备去做：&quot; + remindThing);    }}</code></pre></li><li><p>订阅天气-测试类Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        // 1. 创建目标        ConcreteWeatherSubject weather = new ConcreteWeatherSubject();        // 2. 创建观察者        ConcreteObserver girlObserver = new ConcreteObserver();        girlObserver.setObserverName(&quot;女朋友&quot;);        girlObserver.setRemindThing(&quot;约会&quot;);        ConcreteObserver mumObserver = new ConcreteObserver();        mumObserver.setObserverName(&quot;老妈&quot;);        mumObserver.setRemindThing(&quot;超市打折&quot;);        // 3. 注册观察者        weather.attach(girlObserver);        weather.attach(mumObserver);        // 4. 目标发布天气        weather.setWeatherContent(&quot;明天天气晴朗&quot;);    }}</code></pre></li></ol><h2 id="第3章-观察者模式详解"><a href="#第3章-观察者模式详解" class="headerlink" title="第3章 观察者模式详解"></a>第3章 观察者模式详解</h2><blockquote><p>本章主要介绍观察者模式实现的两种方式推模型和拉模型，利用Java提供的观察者实现第一章的场景问题，观察者模式的优缺点，以及何时使用观察者模式。</p></blockquote><h3 id="3-1-认识观察者模式-06-32"><a href="#3-1-认识观察者模式-06-32" class="headerlink" title="3-1 认识观察者模式 (06:32)"></a>3-1 认识观察者模式 (06:32)</h3><p>目标与观察者之间的关系</p><blockquote><p>一对多的关系<br>一对一的关系（如果观察者只有一个）<br>多对一的关系：如果目标有多个，即一个观察者订阅多个目标，此时不应该只使用一个update方法，应该一个目标对应一个update方法。</p></blockquote><p>单向依赖</p><blockquote><p>在观察者模式中，观察者和目标是单向依赖，只有观察者依赖目标，而不是目标依赖观察者。<br>主动权掌握在目标手中，只有目标知道什么时候需要通知观察者。</p></blockquote><p>命名建议</p><blockquote><p>观察者模式又被称为发布订阅模式<br>目标接口的定义，建议在名称后面跟Subject<br>观察者接口的定义，建议在名称后面跟Observer<br>观察者接口的更新方法，建议名称为update</p></blockquote><p>触发通知的时机</p><blockquote><p>一般情况下，是在完成了状态维护后触发。<br>因为通知会传递数据，不能先通知，后改数据，这会导致观察者和目标对象状态不一致。</p></blockquote><p>观察者模式的调用顺序示意图</p><ul><li><p>准备阶段</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5x8a3zbcj30q00fcaeb.jpg" alt="观察者模式的调用顺序示意图-准备阶段" style="zoom:40%;" /></li><li><p>运行阶段</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga5x9yj30xj30t80f0gpl.jpg" alt="观察者模式的调用顺序示意图-运行阶段" style="zoom:40%;" /></li></ul><p>通知的顺序</p><blockquote><p>从理论上来说，当目标对象的状态发生改变时，通知所有观察者的时候，顺序是不确定的。<br>因此，观察者实现的功能，绝对不能依赖于通知的顺序<br>也就是说，多个观察者之间的顺序是平行的，相互不应该有先后依赖的关系。</p></blockquote><h3 id="3-2-实现的两种方式：推模型和拉模型-07-50"><a href="#3-2-实现的两种方式：推模型和拉模型-07-50" class="headerlink" title="3-2 实现的两种方式：推模型和拉模型 (07:50)"></a>3-2 实现的两种方式：推模型和拉模型 (07:50)</h3><p>推模型</p><blockquote><p>目标对象主动向观察者推送目标的详细信息<br>推送的信息通常是目标对象的全部或部分数据<br>相当于在广播通讯</p></blockquote><p>拉模型（第二章的实现属于拉模型）</p><blockquote><p>目标对象在通知观察者的时候，只传递少量信息<br>如果观察者需要更具体的信息，由观察者主动到目标对象中获取<br>相当于是观察者从目标对象中拉数据<br>一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者</p></blockquote><p>两种模型的区别</p><blockquote><p>推模型是假定目标对象知道观察者需要的数据<br>推模型会使观察者对象难以复用。update方法是按需定制的，可能没有兼顾未考虑到的情况。</p><p>拉模型是目标对象不知道观察者具体需要什么数据，因此把自身传递给观察者，由观察者来取值<br>拉模型下，update方法的参数是目标对象本身，基本上可以适应各种情况的需要</p></blockquote><h3 id="3-3-利用Java提供的观察者实现-16-56"><a href="#3-3-利用Java提供的观察者实现-16-56" class="headerlink" title="3-3 利用Java提供的观察者实现 (16:56)"></a>3-3 利用Java提供的观察者实现 (16:56)</h3><p>Java实现与自己实现的对比</p><blockquote><ol><li>不需要再定义观察者和目标的接口，JDK已定义</li><li>具体的目标实现里面不需要再维护观察者的注册信息，JDK在Observable类里面已实现</li><li>触发通知的方式有一点变化，要先调用setChanged方法，这是为了实现更精确的触发控制</li><li>具体观察者的实现里面，update方法能<strong>同时支持</strong>推模型和拉模型</li></ol></blockquote><p>代码编写</p><blockquote><p>使用JDK实现观察者模式</p></blockquote><ol><li><p>天气目标具体实现类ConcreteWeatherSubject.java</p><pre><code class="java">@Getterpublic class ConcreteWeatherSubject extends Observable {    // 天气情况的内容    private String content;    public void setContent(String content) {        this.content = content;        // 天气情况有了，就要通知所有的观察者        // 在Java中使用Observer模式时，需要先调用setChanged方法        this.setChanged();        // 调用通知方法-推模型        this.notifyObservers(content);        // 调用通知方法-拉模型        /*this.notifyObservers();*/    }}</code></pre></li><li><p>具体的观察者对象ConcreteObserver.java</p><pre><code class="java">@Datapublic class ConcreteObserver implements Observer {    // 观察者的名称，是谁收到了这个信息    private String observerName;    @Override    public void update(Observable o, Object arg) {        // 推模型        System.out.println(observerName + &quot;收到了消息，目标对象推送过来的是：&quot; + arg);        // 拉模型        ConcreteWeatherSubject weatherSubject = (ConcreteWeatherSubject) o;        System.out.println(observerName + &quot;收到了消息，主动到目标对象中去拉：&quot; + weatherSubject.getContent());    }}</code></pre></li><li><p>订阅天气-测试类Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        // 1. 创建目标        ConcreteWeatherSubject weather = new ConcreteWeatherSubject();        // 2. 创建观察者        ConcreteObserver girlObserver = new ConcreteObserver();        girlObserver.setObserverName(&quot;女朋友&quot;);        ConcreteObserver mumObserver = new ConcreteObserver();        mumObserver.setObserverName(&quot;老妈&quot;);        // 3. 注册观察者        weather.addObserver(girlObserver);        weather.addObserver(mumObserver);        // 4. 目标发布天气        weather.setContent(&quot;明天天气晴朗&quot;);    }}</code></pre></li></ol><h3 id="3-4-观察者优缺点-03-46"><a href="#3-4-观察者优缺点-03-46" class="headerlink" title="3-4 观察者优缺点 (03:46)"></a>3-4 观察者优缺点 (03:46)</h3><p>优点</p><blockquote><p>观察者模式实现了观察者和目标之间的抽象耦合</p><p>观察者模式实现了动态联动（所谓联动是指做一个操作会引起其他相关的操作）</p><p>观察者模式支持广播通信</p></blockquote><p>缺点</p><blockquote><p>可能会引起无谓的操作</p></blockquote><h3 id="3-5-何时使用观察者模式-03-33"><a href="#3-5-何时使用观察者模式-03-33" class="headerlink" title="3-5 何时使用观察者模式 (03:33)"></a>3-5 何时使用观察者模式 (03:33)</h3><p>观察者模式的本质：<strong>触发联动</strong></p><p>建议在以下情况中选用观察者模式</p><blockquote><ol><li>当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化</li><li>如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变</li><li>当一个对象必须通知其他对象，但是又希望这个对象和被它通知的对象是松散耦合的</li></ol></blockquote><h2 id="第4章-观察者模式衍生"><a href="#第4章-观察者模式衍生" class="headerlink" title="第4章 观察者模式衍生"></a>第4章 观察者模式衍生</h2><blockquote><p>本章主要介绍如何区别对待观察者场景问题以及代码实现。</p></blockquote><h3 id="4-1-区别对待观察者场景问题-03-41"><a href="#4-1-区别对待观察者场景问题-03-41" class="headerlink" title="4-1 区别对待观察者场景问题 (03:41)"></a>4-1 区别对待观察者场景问题 (03:41)</h3><p>需求总结</p><blockquote><p>区别对待观察者<br>根据需要，不同的天气情况来通知不同的观察者</p><p>女朋友只想接收「下雨」的天气预报<br>老妈想要接收「下雨」或「下雪」的天气预报</p></blockquote><p>解决思路</p><blockquote><p>当天气更新时，在目标天气中进行判断，如果不符合观察者的条件，则不进行通知</p></blockquote><p>实现步骤</p><blockquote><ol><li>定义目标的抽象类和观察者的接口</li><li>实现目标的类和观察者接口</li><li>编写测试类进行测试</li></ol></blockquote><h3 id="4-2-代码示例解决场景问题-07-52"><a href="#4-2-代码示例解决场景问题-07-52" class="headerlink" title="4-2 代码示例解决场景问题 (07:52)"></a>4-2 代码示例解决场景问题 (07:52)</h3><ol><li><p>天气目标抽象类AbstractWeatherSubject.java</p><pre><code class="java">public abstract class AbstractWeatherSubject {    // 用来保存注册的观察者对象    protected List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();    // 增加观察者添加到订阅列表中    public void attach(Observer observer) {        observers.add(observer);    }    // 删除集合中指定的观察者    public void detach(Observer observer) {        observers.remove(observer);    }    // 区别通知观察者-由子类实现    protected abstract void notifyObservers();}</code></pre></li></ol><h3 id="4-3-观察者接口-01-38"><a href="#4-3-观察者接口-01-38" class="headerlink" title="4-3 观察者接口 (01:38)"></a>4-3 观察者接口 (01:38)</h3><ol start="2"><li><p>观察者接口</p><blockquote><p>定义一个更新的接口方法，给那些在目标对象发生改变的时候被通知的观察者对象调用</p></blockquote><pre><code class="java">public interface Observer {    /**     * 更新的接口     *     * @param weatherSubject 传入的目标对象，方便获取相应的目标对象的状态     */    void update(AbstractWeatherSubject weatherSubject);    // 获取观察者名称    String getObserverName();    // 设置观察者名称    void setObserverName(String observerName);}</code></pre></li></ol><h3 id="4-4-目标实现类-07-24"><a href="#4-4-目标实现类-07-24" class="headerlink" title="4-4 目标实现类 (07:24)"></a>4-4 目标实现类 (07:24)</h3><ol start="3"><li><p>天气目标的实现类ConcreteWeatherSubject.java</p><pre><code class="java">@Getterpublic class ConcreteWeatherSubject extends AbstractWeatherSubject {    // 目标对象的状态    // 天气情况：晴天、下雨、下雪    private String weatherContent;    public void setWeatherContent(String weatherContent) {        this.weatherContent = weatherContent;        this.notifyObservers();    }    @Override    protected void notifyObservers() {        // 遍历所有注册的观察者        this.observers.forEach(observer -&gt; {            /*            规则是：                1. 「女朋友」需要「下雨」的条件通知，其他条件不通知                2. 「老妈」需要「下雨」或「下雪」的条件通知，其他条件不通知             */            // 1. 如果天气是晴天            // do nothing...            // 2. 如果天气是下雨            if (Objects.equals(&quot;下雨&quot;, this.getWeatherContent())) {                if (Objects.equals(&quot;女朋友&quot;, observer.getObserverName())) {                    observer.update(this);                }                if (Objects.equals(&quot;老妈&quot;, observer.getObserverName())) {                    observer.update(this);                }            }            // 3. 如果天气是下雪            if (Objects.equals(&quot;下雪&quot;, this.getWeatherContent())) {                if (Objects.equals(&quot;老妈&quot;, observer.getObserverName())) {                    observer.update(this);                }            }        });    }}</code></pre></li></ol><h3 id="4-5-观察者接口类的实现-05-01"><a href="#4-5-观察者接口类的实现-05-01" class="headerlink" title="4-5 观察者接口类的实现 (05:01)"></a>4-5 观察者接口类的实现 (05:01)</h3><ol start="4"><li><p>观察者的实现类ConcreteObserver.java</p><pre><code class="java">@Datapublic class ConcreteObserver implements Observer {    // 观察者的名称，是谁收到了这个消息    private String observerName;    // 天气的内容信息，这个消息从目标处获取    private String weatherContent;    // 提醒的内容，不同的观察者提醒不同的内容    private String remindThing;    /**     * 获取目标类的状态，同步到观察者的状态中     *     * @param weatherSubject 传入的目标对象，方便获取相应的目标对象的状态     */    @Override    public void update(AbstractWeatherSubject weatherSubject) {        this.weatherContent = ((ConcreteWeatherSubject) weatherSubject).getWeatherContent();        System.out.println(observerName + &quot;收到了天气信息&quot; + weatherContent + &quot;，准备去做&quot; + remindThing);    }}</code></pre></li></ol><h3 id="4-6-测试-06-24"><a href="#4-6-测试-06-24" class="headerlink" title="4-6 测试 (06:24)"></a>4-6 测试 (06:24)</h3><ol start="5"><li><p>区别对待观察者-测试类Client.java</p><pre><code class="java">public class Client {    @Test    public void test1() {        // 1. 创建目标        ConcreteWeatherSubject weatherSubject = new ConcreteWeatherSubject();        // 2. 创建观察者        ConcreteObserver girlObserver = new ConcreteObserver();        girlObserver.setObserverName(&quot;女朋友&quot;);        girlObserver.setRemindThing(&quot;宅在家里&quot;);        ConcreteObserver mumObserver = new ConcreteObserver();        mumObserver.setObserverName(&quot;老妈&quot;);        mumObserver.setRemindThing(&quot;收衣服啦&quot;);        // 3. 注册观察者        weatherSubject.attach(girlObserver);        weatherSubject.attach(mumObserver);        // 4. 目标发布天气        weatherSubject.setWeatherContent(&quot;下雪&quot;);        weatherSubject.setWeatherContent(&quot;下雨&quot;);        weatherSubject.setWeatherContent(&quot;下冰雹&quot;);    }}</code></pre></li></ol><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>本章对本课程学习的内容进行总结，帮助小伙伴们巩固所学知识。</p></blockquote><h3 id="5-1-课程总结-02-16"><a href="#5-1-课程总结-02-16" class="headerlink" title="5-1 课程总结 (02:16)"></a>5-1 课程总结 (02:16)</h3><blockquote><p>观察者模式简介：场景描述<br>观察者模式实战：模式原理<br>观察者模式详解：推拉模型、JDK实现、优缺点、何时使用<br>观察者模式衍生：区别对待观察者</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146-模式的秘密---适配器模式</title>
      <link href="/imooc/146-adapter-mode/"/>
      <url>/imooc/146-adapter-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="https://www.imooc.com/learn/146" target="_blank" rel="noopener">https://www.imooc.com/learn/146</a></p><p>简介：所谓适配器，就是连接“源”和“目标”的纽带。本课程由生活中常见的例子入手，深入浅出的讲解适配器模式的含义以及该模式的角色关系，讲解在适配器模式中如何通过“组合”和“继承”实现代码重用，为你的 Java 达人锻造添砖加瓦</p></blockquote><p>@[TOC]</p><h2 id="第1章-适配器模式简介"><a href="#第1章-适配器模式简介" class="headerlink" title="第1章 适配器模式简介"></a>第1章 适配器模式简介</h2><blockquote><p>通过生活中的适配器，引导大家了解什么是适配器模式</p></blockquote><h3 id="1-1-什么是适配器模式-03-13"><a href="#1-1-什么是适配器模式-03-13" class="headerlink" title="1-1 什么是适配器模式 (03:13)"></a>1-1 什么是适配器模式 (03:13)</h3><p>生活中的适配器</p><blockquote><p>翻译软件<br>插座适配器</p></blockquote><p>适配器模式定义</p><blockquote><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作</p></blockquote><p>适配器模式类图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga3gitkzjoj30x40f2wmr.jpg" alt="适配器模式类图" style="zoom:40%;" /><p>适配器分类</p><blockquote><ol><li><p>聚合（组合）<br>定义：采用聚合（组合）方式的适配器称为对象适配器<br>特点：把“被适配者”作为一个对象聚合到适配器类中，以修改目标接口包装被适配者</p></li><li><p>继承<br>定义：采用继承方式的适配器称为类适配器<br>特点：通过多重继承不兼容接口，实现对目标接口的匹配，单一的为某个类而实现适配</p></li></ol></blockquote><h2 id="第2章-适配器模式的实现"><a href="#第2章-适配器模式的实现" class="headerlink" title="第2章 适配器模式的实现"></a>第2章 适配器模式的实现</h2><blockquote><p>分别采用组合和继承的方式实现适配器模式，并讲解两种设计模式的区别</p></blockquote><h3 id="2-1-使用组合的方式实现插座适配器-08-00"><a href="#2-1-使用组合的方式实现插座适配器-08-00" class="headerlink" title="2-1 使用组合的方式实现插座适配器 (08:00)"></a>2-1 使用组合的方式实现插座适配器 (08:00)</h3><p>怎们实现的？</p><ol><li>实现目标接口 ThreePlug</li><li>聚合GbTwoPlug类到当前适配器类中为成员变量</li><li>把”被适配者”作为一个对象聚合到适配器类中，以修改目标接口包装被适配者</li></ol><p>代码编写</p><ol><li><p>三相插座接口ThreePlug.java</p><pre><code class="java">public interface ThreePlug {    // 使用三相电流供电    void powerWithThree();}</code></pre></li><li><p>二相插座接口GbTwoPlug.java</p><pre><code class="java">public class GbTwoPlug {    // 使用二相电流供电    public void powerWithTwo() {        System.out.println(&quot;使用二相电流供电&quot;);    }}</code></pre></li><li><p>二相转三相的插座适配器-聚合方式TwoPlugAdapter.java</p><pre><code class="java">public class TwoPlugAdapter implements ThreePlug{    private GbTwoPlug twoPlug;    public TwoPlugAdapter(GbTwoPlug twoPlug) {        this.twoPlug = twoPlug;    }    @Override    public void powerWithThree() {        System.out.println(&quot;通过转换-聚合方式&quot;);        twoPlug.powerWithTwo();    }}</code></pre></li><li><p>笔记本电脑NoteBook.java</p><pre><code class="java">public class NoteBook {    // 期望使用三相插座进行充电    private ThreePlug threePlug;    public NoteBook(ThreePlug threePlug) {        this.threePlug = threePlug;    }    // 使用插座进行充电    public void charge() {        threePlug.powerWithThree();    }    public static void main(String[] args) {        GbTwoPlug twoPlug = new GbTwoPlug();        // 使用二相转三相的适配器        ThreePlug threePlug = new TwoPlugAdapter(twoPlug);        // 使用三相插座进行充电        NoteBook noteBook = new NoteBook(threePlug);        noteBook.charge();    }}</code></pre></li></ol><h3 id="2-2-使用继承的方式实现插座适配器-05-10"><a href="#2-2-使用继承的方式实现插座适配器-05-10" class="headerlink" title="2-2 使用继承的方式实现插座适配器 (05:10)"></a>2-2 使用继承的方式实现插座适配器 (05:10)</h3><p>代码编写：</p><ol><li><p>二相转三相的插座适配器-继承方式TwoPlugAdapterExtends.java</p><pre><code class="java">public class TwoPlugAdapterExtends extends GbTwoPlug implements ThreePlug {    @Override    public void powerWithThree() {        System.out.println(&quot;通过转换-继承方式&quot;);        this.powerWithTwo();    }}</code></pre></li><li><p>笔记本电脑NoteBook.java</p><pre><code class="java">public class NoteBook {    // 期望使用三相插座进行充电    private ThreePlug threePlug;    public NoteBook(ThreePlug threePlug) {        this.threePlug = threePlug;    }    // 使用插座进行充电    public void charge() {        threePlug.powerWithThree();    }    public static void main(String[] args) {        ThreePlug threePlug = new TwoPlugAdapterExtends();        NoteBook noteBook = new NoteBook(threePlug);        noteBook.charge();    }}</code></pre></li></ol><p>   类适配器</p><blockquote><p>类适配器模式通过多重继承不兼容接口，实现对目标接口的匹配，单一的为某个类而实现适配（Java类单一继承）</p></blockquote>   <img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga3hwd5cxaj30to0c6q8t.jpg" alt="类适配器" style="zoom:45%;" /><h2 id="第3章-适配器模式总结"><a href="#第3章-适配器模式总结" class="headerlink" title="第3章 适配器模式总结"></a>第3章 适配器模式总结</h2><blockquote><p>引入适配器的变体，启发灵活使用适配器。说明了适配器在开发中体现的作用</p></blockquote><h3 id="3-1-适配器模式的总结-01-58"><a href="#3-1-适配器模式的总结-01-58" class="headerlink" title="3-1 适配器模式的总结 (01:58)"></a>3-1 适配器模式的总结 (01:58)</h3><p>适配器模式是一种编程思想</p><blockquote><p>只要是把不兼容的转化成兼容的、匹配的，我们就叫它适配器</p></blockquote><p>模式的变体</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga3h2mrlv3j30u60bejya.jpg" alt="模式的变体" style="zoom:45%;" /><p>适配器的作用</p><blockquote><ol><li><p>透明：通过适配器，客户端可以调用同一个接口，因而对客户端来说是透明的。这样做更简单、更直接、更紧凑</p></li><li><p>重用：复用了现存的类，解决了现存类和复用环境要求不一致的问题。</p></li><li><p>低耦合：将<strong>目标类</strong>和<strong>适配者类</strong>解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码（遵循开闭原则）</p><p>开闭原则：对修改关闭，对扩展开放</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更改作者信息</title>
      <link href="/changing-author-info/"/>
      <url>/changing-author-info/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://help.github.com/cn/github/using-git/changing-author-info" target="_blank" rel="noopener">https://help.github.com/cn/github/using-git/changing-author-info</a></p></blockquote><p>修改邮箱导致提交绿色标识框消失。</p><p>要更改现有提交中记录的名称和/或电子邮件地址，您必须重写 Git 仓库的整个历史记录。</p><h3 id="使用脚本更改仓库的-Git-历史记录"><a href="#使用脚本更改仓库的-Git-历史记录" class="headerlink" title="使用脚本更改仓库的 Git 历史记录"></a>使用脚本更改仓库的 Git 历史记录</h3><p>我们创建了一个用于更改任何提交的脚本，可将此前在作者或提交者字段中填写的旧电子邮件地址更改为正确的名称和电子邮件地址。</p><p><strong>注</strong>：运行此脚本会重写所有仓库协作者的历史记录。 完成这些步骤后，任何拥有复刻或克隆的人都必须获取重写的历史记录，并将任何本地更改变基为重写的历史记录。</p><p>运行此脚本之前，您需要：</p><ul><li>显示在要更改的作者/提交者字段中的旧电子邮件地址</li><li>要将此类提交归因于的正确名称和电子邮件地址</li></ul><ol><li><p>打开 Terminal（终端）。</p></li><li><p>为仓库创建一个全新的裸克隆：</p><pre><code class="shell">git clone --bare https://github.com/user/repo.gitcd repo.git</code></pre></li><li><p>复制并粘贴脚本，根据您收集的信息替换以下变量：</p><ul><li><code>OLD_EMAIL</code></li><li><code>CORRECT_NAME</code></li><li><code>CORRECT_EMAIL</code></li></ul><pre><code class="shell">#!/bin/shgit filter-branch --env-filter &#39;OLD_EMAIL=&quot;your-old-email@example.com&quot;CORRECT_NAME=&quot;Your Correct Name&quot;CORRECT_EMAIL=&quot;your-correct-email@example.com&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#39; --tag-name-filter cat -- --branches --tags</code></pre></li><li><p>按 <strong>Enter</strong> 键以运行脚本。</p></li><li><p>审查新的 Git 历史记录以查找错误。</p></li><li><p>将更正的历史记录推送到 GitHub：</p><pre><code class="shell">git push --force --tags origin &#39;refs/heads/*&#39;</code></pre></li><li><p>清理临时克隆：</p><pre><code class="shell">cd ..rm -rf repo.git</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>214-模式的秘密---代理模式</title>
      <link href="/imooc/214-proxy-mode/"/>
      <url>/imooc/214-proxy-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="http://www.imooc.com/learn/214" target="_blank" rel="noopener">http://www.imooc.com/learn/214</a></p><p>简介：代理模式是一种非常重要的设计模式，在 Java 语言中有着广泛的应用，包括Spring AOP 的核心设计思想，都和代理模式有密切关系。什么场景使用代理模式？代理模式实现原理是什么？本节课程将带你领略代理模式的奥妙。</p></blockquote><p>@[TOC]</p><h2 id="第1章-代理模式概念介绍"><a href="#第1章-代理模式概念介绍" class="headerlink" title="第1章 代理模式概念介绍"></a>第1章 代理模式概念介绍</h2><blockquote><p>本章讲述了代理模式的分类、应用场景及作用</p></blockquote><h3 id="1-1-代理模式概念及分类-04-57"><a href="#1-1-代理模式概念及分类-04-57" class="headerlink" title="1-1 代理模式概念及分类 (04:57)"></a>1-1 代理模式概念及分类 (04:57)</h3><p>学习本课程基础</p><blockquote><p>面向对象的设计思维<br>了解多态的概念<br>了解反射机制</p></blockquote><p>课程目标</p><blockquote><p>代理模式基本概念及分类<br>了解代理模式开发中应用场景<br>掌握代理模式实现方式<br>理解JDK动态代理实现</p></blockquote><p>代理模式定义</p><blockquote><p>为其他对象提供一种代理以控制对这个对象的访问<br>代理对象起到中介作用，可去掉功能服务或添加额外的服务</p></blockquote><p>常见的几种代理模式</p><blockquote><p>远程代理（Remote Proxy）：为一个位于不同地理空间的对象提供局域网代表对象。类似于客户端服务器这种模式，是远程通信的缩影<br>虚拟代理（Virtual Proxy）：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建<br>保护代理（Protect Proxy）：控制对象的访问权限<br>智能代理（Smart Reference Proxy）：提供对目标对象额外的服务</p></blockquote><h2 id="第2章-常用代理模式原理"><a href="#第2章-常用代理模式原理" class="headerlink" title="第2章 常用代理模式原理"></a>第2章 常用代理模式原理</h2><blockquote><p>本章介绍静态代理、动态代理实现原理。并通过案例讲解 JDK 动态代理以及使用 cglib 实现动态代理</p></blockquote><p>智能引用代理</p><blockquote><p>静态代理<br>动态代理</p></blockquote><h3 id="2-1-静态代理概念及实现-09-32"><a href="#2-1-静态代理概念及实现-09-32" class="headerlink" title="2-1 静态代理概念及实现 (09:32)"></a>2-1 静态代理概念及实现 (09:32)</h3><p>静态代理定义</p><blockquote><p>代理和被代理对象在代理之前是确定的。他们都实现相同的接口或者继承相同的抽象类</p></blockquote><p>静态代理图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yud2gy5yj30qo0jcjxj.jpg" alt="image-20191216203507152" style="zoom:35%;" /><p>静态代理</p><blockquote><p>继承方式<br>聚合方式</p></blockquote><p>代码编写</p><ol><li><p>可行驶的接口Moveable.java</p><pre><code class="java">public interface Moveable {    // 行驶的方法    void move();}</code></pre></li><li><p>一辆车实现可行驶的接口Car.java</p><pre><code class="java">public class Car implements Moveable {    @Override    public void move() {        // 记录汽车行驶的时间        /*long startTime = System.currentTimeMillis();        System.out.println(&quot;汽车开始行驶...&quot;);*/        // 实现开车        try {            System.out.println(&quot;汽车行驶中...&quot;);            Thread.sleep(new Random().nextInt(1000));        } catch (InterruptedException e) { }        /*long endTime = System.currentTimeMillis();        System.out.println(&quot;汽车结束行驶...汽车行驶时间：&quot; + (endTime - startTime) + &quot;毫秒&quot;);*/    }}</code></pre></li><li><p>使用继承方式实现静态代理Car2.java</p><pre><code class="java">public class Car2 extends Car {    @Override    public void move() {        // 记录汽车行驶的时间        long startTime = System.currentTimeMillis();        System.out.println(&quot;汽车开始行驶...&quot;);        super.move();        long endTime = System.currentTimeMillis();        System.out.println(&quot;汽车结束行驶...汽车行驶时间：&quot; + (endTime - startTime) + &quot;毫秒&quot;);    }}</code></pre></li><li><p>使用聚合方式实现静态代理Car3.java</p><pre><code class="java">public class Car3 implements Moveable {    private Car car;    public Car3(Car car) {        super();        this.car = car;    }    @Override    public void move() {        // 记录汽车行驶的时间        long startTime = System.currentTimeMillis();        System.out.println(&quot;汽车开始行驶...&quot;);        car.move();        long endTime = System.currentTimeMillis();        System.out.println(&quot;汽车结束行驶...汽车行驶时间：&quot; + (endTime - startTime) + &quot;毫秒&quot;);    }}</code></pre></li><li><p>静态代理测试类Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        // 1. 在执行逻辑代码前后添加信息        /*Moveable car1 = new Car();        car1.move();*/        // 2. 使用继承方式实现静态代理        /*Moveable car2 = new Car2();        car2.move();*/        // 3. 使用聚合方式实现静态代理        Car car = new Car();        Moveable car3 = new Car3(car);        car3.move();    }}</code></pre></li></ol><h3 id="2-2-聚合比继承更适合代理模式-06-21"><a href="#2-2-聚合比继承更适合代理模式-06-21" class="headerlink" title="2-2 聚合比继承更适合代理模式 (06:21)"></a>2-2 聚合比继承更适合代理模式 (06:21)</h3><p>场景分析</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yve0p9zqj31io0u07wh.jpg" alt="实现功能叠加" style="zoom:25%;" /><p>代理类功能叠加</p><blockquote><ol><li>记录日志</li><li>记录时间</li><li>权限功能</li></ol></blockquote><ul><li><p>使用继承方式</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yvfjlv03j30ta0e40zg.jpg" alt="使用继承方式" style="zoom:40%;" /><p>使用继承方式来实现代理功能的叠加，代理类会无限的膨胀下去，所以这种方式不推荐使用。</p></li><li><p>使用聚合方式，通过代码演示</p></li></ul><p>代码编写</p><ol><li><p>汽车日志功能的代理CarLogProxy.java</p><pre><code class="java">public class CarLogProxy implements Moveable {    private Moveable m;    // 因为代理类和被代理类都是实现了相同的接口，所以构造方法传递的对象也是可以是Moveable对象    public CarLogProxy(Moveable m) {        super();        this.m = m;    }    @Override    public void move() {        System.out.println(&quot;日志开始&quot;);        m.move();        System.out.println(&quot;日志结束&quot;);    }}</code></pre></li><li><p>汽车行驶时间的代理CarTimeProxy.java</p><pre><code class="java">public class CarTimeProxy implements Moveable {    private Moveable m;    // 因为代理类和被代理类都是实现了相同的接口，所以构造方法传递的对象也是可以是Moveable对象    public CarTimeProxy(Moveable m) {        super();        this.m = m;    }    @Override    public void move() {        // 记录汽车行驶的时间        long startTime = System.currentTimeMillis();        System.out.println(&quot;汽车开始行驶...&quot;);        m.move();        long endTime = System.currentTimeMillis();        System.out.println(&quot;汽车结束行驶...汽车行驶时间：&quot; + (endTime - startTime) + &quot;毫秒&quot;);    }}</code></pre></li><li><p>静态代理测试类-功能叠加的聚合方式Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {     Car car = new Car();        CarLogProxy clp = new CarLogProxy(car);        CarTimeProxy ctp = new CarTimeProxy(clp);        ctp.move();    }}</code></pre><pre><code>汽车开始行驶...日志开始汽车行驶中...日志结束汽车结束行驶...汽车行驶时间：845毫秒</code></pre></li></ol><p>思考：CarTimeProxy只是对汽车时间代理，如果此时需要对火车、自行车进行时间代理怎们办？还需要重新写火车时间代理类、汽车时间代理类么？</p><h3 id="2-3-了解-JDK-动态代理-08-52"><a href="#2-3-了解-JDK-动态代理-08-52" class="headerlink" title="2-3 了解 JDK 动态代理 (08:52)"></a>2-3 了解 JDK 动态代理 (08:52)</h3><p>场景分析</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ywn8g86yj31dm0nids3.jpg" alt="多种类的时间代理" style="zoom:25%;" /><p>有没有方法动态产生代理，实现对不同类、不同方法的代理呢？</p><p>JDK动态代理类图</p><blockquote><p>Java动态代理机制以巧妙的方式实现了代理模式的设计理念</p></blockquote><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ywswu2xgj31ba0a2whb.jpg" alt="JDK动态代理类图" style="zoom:25%;" /><p>Java动态代理类位于<code>java.lang.reflect</code>包下，一般主要涉及到以下两个类：</p><blockquote><ul><li><p><code>Interface InvocationHandler</code>：该接口中仅定义了一个方法</p><p><code>public Object invoke(Object obj, Method method, Object[] args)</code></p><p>在实际使用时，第一参数<code>obj</code>一般是指代理类，<code>method</code>是被代理的方法，<code>args</code>为该方法的参数数组。</p><p>这个抽象方法在代理类中动态实现。</p></li><li><p>Proxy：该类即为动态代理类</p><p><code>static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code></p><p>返回代理类的一个实例，返回后的代理类可以当做被代理类使用</p><p>（可使用被代理类的在接口中声明过的方法）</p></li></ul></blockquote><p>动态代理实现步骤</p><blockquote><ol><li>创建一个实现InvocationHandler接口的类，它必须实现invoke方法(实现业务逻辑)</li><li>创建被代理的类以及接口</li><li>调用Proxy的静态方法，创建一个代理类<br>Proxy.newProxyInstance(CLassLoader loader, Class[] interfaces, InvocationHandler h)</li><li>通过代理调用方法</li></ol></blockquote><p>代码编写</p><ol><li><p>使用JDK动态代理-对时间上的处理TimeHandler.java</p><pre><code class="java">public class TimeHandler implements InvocationHandler {    private Object target;    public TimeHandler(Object target) {        super();        this.target = target;    }    /**     * JDK动态代理     * @param proxy  被代理对象     * @param method 被代理对象方法     * @param args   方法的参数     * @return 方法的返回值     */    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {        long startTime = System.currentTimeMillis();        System.out.println(&quot;汽车开始行驶...&quot;);        method.invoke(target, args);        long endTime = System.currentTimeMillis();        System.out.println(&quot;汽车结束行驶...汽车行驶时间：&quot; + (endTime - startTime) + &quot;毫秒&quot;);        return null;    }}</code></pre></li><li><p>JDK动态代理测试类Test.java</p><pre><code class="java">public class Test {    public static void main(String[] args) {        Car car = new Car();        InvocationHandler h = new TimeHandler(car);        Class&lt;? extends Car&gt; cls = car.getClass();        // 使用Proxy类newProxyInstance方法动态创建代理类        /*          loader 类加载器          interfaces 实现接口          h InvocationHandler         */        Moveable m = (Moveable)Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), h);        m.move();    }}</code></pre></li></ol><p>所谓Dynamic Proxy是这样一种class</p><blockquote><p>它是在运行时生成的class<br>该class需要实现一组interface<br>使用动态代理类时，必须实现InvocationHandler接口</p></blockquote><h3 id="2-4-使用-cglib-动态产生代理-07-44"><a href="#2-4-使用-cglib-动态产生代理-07-44" class="headerlink" title="2-4 使用 cglib 动态产生代理 (07:44)"></a>2-4 使用 cglib 动态产生代理 (07:44)</h3><p>JDK动态代理与CGLIB动态代理区别</p><blockquote><p>JDK动态代理</p><ol><li>只能代理实现了接口的类</li><li>没有实现接口的类不能实现JDK的动态代理</li></ol><p>CGLIB动态代理</p><ol><li>针对类来实现代理的</li><li>对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用</li><li>因为是使用继承的方式，所以不能对final修饰的类来进行代理</li></ol></blockquote><p>代码编写</p><ol><li><p>添加相关依赖</p><pre><code class="java">&lt;!-- https://mvnrepository.com/artifact/cglib/cglib-nodep --&gt;&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;    &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>代理类CglibProxy.java</p><pre><code class="java">public class CglibProxy implements MethodInterceptor {    private Enhancer enhancer = new Enhancer();    public Object getProxy(Class clazz) {        // 设置创建子类的类，即为哪个类产生代理类        enhancer.setSuperclass(clazz);        enhancer.setCallback(this);        return enhancer.create();    }    /**     * 拦截所有目标类方法的调用     *     * @param o 目标类的实例     * @param method 目标方法的反射对象     * @param objects 方法的参数     * @param methodProxy 代理类的实例     * @return 方法的返回值     * @throws Throwable     */    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;日志开始...&quot;);        // 代理类调用父类的方法        methodProxy.invokeSuper(o, objects);        System.out.println(&quot;日志结束...&quot;);        return null;    }}</code></pre></li><li><p>火车Train.java</p><pre><code class="java">public class Train implements Moveable {    @Override    public void move() {        System.out.println(&quot;火车🚄行驶中&quot;);    }}</code></pre><p>如需再有飞机类则步骤4：</p></li><li><p>飞机Plain.java</p><pre><code class="java">public class Plain implements Moveable {    @Override    public void move() {        System.out.println(&quot;飞机✈行驶中&quot;);    }}</code></pre></li><li><p>CGLIB代理的测试类Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) {        CglibProxy cglibProxy = new CglibProxy();        Train t = (Train) cglibProxy.getProxy(Train.class);        t.move();        Plain p = (Plain) cglibProxy.getProxy(Plain.class);        p.move();    }}</code></pre></li></ol><h2 id="第3章-自定义类模拟-JDK-动态代理的实现"><a href="#第3章-自定义类模拟-JDK-动态代理的实现" class="headerlink" title="第3章 自定义类模拟 JDK 动态代理的实现"></a>第3章 自定义类模拟 JDK 动态代理的实现</h2><blockquote><p>本章通过编写自定义类，模拟 JDK 动态代理的实现，帮助大家深入理解 JDK 动态代理的实现原理与机制</p></blockquote><h3 id="3-1-模拟-JDK-动态代理实现思路分析及简单实现-15-55"><a href="#3-1-模拟-JDK-动态代理实现思路分析及简单实现-15-55" class="headerlink" title="3-1 模拟 JDK 动态代理实现思路分析及简单实现 (15:55)"></a>3-1 模拟 JDK 动态代理实现思路分析及简单实现 (15:55)</h3><p>动态代理实现思路</p><blockquote><p>实现功能：通过Proxy的newProxyInstance返回代理对象</p><ol><li>声明一段源码（动态产生代理）</li><li>编译编码（JDK Compiler API），产生新的类（代理类）</li><li>将这个类load到内存当中，产生一个新的对象（代理对象）</li><li>return代理对象</li></ol></blockquote><p>注：以下代码为教师源码，在GitHub学习项目代码中已做<strong>改进：方法可传递参数</strong></p><p>代码编写</p><ol><li><p>模拟JDK动态代理-业务处理类InvocationHandler.java</p><pre><code class="java">public interface InvocationHandler {    /**     * @param obj    被代理对象     * @param method 被代理对象方法     */    void invoke(Object obj, Method method);}</code></pre></li><li><p>模拟JDK动态代理-代理类Proxy.java</p><pre><code class="java">public class Proxy {    public static Object newProxyInstance(Class infce, InvocationHandler h)            throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {        String rt = &quot;\r\n&quot;;        StringBuilder methodStr = new StringBuilder();        for (Method m : infce.getMethods()) {            methodStr.                    append(&quot;@Override&quot;).append(rt).                    append(&quot;public void &quot;).append(m.getName()).append(&quot;() {&quot;).append(rt)                    .append(&quot;    try {&quot;).append(rt)                    .append(&quot;        Method md = &quot;).append(infce.getName()).append(&quot;.class.getMethod(\&quot;&quot;).append(m.getName()).append(&quot;\&quot;);&quot;).append(rt)                    .append(&quot;        h.invoke(this, md);&quot;).append(rt)                    .append(&quot;    } catch (Exception e) {&quot;).append(rt)                    .append(&quot;        e.printStackTrace();&quot;).append(rt)                    .append(&quot;    }&quot;).append(rt)                    .append(&quot;}&quot;).append(rt);        }        String str = &quot;package com.tuyrk.analog_jdkproxy;&quot; + rt +                &quot;import com.tuyrk.analog_jdkproxy.InvocationHandler;&quot; + rt +                &quot;import java.lang.reflect.Method;&quot; + rt +                &quot;public class $Proxy0 implements &quot; + infce.getName() + &quot; {&quot; + rt +                &quot;    private InvocationHandler h;&quot; + rt +                &quot;    public $Proxy0(InvocationHandler h) {&quot; + rt +                &quot;        this.h = h;&quot; + rt +                &quot;    }&quot; + rt +                methodStr + rt +                &quot;}&quot; + rt;        // 产生代理类的Java文件        String filename = System.getProperty(&quot;user.dir&quot;) + &quot;/214-proxy-mode/target/classes/com/tuyrk/analog_jdkproxy/$Proxy0.java&quot;;        File file = new File(filename);        FileUtils.writeStringToFile(file, str, StandardCharsets.UTF_8);        // 编译-拿到编译器        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();        // 文件管理者        StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null);        // 获取文件        Iterable&lt;? extends JavaFileObject&gt; units = fileMgr.getJavaFileObjects(filename);        // 编译任务        CompilationTask task = compiler.getTask(null, fileMgr, null, null, null, units);        // 进行编译        task.call();        fileMgr.close();        // 获取类加载器        ClassLoader cl = ClassLoader.getSystemClassLoader();        // 加载到内存        Class&lt;?&gt; c = cl.loadClass(&quot;com.tuyrk.analog_jdkproxy.$Proxy0&quot;);        // 获取构造器        Constructor&lt;?&gt; ctr = c.getConstructor(InvocationHandler.class);        return ctr.newInstance(h);    }}</code></pre></li><li><p>模拟JDK动态代理-时间业务逻辑处理TimeHandler.java</p><pre><code class="java">public class TimeHandler implements InvocationHandler {    private Object target;    public TimeHandler(Object target) {        super();        this.target = target;    }    @Override    public void invoke(Object obj, Method method) {        long startTime = System.currentTimeMillis();        System.out.println(&quot;汽车开始行驶...&quot;);        method.invoke(target);        long endTime = System.currentTimeMillis();        System.out.println(&quot;汽车结束行驶...汽车行驶时间：&quot; + (endTime - startTime) + &quot;毫秒&quot;);    }}</code></pre></li><li><p>模拟JDK动态代理-测试类Client.java</p><pre><code class="java">public class Client {    public static void main(String[] args) throws Exception {     Car car = new Car();        InvocationHandler h = new TimeHandler(car);        Moveable m = (Moveable)Proxy.newProxyInstance(Moveable.class, h);        m.move();    }}</code></pre></li></ol><h2 id="第4章-代理模式总结"><a href="#第4章-代理模式总结" class="headerlink" title="第4章 代理模式总结"></a>第4章 代理模式总结</h2><blockquote><p>总结代理模式分类、应用场景、实现原理、实现方式及实现方式优缺点</p></blockquote><h3 id="4-1-课程总结-03-47"><a href="#4-1-课程总结-03-47" class="headerlink" title="4-1 课程总结 (03:47)"></a>4-1 课程总结 (03:47)</h3><blockquote><p>代理模式概念、分类及应用场景<br>静态代理（继承、聚合）<br>JDK动态代理实现日志处理功能<br>模拟JDK动态代理实现</p></blockquote><p>为什么只讲解了智能引用代理？</p><ul><li>智能引用代理应用最广，如日志处理、权限处理、事务处理</li></ul><p>代理模式-动态代理：</p><blockquote><p>不改变原有类的情况下，增加一些额外的业务逻辑。AOP</p></blockquote><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga0w09naq0j30tk0bywhs.jpg" alt="代理模式-动态代理" style="zoom:50%;" /><p>代理模式：</p><blockquote><ul><li>代理模式基本概念及分类</li><li>静态代理概念及实例</li><li>动态代理概念及实例</li><li>模拟JDK动态代理实现</li><li>课程总结</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>261-模式的秘密---工厂模式</title>
      <link href="/imooc/261-factory-mode/"/>
      <url>/imooc/261-factory-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="http://www.imooc.com/learn/261" target="_blank" rel="noopener">http://www.imooc.com/learn/261</a></p><p>简介：工厂模式和抽象工厂模式是在日常开发中使用非常广泛的设计模式。主要用于实现将对象的实例化部分取出来，进而优化系统架构，增强系统的扩展性。本课程即将讲解Java中的工厂模式和抽象工厂模式的应用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-工厂模式概述"><a href="#第1章-工厂模式概述" class="headerlink" title="第1章 工厂模式概述"></a>第1章 工厂模式概述</h2><blockquote><p>本章主要介绍工厂模式的基本概念。</p></blockquote><h3 id="1-1-工厂模式概述-10-29"><a href="#1-1-工厂模式概述-10-29" class="headerlink" title="1-1 工厂模式概述 (10:29)"></a>1-1 工厂模式概述 (10:29)</h3><p>什么是设计模式？</p><blockquote><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</p></blockquote><p>应用设计模式的好处？</p><blockquote><p>设计模式是优秀的使用案例<br>使用设计模式可提高代码的重用性<br>让代码更容易被他人理解<br>保证代码可靠性</p></blockquote><p>重点内容</p><blockquote><ul><li>工厂模式的概念</li><li>工厂模式的意图</li><li>工厂模式的应用场景</li><li>工厂模式的设计思想</li><li>工厂模式的好处</li></ul></blockquote><p>工厂模式的概念</p><blockquote><p>实例化对象，用工厂方法代替new操作<br>工厂模式包括工厂方法模式和抽象工厂模式<br>抽象工厂模式是工厂方法模式的扩展</p></blockquote><p>工厂模式的意图</p><blockquote><p>定义一个接口来创建对象，但是让子类来决定哪些类需要被实例化<br>工厂方法把实例化的工作推迟到子类中去实现</p></blockquote><p>什么情况下适合工厂模式</p><blockquote><p>有一组类似的对象需要创建<br>在编码时不能预见需要创建哪种类的实例<br>系统需要考虑扩展性，不应依赖于产品类实例如何被创建、组合和表达的细节</p></blockquote><p>项目中的现状</p><blockquote><p>在软件系统中经常面临着“对象”的创建工作，由于需求的变化，这个对象可能随之也会发生变化，但它却拥有比较稳定的接口。为此，我们需要提供一种封装机制来隔离出这个易变对象的变化，从而保证系统中其他依赖该对象的对象不随着需求变化而变化。</p></blockquote><p>基于项目现状将代码进行如下设计</p><blockquote><ol><li>尽量松耦合，一个对象的依赖对象的变化与本身无关</li><li>具体产品与客户端剥离，责任分割</li></ol></blockquote><p>工厂方法模式类图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9xivji6hxj30wd0dg74w.jpg" alt="工厂方法模式类图" style="zoom:40%;" /><p>抽象工厂模式类图</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9xiw8hc24j30v20irabj.jpg" alt="抽象工厂模式类图" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9xixfipxsj30zt0ijjsh.jpg" alt="工厂产品族" style="zoom:40%;" /><h2 id="第2章-工厂模式应用"><a href="#第2章-工厂模式应用" class="headerlink" title="第2章 工厂模式应用"></a>第2章 工厂模式应用</h2><blockquote><p>本章通过案例演示工厂模式的应用。</p></blockquote><h3 id="2-1-工厂模式应用-22-18"><a href="#2-1-工厂模式应用-22-18" class="headerlink" title="2-1 工厂模式应用 (22:18)"></a>2-1 工厂模式应用 (22:18)</h3><ol><li><p>发型接口HairInterface.java</p><pre><code class="java">public interface HairInterface {    // 画发型    void draw();}</code></pre></li><li><p>左偏分发型LeftHair.java</p><pre><code class="java">public class LeftHair implements HairInterface {    @Override    public void draw() {        System.out.println(&quot;左偏分发型&quot;);    }}</code></pre></li><li><p>右偏分发型RightHair.java</p><pre><code class="java">public class RightHair implements HairInterface {    @Override    public void draw() {        System.out.println(&quot;右偏分发型&quot;);    }}</code></pre></li><li><p>中分发型InHair.java</p><pre><code class="java">public class InHair implements HairInterface {    @Override    public void draw() {        System.out.println(&quot;中分发型&quot;);    }}</code></pre></li><li><p>配置文件application.properties</p><pre><code class="java">left=com.tuyrk.hair.impl.LeftHairright=com.tuyrk.hair.impl.RightHairin=com.tuyrk.hair.impl.InHair</code></pre></li><li><p>properties文件的读取工具类PropertiesReader.java</p><pre><code class="java">public class PropertiesReader {    // 获取配置文件的属性    public static Map&lt;String, String&gt; getProperties() {        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        try {            Resource resource = new ClassPathResource(&quot;application.properties&quot;);            Properties props = PropertiesLoaderUtils.loadProperties(resource);            Enumeration&lt;?&gt; en = props.propertyNames();            while (en.hasMoreElements()) {                String key = (String) en.nextElement();                String property = props.getProperty(key);                map.put(key, property);            }        } catch (IOException e) {}        return map;    }}</code></pre></li><li><p>发型工厂HairFactory.java</p><pre><code class="java">public class HairFactory {    /**     * 根据类型来创建对象     * @param key 发型种类     * @return 发型实例     */    public HairInterface getHair(String key) {        if (&quot;left&quot;.equals(key)) {            return new LeftHair();        } else if (&quot;right&quot;.equals(key)) {            return new RightHair();        }        return null;    }    /**     * 根据类的名称来生产对象     * @param className 类名     * @return 发型实例     */    public HairInterface getHairByClass(String className) {        try {            return (HairInterface) Class.forName(className).newInstance();        } catch (Exception e) {}        return null;    }    /**     * 根据类的名称来生产对象     * @param key 类名对应名称     * @return 发型实例     */    public HairInterface getHairByClassKey(String key) {        try {            Map&lt;String, String&gt; map = PropertiesReader.getProperties();            return (HairInterface) Class.forName(map.get(key)).newInstance();        } catch (Exception e) {}        return null;    }}</code></pre></li><li><p>测试类Test.java</p><pre><code class="jaa">public class Test {    public static void main(String[] args) {        // 每需要创建一个发型都需要重新new，并且调用draw()        /*HairInterface left = new LeftHair();        left.draw();        HairInterface right = new RightHair();        right.draw();*/        // if-else实现        /*HairFactory factory = new HairFactory();        HairInterface left = factory.getHair(&quot;left&quot;);        left.draw();*/        // className实现        /*HairFactory factory = new HairFactory();         *//*HairInterface left = factory.getHairByClass(&quot;com.tuyrk.hair.impl.LeftHair&quot;);*//*        HairInterface left = factory.getHairByClass(LeftHair.class.getName());        left.draw();*/        // 读取properties实现        HairFactory factory = new HairFactory();        HairInterface hair = factory.getHairByClassKey(&quot;in&quot;);        hair.draw();    }}</code></pre></li></ol><h2 id="第3章-抽象工厂模式应用"><a href="#第3章-抽象工厂模式应用" class="headerlink" title="第3章 抽象工厂模式应用"></a>第3章 抽象工厂模式应用</h2><blockquote><p>本章通过案例演示抽象工厂模式的应用</p></blockquote><h3 id="3-1-抽象工厂模式应用-12-34"><a href="#3-1-抽象工厂模式应用-12-34" class="headerlink" title="3-1 抽象工厂模式应用 (12:34)"></a>3-1 抽象工厂模式应用 (12:34)</h3><ol><li><p>男孩Boy.java</p><pre><code class="java">public interface Boy {    void drawMan();}</code></pre></li><li><p>女孩Girl.java</p><pre><code class="java">public interface Girl {    void drawWomen();}</code></pre></li><li><p>新年系列的男孩HNBoy.java</p><pre><code class="java">public class HNBoy implements Boy {    @Override    public void drawMan() {        System.out.println(&quot;新年男孩&quot;);    }}</code></pre></li><li><p>新年系列的女孩HNGirl.java</p><pre><code class="java">public class HNGirl implements Girl {    @Override    public void drawWomen() {        System.out.println(&quot;新年女孩&quot;);    }}</code></pre></li><li><p>圣诞系列的男孩MCBoy.java</p><pre><code class="java">public class MCBoy implements Boy {    @Override    public void drawMan() {        System.out.println(&quot;圣诞男孩&quot;);    }}</code></pre></li><li><p>圣诞系列的女孩MCGirl.java</p><pre><code class="java">public class MCGirl implements Girl {    @Override    public void drawWomen() {        System.out.println(&quot;圣诞女孩&quot;);    }}</code></pre></li><li><p>人物的实现接口PersonFactory.java</p><pre><code class="java">public interface PersonFactory {    // 男孩接口    Boy getBoy();    // 女孩接口    Girl getGirl();}</code></pre></li><li><p>新年系列工厂HNFactory.java</p><pre><code class="java">public class HNFactory implements PersonFactory {    @Override    public Boy getBoy() {        return new HNBoy();    }    @Override    public Girl getGirl() {        return new HNGirl();    }}</code></pre></li><li><p>圣诞系列工厂MCFactory.java</p><pre><code class="java">public class MCFactory implements PersonFactory {    @Override    public Boy getBoy() {        return new MCBoy();    }    @Override    public Girl getGirl() {        return new MCGirl();    }}</code></pre></li><li><p>测试类Test.java</p><pre><code class="java">public class Test {    public static void main(String[] args) {        // 圣诞女孩        PersonFactory mcFactory = new MCFactory();        Girl girl = mcFactory.getGirl();        girl.drawWomen();// 圣诞女孩        // 新年男孩        PersonFactory hnFactory = new HNFactory();        Boy boy = hnFactory.getBoy();        boy.drawMan();// 新年男孩    }}</code></pre></li></ol><h2 id="第4章-总结"><a href="#第4章-总结" class="headerlink" title="第4章 总结"></a>第4章 总结</h2><blockquote><p>总结工厂模式和抽象工厂模式的应用。</p></blockquote><h3 id="4-1-总结-06-06"><a href="#4-1-总结-06-06" class="headerlink" title="4-1 总结 (06:06)"></a>4-1 总结 (06:06)</h3><p>场景应用</p><ul><li><p>JDBC</p><p>是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9xm3aowguj30o806mt8w.jpg" alt="JDBC" style="zoom:75%;" /></li><li><p>Spring BeanFactory</p><p>BeanFactory，作为Spring基础的IoC容器，是Spring的一个Bean工厂。如果单从工厂模式的角度思考，他就是用来“生产Bean”，然后提供给客户端。</p><p>Bean的实例化过程如下：</p><ol><li>调用Bean的默认构造方法，或指定的构造方法，生成bean实例（暂称为instance1）</li><li>如果Bean的配置文件中注入了Bean属性值，则在instance1基础上进行属性注入形成instance2，这种注入是覆盖性的。</li><li>如果Bean实现了InitializingBean接口，则调用afterPropertiesSet()方法，来改变或操作instance2，得到instance3</li><li>如果Bean的配置文件中指定了init-method=”init”属性，则会调用指定的初始化方法，则在instance3的基础上调用初始化方法init()，将对象最终初始化为instance4；当然，这个初始化的名字是任意的。</li></ol></li></ul><p>工厂方法模式和抽象工厂模式对比</p><blockquote><p>工厂模式是一种极端情况下的抽象工厂模式，而抽象工厂模式可以看成是工厂模式的推广。<br>工厂模式用来创建一个产品的等级结构，而抽象工厂模式是用来创建多个产品的等级结构<br>工厂模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类</p></blockquote><p>工厂模式的实现帮助我们</p><blockquote><p>系统可以在不修改具体工厂角色的情况下引进新的产品<br>客户端不必关心对象如何创建，明确了职责<br>更好的理解面向对象的原则。面向接口编程，而不要面向实现编程</p></blockquote><p>工厂模式适用于哪些场景</p><blockquote><p>一个系统应当不依赖于产品类实例被创立，组成和表示的细节。这对所有形态的工厂模式都是重要的<br>这个系统的产品有至少一个的产品族<br>同属于一个产品族的产品是设计成在一起使用的。这个约束必须得在系统的设计中体现出来<br>不同的产品以一系列的接口的面貌出现，从而使系统不依赖于接口实现的细节</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2-本手册专有名词</title>
      <link href="/alibaba-p3c/72-proper-noun/"/>
      <url>/alibaba-p3c/72-proper-noun/</url>
      
        <content type="html"><![CDATA[<ol><li>POJO（Plain Ordinary Java Object）: 在本手册中，POJO专指只有setter / getter / toString的简单类，包括DO/DTO/BO/VO等。 </li><li>GAV（GroupId、ArtifactId、Version）: Maven坐标，是用来唯一标识jar包。</li><li>OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。 </li><li>ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指iBATIS, mybatis等框架。 </li><li>NPE（java.lang.NullPointerException）: 空指针异常。 </li><li>SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。 </li><li>一方库: 本工程内部子项目模块依赖的库（jar包）。 </li><li>二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar包）。 </li><li>三方库: 公司之外的开源库（jar包）。 </li><li>IDE（Integrated Development Environment）: 用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指IntelliJ IDEA和eclipse。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1-版本历史</title>
      <link href="/alibaba-p3c/71-history-version/"/>
      <url>/alibaba-p3c/71-history-version/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>版本号</th><th align="left">更新日期</th><th align="left">备注</th></tr></thead><tbody><tr><td>1.0.0</td><td align="left">2017.2.9</td><td align="left">阿里巴巴集团正式对外发布</td></tr><tr><td>1.0.1</td><td align="left">2017.2.13</td><td align="left">1）修正String[]的前后矛盾。2）vm修正成velocity。3）修正countdown描述错误。</td></tr><tr><td>1.0.2</td><td align="left">2017.2.20</td><td align="left">1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正final描述。5）去除Comparator部分描述。</td></tr><tr><td>1.1.0</td><td align="left">2017.2.27</td><td align="left">1）增加前言。2）增加&lt;? extends T&gt;描述和说明。3）增加版本历史。4）增加专有名词解释</td></tr><tr><td>1.1.1</td><td align="left">2017.3.31</td><td align="left">修正页码总数和部分示例。</td></tr><tr><td>1.2.0</td><td align="left">2017.5.20</td><td align="left">1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为is_deleted</td></tr><tr><td>1.3.0</td><td align="left">2017.9.25</td><td align="left">增加单元测试规约（PDF终极版），阿里开源的IDE代码规约检测插件：<a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">点此下载</a> 更多及时信息，请关注《阿里巴巴Java开发手册》官方公众号：<img src="images/QRcode.jpg" alt="QRcode"></td></tr><tr><td>1.3.1</td><td align="left">2017.11.30</td><td align="left">修正部分描述；采用和P3C开源IDE检测插件相同的Apache2.0协议。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3-服务器</title>
      <link href="/alibaba-p3c/63-server/"/>
      <url>/alibaba-p3c/63-server/</url>
      
        <content type="html"><![CDATA[<ol><li>【推荐】高并发服务器建议调小TCP协议的<code>time_wait</code>超时时间。 说明：操作系统默认240秒后，才会关闭处于<code>time_wait</code>状态的连接，在高并发访问下，服务器端会因为处于<code>time_wait</code>的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br><br><span style="color:green">正例</span>：在linux服务器上请通过变更/etc/sysctl.conf文件去修改该缺省值（秒）：<pre>net.ipv4.tcp_fin_timeout = 30</pre></li><li>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。<br><br><span style="color:orange">说明</span>：主流操作系统的设计是将TCP/UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为1024，当并发连接数很大时很<br>容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。 建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。 </li><li>【推荐】给JVM设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。<br><br><span style="color:orange">说明</span>：OOM的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。 </li><li>【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC 后调整堆大小带来的压力。 </li><li>【参考】服务器内部重定向使用forward；外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2-二方库依赖</title>
      <link href="/alibaba-p3c/62-lib-depend/"/>
      <url>/alibaba-p3c/62-lib-depend/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】定义GAV遵从以下规则：<br>1） <code>G</code>roupID格式：com.{公司/BU }.业务线.[子业务线]，最多4级。<br><span style="color:orange">说明</span>：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress等BU一级；子业务线可选。<br><span style="color:green">正例</span>：com.taobao.jstorm 或 com.alibaba.dubbo.register<br><br>2） <code>A</code>rtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br><br><span style="color:green">正例</span>：dubbo-client / fastjson-api / jstorm-tool<br>3） <code>V</code>ersion：详细规定参考下方。 </li><li>【强制】二方库版本号命名方式：主版本号.次版本号.修订号<br>1） <strong>主版本号</strong>：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。<br>2） <strong>次版本号</strong>：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。<br>3） <strong>修订号</strong>：保持完全兼容性，修复BUG、新增次要功能特性等。<br>说明：注意起始版本号必须为：<em>1.0.0</em>，而不是0.0.1   正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0 </li><li>【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）。<br><br><span style="color:orange">说明</span>：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。  </li><li>【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行<code>dependency:resolve</code>前后信息比对，如果仲裁结果完全不一致，那么通过<code>dependency:tree</code>命令，找出差异点，进行<code>&lt;excludes&gt;</code>排除jar包。 </li><li>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。 </li><li>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 <br><br><span style="color:orange">说明</span>：依赖springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。</li><li>【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。<br><br><span style="color:orange">说明</span>：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的lib目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。 </li><li>【推荐】所有pom文件中的依赖声明放在<code>&lt;dependencies&gt;</code>语句块中，所有版本仲裁放在<code>&lt;dependencyManagement&gt;</code>语句块中。<br><br><span style="color:orange">说明</span>：<code>&lt;dependencyManagement&gt;</code>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而<code>&lt;dependencies&gt;</code>所有声明在主pom的<code>&lt;dependencies&gt;</code>里的依赖都会自动引入，并默认被所有的子项目继承。 </li><li>【推荐】二方库不要有配置项，最低限度不要再增加配置项。 </li><li>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：<br><br>1）精简可控原则。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。<br><br>2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。  </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1-工程结构</title>
      <link href="/alibaba-p3c/61-app-layer/"/>
      <url>/alibaba-p3c/61-app-layer/</url>
      
        <content type="html"><![CDATA[<h2 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h2><ol><li><p>【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web层，也可以直接依赖于Service层，依此类推：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghosi0phj30dm0bpgmc.jpg" alt="应用分层"></p><ul><li>开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制、流量控制等。 </li><li>终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。 </li><li>Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 </li><li>Service层：相对具体的业务逻辑服务层。 </li><li>Manager层：通用业务处理层，它有如下特征：<br><br>1） 对第三方平台封装的层，预处理返回结果及转化异常信息；<br><br>2） 对Service层通用能力的下沉，如缓存方案、中间件通用处理；<br><br>3） 与DAO层交互，对多个DAO的组合复用。</li><li>DAO层：数据访问层，与底层MySQL、Oracle、Hbase等进行数据交互。 </li><li>外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</li></ul></li><li><p>【参考】（分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager/Service层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></li><li><p>【参考】分层领域模型规约：</p><ul><li>DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.4-ORM映射</title>
      <link href="/alibaba-p3c/54-orm/"/>
      <url>/alibaba-p3c/54-orm/</url>
      
        <content type="html"><![CDATA[<ol><li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<br><br><span style="color:orange">说明</span>：1）增加查询分析器解析成本。2）增减字段容易与resultMap配置不一致。 </p></li><li><p>【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。<br><br><span style="color:orange">说明</span>：参见定义POJO类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。</p></li><li><p>【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。<br><br><span style="color:orange">说明</span>：配置映射关系，使字段与DO类解耦，方便维护。 </p></li><li><p>【强制】sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。 </p></li><li><p>【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。<br><br><span style="color:orange">说明</span>：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。<br><br><span style="color:green">正例</span>：</p><pre><code> Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();     map.put(&quot;start&quot;, start);     map.put(&quot;size&quot;, size);</code></pre></li><li><p>【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。<br><br><span style="color:orange">说明</span>：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</p></li><li><p>【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。</p></li><li><p>【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。 </p></li><li><p>【参考】<code>@Transactional</code>事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 </p></li><li><p>【参考】<code>&lt;isEqual&gt;</code>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；<code>&lt;isNotEmpty&gt;</code>表示不为空且不为null时执行；<code>&lt;isNotNull&gt;</code>表示不为null值时执行。  </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.3-SQL语句</title>
      <link href="/alibaba-p3c/53-sql/"/>
      <url>/alibaba-p3c/53-sql/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】不要使用count(列名)或count(常量)来替代count(<em>)，count(</em>)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。<br><br><span style="color:orange">说明</span>：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 </li><li>【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。 </li><li>【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。<br><br><span style="color:green">正例</span>：可以使用如下方式来避免sum的NPE问题：<pre>SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; </pre></li><li>【强制】使用<code>ISNULL()</code>来判断是否为NULL值。 说明：NULL与任何值的直接比较都为NULL。<br>1） <code>NULL&lt;&gt;NULL</code>的返回结果是NULL，而不是<code>false</code>。<br>2） <code>NULL=NULL</code>的返回结果是NULL，而不是<code>true</code>。<br>3） <code>NULL&lt;&gt;1</code>的返回结果是NULL，而不是<code>true</code>。 </li><li>【强制】 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。 </li><li>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br><br><span style="color:orange">说明</span>：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 </li><li>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 </li><li>【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。 </li><li>【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。 </li><li>【参考】如果有全球化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。<br><br><span style="color:orange">说明</span>：<pre>SELECT LENGTH("轻松工作")； 返回为12SELECT CHARACTER_LENGTH("轻松工作")； 返回为4</pre>如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf-8编码的区别。 </li><li>【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。<br><br><span style="color:orange">说明</span>：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2-索引规约</title>
      <link href="/alibaba-p3c/52-dbi-statute/"/>
      <url>/alibaba-p3c/52-dbi-statute/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br><br><span style="color:orange">说明</span>：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 </li><li>【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。<br><br><span style="color:orange">说明</span>：即使双表join也要注意表索引、SQL性能。 </li><li>【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。<br><br><span style="color:orange">说明</span>：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 </li><li>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br><br><span style="color:orange">说明</span>：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</li><li>【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。<br><br><span style="color:green">正例</span>：where a=? and b=? order by c; 索引：a_b_c<br><br><span style="color:red">反例</span>：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b无法排序。 </li><li>【推荐】利用覆盖索引来进行查询操作，避免回表。<br><br><span style="color:orange">说明</span>：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br><br><span style="color:green">正例</span>：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。 </li><li>【推荐】利用延迟关联或者子查询优化超多分页场景。 <br><span style="color:orange">说明</span>：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。<br><br><span style="color:green">正例</span>：先快速定位需要获取的id段，然后再关联：       <pre>SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id </pre></li><li>【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。<br><br><span style="color:orange">说明</span>：<br>1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br>2）ref 指的是使用普通的索引（normal index）。<br>3）range 对索引进行范围检索。 <br><span style="color:red">反例</span>：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。 </li><li>【推荐】建组合索引的时候，区分度最高的在最左边。 <br><span style="color:green">正例</span>：如果where a=? and b=? ，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。<br><br><span style="color:orange">说明</span>：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;? and b=? 那么即使a的区分度更高，也必须把b放在索引的最前列。 </li><li>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。 </li><li>【参考】创建索引时避免有如下极端误解：  1）宁滥勿缺。认为一个查询就需要建一个索引。  2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。  3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1-建表规约</title>
      <link href="/alibaba-p3c/51-create-table-statute/"/>
      <url>/alibaba-p3c/51-create-table-statute/</url>
      
        <content type="html"><![CDATA[<h2 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h2><ol><li>【强制】表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsigned tinyint（ 1表示是，0表示否）。<br><br><span style="color:orange">说明</span>：任何字段如果为非负数，必须是<code>unsigned</code>。<br><br><span style="color:green">正例</span>：表达逻辑删除的字段名<code>is_deleted</code>，1表示删除，0表示未删除。 </li><li>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 <br><span style="color:orange">说明</span>：MySQL在Windows下不区分大小写，但在Linux下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 <br><span style="color:green">正例</span>：aliyun_admin，rdc_config，level3_name <br><span style="color:red">反例</span>：AliyunAdmin，rdcConfig，level_3_name </li><li>【强制】表名不使用复数名词。<br><br><span style="color:orange">说明</span>：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。 </li><li>【强制】禁用保留字，如<code>desc</code>、<code>range</code>、<code>match</code>、<code>delayed</code>等，请参考MySQL官方保留字。 </li><li>【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。<br><br><span style="color:orange">说明</span>：pk_ 即primary key；uk_ 即 unique key；idx_ 即index的简称。 </li><li>【强制】小数类型为decimal，禁止使用float和double。<br><br><span style="color:orange">说明</span>：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。 </li><li>【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。 </li><li>【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 </li><li>【强制】表必备三字段：id, gmt_create, gmt_modified。<br><br><span style="color:orange">说明</span>：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified的类型均为datetime类型，前者现在时表示主动创建，后者过去分词表示被动更新。 </li><li>【推荐】表的命名最好是加上“业务名称_表的作用”。<br><br><span style="color:green">正例</span>：alipay_task / force_project / trade_config </li><li>【推荐】库名与应用名称尽量一致。 </li><li>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 </li><li>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>1）不是频繁修改的字段。<br>2）不是varchar超长字段，更不能是text字段。<br><br><span style="color:green">正例</span>：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 </li><li>【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。 <br><span style="color:orange">说明</span>：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 </li><li>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 <br><span style="color:green">正例</span>：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 </li></ol><table><thead><tr><th>对象</th><th align="left">年龄区间</th><th align="left">类型</th><th align="left">字节</th></tr></thead><tbody><tr><td>人</td><td align="left">150岁之内</td><td align="left">unsigned tinyint</td><td align="left">1</td></tr><tr><td>龟</td><td align="left">数百岁</td><td align="left">unsigned smallint</td><td align="left">2</td></tr><tr><td>恐龙化石</td><td align="left">数千万岁</td><td align="left">unsigned int</td><td align="left">4</td></tr><tr><td>太阳</td><td align="left">约50亿年</td><td align="left">unsigned bigint</td><td align="left">8</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1-安全规约</title>
      <link href="/alibaba-p3c/41-security-statute/"/>
      <url>/alibaba-p3c/41-security-statute/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。<br><br><span style="color:orange">说明</span>：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。 </li><li>【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br><br><span style="color:orange">说明</span>：个人手机号码显示为:158****9119，隐藏中间4位，防止隐私泄露。 </li><li>【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。 </li><li>【强制】用户请求传入的任何参数必须做有效性验证。<br><br><span style="color:orange">说明</span>：忽略参数校验可能导致： <ul><li>page size过大导致内存溢出 </li><li>恶意order by导致数据库慢查询 </li><li>任意重定向 </li><li>SQL注入 </li><li>反序列化注入 </li><li>正则输入源串拒绝服务ReDoS<br><br><span style="color:orange">说明</span>：Java代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 </li></ul></li><li>【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。 </li><li>【强制】表单、AJAX提交必须执行CSRF安全过滤。<br><br><span style="color:orange">说明</span>：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用/网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。 </li><li>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷导致资损。<br><br><span style="color:orange">说明</span>：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 </li><li>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1-单元测试</title>
      <link href="/alibaba-p3c/31-unit-test/"/>
      <url>/alibaba-p3c/31-unit-test/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】好的单元测试必须遵守AIR原则。<br><br><span style="color:orange">说明</span>：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 <ul><li>A：Automatic（自动化） </li><li>I：Independent（独立性） </li><li>R：Repeatable（可重复） </li></ul></li><li>【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。 </li><li>【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。 <br><span style="color:red">反例</span>：method2需要依赖method1的执行，将执行结果作为method2的输入。 </li><li>【强制】单元测试是可以重复执行的，不能受到外界环境的影响。<br><br><span style="color:orange">说明</span>：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。 <br><span style="color:green">正例</span>：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI框架注入一个本地（内存）实现或者Mock实现。 </li><li>【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。<br><br><span style="color:orange">说明</span>：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。 </li><li>【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。<br><br><span style="color:orange">说明</span>：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。 </li><li>【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。<br><br><span style="color:orange">说明</span>：源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。 </li><li>【推荐】单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%<br><br><span style="color:orange">说明</span>：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。   </li><li>【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。 <ul><li>B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。 </li><li>C：Correct，正确的输入，并得到预期的结果。 </li><li>D：Design，与设计文档相结合，来编写单元测试。 </li><li>E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。 </li></ul></li><li>【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 <br><span style="color:red">反例</span>：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。 </li><li>【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。 <br><span style="color:green">正例</span>：在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。 </li><li>【推荐】对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。 </li><li>【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。 </li><li>【推荐】单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。 </li><li>【参考】为了更方便地进行单元测试，业务代码应避免以下情况：<ul><li>构造方法中做的事情过多。 </li><li>存在过多的全局变量和静态方法。 </li><li>存在过多的外部依赖。 </li><li>存在过多的条件语句。<br><br><span style="color:orange">说明</span>：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。 </li></ul></li><li>【参考】不要对单元测试存在如下误解： <ul><li>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。</li><li>单元测试代码是多余的。汽车的整体功能与各单元部件的测试正常与否是强相关的。 </li><li>单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。 </li><li>单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。 </li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2-日志规约</title>
      <link href="/alibaba-p3c/22-log-statute/"/>
      <url>/alibaba-p3c/22-log-statute/</url>
      
        <content type="html"><![CDATA[<h2 id="tags-代码规范"><a href="#tags-代码规范" class="headerlink" title="tags: [代码规范]"></a>tags: [代码规范]</h2><ol><li>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 <pre>import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class);  </pre></li><li>【强制】日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。 </li><li>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats/monitor/visit等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br><br><span style="color:green">正例</span>：mppserver应用中单独监控时区转换异常，如：<br>mppserver_monitor_timeZoneConvert.log<br><br><span style="color:orange">说明</span>：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。 </li><li>【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。<br><br><span style="color:orange">说明</span>：logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。<br><br><span style="color:green">正例</span>： <pre>（条件）    if (logger.isDebugEnabled()) {       logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);      }  </pre>     <br><span style="color:green">正例</span>： <pre>（占位符）        logger.debug("Processing trade with id: {} and symbol : {} ", id, symbol);   </pre></li><li>【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。<br><br><span style="color:green">正例</span>：<br>   <code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></li><li>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。<br><br><span style="color:green">正例</span>：<pre>logger.error(各类参数或者对象toString + "_" + e.getMessage(), e);</pre> </li><li>【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。 <br><span style="color:orange">说明</span>：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ </li><li>【推荐】可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出error级别，避免频繁报警。<br><br><span style="color:orange">说明</span>：注意日志输出的级别，error级别只记录系统逻辑出错、异常或者重要的错误信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1-异常日志</title>
      <link href="/alibaba-p3c/21-exception/"/>
      <url>/alibaba-p3c/21-exception/</url>
      
        <content type="html"><![CDATA[<h2 id="一-异常处理"><a href="#一-异常处理" class="headerlink" title="(一) 异常处理"></a>(一) 异常处理</h2><ol><li>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。<br><span style="color:orange">说明</span>：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过catch NumberFormatException来实现。 <br><span style="color:green">正例</span>：<pre>if (obj != null) {...} </pre><br><span style="color:red">反例</span>：<pre>try { obj.method() } catch (NullPointerException e) {…}</pre></li><li>【强制】异常不要用来做流程控制，条件控制。<br><br><span style="color:orange">说明</span>：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多。 </li><li>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。<br><br><span style="color:orange">说明</span>：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。<br><br><span style="color:green">正例</span>：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户。 </li><li>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 </li><li>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。 </li><li>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。<br><br><span style="color:orange">说明</span>：如果JDK7及以上，可以使用try-with-resources方式。 </li><li>【强制】不要在finally块中使用return。<br><br><span style="color:orange">说明</span>：finally块中的return返回后方法结束执行，不会再执行try块中的return语句。 </li><li>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br><br><span style="color:orange">说明</span>：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。 </li><li>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分<br><br><span style="color:orange">说明</span>什么情况下会返回null值。 <br><span style="color:orange">说明</span>：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。 </li><li>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景：<br>1）返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。<br><span style="color:red">反例</span>：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。<br>2） 数据库的查询结果可能为null。<br>3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。<br>4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。<br>5） 对于Session中获取的数据，建议NPE检查，避免空指针。<br>6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。<br><br><span style="color:green">正例</span>：使用JDK8的Optional类来防止NPE问题。 </li><li>【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。 </li><li>【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。<br><br><span style="color:orange">说明</span>：关于RPC方法返回方式使用Result方式的理由：<br><br>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。 </li><li>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。<br><br><span style="color:orange">说明</span>：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 <br><span style="color:green">正例</span>：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取： <pre>private boolean checkParam(DTO dto) {...}</pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.9-其他</title>
      <link href="/alibaba-p3c/19-other/"/>
      <url>/alibaba-p3c/19-other/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。<br><br><span style="color:orange">说明</span>：不要在方法体内定义：Pattern pattern = Pattern.compile(规则); </li><li>【强制】velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调用isXxx()方法。 <br><span style="color:orange">说明</span>：注意如果是Boolean包装类对象，优先调用getXxx()的方法。 </li><li>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。<br><br><span style="color:orange">说明</span>：如果var=null或者不存在，那么${var}会直接显示在页面上。 </li><li>【强制】注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的<code>nextInt</code>或者<code>nextLong</code>方法。 </li><li>【强制】获取当前毫秒数<pre>System.currentTimeMillis();</pre> 而不是<pre>new Date().getTime();</pre> <span style="color:orange">说明</span>：如果想获取更加精确的纳秒级时间值，使用<code>System.nanoTime()</code>的方式。在JDK8中，针对统计时间等场景，推荐使用<code>Instant</code>类。 </li><li>【推荐】不要在视图模板中加入任何复杂的逻辑。 <br><span style="color:orange">说明</span>：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。 </li><li>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。 </li><li>【推荐】及时清理不再使用的代码段或配置信息。<br><br><span style="color:orange">说明</span>：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。<br><br><span style="color:green">正例</span>：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(<code>///</code>)来说明注释掉代码的理由。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.8-注释规约</title>
      <link href="/alibaba-p3c/18-annotation-statute/"/>
      <url>/alibaba-p3c/18-annotation-statute/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用/<em>*内容</em>/格式，不得使用// xxx方式。<br><br><span style="color:orange">说明</span>：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 </li><li>【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。<br><br><span style="color:orange">说明</span>：对子类的实现要求，或者调用注意事项，请一并说明。 </li><li>【强制】所有的类都必须添加创建者和创建日期。 </li><li>【强制】方法内部单行注释，在被注释语句上方另起一行，使用<code>//</code>注释。方法内部多行注释使用<code>/* */</code>注释，注意与代码对齐。 </li><li>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 </li><li>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。<br><br><span style="color:red">反例</span>：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 </li><li>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。<br><br><span style="color:orange">说明</span>：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 </li><li>【参考】谨慎注释掉代码。在上方详细说明&lt;，而不是简单地注释掉。如果无用，则删除。<br><br><span style="color:orange">说明</span>：代码被注释掉有两种可能性：<br>1）后续会恢复此段代码逻辑。<br>2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。 </li><li>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同<br>天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。 </li><li>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br><br><span style="color:red">反例</span>：<pre><code>// put elephant into fridge  put(elephant, fridge);      方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。 </code></pre></li><li>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1） 待办事宜（<strong>TODO</strong>）:（ 标记人，标记时间，[预计处理时间]）    表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。<br>2） 错误，不能工作（<strong>FIXME</strong>）:（标记人，标记时间，[预计处理时间]）    在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.7-控制语句</title>
      <link href="/alibaba-p3c/17-control-statement/"/>
      <url>/alibaba-p3c/17-control-statement/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使空代码。 </li><li>【强制】在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：<pre>if (condition) statements;</pre></li><li>【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。<br><br><span style="color:orange">说明</span>：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。<br><br><span style="color:red">反例</span>：判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。 </li><li>【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成： <pre><code> if (condition) {                 ...                 return obj;     }    // 接着写else的业务逻辑代码; </code></pre><br><span style="color:orange">说明</span>：如果非得使用if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过3层。<br><br><span style="color:green">正例</span>：超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下： <pre><code>public void today() {      if (isBusy()) {      System.out.println(“change time.”);               return; }       if (isFree()) {     System.out.println(“go to travel.”);                return;     }  System.out.println(“stay at home to learn Alibaba Java Coding Guidelines.”);      return; } </code></pre></li><li>【推荐】除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。<br><br><span style="color:orange">说明</span>：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ <br><span style="color:green">正例</span>： <pre><code>// 伪代码如下 final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) {    ... }  </code></pre><span style="color:red">反例</span>：<pre><code>if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) {     ... }</code></pre></li><li>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。 </li><li>【推荐】避免采用取反逻辑运算符。<br><br><span style="color:orange">说明</span>：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。<br><br><span style="color:green">正例</span>：使用if (x &lt; 628) 来表达 x 小于628。<br><br><span style="color:red">反例</span>：使用if (!(x &gt;= 628)) 来表达 x 小于628。</li><li>【推荐】接口入参保护，这种场景常见的是用作批量操作的接口。 </li><li>【参考】下列情形，需要进行参数校验：<br>1） 调用频次低的方法。<br>2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。<br>3） 需要极高稳定性和可用性的方法。<br>4） 对外提供的开放接口，不管是RPC/API/HTTP接口。<br>5） 敏感权限入口。 </li><li>【参考】下列情形，不需要进行参数校验：<br><br>1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。<br><br>2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。<br><br>3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.6-并发处理</title>
      <link href="/alibaba-p3c/16-concurrent/"/>
      <url>/alibaba-p3c/16-concurrent/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。<br><br><span style="color:orange">说明</span>：资源驱动类、工具类、单例工厂类都需要注意。 </li><li>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。<br><br><span style="color:green">正例</span>：<pre><code> public class TimerTaskThread extends Thread {           public TimerTaskThread() {                 super.setName(&quot;TimerTaskThread&quot;);              ...      } }</code></pre></li><li>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br><br><span style="color:orange">说明</span>：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 </li><li>【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br><br><span style="color:orange">说明</span>：Executors返回的线程池对象的弊端如下：<br>1）<code>FixedThreadPool</code>和<code>SingleThreadPool</code>:   允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。<br>2）<code>CachedThreadPool</code>和<code>ScheduledThreadPool</code>:   允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</li><li>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。<br><br><span style="color:green">正例</span>：注意线程安全，使用<code>DateUtils</code>。亦推荐如下处理： <pre><code>private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {         Override         protected DateFormat initialValue() {              return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);         }    };</code></pre><span style="color:orange">说明</span>：如果是JDK8的应用，可以使用<code>Instant</code>代替<code>Date</code>，<code>LocalDateTime</code>代替<code>Calendar</code>，<code>DateTimeFormatter</code>代替<code>SimpleDateFormat</code>，官方给出的解释：<blockquote><p>simple beautiful strong immutable thread-safe。</p></blockquote></li><li>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。 <br><span style="color:orange">说明</span>：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。 </li><li>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 <br><span style="color:orange">说明</span>：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。 </li><li>【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。 <br><span style="color:orange">说明</span>：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。 </li><li>【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用<code>ScheduledExecutorService</code>则没有这个问题。 </li><li>【推荐】使用<code>CountDownLatch</code>进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。 <br><span style="color:orange">说明</span>：注意，子线程抛出异常堆栈，不能在主线程try-catch到。 </li><li>【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。<br><br><span style="color:orange">说明</span>：Random实例包括java.util.Random 的实例或者 Math.random()的方式。<br><br><span style="color:green">正例</span>：在JDK7之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例。 </li><li>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型。<br><br><span style="color:red">反例</span>：<pre><code>class Singleton {       private Helper helper = null;      public Helper getHelper() {        if (helper == null)       synchronized(this) {              if (helper == null)                helper = new Helper();          }            return helper;      }      // other methods and fields...  }</code></pre></li><li>【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：<pre><code>AtomicInteger count = new AtomicInteger(); count.addAndGet(1); </code></pre>如果是JDK8，推荐使用<code>LongAdder</code>对象，比<code>AtomicLong</code>性能更好（减少乐观锁的重试次数）。</li><li>【参考】 HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 </li><li>【参考】<code>ThreadLocal</code>无法解决共享对象的更新问题，<code>ThreadLocal</code>对象建议使用static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5-集合处理</title>
      <link href="/alibaba-p3c/15-collection/"/>
      <url>/alibaba-p3c/15-collection/</url>
      
        <content type="html"><![CDATA[<ol><li><p>【强制】关于<code>hashCode</code>和<code>equals</code>的处理，遵循如下规则：<br><br>1） 只要重写<code>equals</code>，就必须重写<code>hashCode</code>。<br><br>2） 因为Set存储的是不重复的对象，依据<code>hashCode</code>和<code>equals</code>进行判断，所以Set存储的对象必须重写这两个方法。<br><br>3） 如果自定义对象作为Map的键，那么必须重写<code>hashCode</code>和<code>equals</code>。<br><br><span style="color:orange">说明</span>：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。 </p></li><li><p>【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.<br><br><span style="color:orange">说明</span>：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。 </p></li><li><p>【强制】在subList场景中，<strong>高度注意</strong>对原集合元素个数的修改，会导致子列表的遍历、增加、删除均会产生ConcurrentModificationException 异常。 </p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是<code>list.size()</code>。<br><br><span style="color:orange">说明</span>：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。<br><br><span style="color:green">正例</span>： </p><pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);      list.add(&quot;guan&quot;);     list.add(&quot;bao&quot;);       String[] array = new String[list.size()];      array = list.toArray(array);</code></pre><p><span style="color:red">反例</span>：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。</p></li><li><p>【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。<br><br><span style="color:orange">说明</span>：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><pre><code>String[] str = new String[] { &quot;you&quot;, &quot;wu&quot; };     List list = Arrays.asList(str); </code></pre><p>第一种情况：list.add(“yangguanbao”); 运行时异常。<br><br>第二种情况：str[0] = “gujin”; 那么list.get(0)也会随之修改。</p></li><li><p>【强制】泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据，此写法的泛型集合不能使用add方法，而<code>&lt;? super T&gt;</code>不能使用get方法，作为接口调用赋值时易出错。<br><br><span style="color:orange">说明</span>：扩展说一下PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用<code>&lt;? super T&gt;</code>。 </p></li><li><p>【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。<br><br><span style="color:green">正例</span>： </p><pre><code> Iterator&lt;String&gt; iterator = list.iterator();  while (iterator.hasNext()) {                 String item = iterator.next();                               if (删除元素的条件) {                                        iterator.remove();                              }       }</code></pre><p><span style="color:red">反例</span>：</p><pre><code> List&lt;String&gt; list = new ArrayList&lt;String&gt;();       list.add(&quot;1&quot;);       list.add(&quot;2&quot;);       for (String item : list) {             if (&quot;1&quot;.equals(item)) {                     list.remove(item);                }    }</code></pre><p><span style="color:orange">说明</span>：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p></li><li><p>【强制】 在JDK7版本及以上，<code>Comparator</code>要满足如下三个条件，不然<code>Arrays.sort</code>，<code>Collections.sort</code>会报IllegalArgumentException异常。<br><br><span style="color:orange">说明</span>：三个条件如下：<br><br>1） x，y的比较结果和y，x的比较结果相反。<br><br>2） x&gt;y，y&gt;z，则x&gt;z。<br><br>3） x=y，则x，z比较结果和y，z比较结果相同。<br><br><span style="color:red">反例</span>：下例中没有处理相等的情况，实际使用中可能会出现异常：</p><pre><code> new Comparator&lt;Student&gt;() {                  @Override                 public int compare(Student o1, Student o2) {                       return o1.getId() &gt; o2.getId() ? 1 : -1;              }   };  </code></pre></li><li><p>【推荐】集合初始化时，指定集合初始值大小。<br><br><span style="color:orange">说明</span>：HashMap使用HashMap(int initialCapacity) 初始化，<br><br><span style="color:green">正例</span>：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即loader factor）默认为0.75，如果暂时无法确定初始值大小，请设置为16（即默认值）。 <br><span style="color:red">反例</span>：HashMap需要放置1024个元素，由于没有设置容量初始大小，随着元素不断增加，容量7次被迫扩大，resize需要重建hash表，严重影响性能。 </p></li><li><p>【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。<br><br><span style="color:orange">说明</span>：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.forEach方法。<br><br><span style="color:green">正例</span>：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。 </p></li><li><p>【推荐】高度注意Map类集合K/V能不能存储null值的情况，如下表格：</p><pre><code>| 集合类            | Key          | Value        | Super       | 说明                   ||-------------------|--------------|--------------|-------------|------------------------|| Hashtable         | 不允许为null | 不允许为null | Dictionary  | 线程安全               || ConcurrentHashMap | 不允许为null | 不允许为null | AbstractMap | 锁分段技术（JDK8:CAS）  || TreeMap           | 不允许为null | 允许为null   | AbstractMap | 线程不安全             || HashMap           | 允许为null   | 允许为null   | AbstractMap | 线程不安全             |</code></pre><p><span style="color:red">反例</span>： 由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，而事实上，存储null值时会抛出NPE异常。</p></li><li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。<br><br><span style="color:orange">说明</span>：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。 </p></li><li><p>【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作。 </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4-OOP规约</title>
      <link href="/alibaba-p3c/14-oop-statute/"/>
      <url>/alibaba-p3c/14-oop-statute/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用<strong>类名</strong>来访问即可。 </li><li>【强制】所有的覆写方法，必须加@Override注解。<br><br><span style="color:orange">说明</span>：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 </li><li>【强制】相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。<br><br><span style="color:orange">说明</span>：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br><br><span style="color:green">正例</span>：<pre><code>public User getUsers(String type, Integer... ids) {...} </code></pre></li><li>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加<code>@Deprecated</code>注解，并清晰地说明采用的新接口或者新服务是什么。 </li><li>【强制】不能使用过时的类或方法。<br><br><span style="color:orange">说明</span>：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 </li><li>【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。<br><br><span style="color:green">正例</span>：”test”.equals(object);<br><br><span style="color:red">反例</span>：object.equals(“test”);<br><br><span style="color:orange">说明</span>：推荐使用java.util.Objects#equals（JDK7引入的工具类）</li><li>【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。<br><br><span style="color:orange">说明</span>：对于Integer var = ?  在-128至127范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。 </li><li>关于基本数据类型与包装数据类型的使用标准如下：<br><br>1） 【强制】所有的POJO类属性必须使用包装数据类型。<br><br>2） 【强制】RPC方法的返回值和参数必须使用包装数据类型。<br><br>3） 【推荐】所有的局部变量使用基本数据类型。<br><br><span style="color:orange">说明</span>：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。<br><br><span style="color:green">正例</span>：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。<br><br><span style="color:red">反例</span>：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。 </li><li>【强制】定义DO/DTO/VO等POJO类时，不要设定任何属性<strong>默认值</strong>。<br><br><span style="color:red">反例</span>：POJO类的gmtCreate默认值为new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 </li><li>【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。<br><br><span style="color:orange">说明</span>：注意serialVersionUID不一致会抛出序列化运行时异常。 </li><li>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。 </li><li>【强制】POJO类必须写toString方法。使用IDE中的工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。 <br><span style="color:orange">说明</span>：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。 </li><li>【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。<br><br><span style="color:orange">说明</span>：<pre><code>String str = &quot;a,b,c,,&quot;;  String[] ary = str.split(&quot;,&quot;);  // 预期大于3，结果是3 System.out.println(ary.length);</code></pre></li><li>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第15条规则。 </li><li>【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。<br><br><span style="color:orange">说明</span>：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。 </li><li>【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度。<br><br><span style="color:red">反例</span>：<pre><code>public Integer getData() {        if (condition) {      return this.data + 100;    } else {     return this.data - 100;   }  }</code></pre></li><li>【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。<br><br><span style="color:orange">说明</span>：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。  <br><span style="color:red">反例</span>：<pre><code>String str = &quot;start&quot;;for (int i = 0; i &lt; 100; i++) {  str = str + &quot;hello&quot;;      }</code></pre></li><li>【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字：<br><br>1） 不允许被继承的类，如：String类。<br><br>2） 不允许修改引用的域对象，如：POJO类的域变量。<br><br>3） 不允许被重写的方法，如：POJO类的setter方法。<br><br>4） 不允许运行过程中重新赋值的局部变量。<br><br>5） 避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。 </li><li>【推荐】慎用Object的clone方法来拷贝对象。<br><br><span style="color:orange">说明</span>：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。 </li><li>【推荐】类成员与方法访问控制从严：<br><br>1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。<br><br>2） 工具类不允许有public或default构造方法。<br><br>3） 类非static成员变量并且与子类共享，必须是protected。<br><br>4） 类非static成员变量并且仅在本类使用，必须是private。<br><br>5） 类static成员变量如果仅在本类使用，必须是private。<br><br>6） 若是static成员变量，必须考虑是否为final。<br><br>7） 类成员方法只供类内部调用，必须是private。<br><br>8） 类成员方法只对继承类公开，那么限制为protected。<br><br><span style="color:orange">说明</span>：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3-代码格式</title>
      <link href="/alibaba-p3c/13-code-format/"/>
      <url>/alibaba-p3c/13-code-format/</url>
      
        <content type="html"><![CDATA[<ol><li><p>【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成<code>{}</code>即可，不需要换行；如果是非空代码块则：<br><br>1） 左大括号前不换行。<br><br>2） 左大括号后换行。<br><br>3） 右大括号前换行。<br><br>4） 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。 </p></li><li><p>【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第5条下方正例提示。<br><br><span style="color:red">反例</span>：</p><pre><code>if (空格a == b空格)</code></pre></li><li><p>【强制】if/for/while/switch/do等保留字与括号之间都必须加空格。 </p></li><li><p>【强制】任何二目、三目运算符的左右两边都需要加一个空格。<br><br><span style="color:orange">说明</span>：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p></li><li><p>【强制】采用4个空格缩进，禁止使用tab字符。<br><br><span style="color:orange">说明</span>：<br> 如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选<code>Use tab character</code>；而在eclipse中，必须勾选<code>insert spaces for tabs</code>。<br><br><span style="color:green">正例</span>： （涉及1-5点）</p><pre><code>   public static void main(String[] args) {       // 缩进4个空格       String say = &quot;hello&quot;;       // 运算符的左右必须有一个空格       int flag = 0;       // 关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格       if (flag == 0) {           System.out.println(say);       }       // 左大括号前加空格且不换行；左大括号后换行       if (flag == 1) {           System.out.println(&quot;world&quot;);           // 右大括号前换行，右大括号后有else，不用换行       } else {           System.out.println(&quot;ok&quot;);           // 在右大括号后直接结束，则必须换行       }   }</code></pre></li><li><p>【强制】注释的双斜线与注释内容之间有且仅有一个空格。<br><br><span style="color:green">正例</span>：</p><pre><code>// 这是示例注释，请注意在双斜线之后有一个空格  String ygb = new String(); </code></pre></li><li><p>【强制】单行字符数限制不超过120个，超出需要换行，换行时遵循如下原则：<br><br>1）第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例。<br><br>2）运算符与下文一起换行。<br><br>3）方法调用的点符号与下文一起换行。<br><br>4） 方法调用时，多个参数，需要换行时，在逗号后进行。<br><br>5） 在括号前不要换行，见反例。<br><br><span style="color:green">正例</span>：</p><pre><code>StringBuffer sb = new StringBuffer();  // 超过120个字符的情况下，换行缩进4个空格，点号和方法名称一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...                .append(&quot;huang&quot;)...                .append(&quot;huang&quot;)...                .append(&quot;huang&quot;);</code></pre><p><br><span style="color:red">反例</span>：</p><pre><code>StringBuffer sb = new StringBuffer();  // 超过120个字符的情况下，不要在括号前换行  sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append      (&quot;huang&quot;);    // 参数很多的方法调用可能超过120个字符，不要在逗号前换行  method(args1, args2, args3, ... , argsX); </code></pre></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。<br><br><span style="color:green">正例</span>：下例中实参的”a”,后边必须要有一个空格。 </p><pre><code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); </code></pre></li><li><p>【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用Windows格式。 </p></li><li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。<br><br><span style="color:green">正例</span>： </p><pre><code>int a = 3;  long b = 4L;  float c = 5F;  StringBuffer sb = new StringBuffer();</code></pre><p><span style="color:orange">说明</span>：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的情况下，是非常累赘的事情。 </p></li><li><p>【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。<br><br><span style="color:orange">说明</span>：没有必要插入<strong>多个空行</strong>进行隔开。 </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2-常量定义</title>
      <link href="/alibaba-p3c/12-const-define/"/>
      <url>/alibaba-p3c/12-const-define/</url>
      
        <content type="html"><![CDATA[<ol><li>【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。<br><br><span style="color:red">反例</span>：<pre><code>String key = &quot;Id#taobao_&quot; + tradeId;       cache.put(key, value); </code></pre></li><li>【强制】long或者Long初始赋值时，使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。<br><br><span style="color:orange">说明</span>：<pre>Long a = 2l;</pre> 写的是数字的<code>21</code>，还是Long型的<code>2</code>? </li><li>【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。<br><br><span style="color:orange">说明</span>：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。<br><br><span style="color:green">正例</span>：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。 </li><li>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<br>1） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。<br>2） 应用内共享常量：放置在一方库中，通常是子模块中的constant目录下。<br><br><span style="color:red">反例</span>：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：<pre><code> 类A中：public static final String YES = &quot;yes&quot;; 类B中：public static final String YES = &quot;y&quot;; A.YES.equals(B.YES) 预期是true，但实际返回为false，导致线上问题。</code></pre>3） 子工程内部共享常量：即在当前子工程的constant目录下。<br>4） 包内共享常量：即在当前包下单独的constant目录下。<br>5） 类内共享常量：直接在类内部private static final定义。 </li><li>【推荐】如果变量值仅在一个固定范围内变化用enum类型来定义。 说明：如果存在名称之外的延伸属性使用enum类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。<br><br><span style="color:green">正例</span>： <pre><code>public enum SeasonEnum {          SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);       int seq;        SeasonEnum(int seq){                    this.seq = seq;            } } </code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1-命名风格</title>
      <link href="/alibaba-p3c/11-naming-style/"/>
      <url>/alibaba-p3c/11-naming-style/</url>
      
        <content type="html"><![CDATA[<h2 id="（一）命名风格"><a href="#（一）命名风格" class="headerlink" title="（一）命名风格"></a>（一）命名风格</h2><ol><li>【强制】代码中的命名均不能以<strong>下划线或美元符号</strong>开始，也不能以<strong>下划线或美元符号</strong>结束。<br> <br><span style="color:red">反例</span>：<code>_name / __name / $name / name_ / name$ / name__</code></li><li>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。<br> <br><span style="color:orange">说明</span>：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。<br> <br><span style="color:green">正例</span>：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。<br> <br><span style="color:red">反例</span>：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3 </li><li>【强制】类名使用<code>UpperCamelCase</code>风格，但以下情形例外：DO / BO / DTO / VO / AO / PO等。<br><br><span style="color:green">正例</span>：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion<br><br><span style="color:red">反例</span>：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion </li><li>【强制】方法名、参数名、成员变量、局部变量都统一使用<code>lowerCamelCase</code>风格，必须遵从驼峰形式。<br><br><span style="color:green">正例</span>： localValue / getHttpMessage() / inputUserId </li><li>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br><br><span style="color:green">正例</span>：MAX_STOCK_COUNT<br><br><span style="color:red">反例</span>：MAX_COUNT </li><li>【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类名开始，以Test结尾。 </li><li>【强制】类型与中括号紧挨相连来定义数组。<br><br><span style="color:green">正例</span>：定义整形数组<code>int[] arrayDemo;</code><br><br><span style="color:red">反例</span>：在main参数中，使用<code>String args[]</code>来定义。 </li><li>【强制】POJO类中布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误。<br><br><span style="color:red">反例</span>：定义为基本数据类型<code>Boolean isDeleted；</code>的属性，它的方法也是<code>isDeleted()</code>，RPC框架在反向解析的时候，“误以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。</li><li>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br><br><span style="color:green">正例</span>：应用工具类包名为com.alibaba.ai.util、类名为MessageUtils（此规则参考spring的框架结构） </li><li>【强制】杜绝完全不规范的缩写，避免望文不知义。<br><br><span style="color:red">反例</span>：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 </li><li>【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。<br><br><span style="color:green">正例</span>：从远程仓库拉取代码的类命名为PullCodeFromRemoteRepository。<br><br><span style="color:red">反例</span>：变量int a; 的随意命名方式。 </li><li>【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。<br><br><span style="color:orange">说明</span>：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。<br><br><span style="color:green">正例</span>：<pre><code>public class OrderFactory;public class LoginProxy;public class ResourceObserver; </code></pre></li><li>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。<br><br><span style="color:green">正例</span>：接口方法签名void f(); 接口基础常量String COMPANY = “alibaba”;<br><br><span style="color:red">反例</span>：接口方法定义public abstract void f();<br><br><span style="color:orange">说明</span>：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。 </li><li>接口和实现类的命名有两套规则：<br>  1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。<br>  <br><span style="color:green">正例</span>：CacheServiceImpl实现CacheService接口。<br><br>  2） 【推荐】 如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able的形式）。<br>  <br><span style="color:green">正例</span>：AbstractTranslator实现 Translatable。 </li><li>【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br><br><span style="color:orange">说明</span>：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br><br><span style="color:green">正例</span>：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKNOWN_REASON。 </li><li>【参考】各层命名规约：<br>A) Service/DAO层方法命名规约<br><br>  1） 获取单个对象的方法用get作前缀。<br>  <br>2） 获取多个对象的方法用list作前缀。<br>  <br>3） 获取统计值的方法用count作前缀。<br>  4） 插入的方法用save/insert作前缀。<br>  5） 删除的方法用remove/delete作前缀。<br>  6） 修改的方法用update作前缀。<br><br>B) 领域模型命名规约 <br><br>  1） 数据对象：xxxDO，xxx即为数据表名。<br>  2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。<br>  3） 展示对象：xxxVO，xxx一般为网页名称。<br>  4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。 </li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112-模式的秘密---单例模式</title>
      <link href="/imooc/112-singleton-mode/"/>
      <url>/imooc/112-singleton-mode/</url>
      
        <content type="html"><![CDATA[<p>系列课程：<a href="https://www.tuyrk.cn/imooc/18-java-mode/">模式宗师养成宝典之Java版</a></p><blockquote><p><a href="http://www.imooc.com/learn/112" target="_blank" rel="noopener">http://www.imooc.com/learn/112</a></p><p>简介：设计模式是前辈们在多年开发工作中经验的总结，可以提高代码的可重用性、可靠性和规范性，让代码更容易理解，而单例模式是在Java中最重要、最简单、最常用的设计模式之一，让我们一起来揭开它的神秘面纱吧。</p></blockquote><p>@[TOC]</p><h2 id="第1章-单例模式简介"><a href="#第1章-单例模式简介" class="headerlink" title="第1章 单例模式简介"></a>第1章 单例模式简介</h2><blockquote><p>本章节让我们一起来学习设计模式和单例模式的相关概念、作用及分类</p></blockquote><h3 id="1-1-单例模式简介-03-43"><a href="#1-1-单例模式简介-03-43" class="headerlink" title="1-1 单例模式简介 (03:43)"></a>1-1 单例模式简介 (03:43)</h3><p>单例模式</p><blockquote><ul><li>概念及应用场景</li><li>饿汉模式</li><li>懒汉模式</li><li>饿汉模式和懒汉模式的区别</li></ul></blockquote><p>什么是设计模式（Design Pattern）</p><blockquote><p>是一套被反复使用、多数人知晓的、<br>经过分类编目的、代码设计经验的总结</p></blockquote><p>目的</p><blockquote><p>使用设计模式是为了可重用代码、<br>让代码更容易被他人理解、保证代码可靠性</p></blockquote><p>设计模式（23种）：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式</p><p>单例设计模式</p><blockquote><p>有些对象我们只需要一个。比如：配置文件、工具类、线程池、缓存、日志对象等<br>如果创造出多个实例，就会导致许多问题，比如占用过多资源，不一致的结果等。<br>单例模式保证整个应用中某个实例有且仅有一个</p></blockquote><h2 id="第2章-单例模式的实现"><a href="#第2章-单例模式的实现" class="headerlink" title="第2章 单例模式的实现"></a>第2章 单例模式的实现</h2><blockquote><p>本章节主要讲解单例模式中的饿汉模式和懒汉模式的实现</p></blockquote><ul><li>懒汉模式</li><li>饿汉模式</li></ul><h3 id="2-1-单例模式的饿汉式实现-10-18"><a href="#2-1-单例模式的饿汉式实现-10-18" class="headerlink" title="2-1 单例模式的饿汉式实现 (10:18)"></a>2-1 单例模式的饿汉式实现 (10:18)</h3><ol><li><p>Singleton类编写</p><pre><code class="java">public class Singleton {    // 1. 将构造方法私有化，不允许外部直接创建对象。    private Singleton() {    }    // 2. 创建类的唯一实例，使用private static修饰    // 此处代码在何时加载？    private static Singleton instance = new Singleton();    // 3. 提供一个用于获取实例的方法，使用public static修饰    public static Singleton getInstance() {        return instance;    }}</code></pre></li><li><p>SingletonTest测试类编写</p><pre><code class="java">public class SingletonTest {    public static void main(String[] args) {        Singleton s1 = Singleton.getInstance();        Singleton s2 = Singleton.getInstance();        System.out.println(s1 == s2);// true    }}</code></pre></li></ol><p>思考此代码在何时加载？</p><pre><code class="java">private static Singleton instance = new Singleton();</code></pre><ul><li>当类被加载的时候加载，不论其他程序是否调用。被称为饿汉模式</li></ul><h3 id="2-2-单例模式的懒汉式实现-04-23"><a href="#2-2-单例模式的懒汉式实现-04-23" class="headerlink" title="2-2 单例模式的懒汉式实现 (04:23)"></a>2-2 单例模式的懒汉式实现 (04:23)</h3><ol><li><p>Singleton2类编写</p><pre><code class="java">public class Singleton2 {    // 1. 将构造方法私有化，不允许外部直接创建对象    private Singleton2() {    }    // 2. 声明类的唯一实例，使用private static修饰    private static Singleton2 instance;    // 3. 提供一个用于获取实例的方法，使用public static修饰    public static Singleton2 getInstance() {        if (instance == null) {            instance = new Singleton2();        }        return instance;    }}</code></pre></li><li><p>SingletonTest测试类编写</p><pre><code class="java">public class SingletonTest {    public static void main(String[] args) {        Singleton2 s3 = Singleton2.getInstance();        Singleton2 s4 = Singleton2.getInstance();        System.out.println(s3 == s4);// true    }}</code></pre></li></ol><h2 id="第3章-“饿汉模式”和“懒汉模式”的区别"><a href="#第3章-“饿汉模式”和“懒汉模式”的区别" class="headerlink" title="第3章 “饿汉模式”和“懒汉模式”的区别"></a>第3章 “饿汉模式”和“懒汉模式”的区别</h2><blockquote><p>理解饿汉模式和懒汉模式的区别，活学活用</p></blockquote><h3 id="3-1-“饿汉式”-pk-“懒汉式”-01-52"><a href="#3-1-“饿汉式”-pk-“懒汉式”-01-52" class="headerlink" title="3-1 “饿汉式” pk “懒汉式” (01:52)"></a>3-1 “饿汉式” pk “懒汉式” (01:52)</h3><p>区别：</p><ol><li>饿汉模式的特点是加载类时比较慢，但运行时获取对象的速度比较快，线程安全</li><li>懒汉模式的特点是加载类时比较快，但运行时获取对象的速度比较慢，线程不安全</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>139-课程结束，内容回顾，下季内容预告</title>
      <link href="/wang-thread/139-summary/"/>
      <url>/wang-thread/139-summary/</url>
      
        <content type="html"><![CDATA[<p>Synchronized关键字并不会比其他显式锁性能差。（底层已经过优化）</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138-给线程池增加自动扩充线程数量，以及闲时自动回收的功能</title>
      <link href="/wang-thread/138-thread-pool-expan/"/>
      <url>/wang-thread/138-thread-pool-expan/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">public class SimpleThreadPool extends Thread {    // 最小线程数量    private int min;    // 活跃线程数量    private int active;    // 最大线程数量    private int max;    // 传参线程池大小(当前线程池中线程的数量)    private int size;    // 线程队列的大小    private final int queueSize;    // 拒绝策略    private final DiscardPolicy discardPolicy;    // 线程池是否被销毁    private volatile boolean destroy = false;    // 默认线程队列的大小    private static final int DEFAULT_TASK_QUEUE_SIZE = 2000;    // 默认拒绝策略-抛出异常    public static final DiscardPolicy DEFAULT_DISCARD_POLICY = () -&gt; {        throw new DiscardException(&quot;Discard This Task.&quot;);    };    // 线程名自增序号    private static AtomicInteger sequence = new AtomicInteger();    // 线程名前缀    private static final String THREAD_PREFIX = &quot;SIMPLE_THREAD_POOL-&quot;;    // 线程组    private static final ThreadGroup GROUP = new ThreadGroup(&quot;Pool_Group&quot;);    // 任务队列    private static final LinkedList&lt;Runnable&gt; TASK_QUEUE = new LinkedList&lt;&gt;();    // 线程队列    private static final List&lt;WorkerTask&gt; THREAD_QUEUE = new ArrayList&lt;&gt;();    public SimpleThreadPool() {        this(4, 8, 12, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);    }    /**     * 构造方法     * @param min           最小线程数量     * @param active        活跃线程数量     * @param max           最大线程数量     * @param queueSize     线程队列的大小     * @param discardPolicy 拒绝策略     */    public SimpleThreadPool(int min, int active, int max, int queueSize, DiscardPolicy discardPolicy) {        this.min = min;        this.active = active;        this.max = max;        this.queueSize = queueSize;        this.discardPolicy = discardPolicy;        init();    }    @Override    public void run() {        while (!destroy) {            System.out.printf(&quot;Pool#Min:%d,Active:%d,Max:%d,Current:%d,QueueSize:%d\n&quot;,                    this.min, this.active, this.max, this.size, TASK_QUEUE.size());            try {                Thread.sleep(5_000L);                // 任务队列数量过大，线程队列的数量扩充到active                if (size &lt; active &amp;&amp; active &lt; TASK_QUEUE.size()) {                    IntStream.range(size, active).forEach(i -&gt; createWorkTask());                    size = active;                    System.out.println(&quot;The Pool incremented to active.&quot;);                }                // 任务队列数量过大，线程队列的数量扩充到max                else if (size &lt; max &amp;&amp; max &lt; TASK_QUEUE.size()) {                    IntStream.range(active, max).forEach(i -&gt; createWorkTask());                    size = max;                    System.out.println(&quot;The Pool incremented to max.&quot;);                }                // 防止新插入任务队列的任务使用线程队列中的线程执行任务。                synchronized (THREAD_QUEUE) {                    // 任务队列数量为空，线程队列的数量减少到active                    if (size &gt; active &amp;&amp; TASK_QUEUE.isEmpty()) {                        System.out.println(&quot;=========Reduce=========&quot;);                        int releaseSize = size - active;                        for (Iterator&lt;WorkerTask&gt; it = THREAD_QUEUE.iterator(); it.hasNext(); ) {                            if (releaseSize &lt;= 0) {                                break;                            }                            WorkerTask task = it.next();                            task.interrupt();                            task.close();                            it.remove();                            releaseSize--;                        }                        size = active;                    }                }            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    private void init() {        IntStream.range(0, this.min).forEach(i -&gt; createWorkTask());        this.size = this.min;        this.start();    }    private void createWorkTask() {        WorkerTask task = new WorkerTask(GROUP, THREAD_PREFIX + (sequence.getAndIncrement()));        task.start();        THREAD_QUEUE.add(task);    }    // 提交任务    public void submit(Runnable runnable) {        // 如果线程池被销毁，不能添加任务到任务队列        if (destroy) {            throw new IllegalThreadStateException(&quot;The thread pool already destroy and not allow submit task.&quot;);        }        synchronized (TASK_QUEUE) {            // 任务队列数量超过阈值，则执行拒绝策略            if (TASK_QUEUE.size() &gt; queueSize) {                discardPolicy.discard();            }            TASK_QUEUE.addLast(runnable);            TASK_QUEUE.notifyAll();        }    }    // 关闭线程池中的线程    public void shutdown() throws InterruptedException {        // 当任务队列还有任务，则稍微等待。        while (!TASK_QUEUE.isEmpty()) {            Thread.sleep(50);        }        // 判断线程中有没有正在运行的任务        synchronized (THREAD_QUEUE) {            int initVal = THREAD_QUEUE.size();            while (initVal &gt; 0) {                for (WorkerTask task : THREAD_QUEUE) {                    if (task.getTaskState() == TaskState.BLOCKED) {                        task.interrupt();                        task.close();                        initVal--;                    } else {                        Thread.sleep(10);                    }                }            }        }        System.out.println(&quot;Group active count is &quot; + GROUP.activeCount());        this.destroy = true;        System.out.println(&quot;The thread pool disposed.&quot;);    }    // 封装任务类    private static class WorkerTask extends Thread {        private volatile TaskState taskState = TaskState.FREE;        public TaskState getTaskState() {            return this.taskState;        }        public WorkerTask(ThreadGroup group, String name) {            super(group, name);        }        @Override        public void run() {            OUTER:            while (this.taskState != TaskState.DEAD) {                Runnable runnable;                synchronized (TASK_QUEUE) {                    // 任务队列为空，则进入阻塞状态                    while (TASK_QUEUE.isEmpty()) {                        try {                            this.taskState = TaskState.BLOCKED;                            TASK_QUEUE.wait();                        } catch (InterruptedException e) {                            System.out.println(&quot;Closed.&quot;);                            break OUTER;                        }                    }                    // 任务队列不为空，取出任务                    runnable = TASK_QUEUE.removeFirst();                }                // 任务不为空，则执行任务                if (runnable != null) {                    this.taskState = TaskState.RUNNING;                    runnable.run();                    this.taskState = TaskState.FREE;                }            }        }        public void close() {            this.taskState = TaskState.DEAD;        }    }    // 线程状态    private enum TaskState {        FREE, RUNNING, BLOCKED, DEAD    }    // 拒绝策略    public interface DiscardPolicy {        void discard() throws DiscardException;    }    // 拒绝策略异常    public static class DiscardException extends RuntimeException {        public DiscardException(String message) {            super(message);        }    }}</code></pre><pre><code class="java">public static void main(String[] args) throws InterruptedException {    SimpleThreadPool threadPool = new SimpleThreadPool();    IntStream.rangeClosed(1, 40).forEach(i -&gt; {        threadPool.submit(() -&gt; {            System.out.printf(&quot;The runnable %d be serviced by %s start.\n&quot;, i, Thread.currentThread().getName());            Thread.sleep(3_000L);            System.out.printf(&quot;The runnable %d be serviced by %s finished.\n&quot;, i, Thread.currentThread().getName());        });    });    Thread.sleep(30_000L);    threadPool.shutdown();// 关闭线程池中的线程}</code></pre><p>升级改造：</p><ul><li><p>批次处理任务</p></li><li><p>处理完成后立即返回结果</p></li><li><p>立即shutdown，并返回未执行完成的<code>List&lt;Runnable&gt;</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>137-给线程池增加拒绝策略以及停止方法</title>
      <link href="/wang-thread/137-thread-pool-discard/"/>
      <url>/wang-thread/137-thread-pool-discard/</url>
      
        <content type="html"><![CDATA[<p>拒绝策略：线程池不能无限的提交任务，当线程处理不过来时，任务就会积压到任务队列。当任务数量达到阈值时就会执行一些操作拒绝再次加入到任务队列。</p><pre><code class="java">public class SimpleThreadPool {    // 传参线程池大小    private final int size;    // 线程队列的大小    private final int queueSize;    // 拒绝策略    private final DiscardPolicy discardPolicy;    // 线程池是否被销毁    private volatile boolean destory = false;    // 默认线程池大小    private static final int DEFAULT_SIZE = 10;    // 默认线程队列的大小    private static final int DEFAULT_TASK_QUEUE_SIZE = 2000;    // 默认拒绝策略-抛出异常    public static final DiscardPolicy DEFAULT_DISCARD_POLICY = () -&gt; {        throw new DiscardException(&quot;&quot;);    };    // 线程名自增序号    private static AtomicInteger sequence = new AtomicInteger();    // 线程名前缀    private static final String THREAD_PREFIX = &quot;SIMPLE_THREAD_POOL-&quot;;    // 线程组    private static final ThreadGroup GROUP = new ThreadGroup(&quot;Pool_Group&quot;);    // 任务队列    private static final LinkedList&lt;Runnable&gt; TASK_QUEUE = new LinkedList&lt;&gt;();    // 线程队列    private static final List&lt;WorkerTask&gt; THREAD_QUEUE = new ArrayList&lt;&gt;();    public SimpleThreadPool() {        this(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);    }    public SimpleThreadPool(int size, int queueSize, DiscardPolicy discardPolicy) {        this.size = size;        this.queueSize = queueSize;        this.discardPolicy = discardPolicy;        init();    }    private void init() {        for (int i = 0; i &lt; size; i++) {            createWorkTask();        }    }    private void createWorkTask() {        WorkerTask task = new WorkerTask(GROUP, THREAD_PREFIX + (sequence.getAndIncrement()));        task.start();        THREAD_QUEUE.add(task);    }    // 提交任务    public void submit(Runnable runnable) {        // 如果线程池被销毁，不能添加任务到任务队列        if (destory) {            throw new IllegalThreadStateException(&quot;The thread pool already destroy and not allow submit task.&quot;);        }        synchronized (TASK_QUEUE) {            // 任务队列数量超过阈值，则执行拒绝策略            if (TASK_QUEUE.size() &gt; queueSize) {                discardPolicy.discard();            }            TASK_QUEUE.addLast(runnable);            TASK_QUEUE.notifyAll();        }    }    // 关闭线程池中的线程    public void shutdown() throws InterruptedException {        // 当任务队列还有任务，则稍微等待。        while (!TASK_QUEUE.isEmpty()) {            Thread.sleep(50);        }        // 判断线程中有没有正在运行的任务        int initVal = THREAD_QUEUE.size();        while (initVal &gt; 0) {            for (WorkerTask task : THREAD_QUEUE) {                if (task.getTaskState() == TaskState.BLOCKED) {                    task.interrupt();                    task.close();                    initVal--;                } else {                    Thread.sleep(10);                }            }        }        this.destory = true;        System.out.println(&quot;The thread pool disposed.&quot;);    }    public int getSize() {        return size;    }    public int getQueueSize() {        return queueSize;    }    public boolean destory() {        return destory;    }    // 封装任务类    private static class WorkerTask extends Thread {        private volatile TaskState taskState = TaskState.FREE;        public TaskState getTaskState() {            return this.taskState;        }        public WorkerTask(ThreadGroup group, String name) {            super(group, name);        }        @Override        public void run() {            OUTER:            while (this.taskState != TaskState.DEAD) {                Runnable runnable;                synchronized (TASK_QUEUE) {                    // 任务队列为空，则进入阻塞状态                    while (TASK_QUEUE.isEmpty()) {                        try {                            this.taskState = TaskState.BLOCKED;                            TASK_QUEUE.wait();                        } catch (InterruptedException e) {                            break OUTER;                        }                    }                    // 任务队列不为空，取出任务                    runnable = TASK_QUEUE.removeFirst();                }                // 任务不为空，则执行任务                if (runnable != null) {                    this.taskState = TaskState.RUNNING;                    runnable.run();                    this.taskState = TaskState.FREE;                }            }        }        public void close() {            this.taskState = TaskState.DEAD;        }    }    // 线程状态    private enum TaskState {        FREE, RUNNING, BLOCKED, DEAD    }    // 拒绝策略    public interface DiscardPolicy {        void discard() throws DiscardException;    }    // 拒绝策略异常    public static class DiscardException extends RuntimeException {        public DiscardException(String message) {            super(message);        }    }}</code></pre><pre><code class="java">public static void main(String[] args) throws InterruptedException {    SimpleThreadPool threadPool = new SimpleThreadPool();    /*SimpleThreadPool threadPool = new SimpleThreadPool(6, 10, SimpleThreadPool.DEFAULT_DISCARD_POLICY);*/    IntStream.rangeClosed(1, 40).forEach(i -&gt; {        threadPool.submit(() -&gt; {            System.out.printf(&quot;The runnable %d be serviced by %s start.\n&quot;, i, Thread.currentThread().getName());            Thread.sleep(10_000);            System.out.printf(&quot;The runnable %d be serviced by %s finished.\n&quot;, i, Thread.currentThread().getName());        });    });    Thread.sleep(10_000);    threadPool.shutdown();// 关闭线程池中的线程    threadPool.submit(() -&gt; System.out.println(&quot;线程池被销毁，不能添加任务到任务队列&quot;));}</code></pre><p>下节课内容：</p><ol><li>线程池定期输出现在的一些状态信息。</li><li>定义min、active、max</li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136-自定义个简单的线程池并且测试</title>
      <link href="/wang-thread/136-costum-thread-pool/"/>
      <url>/wang-thread/136-costum-thread-pool/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">public class SimpleThreadPool {    // 传参线程池大小    private final int size;    // 默认线程池大小    private static final int DEFAULT_SIZE = 10;    // 线程名自增序号    private static AtomicInteger sequence = new AtomicInteger();    // 线程名前缀    private static final String THREAD_PREFIX = &quot;SIMPLE_THREAD_POOL-&quot;;    // 线程组    private static final ThreadGroup GROUP = new ThreadGroup(&quot;Pool_Group&quot;);    // 任务队列    private static final LinkedList&lt;Runnable&gt; TASK_QUEUE = new LinkedList&lt;&gt;();    // 线程队列    private static final List&lt;WorkerTask&gt; THREAD_QUEUE = new ArrayList&lt;&gt;();    public SimpleThreadPool() {        this(DEFAULT_SIZE);    }    public SimpleThreadPool(int size) {        this.size = size;        init();    }    private void init() {        for (int i = 0; i &lt; size; i++) {            createWorkTask();        }    }    private void createWorkTask() {        WorkerTask task = new WorkerTask(GROUP, THREAD_PREFIX + (sequence.getAndIncrement()));        task.start();        THREAD_QUEUE.add(task);    }    // 提交任务    public void submit(Runnable runnable) {        synchronized (TASK_QUEUE) {            TASK_QUEUE.addLast(runnable);            TASK_QUEUE.notifyAll();        }    }    // 封装任务类    private static class WorkerTask extends Thread {        private volatile TaskState taskState = TaskState.FREE;        public TaskState getTaskState() {            return this.taskState;        }        public WorkerTask(ThreadGroup group, String name) {            super(group, name);        }        @Override        public void run() {            OUTER:            while (this.taskState != TaskState.DEAD) {                Runnable runnable;                synchronized (TASK_QUEUE) {                    // 任务队列为空，则进入阻塞状态                    while (TASK_QUEUE.isEmpty()) {                        try {                            this.taskState = TaskState.BLOCKED;                            TASK_QUEUE.wait();                        } catch (InterruptedException e) {                            break OUTER;                        }                    }                    // 任务队列不为空，取出任务。很快                    runnable = TASK_QUEUE.removeFirst();                }                // 任务不为空，则执行任务。很慢                if (runnable != null) {                    this.taskState = TaskState.RUNNING;                    runnable.run();                    this.taskState = TaskState.FREE;                }            }        }        public void close() {            this.taskState = TaskState.DEAD;        }    }    // 线程状态    private enum TaskState {        FREE, RUNNING, BLOCKED, DEAD    }}</code></pre><pre><code class="java">public static void main(String[] args) {    SimpleThreadPool threadPool = new SimpleThreadPool();    IntStream.rangeClosed(1, 40).forEach(i -&gt; {        threadPool.submit(() -&gt; {            System.out.printf(&quot;The runnable %d be serviced by %s start.\n&quot;, i, Thread.currentThread().getName());            Thread.sleep(10_000);            System.out.printf(&quot;The runnable %d be serviced by %s finished.\n&quot;, i, Thread.currentThread().getName());        });    });}</code></pre><p>实现了任务队列，还未支持拒绝策略。</p><p>目前只有init，还需实现active，max</p><p>还需实现停止线程池（shutdown）</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>135-线程池原理与自定义线程池</title>
      <link href="/wang-thread/135-thread-pool-theory/"/>
      <url>/wang-thread/135-thread-pool-theory/</url>
      
        <content type="html"><![CDATA[<p>JUC包已经实现了非常好用的线程池，在实际开发中大多都使用JUC包下的线程池。</p><p>自定义线程池可以帮助理解线程池的工作原理</p><p>没有线程池的弊端：多次创建、销毁线程会浪费大量时间。</p><p>解决方案：比如服务器，在服务器启动的时候就会（在线程池）创建一些线程，然后有请求访问的时候就会使用其中一个线程做任务，当请求操作结束后线程并不会销毁，而是将线程又回归到线程池中。一个线程可以循环可回收利用，可以处理多个任务。在服务器关闭的时候才会关闭线程。</p><p>线程池概念：</p><ol><li>任务队列：存储待执行的任务</li><li>拒绝策略：请求任务过多，拒绝一部分任务<ul><li>抛出异常、直接丢弃、阻塞请求、临时队列</li></ul></li><li>init（min）</li><li>active</li><li>max</li></ol><p>min&lt;=active&lt;=max</p><p>线程池通用规则：</p><ol><li>首先线程池创建min个线程，如果处理线程过多会适量增加到active，更多则增加到max。如果线程数量超过了max则会添加到任务队列，如果任务队列满了则会执行拒绝策略。</li><li>线程执行如果过了顶峰期（比如双十一）需要减少线程池中线程的数据到active（线程过多切换上下文会影响应用性能），如果有过多的任务则又增加线程数量。</li></ol><p>线程池异步任务、批量任务</p><p>使用到线程池的开源项目：Quartz、Control-M</p><p>补充：<a href="https://www.cnblogs.com/ibigboy/p/11298004.html" target="_blank" rel="noopener">为什么阿里Java规约禁止使用Java内置Executors创建线程池？</a></p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2小时Spring Boot红包程序 尽显极客浪漫Style</title>
      <link href="/imooc/328-2Hours-SpringBoot/"/>
      <url>/imooc/328-2Hours-SpringBoot/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://coding.imooc.com/class/chapter/328.html" target="_blank" rel="noopener">2小时Spring Boot红包程序 尽显极客浪漫Style</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-【惊鸿一瞥】花絮引导"><a href="#第1章-【惊鸿一瞥】花絮引导" class="headerlink" title="第1章 【惊鸿一瞥】花絮引导"></a>第1章 【惊鸿一瞥】花絮引导</h2><blockquote><p>导学将以幽默风趣的风格，让你了解一下普罗大众眼中的“程序员”。</p></blockquote><h3 id="1-1-【开篇有惊喜】精彩花絮之课程引导"><a href="#1-1-【开篇有惊喜】精彩花絮之课程引导" class="headerlink" title="1-1 【开篇有惊喜】精彩花絮之课程引导"></a>1-1 【开篇有惊喜】精彩花絮之课程引导</h3><p>SpringBoot使配置、部署、编码、监控变得简单。</p><p> SpringMVC =&gt; SpringBoot</p><p>SpringBoot的特点：</p><blockquote><ol><li>化繁为简，简化配置</li><li>备受关注，是下一代框架</li><li>微服务的入门级微框架</li></ol></blockquote><p>SpringBoot ==&gt; SpringCloud ==&gt; 微服务</p><p>课程介绍：</p><blockquote><ol><li>第一个SpringBoot程序</li><li>自定义属性配置</li><li>Controller的使用</li><li>spring-data-jpa</li><li>事务管理</li></ol></blockquote><p>注：</p><blockquote><ol><li>具备必要的前置知识<ul><li>利用maven构建项目</li><li>Spring注解</li><li>RESTful API</li></ul></li><li>不需要去学SpringMVC</li><li>Java、Maven等版本保持一致</li></ol></blockquote><h2 id="第2章-【初遇】坐而论“道”之SpringBoot"><a href="#第2章-【初遇】坐而论“道”之SpringBoot" class="headerlink" title="第2章 【初遇】坐而论“道”之SpringBoot"></a>第2章 【初遇】坐而论“道”之SpringBoot</h2><blockquote><p>与SpringBoot初遇。坐而论“道”之SpringBoot是什么？</p></blockquote><h3 id="2-1-初遇SpringBoot"><a href="#2-1-初遇SpringBoot" class="headerlink" title="2-1 初遇SpringBoot"></a>2-1 初遇SpringBoot</h3><h2 id="第3章-【初识】从前，车马很慢，书信很远，一生只够爱一人"><a href="#第3章-【初识】从前，车马很慢，书信很远，一生只够爱一人" class="headerlink" title="第3章 【初识】从前，车马很慢，书信很远，一生只够爱一人"></a>第3章 【初识】从前，车马很慢，书信很远，一生只够爱一人</h2><blockquote><p>人生第一个SpringBoot程序</p></blockquote><h3 id="3-1-人生中第一个SpringBoot程序"><a href="#3-1-人生中第一个SpringBoot程序" class="headerlink" title="3-1 人生中第一个SpringBoot程序"></a>3-1 人生中第一个SpringBoot程序</h3><p>版本一致：</p><pre><code class="shell">java -versionmvn -version</code></pre><p>SpringBoot版本：</p><blockquote><p>SNAPSHOT（快照版）只做一个存档，并不是Linux版本.</p></blockquote><p>配置Maven阿里云镜像地址：</p><pre><code class="xml">&lt;!-- settings.xml --&gt;&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;</code></pre><p>请求方法注解：</p><blockquote><ol><li>新版@GetMapping(“/hello”)</li><li>老版@RequestMapping(value=”/hel1o”，method=RequestMethod.GET)</li></ol></blockquote><p>Sprint Boot里内嵌了一个Tomcat</p><pre><code class="shell"># 启动SpringBoot程序mvn spring-boot:run# 程序打包mvn clean package# 运行程序java -jar -Dspring.profiles.active=prod luckymoney.jar</code></pre><h2 id="第4章-【君子之交-淡如水】"><a href="#第4章-【君子之交-淡如水】" class="headerlink" title="第4章 【君子之交-淡如水】"></a>第4章 【君子之交-淡如水】</h2><blockquote><p>SpringBoot配置知多少</p></blockquote><h3 id="4-1-项目属性配置知多少"><a href="#4-1-项目属性配置知多少" class="headerlink" title="4-1 项目属性配置知多少"></a>4-1 项目属性配置知多少</h3><p>项目配置：</p><pre><code class="properties"># application.propertiesserver.port=8081server.servlet.context-path=/luckymonel</code></pre><pre><code class="yaml">servert:   port: 8081  servlet:     context-path: /luckymoneyminMoney: 1description: 最少要发${minMoney}元limit:   minMoney: 1  maxMoney: 10  description: 最少要发${limit.minMone}元，最多${limit.maxMoney}元</code></pre><p>单配置属性值：</p><pre><code class="java">@Value(&quot;${minMoney}&quot;)private BigDecimal minMoney;@Value(&quot;${description}&quot;)private String description;</code></pre><p>组项目属性值：</p><pre><code class="java">@Data@Component@ConfigurationProperties(prefix = &quot;limit&quot;)public class LimitConfig {    private BigDecimal minMoney;    private BigDecimal maxMoney;    private String description;}</code></pre><pre><code class="java">@Autowired private LimitConfig limitConfig;</code></pre><p>项目环境：</p><ul><li><p>application-dev.yml：开发环境的配置</p></li><li><p>application-prod.yml是生产环境的配置</p></li><li><p>application-test.yml是测试环境的配置</p></li><li><p>application.yml中配置要运用的环境配置</p><pre><code class="yaml">spring:  profiles:    active: dev</code></pre><pre><code class="shell">mvn clean packagejava -jar -Dspring.profiles.active=prod luckymoney.jar</code></pre></li></ul><p>配置总结：</p><blockquote><p>@Value<br>@Component<br>@ConfigurationProperties</p></blockquote><h2 id="第5章-【人生若只如初见】从“程序”的入口开始"><a href="#第5章-【人生若只如初见】从“程序”的入口开始" class="headerlink" title="第5章 【人生若只如初见】从“程序”的入口开始"></a>第5章 【人生若只如初见】从“程序”的入口开始</h2><blockquote><p>还记得《北京东路的日子》那首歌….开始的开始，我们还是孩子…现在本章内容将从基于SpringBoot的“红包收发 ”程序的入口开始，实现极客专属的浪漫红包表白程序学习之旅。摒弃枯燥乏味的理论，让你尽情撸一把红包代码，Show一场法式浪漫。…</p></blockquote><h3 id="5-1-Controller-从红包程序的入口开始"><a href="#5-1-Controller-从红包程序的入口开始" class="headerlink" title="5-1 Controller:从红包程序的入口开始"></a>5-1 Controller:从红包程序的入口开始</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Controller</td><td>处理http请求</td></tr><tr><td>@RestController</td><td>Spring4之后新加的注解，原来返回JSON需要@ResponseBody配合@Controller</td></tr><tr><td>@RequestMapping</td><td>配置url映射</td></tr></tbody></table><p>模板的使用：</p><ol><li><p>添加POM依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>创建文件/resources/templates/index.html</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎学习SpringBoot!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>使用模板</p><pre><code class="java">@Controllerpublic class HelloController {    @Autowired    private LimitConfig limitConfig;    @GetMapping(&quot;/hello&quot;)    public String say() {        return &quot;index&quot;;    }}</code></pre></li></ol><p>注：</p><blockquote><ol><li>@Controller + @ResponseBody = @RestController</li><li>@GetMapping({“/hello”, “/hi”})</li><li>类注解@RequestMapping(“/hello”)</li></ol></blockquote><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@PathVariable</td><td>获取URL中的数据</td></tr><tr><td>@RequestParam</td><td>获取请求参数的值</td></tr></tbody></table><p> 注：</p><blockquote><ol><li><p>/luckymoney/hello/say/100</p><p>@GetMapping(value=”/{id}/say”)</p><p>@PathVariable(“id”) Integer id</p></li><li><p>/luckymoney/hello/say?id=100</p><p>@RequestParam(value=”id”, required=false, defaultValue=”0”) Integer id</p></li></ol></blockquote><p>注：</p><ul><li><strong>Post使用form-data</strong></li><li><strong>Put使用x-www-form-urlencoded</strong></li></ul><h2 id="第6章-【收获人生”红颜”知己】"><a href="#第6章-【收获人生”红颜”知己】" class="headerlink" title="第6章 【收获人生”红颜”知己】"></a>第6章 【收获人生”红颜”知己】</h2><blockquote><p>收获“女神”总是需要套路的，正所谓“自古深情留不住，总是套路得人心”</p></blockquote><h3 id="6-1-关于红包收发之操作数据库-上"><a href="#6-1-关于红包收发之操作数据库-上" class="headerlink" title="6-1 关于红包收发之操作数据库(上)"></a>6-1 关于红包收发之操作数据库(上)</h3><p>数据库操作</p><blockquote><p>Spring-Data-Jpa -&gt; MySQL</p></blockquote><p>Spring-Data-JPA</p><blockquote><p>JPA(Java Persistence API)定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate、TopLink等。</p><p>Spring-Data-JPA就是对Hibernate的整合</p></blockquote><p>RESTful API设计：</p><table><thead><tr><th>请求类型</th><th>请求路径</th><th>功能</th></tr></thead><tbody><tr><td>GET</td><td>/luckymoneys</td><td>获取红包列表</td></tr><tr><td>POST</td><td>/luckymoneys</td><td>创建一个红包</td></tr><tr><td>GET</td><td>/luckymoneys/id</td><td>通过id查询红包</td></tr><tr><td>PUT</td><td>/luckymoneys/id</td><td>通过id更新红包</td></tr></tbody></table><p>步骤：</p><ol><li><p>添加POM依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springf ramework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置数据库信息和Spring-Data-JPA信息</p><pre><code class="yaml">spring:   datasource:     driver-class-name: com.mysql.cj.jdbc.Driver    ur1: jdbc:mysql://127.0.0.1:3306/luckymoney?characterEncoding=utf-8    username: root    password: 123456  jpa:     hibernate:       ddl-auto: create    show-sql: true</code></pre><p>MySQL可视化工具：</p><ul><li>Mac：Sequel Pro</li><li>Windows：Navicat</li></ul><p>ddl-auto参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>create</td><td>运行时自动创建表。每次程序运行都会创建空表，如果已存在则会先删除表</td></tr><tr><td>create-drop</td><td>应用停下来的时候就会把表删除</td></tr><tr><td>none</td><td>不做任何操作。</td></tr><tr><td>update</td><td>运行时自动创建表。当已存在表则不会操作</td></tr><tr><td>validate</td><td>验证实体属性是否和表结构一致，不一致则会报错。</td></tr></tbody></table></li><li><p>创建实体类</p><pre><code class="java">@Entitypublic class Luckymoney {    @Id    @GenerateValue    private Integer id;    private BigDecimal money;    /** 发送方 */    private String producer;    /** 接收方 */    private String consumer;    // 无参构造函数。必须要有，否则报错    // ...getter and setter...}</code></pre></li><li><p>运行程序</p></li></ol><h3 id="6-2-关于红包收发之操作数据库-下"><a href="#6-2-关于红包收发之操作数据库-下" class="headerlink" title="6-2 关于红包收发之操作数据库(下)"></a>6-2 关于红包收发之操作数据库(下)</h3><ol><li><p>Dao</p><pre><code class="java">public interface LuckmoneyRepository extends JpaRepository&lt;Luckymoney, Integer&gt; {}</code></pre></li><li><p>Controller</p><pre><code class="java">@RestControllerpublic class LuckymoneyController {    @Autowired    private LuckmoneyRepository repository;    @Autowired    private LuckymoneyService service;    /**     * 获取红包列表     */    @GetMapping(&quot;/luckymoneys&quot;)    public List&lt;Luckymoney&gt; list() {        return repository.findAll();    }    /**     * 创建红包(发红包)     */    @PostMapping(&quot;/luckymoneys&quot;)    public Luckymoney create(@RequestParam(&quot;producer&quot;) String producer,                             @RequestParam(&quot;money&quot;) BigDecimal money) {        Luckymoney luckymoney = new Luckymoney();        luckymoney.setProducer(producer);        luckymoney.setMoney(money);        return repository.save(luckymoney);    }    /**     * 通过id查询红包     */    @GetMapping(&quot;/luckymoneys/{id}&quot;)    public Luckymoney findById(@PathVariable(&quot;id&quot;) Integer id) {        return repository.findById(id).orElse(null);    }    /**     * 更新红包(领红包)     */    @PutMapping(&quot;/luckymoneys/{id}&quot;)    public Luckymoney update(@PathVariable(&quot;id&quot;) Integer id,                             @RequestParam(&quot;consumer&quot;) String consumer) {        Optional&lt;Luckymoney&gt; optional = repository.findById(id);        if (optional.isPresent()) { // 如果有内容。            Luckymoney luckymoney = optional.get();// 获取数据            luckymoney.setConsumer(consumer);            return repository.save(luckymoney);        }        return null;    }}</code></pre></li></ol><p>注：</p><ul><li><strong>Post使用form-data</strong></li><li><strong>Put使用x-www-form-urlencoded</strong></li></ul><h2 id="第7章-【搞定并发就要在一起】"><a href="#第7章-【搞定并发就要在一起】" class="headerlink" title="第7章 【搞定并发就要在一起】"></a>第7章 【搞定并发就要在一起】</h2><blockquote><p>搞定并发，任何压力都无法阻挡我们在一起</p></blockquote><h3 id="7-1-关于事务：红包并发中的事务"><a href="#7-1-关于事务：红包并发中的事务" class="headerlink" title="7-1 关于事务：红包并发中的事务"></a>7-1 关于事务：红包并发中的事务</h3><p>事务：</p><blockquote><p>数据库事务，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p></blockquote><p>实现实务操作：</p><ol><li><p>编写Service发送两个红包</p><pre><code class="java">@Servicepublic class LuckymoneyService {    @Autowired    private LuckmoneyRepository repository;    /**     * 事务 指数据库事务     * 扣库存 &gt; 创建订单     */    @Transactional    public void createTwo() {        Luckymoney luckymoney1 = new Luckymoney();        luckymoney1.setProducer(&quot;廖师兄&quot;);        luckymoney1.setMoney(new BigDecimal(&quot;520&quot;));        repository.save(luckymoney1);        Luckymoney luckymoney2 = new Luckymoney();        luckymoney2.setProducer(&quot;廖师兄&quot;);        luckymoney2.setMoney(new BigDecimal(&quot;1314&quot;));        repository.save(luckymoney2);    }}</code></pre></li><li><p>调用Service方法发送红包</p><pre><code class="java">@PostMapping(&quot;/luckymoneys/two&quot;)public void createTwo() {    service.createTwo();}</code></pre></li></ol><p>事务失败原因：数据库默认为MyISAM不支持事物回滚，需要设置为InnoDB</p><p>解决方法： 改为INNODB</p><p>更改语句：</p><pre><code class="mysql">ALTER TABLE luckymoney ENGINE=INNODB;</code></pre><p>事务失败原因：SpringBoot2.*实体的默认引擎为MyISAM不支持事务，需要配置引擎为为innoDB<br>解决方法：在application.yml添加配置</p><pre><code class="yaml">spring:     jpa:         database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</code></pre><blockquote><p>只有查询的时候不加事务，其它任何操作都要加事务。</p><p>进行添加操作的时候，如果要求，要么全部添加成功，要么全部失败</p><p>@Transactional事务处理注解的使用方法，在Service进行事务处理</p></blockquote><h2 id="第8章-【时光不老我们不散】"><a href="#第8章-【时光不老我们不散】" class="headerlink" title="第8章 【时光不老我们不散】"></a>第8章 【时光不老我们不散】</h2><blockquote><p>时光不老，我们不散。从“实战课程”再次出发？我们一起约？</p></blockquote><h3 id="8-1-总结：精华提炼，经典再现"><a href="#8-1-总结：精华提炼，经典再现" class="headerlink" title="8-1 总结：精华提炼，经典再现"></a>8-1 总结：精华提炼，经典再现</h3><ol><li><p>SpringBoot介绍</p><ul><li><p>是什么</p><p>SpringBoot是新一代框架，简化了开发过程，提升开发效率。底层还是Spring</p></li><li><p>为什么要学</p><p>好处多，发展趋势</p></li></ul></li><li><p>第一个SpringBoot应用</p><ul><li>IDEA创建</li><li>官网下载创建</li></ul></li><li><p>项目配置</p><ul><li>单个配置@Value</li><li>对象配置@ConfigurationProperties</li><li>区分环境：开发、生产环境使用不同的配置</li></ul></li><li><p>Controller的使用</p><ul><li>方式<ul><li>Controller</li><li>ResponseBody</li><li>RestController</li></ul></li><li>获取参数<ul><li>PathVariable</li><li>RequestParam</li></ul></li></ul></li><li><p>数据库操作</p><ul><li><p>Spring-Data-JPA</p><p>extents JpaRepository</p><ul><li>save()</li><li>findById</li><li>findAll</li></ul></li></ul></li><li><p>事务</p><p>特指数据库的事务</p><p>@Transactional</p></li></ol><p>廖师兄课程学习顺序：</p><ol><li>SpringBoot入门</li><li>SpringBoot进阶</li><li>SpringBoot微信点餐实战</li><li>SpringCloud微服务实战</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课程脚本</title>
      <link href="/imooc/219-docker/00-script/"/>
      <url>/imooc/219-docker/00-script/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="Docker虚拟机常用命令"><a href="#Docker虚拟机常用命令" class="headerlink" title="Docker虚拟机常用命令"></a>Docker虚拟机常用命令</h2><ol><li><p>先更新软件包</p><pre><code class="shell">yum -y update</code></pre></li><li><p>安装Docker虚拟机</p><pre><code class="shell">yum install -y docker</code></pre></li><li><p>运行、重启、关闭Docker虚拟机</p><pre><code class="shell">service docker startservice docker startservice docker stop</code></pre></li><li><p>搜索镜像</p><pre><code class="shell">docker search 镜像名称</code></pre></li><li><p>下载镜像</p><pre><code class="shell">docker pull 镜像名称</code></pre></li><li><p>查看镜像</p><pre><code class="shell">docker images</code></pre></li><li><p>删除镜像</p><pre><code class="shell">docker rmi 镜像名称</code></pre></li><li><p>运行容器</p><pre><code class="shell">docker run 启动参数  镜像名称</code></pre></li><li><p>查看容器列表</p><pre><code class="shell">docker ps -a</code></pre></li><li><p>停止、挂起、恢复容器</p><pre><code class="shell">docker stop 容器IDdocker pause 容器IDdocker unpase 容器ID</code></pre></li><li><p>查看容器信息</p><pre><code class="shell">docker inspect 容器ID</code></pre></li><li><p>删除容器</p><pre><code class="shell">docker rm 容器ID</code></pre></li><li><p>数据卷管理</p><pre><code class="shell">docker volume create 数据卷名称  #创建数据卷docker volume rm 数据卷名称  #删除数据卷docker volume inspect 数据卷名称  #查看数据卷</code></pre></li><li><p>网络管理</p><pre><code class="shell">docker network ls 查看网络信息docker network create --subnet=网段 网络名称docker network rm 网络名称</code></pre></li><li><p>避免VM虚拟机挂起恢复之后，Docker虚拟机断网</p><pre><code class="shell">vi /etc/sysctl.conf</code></pre></li></ol><pre><code>文件中添加`net.ipv4.ip_forward=1`这个配置```shell#重启网络服务systemctl  restart network```</code></pre><h2 id="安装PXC集群，负载均衡，双机热备"><a href="#安装PXC集群，负载均衡，双机热备" class="headerlink" title="安装PXC集群，负载均衡，双机热备"></a>安装PXC集群，负载均衡，双机热备</h2><ol><li><p>安装PXC镜像</p><pre><code class="shell">docker pull percona/percona-xtradb-cluster</code></pre></li><li><p>为PXC镜像改名</p><pre><code class="shell">docker tag percona/percona-xtradb-cluster pxc</code></pre></li><li><p>创建net1网段</p><pre><code class="shell">docker network create --subnet=172.18.0.0/16 net1</code></pre></li><li><p>创建5个数据卷</p><pre><code class="shell">docker volume create --name v1docker volume create --name v2docker volume create --name v3docker volume create --name v4docker volume create --name v5</code></pre></li><li><p>创建备份数据卷（用于热备份数据）</p><pre><code class="shell">docker volume create --name backup</code></pre></li><li><p>创建5节点的PXC集群</p><p>注意，每个MySQL容器创建之后，因为要执行PXC的初始化和加入集群等工作，耐心等待1分钟左右再用客户端连接MySQL。另外，必须第1个MySQL节点启动成功，用MySQL客户端能连接上之后，再去创建其他MySQL节点。</p><pre><code class="shell">#创建第1个MySQL节点docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc#创建第2个MySQL节点docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql -v backup:/data --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc#创建第3个MySQL节点docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc#创建第4个MySQL节点docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc#创建第5个MySQL节点docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql -v backup:/data --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc</code></pre></li><li><p>安装Haproxy镜像</p><pre><code class="shell">docker pull haproxy</code></pre></li><li><p>宿主机上编写Haproxy配置文件</p><pre><code class="shell">vi /home/soft/haproxy.cfg</code></pre><p>配置文件如下：</p><pre><code class="properties">global    #工作目录    chroot /usr/local/etc/haproxy    #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info    log 127.0.0.1 local5 info    #守护进程运行    daemondefaults    log    global    mode    http    #日志格式    option    httplog    #日志中不记录负载均衡的心跳检测记录    option    dontlognull    #连接超时（毫秒）    timeout connect 5000    #客户端超时（毫秒）    timeout client  50000    #服务器超时（毫秒）    timeout server  50000#监控界面listen  admin_stats    #监控界面的访问的IP和端口    bind  0.0.0.0:8888    #访问协议    mode        http    #URI相对地址    stats uri   /dbs    #统计报告格式    stats realm     Global\ statistics    #登陆帐户信息    stats auth  admin:abc123456#数据库负载均衡listen  proxy-mysql    #访问的IP和端口    bind  0.0.0.0:3306    #网络协议    mode  tcp    #负载均衡算法（轮询算法）    #轮询算法：roundrobin    #权重算法：static-rr    #最少连接算法：leastconn    #请求源IP算法：source    balance  roundrobin    #日志格式    option  tcplog    #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测    option  mysql-check user haproxy    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000    server  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000    server  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000    server  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000    #使用keepalive检测死链    option  tcpka</code></pre></li><li><p>创建两个Haproxy容器</p><pre><code class="shell">#创建第1个Haproxy负载均衡服务器docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 --ip 172.18.0.7 haproxy#进入h1容器，启动Haproxydocker exec -it h1 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg#创建第2个Haproxy负载均衡服务器docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h2 --privileged --net=net1 --ip 172.18.0.8 haproxy#进入h2容器，启动Haproxydocker exec -it h2 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg</code></pre></li><li><p>Haproxy容器内安装Keepalived，设置虚拟IP</p><pre><code class="shell">#进入h1容器docker exec -it h1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件（参考下方配置文件）vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start#宿主机执行ping命令ping 172.18.0.201</code></pre><p>配置文件内容如下：</p><pre><code>vrrp_instance  VI_1 {    state  MASTER    interface  eth0    virtual_router_id  51    priority  100    advert_int  1    authentication {        auth_type  PASS        auth_pass  123456    }    virtual_ipaddress {        172.18.0.201    }}</code></pre><pre><code class="shell">#进入h2容器docker exec -it h2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start#宿主机执行ping命令ping 172.18.0.201</code></pre><p>配置文件内容如下：</p><pre><code class="shell">vrrp_instance  VI_1 {    state  MASTER    interface  eth0    virtual_router_id  51    priority  100    advert_int  1    authentication {        auth_type  PASS        auth_pass  123456    }    virtual_ipaddress {        172.18.0.201    }}</code></pre></li><li><p>宿主机安装Keepalived，实现双击热备</p><pre><code class="shell">#宿主机执行安装Keepalivedyum -y install keepalived#修改Keepalived配置文件vi /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><p>Keepalived配置文件如下：</p><pre><code class="shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    virtual_ipaddress {           192.168.99.150    }}virtual_server 192.168.99.150 8888 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 172.18.0.201 8888 {        weight 1    }}virtual_server 192.168.99.150 3306 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 172.18.0.201 3306 {        weight 1    }}</code></pre></li><li><p>热备份数据</p><pre><code class="shell">#进入node1容器docker exec -it node1 bash#更新软件包apt-get update#安装热备工具apt-get install percona-xtrabackup-24#全量热备innobackupex --user=root --password=abc123456 /data/backup/full</code></pre></li><li><p>冷还原数据<br>停止其余4个节点，并删除节点</p><pre><code class="shell">docker stop node2docker stop node3docker stop node4docker stop node5docker rm node2docker rm node3docker rm node4docker rm node5</code></pre><p>node1容器中删除MySQL的数据</p><pre><code class="shell">#删除数据rm -rf /var/lib/mysql/*#清空事务innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-04-15_05-09-07/#还原数据innobackupex --user=root --password=abc123456 --copy-back  /data/backup/full/2018-04-15_05-09-07/</code></pre><p>重新创建其余4个节点，组件PXC集群</p></li></ol><h2 id="安装Redis，配置RedisCluster集群"><a href="#安装Redis，配置RedisCluster集群" class="headerlink" title="安装Redis，配置RedisCluster集群"></a>安装Redis，配置RedisCluster集群</h2><ol><li><p>安装Redis镜像</p><pre><code class="shell">docker pull yyyyttttwwww/redis</code></pre></li><li><p>创建net2网段</p><pre><code class="shell">docker network create --subnet=172.19.0.0/16 net2</code></pre></li><li><p>创建6节点Redis容器</p><pre><code class="shell">docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bashdocker run -it -d --name r2 -p 5002:6379 --net=net2 --ip 172.19.0.3 redis bashdocker run -it -d --name r3 -p 5003:6379 --net=net2 --ip 172.19.0.4 redis bashdocker run -it -d --name r4 -p 5004:6379 --net=net2 --ip 172.19.0.5 redis bashdocker run -it -d --name r5 -p 5005:6379 --net=net2 --ip 172.19.0.6 redis bash</code></pre></li><li><p>启动6节点Redis服务器</p><pre><code class="shell">#进入r1节点docker exec -it r1 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r2节点docker exec -it r2 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r3节点docker exec -it r3 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r4节点docker exec -it r4 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r5节点docker exec -it r5 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r6节点docker exec -it r6 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf</code></pre></li><li><p>创建Cluster集群</p><pre><code class="shell">#在r1节点上执行下面的指令cd /usr/redis/srcmkdir -p ../clustercp redis-trib.rb ../cluster/cd ../cluster#创建Cluster集群./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</code></pre></li></ol><h2 id="打包部署后端项目"><a href="#打包部署后端项目" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol><li><p>进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个JAR文件）</p><pre><code class="shell">mvn clean install -Dmaven.test.skip=true</code></pre></li><li><p>安装Java镜像</p><pre><code class="shell">docker pull java</code></pre></li><li><p>创建3节点Java容器</p><pre><code class="shell">#创建数据卷，上传JAR文件docker volume create j1#启动容器docker run -it -d --name j1 -v j1:/home/soft --net=host java#进入j1容器docker exec -it j1 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar#创建数据卷，上传JAR文件docker volume create j2#启动容器docker run -it -d --name j2 -v j2:/home/soft --net=host java#进入j1容器docker exec -it j2 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar#创建数据卷，上传JAR文件docker volume create j3#启动容器docker run -it -d --name j3 -v j3:/home/soft --net=host java#进入j1容器docker exec -it j3 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar</code></pre></li><li><p>安装Nginx镜像</p><pre><code class="shell">docker pull nginx</code></pre></li><li><p>创建Nginx容器，配置负载均衡</p><p>宿主机上/home/n1/nginx.conf配置文件内容如下：</p><pre><code class="properties">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream tomcat {        server 192.168.99.104:6001;        server 192.168.99.104:6002;        server 192.168.99.104:6003;    }    server {        listen       6101;        server_name  192.168.99.104;        location / {            proxy_pass   http://tomcat;            index  index.html index.htm;        }    }}</code></pre><p>创建第1个Nginx节点</p><pre><code class="shell">docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre><p>宿主机上/home/n2/nginx.conf配置文件内容如下：</p><pre><code class="properties">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream tomcat {        server 192.168.99.104:6001;        server 192.168.99.104:6002;        server 192.168.99.104:6003;    }    server {        listen       6102;        server_name  192.168.99.104;        location / {            proxy_pass   http://tomcat;            index  index.html index.htm;        }    }}</code></pre><p>创建第2个Nginx节点</p><pre><code class="shell">docker run -it -d --name n2 -v /home/n2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre></li><li><p>在Nginx容器安装Keepalived</p><pre><code class="shell">#进入n1节点docker exec -it n1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre><code>vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.151    }}virtual_server 192.168.99.151 6201 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6101 {        weight 1    }}</code></pre><pre><code class="shell">#进入n1节点docker exec -it n2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre><code class="shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.151    }}virtual_server 192.168.99.151 6201 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6102 {        weight 1    }}</code></pre></li></ol><h2 id="打包部署后端项目-1"><a href="#打包部署后端项目-1" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol><li><p>在前端项目路径下执行打包指令</p><pre><code class="shell">npm run build</code></pre></li><li><p>build目录的文件拷贝到宿主机的/home/fn1/renren-vue、/home/fn2/renren-vue、/home/fn3/renren-vue的目录下面</p></li><li><p>创建3节点的Nginx，部署前端项目</p><p>宿主机/home/fn1/nginx.conf的配置文件</p><pre><code>user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6501;        server_name  192.168.99.104;        location  /  {            root  /home/fn1/renren-vue;            index  index.html;        }    }}</code></pre><pre><code class="shell">#启动第fn1节点docker run -it -d --name fn1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx</code></pre><p>宿主机/home/fn2/nginx.conf的配置文件</p><pre><code class="shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6502;        server_name  192.168.99.104;        location  /  {            root  /home/fn2/renren-vue;            index  index.html;        }    }}</code></pre><pre><code class="shell">#启动第fn2节点docker run -it -d --name fn2 -v /home/fn2/nginx.conf:/etc/nginx/nginx.conf -v /home/fn2/renren-vue:/home/fn2/renren-vue --privileged --net=host nginx</code></pre><p>宿主机/home/fn3/nginx.conf的配置文件</p><pre><code class="shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6503;        server_name  192.168.99.104;        location  /  {            root  /home/fn3/renren-vue;            index  index.html;        }    }}</code></pre><p>启动fn3节点</p><pre><code class="shell">#启动第fn3节点docker run -it -d --name fn3 -v /home/fn3/nginx.conf:/etc/nginx/nginx.conf -v /home/fn3/renren-vue:/home/fn3/renren-vue --privileged --net=host nginx</code></pre></li><li><p>配置负载均衡</p><p>宿主机/home/ff1/nginx.conf配置文件</p><pre><code class="shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream fn {        server 192.168.99.104:6501;        server 192.168.99.104:6502;        server 192.168.99.104:6503;    }    server {        listen       6601;        server_name  192.168.99.104;        location / {            proxy_pass   http://fn;            index  index.html index.htm;        }    }}</code></pre><pre><code class="shell">#启动ff1节点docker run -it -d --name ff1 -v /home/ff1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre><p>宿主机/home/ff2/nginx.conf配置文件</p><pre><code class="shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream fn {        server 192.168.99.104:6501;        server 192.168.99.104:6502;        server 192.168.99.104:6503;    }    server {        listen       6602;        server_name  192.168.99.104;        location / {            proxy_pass   http://fn;            index  index.html index.htm;        }    }}</code></pre><pre><code class="shell">#启动ff2节点docker run -it -d --name ff2 -v /home/ff2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre></li><li><p>配置双机热备</p><pre><code class="shell">#进入ff1节点docker exec -it ff1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre><code class="shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 52    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.152    }}virtual_server 192.168.99.151 6701 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6601 {        weight 1    }}</code></pre><pre><code class="shell">#进入ff1节点docker exec -it ff2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre><code class="shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 52    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.152    }}virtual_server 192.168.99.151 6701 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6602 {        weight 1    }}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第09章-课程总结</title>
      <link href="/imooc/219-docker/09-summary/"/>
      <url>/imooc/219-docker/09-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>回顾renren-fast案例的部署架构</p></blockquote><p>@[TOC]</p><h3 id="9-1-课程总结"><a href="#9-1-课程总结" class="headerlink" title="9-1 课程总结"></a>9-1 课程总结</h3><p>部署流程：</p><p>【数据库】-【Redis】-【后端项目】-【前端项目】</p><p>前端部署方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1okfdej30om07b0t2.jpg" alt="前端部署方案" style="zoom:50%;" /><p>后端部署方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1pgdzqj30ow07g3yt.jpg" alt="后端部署方案" style="zoom:50%;" /><p>数据库集群部署方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1qboknj30t70acdgb.jpg" alt="数据库集群部署方案" style="zoom:50%;" /><p>Redis集群部署方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1qt38kj30ht06xwek.jpg" alt="Redis集群部署方案" style="zoom:50%;" /><p>学习成果：</p><ul><li><p>通过Docker环境中部署数据库、高速缓存和前后端分离项目，可以举一反三，在Docker中部署更加复杂的大型项目</p><p>【前后端分离项目】–演进–【微服务】</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第08章-云平台部署前后端分离</title>
      <link href="/imooc/219-docker/08-cloud-deploy/"/>
      <url>/imooc/219-docker/08-cloud-deploy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本课程的案例既可以部署在本地，也可以部署在云平台，本章我们将比较阿里云、腾讯云、百度云的特点，以阿里云为例，介绍云主机的购买和使用，以及在阿里云ECS主机上部署本课程的相关程序。</p></blockquote><p>@[TOC]</p><h3 id="8-1-云端部署"><a href="#8-1-云端部署" class="headerlink" title="8-1 云端部署"></a>8-1 云端部署</h3><p>云平台分类：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1nl1gcj30m80ag0t7.jpg" alt="云平台分类" style="zoom: 50%;" /><ul><li><p>IaaS</p><p>提供虚拟主机，各种硬件配置的支持</p></li><li><p>PaaS</p><p>虚拟机提供MySQL，Tomcat等软件</p></li><li><p>SaaS</p><p>虚拟机提供定制开发系统</p></li></ul><p>国内主流云平台：</p><ul><li><p>百度云</p><p>倾向于Google的设计思路，利用搜索引擎的技术特长在基础设施上封装PaaS云和SaaS云，例如分布式数据计算，海量数据处理</p></li><li><p>阿里云</p><p>倾向于亚马逊的设计思路，转租基础设施（IaaS、PaaS）。AWS</p></li><li><p>腾讯云</p><p>PaaS云</p></li></ul><pre><code class="shell"># 更新软件# CentOSyum -y update# Ubuntuapt-get update# 安装Dockeryum -y install docker# 启动Docker虚拟机service docker start# 安装PXC镜像docker pull parcona/percona-xtradb-clusterdocker tag parcona/percona-xtradb-cluster pxcdocker rmi parcona/percona-xtradb-cluster# 利用服务器私有IP，搭建Swarm集群docker swarm init --listen-addr 172.31.8.139 -advertise-addr 172.31.8.139# 创建共享网络docker network create -d overlay --attachable net1# 创建数据库节点的数据卷docker volume create v1docker volume create backup# 创建数据库节点docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 pxc# 开放宿主机3306端口</code></pre><p>开放阿里云宿主机端口：</p><p>【云服务器ECS】-【网络和安全】-【安全组】-【配置规则】-【快速创建规则】</p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第07章-课后作业</title>
      <link href="/imooc/219-docker/07-homework/"/>
      <url>/imooc/219-docker/07-homework/</url>
      
        <content type="html"><![CDATA[<blockquote><p>俗话说“鸡蛋不要放在同一个篮子里”，所以要对本地部署方案改造成跨主机的运营平台。我们将创建四个Linux主机，利用Swarm技术组建Docker集群。通过Swarm的共享网络，组建起多主机多容器分布式部署的运营平台。</p></blockquote><p>@[TOC]</p><h3 id="7-1-课后作业（上）"><a href="#7-1-课后作业（上）" class="headerlink" title="7-1 课后作业（上）"></a>7-1 课后作业（上）</h3><ol><li>创建Swarm集群</li><li>搭建PXC集群</li></ol><blockquote><p>如果所有节点都部署在同一台宿主机中，当宿主机宕机程序将会崩溃。</p><p>此时，应采用多宿主机部署不同的节点。</p></blockquote><p>Docker Swarm：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gimo8truj30rs0kd3zq.jpg" alt="多宿主机部署-Docker Swarm" style="zoom: 30%;" /><p>Google K8S：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gimnqf0dj30ro0kh3zp.jpg" alt="多宿主机部署-Google K8S" style="zoom:30%;" /><p>Docker三剑客：</p><ul><li><p>docker-machine：容器服务</p></li><li><p>docker-compose：脚本执行服务</p></li><li><p>docker-swarm：容器集群</p></li></ul><p>docker-swarm去中心化的设计</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gimoro5yj316g0e60ui.jpg" alt="docker-swarm去中心化的设计" style="zoom:40%;" /><p>注：</p><ul><li><p>Manager节点是管理swarm集群，承担worker节点的工作</p></li><li><p>Worker节点是运行容器部署项目</p><p>Manger节点和Worker节点都可配置多节点</p></li></ul><p>创建Swarm集群：</p><pre><code class="shell">docker swarm init</code></pre><p>注：</p><ul><li><p><code>listen-addr ip:port</code>：管理者节点</p><p>创建Swarm集群时，必须应该含有一个管理者节点</p><p>不存在没有管理者的Swarm集群</p></li><li><p><code>advertise-addr ip</code>：广播地址</p><p>其他节点访问广播地址的IP能加入到Swarm集群</p></li></ul><p>加入Swarm集群：</p><blockquote><p>创建Swarm集群后，命令行会出现提示文字。只需将该文字复制到其他Docker节点并执行即可加入Swarm集群。此方法只能以Worker的身份加入集群。</p></blockquote><pre><code class="shell"># 在管理者节点执行...docker swarm join-token managerdocker swarm join-token worker</code></pre><p>注：</p><ul><li>添加manager或者worker节点到集群，只要执行对应的命令即可</li></ul><p>创建4个Centos系统服务器。</p><p>1、2号服务器为manager节点，3、4号服务器为worker节点。</p><pre><code class="shell"># 1号服务器docker swarm initdocker swarm join-token managerdocker swarm join-token worker# 2号服务器 docker swarm join-token managerdocker swarm join --token ....... IP:PORT# 3号服务器 docker swarm join-token workerdocker swarm join --token ....... IP:PORT# 4号服务器 docker swarm join-token workerdocker swarm join --token ....... IP:PORT</code></pre><p>查看Swarm集群节点：</p><pre><code class="shell">docker node ls</code></pre><p>注：</p><ul><li>只可以在Manager节点执行该命令</li></ul><p>查看Swarm集群网络：</p><pre><code class="shell">docker network ls# 输出.... ingress overlay swarm</code></pre><p>创建共享网络</p><pre><code class="shell">docker network create -d overlay --attachable share_net_name</code></pre><p>注：</p><ul><li>ingress网络用于管理Swarm集群，所以我们还需要创建新的共享网络传输业务数据。</li></ul><p>创建多宿主机PXC集群：</p><pre><code class="shell"># 安装PXC镜像docker pull percona/percona-xtradb-cluster# 对PXC镜像进行改名docker tag percona/percona-xtradb-cluster pxcdocker rmi percona/percona-xtradb-cluster# 创建数据卷docker volume create v1docker volume create backup# 创建PXC容器docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=share_net_name pxc</code></pre><p>创建容器：</p><pre><code class="shell">docker run -it --net=share_net_name ...</code></pre><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1fl31hj30qg07amy6.jpg" alt="创建多宿主机PXC容器" style="zoom:33%;" /><h3 id="7-2-课后作业（中）"><a href="#7-2-课后作业（中）" class="headerlink" title="7-2 课后作业（中）"></a>7-2 课后作业（中）</h3><ol><li>Swarm容器集群</li><li>退出Swarm集群</li></ol><p>查看容器的IP地址</p><pre><code class="shell"># 1号服务器# 查看Docker容器的IP地址docker inspect node1docker inspect node2</code></pre><p>Swarm容器集群</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1i88iaj318o0llwl8.jpg" alt="容器集群" style="zoom:30%;" /><p>Swarm只是管理容器状态，没有实现负载均衡</p><p>容器集群适合场景：</p><ul><li><p>容器集群不适合有状态程序，例如数据库、缓存等。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1iw2rdj30vo0e9gnp.jpg" alt="容器集群数据库程序" style="zoom:45%;" /></li></ul><p>只是用DockerSwarm提供的共享网络，而不轻易使用DockerSwarm容器集群</p><p>退出Swarm集群：</p><ol><li><p>主动退出</p><pre><code class="shell">docker swarm leave --force</code></pre><p>注：</p><ul><li>Manager节点退出集群必须要使用–force参数</li></ul></li><li><p>被动退出</p><pre><code class="shell"># 查看Docker集群的节点名docker node ls# 降级操作，将manager节点降级为worker节点docker node demote node_name# 停止Docker服务service docker stop# 删除Docker节点docker node rm node_name</code></pre><p>注：</p><ul><li>删除任何的节点必须要先停止他的Docker服务</li><li>Manager节点必须先降级为Worker节点，然后再去删除</li></ul></li></ol><h3 id="7-3-课后作业（下）"><a href="#7-3-课后作业（下）" class="headerlink" title="7-3 课后作业（下）"></a>7-3 课后作业（下）</h3><ol><li>图形化界面部署</li></ol><p>使用Portainer管理Docker：</p><ul><li><p>安装Portainer镜像</p><pre><code class="shell">docker pull portainer/portainer</code></pre></li></ul><p>开放Docker网络管理端口：</p><pre><code class="shell"># 编辑配置文件vim /etc/sysconfig/docker# 重启Dockerservice docker restart</code></pre><p>注：</p><ul><li><p>在配置文件结尾添加开放Docker开发2375端口的参数</p><pre><code class="shell">OPTIONS=&#39;-Htcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&#39;</code></pre></li></ul><p>启动Portainer容器：</p><pre><code class="shell">docker run -d -p 9000:9000 portainer/portainer -H tcp://192.168.99.196:2375</code></pre><p>访问Portainer管理界面：<a href="192.168.99.196:9000" target="_blank" rel="noopener">192.168.99.196:9000</a></p><p>图形界面的Worker节点无法显示Swarm共享网络，但是Worker节点可以使用Swarm共享网络创建容器，所以只能在命令行创建使用Swarm共享网络的容器。</p><p>四台主机之上的PXC部署方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1jwjsuj31c00k9gpi.jpg" alt="四台主机之上的PXC部署方案" style="zoom:33%;" /><p>注：</p><ul><li>Keepalived必须安装在Haproxy所在的容器里。</li></ul><p>四台主机之上的前端项目部署方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1kupvnj31c40kdq6a.jpg" alt="四台主机之上的前端项目部署方案" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第06章-部署前后端分离项目</title>
      <link href="/imooc/219-docker/06-front-back-deploy/"/>
      <url>/imooc/219-docker/06-front-back-deploy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>除了MySQL和Redis要使用集群外，业务的节点的部署也要使用集群方案，才能保证高性能、高负载和高可用。这一章我们将学习打包前端VUE项目和后端SpringBoot项目，以集群的方式部署在Docker容器内。</p></blockquote><p>@[TOC]</p><h3 id="6-1-后端项目后端项目部署与负载均衡"><a href="#6-1-后端项目后端项目部署与负载均衡" class="headerlink" title="6-1 后端项目后端项目部署与负载均衡"></a>6-1 后端项目后端项目部署与负载均衡</h3><ol><li><p>在MySQL集群导入项目SQL文件。</p></li><li><p>修改配置文件（数据库连接信息、Redis连接信息、Tomcat端口）</p><pre><code class="yaml">redis:    ## 单节点    # host: localhsot    # port: 6379    # password:     ## 集群    cluster:        nodes:        - 172.19.0.2:6379        - 172.19.0.3:6379        - 172.19.0.4:6379        - 172.19.0.5:6379        - 172.19.0.6:6379        - 172.19.0.7:6379</code></pre></li><li><p>利用Maven打包工程</p><ul><li><p>renren-fast包含了tomcat.jar文件，所以工程打包成JAR文件就能独立运行</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi13ldb3j30no09tjse.jpg" alt="打包部署流程" style="zoom:33%;" /></li></ul></li></ol><pre><code> Maven打包指令 - 进入renren-fast目录，执行mvn命令   ```shell   mvn clean install -Dmaven.test.skip=true   ```   注：   - `clean`：表示清除之前的JAR文件   - `install`：意味着打包到本地   - `-Dmaven.test.skip`：代表跳过测试代码</code></pre><ol start="4"><li><p>运行Java容器部署后台项目</p><ul><li><p>运行Java容器，部署并运行JAR文件</p><pre><code class="shell"># 创建Docker卷，并上传JAR至Docker卷docker volume create volume_name1ls /var/lib/docker/volumes/volume_name1/_data/# 运行Java容器docker run -it -d --name container_name -v volume_name1:/home/soft --net=host java# 进入Java容器docker exec -it container_name bash# 运行Java程序nohup java -jar /home/soft/renren-fast.jar &amp;</code></pre></li></ul></li></ol><ol start="5"><li><p>后台程序负载均衡</p><ul><li><p>Nginx是性能非常出色的反向代理服务器，最大可以支持8万/秒的并发访问</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi14yjzgj30og0dxq4e.jpg" alt="Nginx负载均衡示意图" style="zoom:33%;" /><p>注：Haproxy对TCP/IP支持很好；Nginx对HTTP支持很好。</p></li><li><p>步骤：</p><ol><li><p>安装Nginx镜像</p><ul><li><p>Docker仓库提供了Nginx镜像，下载安装即可。</p><pre><code class="shell">docker pull nginx</code></pre></li></ul></li><li><p>Nginx配置文件</p><pre><code class="conf"># Java容器负载均衡upstream upstream_name {    server 192.168.99.104:6001;# Java容器IP与端口号    server 192.168.99.104:6002;    server 192.168.99.104:6003;}# Nginx服务server {    listen 6101;    server_name 192.168.99.104;    location / {        proxy_pass http://upstream_name;        index index.html index.htm;    }}</code></pre></li><li><p>启动Nginx容器</p><pre><code class="shell"># 将Nginx配置文件上传至/homels /homedocker run -it -d --name container_name -v /home/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre><p>注：Docker数据卷只能映射目录，不能映射文件。</p></li></ol></li></ul></li></ol><h3 id="6-2-后端项目双机热备负载均衡"><a href="#6-2-后端项目双机热备负载均衡" class="headerlink" title="6-2 后端项目双机热备负载均衡"></a>6-2 后端项目双机热备负载均衡</h3><p>利用Keepalived实现双机热备</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi19n70wj30vg0eagoy.jpg" alt="Keepalived实现双机热备示意图" style="zoom:50%;" /><pre><code class="shell"># 进入container_name1容器docker exec -it container_name1 bash# 安装Keepalivedapt-get updateapt-get install Keepalived# 安装vim编辑器apt-get install vim# 修改Keepalived配置文件vi /etc/keepalived/keepalived.conf# 启动Keepalivedservice Keepalived start# 退出docker容器exitping 192.168.99.151</code></pre><pre><code class="shell"># /etc/keepalived/keepalived.confvrrp_instance VI_1 {    state MASTER    interface ens33 # 网卡设置，使用宿主机网络    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    vritual_ipaddress {        192.168.99.151    }}virtual_server 192.168.99.151 6201 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6101 {# 转发的IP        weight 1    }}</code></pre><h3 id="6-3-前端项目后端项目部署与负载均衡"><a href="#6-3-前端项目后端项目部署与负载均衡" class="headerlink" title="6-3 前端项目后端项目部署与负载均衡"></a>6-3 前端项目后端项目部署与负载均衡</h3><p>利用Webpack打包工程</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1bbyiij30t80dygps.jpg" alt="Webpack打包工程" style="zoom:50%;" /><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1csksnj30r007amyi.jpg" alt="前端项目运行" style="zoom:33%;" /><ol><li><p>修改配置文件</p><pre><code class="js">// /static/conf/index-prod.js// api接口请求地址window.SITE_CONFIG[&#39;baseUrl&#39;] = &#39;http://192.168.99.151:6201/renren-fast&#39;;</code></pre></li><li><p>打包前端项目</p><ul><li><p>执行Webpack打包指令</p><pre><code class="shell">npm run build</code></pre></li></ul></li></ol><pre><code> npm安装较慢可以使用[淘宝NPM镜像](https://npm.taobao.org) 使用淘宝NPM镜像定制的cnpm（gzip压缩支持）命令行工具代替默认的npm： ```shell npm install -g cnpm --registry=https://registry.npm.taobao.org ```</code></pre><ul><li><p>打包之后的文件需要拷贝到Nginx中运行</p><pre><code class="conf">server {    listen 6501;# NGINX分配的端口    server_name 192.168.99.104;# NGINX分配的IP。为宿主机IP    location / {        root /home/fn1/renren-vue;        index index.html;    }}</code></pre></li></ul><ol start="3"><li><p>创建并运行Nginx容器</p><pre><code class="shell">docker run -it -d --name container_name1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx</code></pre></li></ol><ol start="4"><li><p>利用Keepalived实现双机热备</p>   <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi1ewuhvj31980digpo.jpg" alt="Keepalived实现前端双机热备" style="zoom: 33%;" /><ol><li><p>创建3个前端项目节点</p></li><li><p>创建2个Nginx节点做负载均衡</p><pre><code class="shell"># ff1/nginx.confupstream fn {    server 192.168.99.104:6501;    server 192.168.99.104:6502;    server 192.168.99.104:6503;}server {    listen       6601;    server_name  192.168.99.104;     location / {          proxy_pass   http://fn;        index  index.html index.htm;      }  }</code></pre></li><li><p>安装Keepalived实现双机热备</p><p>见下一节。。</p></li></ol></li></ol><h3 id="6-4-前端项目双机热备负载均衡"><a href="#6-4-前端项目双机热备负载均衡" class="headerlink" title="6-4 前端项目双机热备负载均衡"></a>6-4 前端项目双机热备负载均衡</h3><pre><code class="shell">#进入ff1节点docker exec -it ff1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre><code class="shell"># /etc/keepalived/keepalived.confvrrp_instance VI_1 {   state MASTER   interface ens33 # 网卡。   virtual_router_id 52   priority 100   advert_int 1   authentication {       auth_type PASS       auth_pass 123456   }   virtual_ipaddress {       192.168.99.152# 虚拟IP   }}virtual_server 192.168.99.151 6701 {   delay_loop 3   lb_algo rr   lb_kind NAT   persistence_timeout 50   protocol TCP   real_server 192.168.99.104 6601 {       weight 1   }}</code></pre><p>注：VM虚拟机对Keepalived支持不友好。当VM虚拟机挂起重新恢复后，宿主机会PING不通Keepalived的虚拟IP，此时需要进入容器重启Keepalived服务。</p><pre><code class="shell">service keepalived restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第05章-搭建Redis集群</title>
      <link href="/imooc/219-docker/05-redis-cluster/"/>
      <url>/imooc/219-docker/05-redis-cluster/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redis高速缓存可以减少数据库IO的压力，在秒杀商品、抢红包等业务中频繁用到。这一章我们要学习的是为renren-fast项目搭建6节点的RedisCluster集群。</p></blockquote><p>@[TOC]</p><h3 id="5-1-Redis高速缓存介绍"><a href="#5-1-Redis高速缓存介绍" class="headerlink" title="5-1 Redis高速缓存介绍"></a>5-1 Redis高速缓存介绍</h3><p>高速缓存介绍：</p><ul><li>高速缓存利用内存保存数据，读写速度远远超硬盘</li><li>高速缓存可以减少I/O操作，降低I/O压力</li><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi10gsqsj30ys0ipn4a.jpg" alt="高速缓存介绍-淘宝网" style="zoom:50%;" /></li></ul><p>Redis介绍：</p><ul><li>Redis是Wmware开发的开源免费的KV型NoSQL缓存产品</li><li>Redis具有很好的性能，最多可以提供10万次/秒的读写</li><li>目前新浪微博团队组建了世界上最大规模的Redis集群</li></ul><p>Redis集群介绍：</p><ul><li>Redis目前的集群方案分为以下几种：<ol><li>RedisCluster：官方推荐，没有中心节点</li><li>Codis：中间件产品，存在中心节点。360公司推出。</li><li>Twemproxy：中间件产品，存在中心节点。</li></ol></li></ul><p>RedisCluster：</p><ul><li>无中心节点，客户端与Redis节点直连，不需要中间代理层</li><li>数据可以被分片存储</li><li>管理方便，后续可自行增加或摘除节点</li><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi11ony7j31100mpwiq.jpg" alt="RedisCluster示意图" style="zoom:50%;" /></li></ul><h3 id="5-2-Redis主从同步"><a href="#5-2-Redis主从同步" class="headerlink" title="5-2 Redis主从同步"></a>5-2 Redis主从同步</h3><p>主从同步：</p><ul><li><p>Redis集群中的数据库复制是通过主从同步来实现的</p></li><li><p>主节点（Master）把数据分发给从节点（Slave）</p></li><li><p>主从同步的好处在于高可用，Redis节点有冗余设计</p><p>Master —复制—&gt; Slave</p></li></ul><p>Redis集群高可用：</p><ul><li><p>Redis集群中应该包含奇数个Master，至少应该有3个MAster</p></li><li><p>Redis集群中每个Mater都应该有Slave</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi131rwoj30y00bpju6.jpg" alt="Redis集群中Master与Slave节点的关系" style="zoom:33%;" /></li></ul><p>Redis集群为何不配置负载均衡？</p><ul><li>后台程序使用了Spring架构，而Spring自动实现了负载均衡</li></ul><h3 id="5-3-配置RedisCluster集群"><a href="#5-3-配置RedisCluster集群" class="headerlink" title="5-3 配置RedisCluster集群"></a>5-3 配置RedisCluster集群</h3><p>安装Redis镜像</p><ul><li><p>导入本地Redis镜像文件，运行Redis容器</p><pre><code class="shell">docker pull yyyyttttwwww/redisdocker run -it -d --name redis_name1 -p 5001:6379 --net=network_name1 --ip 172.19.0.2 redis bash</code></pre></li></ul><p>解除Docker集群</p><pre><code class="shell">docker swarm leave -f</code></pre><p>查看Docker内部网络</p><pre><code class="shell">docker network ls</code></pre><p>删除Docker网络</p><pre><code class="shell">docker network rm docker_network_name</code></pre><p>创建Docker网络</p><pre><code class="shell">docker network create -subnet=172.19.0.0/16 net2</code></pre><p>进入Redis的Docker容器</p><pre><code class="shell">docker exec -it redis_name1 bash</code></pre><p>配置Redis节点：</p><pre><code class="shell">/usr/redis/redis.confdaemonize yes                    # 以后台进程运行cluster-enabled yes                # 开启集群cluster-config-file nodes.conf    # 集群配置文件cluster-node-timeout 15000        # 超时时间appendonly yes                    # 开启AOF模式</code></pre><p>启动Redis：</p><pre><code class="shell">cd /usr/redis/src./redis-server ../redis.conf</code></pre><p>安装redis-trib.rb</p><ul><li><p>redis-trib是基于Ruby的Redis集群命令行工具</p><pre><code class="shell">cp /usr/redis/src/redis-trib.rb /usr/redis/clustercd /usr/redis/clusterapt-get install rubyapt-get install rubygemsgem install redis</code></pre></li></ul><p>创建Redis集群</p><ul><li><p>利用redis-trib.rb创建Redis集群</p><pre><code class="shell">./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</code></pre><p>注：</p><ul><li><code>--replicas 1</code>：参数表示为每个主节点创建一个从节点</li></ul></li></ul><p>暂停Docker容器</p><pre><code class="shell">docker pause container_name</code></pre><p>恢复Docker容器</p><pre><code class="shell">docker unpause container_name</code></pre><p>查看Redis集群节点的运行状况</p><pre><code class="shell">cluster nodes</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第04章-搭建MySQL集群</title>
      <link href="/imooc/219-docker/04-mysql-cluster/"/>
      <url>/imooc/219-docker/04-mysql-cluster/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大型项目的持久层都会选择数据库集群，本门课程选择的是MySQL领域中最成熟可靠的PXC（Percona XtraDB Cluster）集群方案。在本章节，我们会学习在Docker容器中划分网段，创建PXC容器和组建5节点的PXC集群。</p></blockquote><p>@[TOC]</p><h3 id="4-1-MySQL集群方案介绍"><a href="#4-1-MySQL集群方案介绍" class="headerlink" title="4-1 MySQL集群方案介绍"></a>4-1 MySQL集群方案介绍</h3><p>单节点数据库的弊病</p><ul><li>大型互联网程序用户群体庞大，所以架构必须要特殊设计</li><li>单节点的数据库无法满足性能上的要求</li><li>单节点的数据库没有冗余设计，无法满足高可用</li></ul><p>单节点MySQL的性能瓶颈</p><ul><li>2016年春节微信红包巨大业务量，数据库承受巨大负载</li></ul><p>常见MySQL集群方案</p><ul><li><p>Replication</p><p>速度快、弱一致性、低价值</p><p>日志、新闻、帖子</p></li><li><p>PXC</p><p>速度慢、强一致性、高价值</p><p>订单、账户、财务</p></li></ul><p>PXC原理</p><blockquote><p>淘宝网的数据库集群也借鉴了PXC集群方案</p></blockquote><ul><li><p>PXC（Percona XtraDB Cluster）</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0iurljj30jr0a1aca.jpg" alt="PXC（Percona XtraDB Cluster）" style="zoom:33%;" /></li><li><p>建议PXC使用PerconaServer（MySQL改进版，性能提升很大）</p></li></ul><p>PXC方案与Replication方案的对比</p><ul><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0jxp2dj30pt0g0gob.jpg" alt="PXC方案" style="zoom:33%;" /><p>双向同步</p></li><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0kupa5j30hu0bv3zs.jpg" alt="Replication方案" style="zoom:33%;" /><p>单向同步</p></li></ul><p>PXC的数据强一致性</p><ul><li><p>PXC采用同步复制，事务在所有集群节点要么同时提交，要么不提交</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0m9qu1j30n40do771.jpg" alt="PXC同步复制机制" style="zoom:33%;" /></li><li><p>Replication采用异步复制，无法保证数据的一致性</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0n3wzhj30m808iab8.jpg" alt="Replication异步复制机制" style="zoom:33%;" /></li></ul><pre><code class="mysql">STOP SLAVE;# 停止slave节点的数据库同步关联SHOW SLAVE STATUS;# 查看slave节点的数据同步状态（Slave_IO_Running、Slave_SQL_Running）</code></pre><p>关闭防火墙端口：</p><blockquote><p>Centos防火墙使用firewall命令</p><p>Ubuntu防火墙使用iptables命令</p></blockquote><pre><code class="shell">iptables -A INPUT -p tcp -dport 4567 -j DROPiptables -A OUTPUT -p tcp -dport 4567 -j DROP</code></pre><h3 id="4-2-创建MySQL集群"><a href="#4-2-创建MySQL集群" class="headerlink" title="4-2 创建MySQL集群"></a>4-2 创建MySQL集群</h3><p>PXC集群安装介绍</p><blockquote><p>PXC集群只能安装在Linux系统或Docker容器</p></blockquote><ul><li><p>Docker的镜像仓库中包含了PXC数据库镜像，<a href="https://hub.docker.com/r/percona/percona-xtradb-cluster/" target="_blank" rel="noopener">下载</a>即可</p><pre><code class="shell">docker pull percona/percona-xtradb-cluster</code></pre></li></ul><p>安装PXC镜像</p><ul><li><p>下载或者导入本地镜像</p><pre><code class="shell"># 下载镜像安装docker pull percona/percona-xtradb-cluster# 导入本地镜像安装docker load &lt; /home/soft/pxc.tar.gz</code></pre><pre><code class="shell"># 修改镜像名称docker tag old_image_name new_image_namedocker rmi old_image_name</code></pre></li></ul><p>创建内部网络</p><ul><li><p>出于安全考虑，需要给PCX集群实例创建Docker内部网络</p><pre><code class="shell"># 创建内部网段docker network create network_name# 查看网段相关信息docker network inspect network_name# 删除网段docker network rm network_name</code></pre><p>Docker内置网段：172.17.0.*</p><p>创建网段1：172.18.0.*</p><p>创建网段2：172.19.0.*</p><p>创建网段3：172.20.0.*</p><p>…以此类推…</p></li></ul><p>  创建自定义端口网段：</p><pre><code class="shell">  docker network create --subnet=172.18.0.0/24 network_name</code></pre><p>Docker容器使用原则：</p><ol><li>一旦创建出Docker容器，尽量不要在容器内保存业务数据，应将业务数据保存在宿主机里。应使用目录映射机制</li><li>PXC运行在Docker容器是不能直接使用映射的目录，PXC容器会启动闪退。此时应使用Docker卷映射目录</li></ol><p>创建Docker卷</p><ul><li><p>容器中的PXC节点映射数据目录的解决办法</p><pre><code class="shell">docker volume create volume_namedocker volume create --name volume_name</code></pre></li></ul><p>查看Docker卷信息</p><pre><code class="shell">docker volume inspect volume_name</code></pre><p>删除Docker卷</p><pre><code class="shell">docker volume rm volume_name</code></pre><p>创建PXC容器</p><ul><li><p>只需要向PXC镜像传入运行参数就能创建出PXC容器</p><pre><code class="shell">docker run -d -p 3306:3306-v volume_name1:/var/lib/mysql-e MYSQL_ROOT_PASSWORD=mysql_root_password-e CLUSTER_NAME=cluster_name-e XTRABACKUP_PASSWORD=xtrabackup_password--prilileged --name=container_name --net=network_name --ip 172.18.0.2pxc</code></pre><p>注：</p><ul><li><code>-d</code>：后台运行容器</li></ul></li></ul><p>创建PXC容器集群</p><pre><code class="shell">docker volume create --name volume_name1docker volume create --name volume_name2docker volume create --name volume_name3docker volume create --name volume_name4docker volume create --name volume_name5docker run -d -p 3306:3306 -v volume_name1:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=mysql_root_password -e CLUSTER_NAME=cluster_name -e XTRABACKUP_PASSWORD=xtrabackup_password --prilileged --name=container_name1 --net=network_name --ip 172.18.0.2 pxcdocker run -d -p 3307:3306 -v volume_name2:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=mysql_root_password -e CLUSTER_NAME=cluster_name -e XTRABACKUP_PASSWORD=xtrabackup_password -e CLUSTER_JOIN=container_name1 --prilileged --name=container_name2 --net=network_name --ip 172.18.0.3 pxcdocker run -d -p 3308:3306 -v volume_name3:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=mysql_root_password -e CLUSTER_NAME=cluster_name -e XTRABACKUP_PASSWORD=xtrabackup_password -e CLUSTER_JOIN=container_name1 --prilileged --name=container_name3 --net=network_name --ip 172.18.0.4 pxcdocker run -d -p 3309:3306 -v volume_name4:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=mysql_root_password -e CLUSTER_NAME=cluster_name -e XTRABACKUP_PASSWORD=xtrabackup_password -e CLUSTER_JOIN=container_name1 --prilileged --name=container_name4 --net=network_name --ip 172.18.0.5 pxcdocker run -d -p 3310:3306 -v volume_name5:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=mysql_root_password -e CLUSTER_NAME=cluster_name -e XTRABACKUP_PASSWORD=xtrabackup_password -e CLUSTER_JOIN=container_name1 --prilileged --name=container_name5 --net=network_name --ip 172.18.0.6 pxc</code></pre><p>数据库客户端连接</p><blockquote><p>ip:宿主机IP<br>port:宿主机与容器映射的端口<br>username:创建实例的数据库用户名（默认root）<br>password:创建实例的数据库密码</p></blockquote><h3 id="4-3-数据库负载均衡"><a href="#4-3-数据库负载均衡" class="headerlink" title="4-3 数据库负载均衡"></a>4-3 数据库负载均衡</h3><blockquote><p>数据库的负载均衡：数据请求均匀的发送给每一个数据节点</p></blockquote><p>数据库负载均衡的必要性：</p><ul><li><p>虽然搭建了集群，但是不使用数据库负载均衡，单节点处理所有请求，负载高，性能差</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0o6a7kj30v00cxgni.jpg" alt="数据库单节点" style="zoom:33%;" /></li><li><p>使用Haproxy做负载均衡，请求被均匀分发给每个节点，单节点负载低，性能好</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0p7lmej30ug0hp42c.jpg" alt="数据库负载均衡" style="zoom:33%;" /></li></ul><p>负载均衡中间件对比</p><table><thead><tr><th>比较</th><th>Haproxy</th><th>Nginx</th><th>Apache</th><th>LVS</th></tr></thead><tbody><tr><td>是否免费</td><td>免费</td><td>免费</td><td>免费</td><td>免费</td></tr><tr><td>支持虚拟机</td><td>支持</td><td>支持</td><td>支持</td><td>否</td></tr><tr><td>HTTP协议</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>TCP/IP协议</td><td>支持</td><td>刚刚支持</td><td>不支持</td><td>支持</td></tr><tr><td>支持插件</td><td>不支持</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>性能</td><td>好</td><td>好</td><td>一般</td><td>最好</td></tr></tbody></table><p>安装Haproxy镜像</p><ul><li><p>Docker仓库中保存了Haproxy的镜像，只需下载即可</p><pre><code class="shell">docker pull haproxy</code></pre></li></ul><p>创建Haproxy配置文件</p><blockquote><p>首先在宿主机创建Haproxy的配置文件，然后将其文件映射到Haproxy的Docker容器</p></blockquote><ul><li><p>配置文件详情可以<a href="https://zhangge.net/5125.html" target="_blank" rel="noopener">参考</a></p><pre><code class="shell">touch /home/soft/haproxy.cfg</code></pre><pre><code class="shell">global    # 工作目录    chroot /usr/local/etc/haproxy    # 日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info    log 127.0.0.1 local5 info    # 守护进程运行    daemondefaults    log global    mode http    # 日志格式    option httplog    # 日志中不记录负载均衡的心跳检测记录    option dontlognull    # 连接超时（毫秒）    timeout connect 5000    # 客户端超时（毫秒）    timeout client 50000    # 服务器超时（毫秒）    timeout server 50000# 监控界面listen admin_stats    # 监控界面的访问的IP和端口    bind 0.0.0.0:8888    # 访问协议    mode http    # URI相对地址    stats uri /dbs    # 统计报告格式    stats realm Clobal\ statistics    # 登录账户信息    stats auth admin:123456# 数据库负载均衡listen proxy-mysql    # 访问的IP和端口    bind 0.0.0.0:3306    # 网络协议    mode tcp    # 负载均衡算法（轮询算法）    # 轮询算法：roundrobin    # 权重算法：static-rr    # 最少连接算法：leastconn    # 请求源IP算法：source    balance roundrobin    # 日志格式    option tcplog    # 在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测    option mysql-check user haproxy    server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000    server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000    server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000    server MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000    server MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000    # 使用keepalive检测死链    option tcpka</code></pre></li></ul><p>创建Haproxy容器</p><pre><code class="shell">docker run -it -d-p 4001:8888 -p 4002:3306-v /home/soft/haproxy:/usr/local/etc/haproxy--name container_name --privileged --net=network_namehaproxyhaproxy -f /usr/local/etc/haproxy/haproxy.cfg</code></pre><p>进入后台运行的Docker容器</p><pre><code class="shell">docker exec -it container_name bash</code></pre><p>创建没有权限的haproxy用户，密码为空</p><p>Haproxy使用这个账户对MySQL数据库心跳检测</p><pre><code class="mysql">create user &#39;haproxy&#39;@&#39;%&#39; identified by &#39;&#39;;</code></pre><p>关闭数据库节点</p><pre><code class="shell">docker stop container_name1</code></pre><h3 id="4-4-负载均衡的高可用方案（上）"><a href="#4-4-负载均衡的高可用方案（上）" class="headerlink" title="4-4 负载均衡的高可用方案（上）"></a>4-4 负载均衡的高可用方案（上）</h3><p>为什么要采用双机热备？</p><ul><li><p>单节点Haproxy不具备高可用，必须要有冗余设计</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0qd4wjj30xc0c5gnb.jpg" alt="单节点Haproxy部署图" style="zoom:33%;" /></li></ul><p>虚拟IP地址</p><blockquote><p>虚拟IP是Haproxy双机热备方案的关键技术</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0rdszyj30y40cmwhs.jpg" alt="虚拟IP地址" style="zoom:33%;" /><p>利用Keepalived实现双机热备</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0sauamj30n80cyq5b.jpg" alt="双机热备的具体细节" style="zoom:33%;" /><p>Haproxy双机热备方案</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0v5ovhj31js0gatfu.jpg" alt="双机热备的架构设计" style="zoom:33%;" /><p>Docker内的虚拟IP不能被外网使用，所以需要借助宿主机Keepalived映射成外网可以访问的虚拟IP</p><p>安装Keepalived</p><ul><li><p>Keepalived必须要安装在Haproxy所在的容器之内</p><pre><code class="shell">docker exec -it container_name bash# 因为Haproxy是使用Ubuntu系统创建出来的，所以此时安装Keepalived需要使用apt-get指令apt-get updateapt-get install keepalived</code></pre></li></ul><p>Keepalived配置文件</p><ul><li><p>Keepalived的配置文件是<code>/etc/keepalived/keepalived.conf</code></p><pre><code class="shell">apt-get install vimvim /etc/keepalived/keepalived.conf</code></pre><pre><code class="shell">vrrp_instance  CONF_NAME {    state  MASTER    interface  eth0    virtual_router_id  51    priority  100    advert_int  1    authentication {        auth_type  PASS        auth_pass  123456    }    virtual_ipaddress {        172.18.0.201    }}</code></pre><p>注：</p><ul><li><p><code>CONF_NAME</code>：配置信息名字，可自定义</p></li><li><p><code>state  MASTER</code>：Keepalived的身份（MASTER主服务，BACKUP备服务器）。主服务要抢占虚拟IP，备服务器不会抢占虚拟IP。</p></li><li><p><code>interface  eth0</code>：网卡设备。eth0是网卡名字，Docker虚拟机的网卡。</p></li><li><p><code>virtual_router_id  51</code>：虚拟路由标识，MASTER和BACKUP的虚拟路由标识必须一致。标识可以是0~255</p></li><li><p><code>priority  100</code>：MASTER权重 要 高于BACKUP，数据越大优先级越高</p></li><li><p><code>advert_int  1</code>：MASTER与BACKUP节点间同步检查（心跳检测）的时间间隔，单位为秒。主备之间必须一致。</p></li><li><p><code>authentication</code>：主从服务器验证方式。主备必须使用相同的密码才能正常通信。心跳检测登录Keepalived节点，开放账号密码。</p></li><li><p><code>virtual_ipaddress</code>：虚拟IP地址。可以设置多个虚拟IP地址，每行一个</p></li></ul></li></ul><p>启动Keepalived</p><ul><li><p>启动Keepalived之后，宿主机可以PING通虚拟IP</p><pre><code class="shell">service Keepalived startping 172.18.0.201</code></pre></li></ul><h3 id="4-5-负载均衡的高可用方案（下）"><a href="#4-5-负载均衡的高可用方案（下）" class="headerlink" title="4-5 负载均衡的高可用方案（下）"></a>4-5 负载均衡的高可用方案（下）</h3><p>…视频丢失…0.0</p><h3 id="4-6-热备份数据"><a href="#4-6-热备份数据" class="headerlink" title="4-6 热备份数据"></a>4-6 热备份数据</h3><p>MySQL备份语句：</p><pre><code class="mysql"># 数据库地址：127.0.0.1# 数据库用户名：root# 数据库密码：123456# 数据库名称：test# 备份数据库到D盘根目录mysqldump -h127.0.0.1 -uroot -p123456 test &gt; d:/backup_file.sql</code></pre><p>冷备份</p><ul><li>冷备份是关闭数据库时候的备份方式，通常做法是拷贝数据文件</li><li>冷备份是最简单最安全的一种备份方式</li><li>大型网站无法做到关闭业务备份数据，所以冷备份不是最佳选择</li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0xf5hnj312g041dh2.jpg" alt="集群冷备份方案" style="zoom:33%;" /><p>热备份</p><ul><li>热备份是在系统运行的状态下备份数据，也是难度最大的备份</li><li>MySQL常见的热备份有LVM和XtraBackup两种方案</li><li>建议使用XtraBackup热备份MySQL</li></ul><p>XtraBackup介绍</p><ul><li>XtraBackup是一款基于InnoDB的在线热备工具，具有开源免费，支持在线热备，占用磁盘空间小，能够非常快速地备份与恢复MySQL数据库。支持MySQL官方版及各种衍生版。XtraBackup支持全量备份、增量备份。</li></ul><p>XtraBackup优势</p><ul><li>XtraBackup备份过程不锁表、快速可靠</li><li>XtraBackup备份过程不会打断正在执行的事务</li><li>XtraBackup能够基于压缩等功能节约磁盘空间和流量</li></ul><p>全量备份和增量备份</p><ul><li>全量备份是备份全部数据。备份过程时间长，占用空间大。</li><li>增量备份是只备份变化的那部分数据。备份时间短，占用空间小。</li></ul><p>对数据库首次备份应使用全量备份，后续可使用增量备份。备份速度快，减少硬盘压力</p><pre><code class="shell">docker volume create volume_backupdocker stop container_namedocker rm container_namedocker run -d -p 3306:3306 -v volume_name1:var/lib/mysql -v colume_backup:/data --privileged -e MYSQL_ROOT_PASSWORD=mysql_root_password -e CLUSTER_NAME=cluster_name -e XTRABACKUP_PASSWORD=xtrabackup_password -e CLUSTER_JOIN=container_name2 --name=container_name1 --net=network_name --ip 172.18.0.2 pxc</code></pre><p>PXC全量备份步骤</p><ul><li><p>PXC容器中安装XtraBackup，并执行备份</p><pre><code class="shell">docker exec -it container_name1 bashapt-get updateapt-get install percona-xtrabackup-24# 数据库用户名：root# 数据库密码：123456innobackupex --user=root --password=123456 /data/backup/full</code></pre></li></ul><p>查看Docker卷信息（如卷位置）</p><pre><code class="shell">docker inspect volume_name</code></pre><p>PXC全量恢复步骤</p><p>数据库恢复数据只有冷还原，没有热还原。恢复数据与事务数据相互影响。</p><ul><li>数据库可以热备份，但是不能热还原。为了避免恢复过程中的数据同步，我们采用空白的MySQL还原数据，然后再建立PXC集群。</li><li>还原数据前要将未提交的事务回滚，还原数据之后重启MySQL</li></ul><pre><code class="shell"># 删除MySQL内部的数据rm -rf /var/lib/mysql/*# 把未提交的事务进行回滚innobackupex --user=root --password=123456 --apply-back /data/backup/full/2018-04-15_05-09-07/# 全量冷还原innobackupex --user=root --password=123456 --copy-back /data/backup/full/2018-04-15_05-09-07/</code></pre><p>步骤：</p><pre><code class="shell">docker stop container_name1 container_name2 container_name3 container_name4 container_name5docker rm container_name1 container_name2 container_name3 container_name4 container_name5docker volume rm volume_name1 volume_name2 volume_name3 volume_name4 volume_name5docker volume create volume_name1docker run -d -p 3306:3306 -v volume_name1:/var/lib/mysql -v colume_backup:/data -e MYSQL_ROOT_PASSWORD=mysql_root_password -e CLUSTER_NAME=cluster_name -e XTRABACKUP_PASSWORD=xtrabackup_password --prilileged --name=container_name1 --net=network_name --ip 172.18.0.2 pxcdcoker exec -it container_name bashrm -rf /var/lib/mysql/*innobackupex --user=root --password=123456 --apply-back /data/backup/full/2018-04-15_05-09-07/innobackupex --user=root --password=123456 --copy-back /data/backup/full/2018-04-15_05-09-07/exitdocker stop container_name1docker start container_name1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第03章-Linux基础知识强化</title>
      <link href="/imooc/219-docker/03-linux-base/"/>
      <url>/imooc/219-docker/03-linux-base/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章内容是巩固和复习Linux系统基础知识，重点讲解Linux系统中的目录结构和常用指令，以及防火墙等。为在Linux环境中部署前后端分离项目扫清基础知识障碍。而且还会讲解Docker虚拟机的安装。</p></blockquote><p>@[TOC]</p><h3 id="3-1-Linux系统构成和基本操作（上）"><a href="#3-1-Linux系统构成和基本操作（上）" class="headerlink" title="3-1 Linux系统构成和基本操作（上）"></a>3-1 Linux系统构成和基本操作（上）</h3><p>Windows操作系统的缺点：</p><ol><li>图形界面未响应会引起卡顿</li><li>安装某些软件需要重新启动系统</li><li>硬件驱动不好会出现 蓝屏、死机</li></ol><p>Linux操作系统的优点：</p><ol><li><p>跨平台的硬件支持，如服务器、嵌入式（手表、智能电视）</p></li><li><p>丰富的软件支持</p><p>CentOS使用yum指令</p><p>Ubuntu使用apt-get指令</p></li><li><p>多用户多任务</p></li><li><p>可靠的安全性</p></li><li><p>良好的稳定性</p></li><li><p>完善的网络功能</p></li></ol><p>Linux目录结构：</p><p>/    ―― Linux根目录</p><p>​    <strong>/dev          ―― 存放抽象硬件（网卡、硬盘）</strong></p><p>​    /boot        ―― 存放内核与启动文件</p><p>​    /lib            ―― 存放系统库文件</p><p>​    <strong>/bin          ―― 存放二进制文件（可执行命令）</strong></p><p>​    /sbin        ―― 存放特权级二进制文件</p><p>​    <strong>/usr          ―― 存放安装程序（软件默认目录）</strong></p><p>​    <strong>/var          ―― 存放经常变化的文件（日志）</strong></p><p>​    <strong>/mnt        ―― 文件挂载目录（U盘、光驱）</strong></p><p>​    <strong>/home     ―― 普通用户目录</strong></p><p>​    /root        ―― 特权用户目录</p><p>​    <strong>/etc          ―― 存放配置文件目录</strong></p><p>​    /opt          ―― 大型软件存放目录（非强制）</p><p>Linux目录与文件管理：</p><ul><li><p>列出目录内容</p><p><code>ls</code></p></li><li><p>创建新目录</p><p><code>mkdir dir_name</code></p></li><li><p>创建文件</p><p><code>touch file_name</code></p></li><li><p>向文件写入内容</p><p><code>echo content_info &gt; file_name</code></p></li><li><p>查看文件内容</p><p><code>cat file_name</code></p></li><li><p>修改文件内容</p><p><code>vi file_name</code></p></li><li><p>复制文件或目录</p><p><code>cp src_name tar_name</code>     ―― 复制文件</p><p><code>cp  -r src_name tar_name</code>    ―― 复制文件夹</p><p>注：</p><ul><li>-r：递归复制目录的内容</li></ul></li><li><p>删除文件或目录</p><p><code>rm file_name</code>    ―― 删除文件</p><p><code>rm -r file_name</code>    ―― 删除文件夹</p><p>注：</p><ul><li>-r：递归删除文件夹的文件</li><li>-f：强制删除文件</li></ul></li><li><p>移动目录或文件</p><p><code>mv -f src_name tar_name</code></p><p>注：</p><ul><li>-f：强制覆盖已存在的目录或文件</li></ul></li><li><p>查看文件属性</p><p><code>ls -l</code>或<code>ll</code></p><pre><code class="shell">-rw-r--r--    1 root root    0 6月    23    23:56 file_name</code></pre><p>注：</p><ul><li><p><code>-rw-r--r--</code>：文件类型与权限</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0ce4gcj31et0g578m.jpg" alt="Linux文件属性" style="zoom:25%;" /></li><li><p><code>1</code>：文件数量</p></li><li><p><code>root root</code>：用户名、用户组</p></li><li><p><code>0</code>：文件（夹）容量大小</p></li><li><p><code>6月    23    23:56</code>：创建文件时间的时间信息，6月23日23:56</p></li><li><p><code>file_name</code>：文件名</p></li></ul></li><li><p>修改文件属性</p><p><code>chmod 700 file_name</code></p><p>权限代码使用三位二进制标识</p></li><li><p>创建新用户</p><p><code>adduser user_name</code></p></li><li><p>为用户设置密码</p><p><code>passwd user_name</code></p></li></ul><h3 id="3-2-Linux系统构成和基本操作（下）"><a href="#3-2-Linux系统构成和基本操作（下）" class="headerlink" title="3-2 Linux系统构成和基本操作（下）"></a>3-2 Linux系统构成和基本操作（下）</h3><p>​    参上。</p><h3 id="3-3-防火墙管理"><a href="#3-3-防火墙管理" class="headerlink" title="3-3 防火墙管理"></a>3-3 防火墙管理</h3><blockquote><p>CentOS默认安装了firewall防火墙</p><p>利用防火墙，我们可以允许或是限制传输的数据通过</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0dc4jyj30yn04p763.jpg" alt="CentOS防火墙" style="zoom:25%;" /></blockquote><p>管理防火墙</p><ul><li><p>查看、启动、关闭、重启防火墙</p><pre><code class="bash"># 查看防火墙firewall-cmd --state# 启动防火墙service firewall start# 关闭防火墙service firewall stop# 重启防火墙service firewall restart</code></pre></li><li><p>端口管理</p><pre><code class="shell"># 开启端口firewall-cmd --permanent --add-port=8080-8085/tcp# 加载设置firewall-cmd --reload# 关闭端口firewall-cmd --permanent --remove-port=8080-8085/tcp</code></pre></li><li><p>查看开启的端口和服务</p><pre><code class="shell"># 查看防火墙已开放端口firewall-cmd --permanent --list-prots# 查看防火墙已启动服务firewall-cmd --permanent --list-services</code></pre></li></ul><h3 id="3-4-Docker虚拟机（上）"><a href="#3-4-Docker虚拟机（上）" class="headerlink" title="3-4 Docker虚拟机（上）"></a>3-4 Docker虚拟机（上）</h3><blockquote><p>隔离性、轻量级</p></blockquote><p>Docker虚拟机架构：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0eip3ij30hc0g4tck.jpg" alt="Docker虚拟机架构" style="zoom:35%;" /><p>Docker创建的所有虚拟实例共用一个Linux内核，对硬件占用较小，属于轻量级虚拟机</p><p>云计算中的Docker虚拟机：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0fy4ikj313e0l0tjr.jpg" alt="云计算中的Docker虚拟机" style="zoom:30%;" /><p>Docker镜像与容器</p><ul><li><p>容器是从镜像中创建出来的虚拟实例</p><blockquote><p>容器用来运行程序，是读写层</p><p>镜像用来安装程序，是只读层</p></blockquote></li></ul><p>安装Docker虚拟机</p><ul><li><p>先更新yum软件管理器，然后再安装Docker</p><pre><code class="shell"># 更新yum软件管理器yum -y update# 安装Dockeryum install -y docker</code></pre><p>注：</p><ul><li>-y：代表选择程序安装中的yes选项</li></ul></li></ul><p>管理Docker虚拟机</p><ul><li><p>启动、关闭与重启</p><pre><code class="shell">service docker startservice docker stopservice docker restart</code></pre></li></ul><p>Docker虚拟机管理命令：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi0hvhmgj31ah0m5wpq.jpg" alt="Docker虚拟机管理命令" style="zoom:30%;" /><h3 id="3-5-Docker虚拟机（下）"><a href="#3-5-Docker虚拟机（下）" class="headerlink" title="3-5 Docker虚拟机（下）"></a>3-5 Docker虚拟机（下）</h3><p>在线安装镜像</p><ul><li><p>在线安装Java镜像</p><pre><code class="shell">docker search javadocker pull java</code></pre><p>国外镜像仓库下载速度较慢，建议使用国内镜像仓库，如DaoCloud</p><p><a href="http://www.daocloud.io" target="_blank" rel="noopener">http://www.daocloud.io</a></p><p>【更多】–&gt;【加速器】–&gt;【配置Docker加速器】–&gt;【复制命令并执行】–&gt;【修改Docker配置(删除<code>,</code>)】</p><pre><code class="shell">curl -sSL https://get.daocloud.io/daotools/ser_mirror.sh | sh -s http://1474c648.m.daocloud.io</code></pre><pre><code class="shell">vi /etc/docker/daemon.json</code></pre><pre><code class="shell"># 查看Docker已经安装镜像docker images</code></pre></li><li><p>导入导出镜像</p><pre><code class="shell"># 导出镜像docker save container_name &gt; /home/container_name.tar.gz# 导入镜像docker load &lt; /home/container_name.tar.gz# 查看Docker已安装镜像docker images# 删除镜像docker rmi image_name</code></pre></li><li><p>启动容器</p><ul><li><p>启动镜像会创建出一个运行状态的容器</p><pre><code class="shell"># 创建并启动一个容器docker run -it image_name bashdocker run -it --name container_name image_name bashdocker run -it --name container_name -p 9000:8080 -p 9001:8085 image_name bashdcoker run -it --name container_name -v /home/project:/soft --privileged image_name bash</code></pre><p>注：</p><ul><li><p><code>-it</code>：启动容器后，开启一个交互界面</p></li><li><p><code>--name myjava</code>：给容器命名（可选）</p></li><li><p><code>java</code>：镜像名称</p></li><li><p><code>bash</code>：启动容器所运行的程序</p></li><li><p><code>-p 9000:8080</code>：映射端口，宿主机9000与容器8080映射</p></li><li><p><code>-v /home/project:/soft</code>：文件或目录的映射，宿主机/home/project与容器/soft映射</p><p>程序的数据库等数据文件应在宿主机存储，利于数据的备份与恢复</p></li><li><p><code>--privileged</code>：文件或目录权限</p></li></ul></li></ul></li><li><p>暂停和停止容器</p><pre><code class="shell"># 暂停容器docker pause container_name# 恢复容器docker unpause container_name# 停止容器docker stop container_name# 开始容器docker start -i container_name</code></pre></li><li><p>删除容器</p><pre><code class="shell">docker rm container_name</code></pre></li><li><p>查看所有容器</p><pre><code class="shell">docker ps -a</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第02章-人人开源前后端分离项目下载与配置</title>
      <link href="/imooc/219-docker/02-renren-fast/"/>
      <url>/imooc/219-docker/02-renren-fast/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本章以renren-fast开源项目为部署案例，详细讲解了这个项目的前端部分和后端部分的安装和配置，在Windows平台上运行调试该项目。</p></blockquote><p>@[TOC]</p><h3 id="2-1-前后端分离框架介绍"><a href="#2-1-前后端分离框架介绍" class="headerlink" title="2-1 前后端分离框架介绍"></a>2-1 前后端分离框架介绍</h3><p>人人网开源项目（<a href="http://www.renren.io" target="_blank" rel="noopener">www.renren.io</a>）</p><ul><li>renren-security：轻量级权限管理系统</li><li>renren-fast：Java快速开发平台</li><li>renren-generator：代码生成器</li></ul><h3 id="2-2-后端项目下载与配置"><a href="#2-2-后端项目下载与配置" class="headerlink" title="2-2 后端项目下载与配置"></a>2-2 后端项目下载与配置</h3><p>renren-fast后台项目：</p><ul><li>SpringBoot、SSM、Shiro、Redis、<strong>Swagger</strong>、<strong>JWT</strong></li></ul><p><strong>单点登录</strong></p><p>Maven环境（Maven依赖于JDK）</p><ul><li>Apache Maven是一套软件工程管理和整合工具</li><li><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a></li><li>解压缩，无需安装。</li><li>配置Maven环境变量</li><li>Maven镜像地址与本地仓库地址配置</li><li>在Eclipse/IDEA中设置Maven的HOME路径与settings.xml文件</li></ul><p><a href="https://gitee.com/renrenio/renren-fast" target="_blank" rel="noopener">renren-fast后端源码下载</a></p><p><a href="https://www.renren.io/guide/" target="_blank" rel="noopener">renren-fast开发文档</a></p><p>数据库管理工具：</p><ul><li>Navicat</li><li><a href="https://www.jetbrains.com/datagrip/" target="_blank" rel="noopener">DataGrip</a></li></ul><h3 id="2-3-前台项目的下载与配置"><a href="#2-3-前台项目的下载与配置" class="headerlink" title="2-3 前台项目的下载与配置"></a>2-3 前台项目的下载与配置</h3><p>renren-fast前端项目：</p><ul><li>VUE：前端工程的MVVM框架</li><li>NodeJS：为前端工程提供了动态运行环境</li><li>ElementUI：为前端工程提供了丰富的组件</li></ul><p><a href="https://github.com/renrenio/renren-fast-vue" target="_blank" rel="noopener">renren-fast前端源码下载</a></p><p>初始化工程：</p><ul><li><p><a href="https://nodejs.org" target="_blank" rel="noopener">安装NodeJS运行工具</a></p></li><li><p>安装依赖&amp;运行项目名</p><pre><code class="shell">cmd 工程目录npm installnpm run dev</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第01章-课程介绍</title>
      <link href="/imooc/219-docker/01-introduce/"/>
      <url>/imooc/219-docker/01-introduce/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://coding.imooc.com/class/219.html" target="_blank" rel="noopener">Docker环境下的前后端分离项目部署与运维</a></p><p>展示前后端分离项目部署的成果，介绍学习本门课程需要的硬件环境和软件环境，并利用VMware虚拟机安装CentOS，搭建Docker部署环境。</p></blockquote><p>@[TOC]</p><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><ul><li><p>课程目的：</p><p>高性能、高负载、高可用的部署方案</p><p>人人网企业级案例讲解分部署集群部署与运维</p></li><li><p>课程收获：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghyxivmjj31400ktthy.jpg" alt="课程收获" style="zoom:67%;" /></li></ul><h3 id="1-2-项目演示"><a href="#1-2-项目演示" class="headerlink" title="1-2 项目演示"></a>1-2 项目演示</h3><ul><li><p>哪些需要集群？</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghyyob43j318g0jl0wi.jpg" alt="哪些需要集群？" style="zoom:33%;" /></li><li><p>人人快速开发平台</p></li><li><p>关闭集群节点：<code>docker pause node1</code></p></li></ul><h3 id="1-3-开发环境要求"><a href="#1-3-开发环境要求" class="headerlink" title="1-3 开发环境要求"></a>1-3 开发环境要求</h3><p>前后端分离项目部署图：</p><ul><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghz0hl9xj318c0jpdla.jpg" alt="前后端分离项目部署图" style="zoom:33%;" /></li></ul><p>查看虚拟机IP地址：<code>ip address</code></p><p>配置SSH：</p><ul><li>Linux默认开启SSH，无需设置</li><li>下载XShell软件</li></ul><p>配置SFTP：</p><ul><li>下载FlashFXP软件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
          <category> 219-Docker环境下的前后端分离项目部署与运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>134-ThreadGroup API介绍之二</title>
      <link href="/wang-thread/134-thread-group-api2/"/>
      <url>/wang-thread/134-thread-group-api2/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">ThreadGroup tg1 = new ThreadGroup(&quot;TG1&quot;);Thread t1 = new Thread(tg1, () -&gt; {    while (true) {        try {            Thread.sleep(1_000);        } catch (InterruptedException e) {            e.printStackTrace();            break;        }    }}, &quot;T1&quot;);t1.start();ThreadGroup tg2 = new ThreadGroup(tg1, &quot;TG2&quot;);Thread t2 = new Thread(tg2, () -&gt; {    while (true) {        try {            Thread.sleep(1_000);        } catch (InterruptedException e) {            e.printStackTrace();            break;        }    }}, &quot;T2&quot;);t2.start();</code></pre><p><code>int activeCount()</code></p><blockquote><p>返回此线程组及其子组中活动线程数的估计值。</p></blockquote><p><code>int activeGroupCount()</code></p><blockquote><p>返回此线程组及其子组中活动线程组的数量的估计值。</p></blockquote><p><code>void checkAccess()</code></p><blockquote><p>确定当前正在运行的线程是否有权修改此线程组。</p></blockquote><p><code>void destroy()</code></p><blockquote><p>销毁该线程组及其所有子组。如果线程组不为空或线程组已被销毁将抛出<code>IllegalThreadStateException</code></p><p>销毁前需要确定线程组里没有活跃的线程</p></blockquote><p><code>int enumerate(Thread[] list)</code></p><blockquote><p>将此线程组及其子组中的每个活动线程复制到指定的数组中。</p></blockquote><p><code>int enumerate(Thread[] list, boolean recurse)</code></p><blockquote><p>将此线程组中(不包含子组)的每个活动线程复制到指定的数组中。</p></blockquote><pre><code class="java">Thread[] ts1 = new Thread[tg1.activeCount()];tg1.enumerate(ts1);System.out.println(Arrays.toString(ts1));// [Thread[T1,5,TG1], Thread[T2,5,TG2]]Thread[] ts2 = new Thread[tg1.activeCount()];tg1.enumerate(ts2, false);System.out.println(Arrays.toString(ts2));// [Thread[T1,5,TG1], null]ThreadGroup mainThreadGroup = Thread.currentThread().getThreadGroup();Thread[] ts3 = new Thread[mainThreadGroup.activeCount()];mainThreadGroup.enumerate(ts3, false);System.out.println(Arrays.toString(ts3));// [Thread[main,5,main], Thread[Monitor Ctrl-Break,5,main], null, null]</code></pre><p><code>void interrupt()</code></p><blockquote><p>中断该线程组（包括子组）中的所有线程。</p></blockquote><p><code>boolean isDaemon()</code></p><blockquote><p>测试此线程组是否是守护程序线程组。</p></blockquote><p><code>void setDaemon(boolean daemon)</code></p><blockquote><p>更改此线程组的守护程序状态。</p><p>守护程序线程组在其最后一个线程停止时或在其最后一个线程组被销毁时会自动销毁。</p><p>线程组创建完成后并没有被销毁，需要显示地销毁关闭，否则将一直存活。</p></blockquote><pre><code class="java">ThreadGroup tg3 = new ThreadGroup(&quot;TG3&quot;);Thread t3 = new Thread(tg3, () -&gt; {    Thread.sleep(1_000);}, &quot;T3&quot;);/*tg3.setDaemon(true);*/Thread.sleep(2_000);System.out.println(tg3.isDestroyed());// true// 手动回收ThreadGrouptg3.destroy();System.out.println(tg3.isDestroyed());</code></pre><p><code>void list()</code></p><blockquote><p>将有关此线程组的信息输出到控制台。主要用来做测试用的。</p></blockquote><p><code>void uncaughtException(Thread t, Throwable e)</code></p><blockquote><p>当此线程组中的线程由于未捕获的异常而停止并且该线程未安装特定的Thread.UncaughtExceptionHandler时，由Java虚拟机调用。</p></blockquote><p><code>boolean parentOf(ThreadGroup g)</code></p><blockquote><p>测试此线程组是不是参数线程组的祖先线程组之一。（测试我是不是你老汉儿）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>133-ThreadGroup API介绍之一</title>
      <link href="/wang-thread/133-thread-group-api1/"/>
      <url>/wang-thread/133-thread-group-api1/</url>
      
        <content type="html"><![CDATA[<p>通过<code>new Thread()</code>创建线程的时候，如果没有指定ThreadGroup，则默认使用创建线程的ThreadGroup。</p><p>ThreadGroup和Thread关系：</p><blockquote><p>线程组代表一组线程。此外，线程组还可以包括其他线程组。线程组形成一棵树，其中除初始线程组之外的每个线程组都有一个父级。</p><p>允许线程访问有关其自己的线程<em>组的信息，但不允许访问有关其线程组的</em>父线程组或任何其他线程组的信息。（测试结果：<strong>可以访问父线程组的只读信息，也可以访问其他线程组的只读信息</strong>）</p></blockquote><p>main是一个线程，其ThreadGroup为main</p><pre><code class="java">public static void main(String[] args) {    Thread.currentThread().getName()// main    Thread.currentThread().getThreadGroup().getName()// main}</code></pre><p>main线程的优先级为10（最高），StackSize也是比手动创建的线程大。</p><p>线程组的创建：</p><ol><li><p>use the name</p><blockquote><p><code>ThreadGroup(String name)</code></p></blockquote><pre><code class="java">ThreadGroup tg1 = new ThreadGroup(&quot;TG1&quot;);Thread t1 = new Thread(tg1, () -&gt; {    while (true) {        try {            ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();            System.out.println(threadGroup.getName());// TG1            // 访问线程父ThreadGroup的信息            System.out.println(threadGroup.getParent().getName());// main            System.out.println(threadGroup.getParent().activeCount());// 3            System.out.println(threadGroup.getParent().isDaemon());// false            // sleep不会放弃CPU执行权            Thread.sleep(10_000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}, &quot;T1&quot;);t1.start();System.out.println(&quot;t1&#39;s thread group name = &quot;+t1.getThreadGroup().getName());// TG1</code></pre></li><li><p>use the parent and group name</p><blockquote><p><code>ThreadGroup(ThreadGroup parent, String name)</code></p></blockquote><pre><code class="java">ThreadGroup tg2 = new ThreadGroup(tg1, &quot;TG2&quot;);System.out.println(&quot;tg2&#39;s name = &quot;+tg2.getName());System.out.println(&quot;tg2&#39;s parent name = &quot;+tg2.getParent().getName());</code></pre></li></ol><p>TG3与TG1为同一个父ThreadGroup-main，测试TG3能否访问TG1的一些信息</p><pre><code class="java">ThreadGroup tg3 = new ThreadGroup(&quot;TG3&quot;);Thread t3 = new Thread(tg3, () -&gt; {    System.out.println(&quot;&gt;&gt;&gt;&gt;&quot; + t1.getName());// TG1    Thread[] threads = new Thread[tg1.activeCount()];    tg1.enumerate(threads);    Stream.of(threads).forEach(System.out::println);// Thread[T1,5,TG1]}, &quot;T3&quot;);t3.start();</code></pre><p>测试结果：<strong>可以访问其他线程组的信息</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>132-如何捕获线程运行期间的异常</title>
      <link href="/wang-thread/132-catch-thread-exception/"/>
      <url>/wang-thread/132-catch-thread-exception/</url>
      
        <content type="html"><![CDATA[<p>捕获线程异常</p><pre><code class="java">public static void main(String[] args) {    Thread t = new Thread(() -&gt; {        try {            Thread.sleep(1_000L);            int result = 10 / 0;            System.out.println(&quot;result = &quot; + result);        } catch (InterruptedException e) {            e.printStackTrace();        }    });    t.start();    t.setUncaughtExceptionHandler((thread, e) -&gt; {        System.out.println(e);        System.out.println(thread.getName());    });}</code></pre><p>StackTrace。方法调用。</p><pre><code class="java">public class ThreadException {    public static void main(String[] args) {        new Test1().test();    }}</code></pre><pre><code class="java">public class Test1 {    private Test2 test2 = new Test2();    public void test() {        test2.test();    }}</code></pre><pre><code class="java">public class Test2 {    public void test() {        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();        Stream.of(stackTrace)                .filter(e -&gt; !e.isNativeMethod())                .forEach(e -&gt;                        Optional.of(e.getClassName() + &quot;.&quot; + e.getMethodName() + &quot;:&quot; + e.getLineNumber()).ifPresent(System.out::println)                );    }}</code></pre><Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/><Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131-如何给你的应用程序注入钩子程序，Linux下演示</title>
      <link href="/wang-thread/131-hook-processor/"/>
      <url>/wang-thread/131-hook-processor/</url>
      
        <content type="html"><![CDATA[<p>如何获取线程的Exception？</p><blockquote><p>我知道线程的<code>void run()</code>方法是不可以抛出异常的，如果线程死掉，调用者是不知道线程执行情况的。</p><p>如果没有捕获异常，在错误的情况下只是输出堆栈信息，调用者并不知道是什么异常导致。</p></blockquote><p>线程的栈可以跟踪到方法调用。</p><p>JDK模式：client、server</p><p>server模式会进行运行时优化。JIT，即Just In Time</p><p>Runtime可以调用一些系统命令</p><pre><code class="java">public class ExitCapture {    public static void main(String[] args) {        while (true) {            Thread.sleep(1_000L);            System.out.println(&quot;I am working...&quot;);        }    }}</code></pre><pre><code class="shell">javac ExitCapture.javajava -cp . ExitCapturenohup java -cp . ExitCapture &amp;tail -f nohup.outkill 2181</code></pre><p>如果程序占用了很多数据库连接或者是文件句柄，想要在kill程序的时候一并进行释放，或者在异常退出程序的情况下通知一下调用者程序知道它出错了，并不是调用者时时地去监控程序。（程序主动告诉，并不是被动发现）</p><pre><code class="java">public class ExitCapture {    public static void main(String[] args) {        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {            System.out.println(&quot;The application will be exit.&quot;);            notifyAndRelease();        }));        int i = 0;        while (true) {            Thread.sleep(1_000L);            System.out.println(&quot;I am working...&quot;);            i++;            if (i &gt; 20) {                throw new RuntimeException(&quot;Error&quot;);            }        }    }    private static void notifyAndRelease() {        System.out.println(&quot;notify to the admin.&quot;);        Thread.sleep(1_000L);        System.out.println(&quot;Will release resource(socket, file, connection.)&quot;);        Thread.sleep(1_000L);        System.out.println(&quot;Release and Notify Done!&quot;);    }}</code></pre><p>运行程序，在i&gt;20时程序抛出异常，被捕获到并执行<code>notifyAndRelease()</code>；通过<code>kill</code>杀死程序也可以被捕获并执行<code>notifyAndRelease()</code>，但是使用<code>kill -9</code>强制杀死程序则不会执行<code>notifyAndRelease()</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTF-8带BOM转UTF-8无BOM格式编码</title>
      <link href="/utf8bom-to-utf8/"/>
      <url>/utf8bom-to-utf8/</url>
      
        <content type="html"><![CDATA[<ol><li><p>保存的时候去掉BOM头（notepad++支持<strong>以UTF-8无BOM格式编码</strong>）</p></li><li><p>程序做兼容，兼容代码如下：</p><pre><code class="java">public static String deleteUTF8Bom(String fileStr) {    byte[] UTF8_BOM_BYTES = new byte[]{(byte) 0xEF, (byte) 0xBB, (byte) 0xBF};    byte[] bytes = fileStr.getBytes();    if (bytes[0] == UTF8_BOM_BYTES[0]            &amp;&amp; bytes[1] == UTF8_BOM_BYTES[1]            &amp;&amp; bytes[2] == UTF8_BOM_BYTES[2]) {        return new String(bytes, 3, bytes.length - 3);    }    return fileStr;}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中DO、BO、DTO、VO、AO、PO</title>
      <link href="/code-rules-object-model/"/>
      <url>/code-rules-object-model/</url>
      
        <content type="html"><![CDATA[<h2 id="1-DO（Domain-Object）领域对象"><a href="#1-DO（Domain-Object）领域对象" class="headerlink" title="1.DO（Domain Object）领域对象"></a>1.DO（Domain Object）领域对象</h2><p>​        就是从现实世界中抽象出来的有形或无形的业务实体。一般<strong>和数据中的表结构对应</strong>。</p><h2 id="2-BO-Business-Object-业务对象"><a href="#2-BO-Business-Object-业务对象" class="headerlink" title="2.BO(Business Object) 业务对象"></a>2.BO(Business Object) 业务对象</h2><p>​        主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 </p><p>​        比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。</p><h2 id="3-DTO（Data-Transfer-Object）数据传输对象"><a href="#3-DTO（Data-Transfer-Object）数据传输对象" class="headerlink" title="3.DTO（Data Transfer Object）数据传输对象"></a>3.DTO（Data Transfer Object）数据传输对象</h2><blockquote><p> 这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，</p></blockquote><p>​        但在这里，泛指用于展示层(Controller)与服务层(Service)之间的数据传输对象</p><p>​        DTO 的单向的？ 还是相互的？</p><h2 id="4-VO-View-Object-值对象"><a href="#4-VO-View-Object-值对象" class="headerlink" title="4.VO(View Object) 值对象"></a>4.VO(View Object) 值对象</h2><p>​        视图对象，用于展示层。它的作用是把某个指定页面（或组件）的所有数据封装起来，是Controller层返回给前端（浏览器端）的数据的类型</p><h2 id="5-PO-Persistant-Object-持久对象"><a href="#5-PO-Persistant-Object-持久对象" class="headerlink" title="5.PO(Persistant Object) 持久对象"></a>5.PO(Persistant Object) 持久对象</h2><p>​        在 O/R 映射的时候出现的概念，如果没有 O/R 映射，没有这个概念存在了。通常对应数据模型 ( 数据库 )，本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的 Java 对象。最简单的 PO 就是对应数据库中某个表中的一条记录，多个记录可以用 PO 的集合。 PO 中应该不包含任何对数据库的操作。</p><h2 id="6-TO-Transfer-Object-，数据传输对象"><a href="#6-TO-Transfer-Object-，数据传输对象" class="headerlink" title="6.TO(Transfer Object) ，数据传输对象"></a>6.TO(Transfer Object) ，数据传输对象</h2><p>​        在应用程序不同 tie( 关系 ) 之间传输的对象</p><h2 id="7-POJO-Plain-Ordinary-Java-Object-简单无规则-java-对象"><a href="#7-POJO-Plain-Ordinary-Java-Object-简单无规则-java-对象" class="headerlink" title="7.POJO(Plain Ordinary Java Object) 简单无规则 java 对象"></a>7.POJO(Plain Ordinary Java Object) 简单无规则 java 对象</h2><p>​        纯的传统意义的 java 对象。就是说在一些 Object/Relation Mapping 工具中，能够做到维护数据库表记录的 persisent object 完全是一个符合 Java Bean 规范的纯 Java 对象，没有增加别的属性和方法。我的理解就是最基本的 Java Bean ，只有属性字段及 setter 和 getter 方法。</p><h2 id="8-DAO-Data-Access-Object-数据访问对象"><a href="#8-DAO-Data-Access-Object-数据访问对象" class="headerlink" title="8.DAO(Data Access Object) 数据访问对象"></a>8.DAO(Data Access Object) 数据访问对象</h2><p>​        是一个 SUN 的一个标准 J2EE 设计模式， 这个模式中有个接口就是 DAO ，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作</p><p><strong>分层领域模型规约：</strong></p><ul><li>DO（ Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（ Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（ Business Object）：业务对象。 由Service层输出的封装业务逻辑的对象。</li><li>AO（ Application Object）：应用对象。 在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（ View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>POJO（ Plain Ordinary Java Object）：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。</li><li>Query：数据查询对象，各层接收上层的查询请求。 注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴代码规范考试试题</title>
      <link href="/alibaba-p3c/alibaba-p3c-exam/"/>
      <url>/alibaba-p3c/alibaba-p3c-exam/</url>
      
        <content type="html"><![CDATA[<ol><li><p>【多选 】关于索引的设计和使用，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.若查询条件中不包含索引的最左列，则无法使用索引。</li><li><input checked="" disabled="" type="checkbox"> B.对于范围查询，只能利用索引的最左列。</li><li><input checked="" disabled="" type="checkbox"> C.对于<code>order by A</code>或<code>group by A</code>语句，在<code>A</code>上建立索引，可以避免排序。</li><li><input checked="" disabled="" type="checkbox"> D.对于多列排序，需要所有列排序方向一致，才能利用索引。</li></ul></li><li><p>【多选 】关于explain执行计划，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>type</code>列显示了连接使用了何种类型，从最好到最差的连接类型为：<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>range</code>，<code>index</code>，<code>ALL</code>.</li><li><input checked="" disabled="" type="checkbox"> B.<code>possible_keys</code>显示可能在这张表中的索引，如果为空，表示没有可能的索引。</li><li><input checked="" disabled="" type="checkbox"> C.<code>key</code>列表示实际使用的索引。</li><li><input checked="" disabled="" type="checkbox"> D.<code>ref</code>列显示索引的哪一列被使用了。</li></ul></li><li><p>【多选 】关于数据库模糊检索的描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.绝对禁止左模糊。</li><li><input checked="" disabled="" type="checkbox"> B.绝对禁止全模糊。</li><li><input disabled="" type="checkbox"> C.绝对禁止右模糊。</li><li><input checked="" disabled="" type="checkbox"> D.全模糊或左模糊查询需求，优先使用搜索引擎。</li></ul></li><li><p>【多选 】数组使用<code>Arrays.asList</code>转化为集合，下列说法哪些正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> <strong>A.数组元素的修改，会影响到转化过来的集合。</strong></li><li><input disabled="" type="checkbox"> B.数组元素的修改，不会影响到转化过来的集合。</li><li><input checked="" disabled="" type="checkbox"> <strong>C.对于转换过来的集合，它的<code>add</code>/<code>remove</code>/<code>clear</code>方法会抛出：<code>UnsupportedOperationException</code>.</strong></li><li><input checked="" disabled="" type="checkbox"> D.<code>Arrays.asList</code>体现的是适配器模式，只是转换接口，后台的数据仍是数组。</li></ul></li><li><p>【多选 】关于捕获异常和抛异常，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.如果需要捕获不同类型异常，为了方便处理，可以使用<code>catch(Exception e){}</code>。</li><li><input checked="" disabled="" type="checkbox"> B.不要捕获异常后不处理，丢弃异常信息。</li><li><input checked="" disabled="" type="checkbox"> C.捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</li><li><input checked="" disabled="" type="checkbox"> D.异常定义时区分<code>unchecked</code>/<code>checked</code>异常，避免直接使用<code>RuntimeException</code>抛出。</li></ul></li><li><p>【单选】KV结构的集合，在处理null值的存储上有细微的区别，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> <p>A.<code>TreeMap</code>的key不可以为null</p></li><li><input disabled="" type="checkbox"> <p>B.<code>TreeMap</code>的key可以为null</p></li><li><input disabled="" type="checkbox"> <p>C.<code>ConcurrentHashMap</code>的key可以为null</p></li><li><input disabled="" type="checkbox"> <p>D.<code>ConcurrentHashMap</code>的value可以为null</p><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td><code>Hashtable</code></td><td>不允许为NULL</td><td>不允许为NULL</td><td>Dictionary</td><td>线程安全</td></tr><tr><td><code>ConcurrentHashMap</code></td><td>不允许为NULL</td><td>不允许为NULL</td><td>AbstractMap</td><td>分段锁技术</td></tr><tr><td><code>TreeMap</code></td><td>不允许为NULL</td><td><em>允许为NULL</em></td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td><code>HashMap</code></td><td><em>允许为NULL</em></td><td><em>允许为NULL</em></td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table></li></ul></li><li><p>【多选】关于<code>Java</code>的接口描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.在接口类中的方法和属性使用<code>public</code>修饰符。</li><li><input checked="" disabled="" type="checkbox"> B.对于<code>Service</code>类，内部的实现类加<code>Imp</code>的后缀与接口区别。例如：<code>ProductServicelmpl</code>实现<code>ProductService</code>接口。</li><li><input checked="" disabled="" type="checkbox"> C.对于<code>Service</code>类，基于<code>SOA</code>的理念，是以接口方式暴露服务。</li><li><input checked="" disabled="" type="checkbox"> D.尽量不在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，而且是整个应用的基础常量。</li></ul></li><li><p>【多选】关于代码注释，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> <p>A.特殊注释标记，请注明标记人与标记时间。</p></li><li><input checked="" disabled="" type="checkbox"> <p>B.待办事宜（TODO）：（[标记人，标记时间，[预计处理时间]）</p></li><li><input disabled="" type="checkbox"> <p>C.在注释中用FIXME标记某代码虽然实现了功能，但是实现的方法有待商椎，希望将来能改进</p></li><li><input checked="" disabled="" type="checkbox"> <p>D.在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况 </p><table><thead><tr><th>标记</th><th>说明</th></tr></thead><tbody><tr><td>TODO</td><td>如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</td></tr><tr><td>FIXME</td><td>如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</td></tr><tr><td>XXX</td><td>如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</td></tr></tbody></table></li></ul></li><li><p>【多选】关于文件编码和格式的设定，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.IDE的<code>text file encoding</code>设置为<code>GBK</code>格式。</li><li><input checked="" disabled="" type="checkbox"> B.IDE的t<code>ext file encoding</code>设置为<code>UTF-8</code>格式。</li><li><input checked="" disabled="" type="checkbox"> C.IDE中文件的换行符使用<code>Unix</code>格式。</li><li><input disabled="" type="checkbox"> D.IDE中文件的换行符使用<code>Windows</code>格式。</li></ul></li><li><p>【多选】在《阿里巴巴Java开发手册》中，提到不要对单元测试存在哪些误解？</p><ul><li><input checked="" disabled="" type="checkbox"> A.那是测试同学干的事情。</li><li><input checked="" disabled="" type="checkbox"> B.单元测试代码是多余的。</li><li><input checked="" disabled="" type="checkbox"> C.单元测试代码不需要维护。</li><li><input checked="" disabled="" type="checkbox"> D.单元测试与线上故障没有辩证关系。</li></ul></li><li><p>【多选】对于索引<code>(a，b，c)</code>，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.查询语句<code>where a between 5 and 10</code>可以使用该索引。</li><li><input checked="" disabled="" type="checkbox"> B.查询语句<code>where a = 5 and b between 5 and 10</code>可以使用该索引。</li><li><input checked="" disabled="" type="checkbox"> C.查询语句<code>where a in（5, 6, 7, 8, 9）and b = 5</code>可以使用该索引。</li><li><input disabled="" type="checkbox"> D.查询语句<code>where b = 5 and c = 10</code>可以使用该索引。</li></ul></li><li><p>【多选】以下关于命名规约内容说明，正确的是：</p><ul><li><input disabled="" type="checkbox"> A.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，并且使用<del>复数形式</del>，例口：应用工具类包名为<code>com.alibaba.mpp.utils</code></li><li><input checked="" disabled="" type="checkbox"> B.类名使用<code>UperCamelCase</code>，必须通从验峰形式，但以下情形例外：（领域模型的相关命名）<code>DO</code>/<code>DTO</code>/<code>VO</code>/<code>DA0</code>等。</li><li><input checked="" disabled="" type="checkbox"> C.抽象类命名使用<code>Abstrac</code>或<code>Base</code>开头；异常类命名使用<code>Exepion</code>结尾；测试类命名以它要测式的类的名称开始，以<code>Test</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> D.枚举类名建议带上<code>Enum</code>后缀，枚举成员名称需要全大写，单词间用下划线隔开。</li></ul></li><li><p>【多选】关于类命名，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.抽象类命名使用<code>Abstract</code>或<code>Base</code>开头。</li><li><input checked="" disabled="" type="checkbox"> B.异常类命名使用<code>Excepion</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> C.测法类命名以它要测试的类的名称开始，以<code>Test</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> D.如果使用到了设计模式，建议在类名中体现出具体模式。例如代理模式的类命名：<code>LoginProxy</code>；观察者模式命名：<code>ResourceObserver</code>.</li></ul></li><li><p>【多选】下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</li><li><input disabled="" type="checkbox"> B.永久弃用的代码段注释掉即可，即不用加任何注释。</li><li><input checked="" disabled="" type="checkbox"> C.对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠（///）来说明注释掉代码的理由。</li><li><input checked="" disabled="" type="checkbox"> D.不要在视图模板中加入任何复杂的逻辑。</li></ul></li><li><p>【多选】关于日志级别的使用，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.<code>info</code>日志尽可能多输出，方便开发人员排查问题。</li><li><input checked="" disabled="" type="checkbox"> B.如果使用<code>warn</code>来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。</li><li><input checked="" disabled="" type="checkbox"> C.生产环境禁止输出<code>debug</code>日志。</li><li><input checked="" disabled="" type="checkbox"> D.<code>error</code>级别只记录系统逻辑出错、异常或者重要的错误信息。</li></ul></li><li><p>【多选】以下关于格式规约的说法，正确的有哪些：</p><ul><li><input checked="" disabled="" type="checkbox"> A.左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格，如：<code>if (flag == 1) {System.out.println(&quot;world&quot;);}</code></li><li><input checked="" disabled="" type="checkbox"> B.<code>if</code>/<code>for</code>/<code>while</code>/<code>switch</code>/<code>do</code>等保留字与左右括号之间都必须加空格。</li><li><input disabled="" type="checkbox"> C.<code>while</code>这个保留字比较特殊，使用时左右括号之间可以不用加空格，例如：<code>while(true){...}</code></li><li><input checked="" disabled="" type="checkbox"> D.任何运算符左右必须加一个空格，运算符包括赋值运算符<code>=</code>、逻辑运算符<code>&amp;&amp;</code>、加减乘除符号、三目运行符等。</li></ul></li><li><p>【多选】关于用日志记录异常信息，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.日志尽量记录案发现场信息和异常堆栈信息。</li><li><input checked="" disabled="" type="checkbox"> B.如果日志中输出<code>POJO</code>类，<code>POJO</code>类需要重写<code>toString()</code>方法，避免只输出<code>hashCode</code>.</li><li><input disabled="" type="checkbox"> C.不建议输出任何日志，因为日志记录消耗性能。</li><li><input disabled="" type="checkbox"> D.捕获异常后，一律抛给调用者去处理。</li></ul></li><li><p>【多选】关于工具类二方库已经提供的，尽量不要在本应用中编程实现，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>JSON</code>操作使用<code>fasijson</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>MD5</code>操作使用<code>commons-codec</code>，</li><li><input disabled="" type="checkbox"> C.<code>ArrayUtils</code>、<code>NumberUtils</code>、<code>DateFormatUtils</code>、<code>DateUtils</code>等优先使用<code>org apache.commons.lang</code>包。</li><li><input checked="" disabled="" type="checkbox"> D.<code>CollectionUtils</code>优先使用<code>org.apache.commons.collections4</code>包。</li></ul></li><li><p>【多选】关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。</li><li><input disabled="" type="checkbox"> B.魔法值是指程序中随意定义并赋值的变量值，如果代码编写者明白变量值意义是可以任意使用的，例如在代码中写<code>if (status == 3) return error;</code>符合规范。</li><li><input checked="" disabled="" type="checkbox"> C.如果变量值仅在一个范围内变化推荐用<code>Enum</code>类。</li><li><input disabled="" type="checkbox"> D.在程序中，一律禁止使用枚举类型。</li></ul></li><li><p>【多选】下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</li><li><input checked="" disabled="" type="checkbox"> B.在<code>JDK8</code>中，针对统计时间等场景，推荐使用<code>Instant</code>类。</li><li><input checked="" disabled="" type="checkbox"> C.尽量不要在<code>VM</code>中加入变量声明、逻辑运算符，更不要在<code>VM</code>模板中加入任何复杂的逻辑。</li><li><input checked="" disabled="" type="checkbox"> D.后台输送给页面的变量必须加<code>$!{var}</code>——中间的感叹号。</li></ul></li><li><p>【多选】关于变量、方法名、包的命名，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>POJO</code>类中的任何布尔类型的变量，都不要加<code>is</code>，因为部分框架解析时有可能会出现序列化错误。</li><li><input checked="" disabled="" type="checkbox"> B.包名统一使用单数形式，如：<code>com.alibaba.mpp.util</code>。</li><li><input checked="" disabled="" type="checkbox"> C.中括号是数组类型的一部分，数组定义如下：<code>String[] args</code>；不要误写为<code>String args[]</code>;</li><li><input checked="" disabled="" type="checkbox"> D.<code>Service</code>/<code>DAO</code>层方法命名可以参考规约，例如：删除的方法推荐使用<code>remove</code>或<code>delete</code>做前缀。</li></ul></li><li><p>【多选】关于枚举类型，以下描述符合规范的是：</p><ul><li><input disabled="" type="checkbox"> A.只要是常量，就使用权举值。</li><li><input checked="" disabled="" type="checkbox"> B.如果变量值在一个范围内变化，而且还带有名称之外的延伸属性，必须使用<code>Enum</code>类，如：<code>pubic enum MonthEnum{ JANUARY(1), FEBRUARY(2), MARCH(3), APRIL(4), …, DECEMBER(12);}</code>。</li><li><input checked="" disabled="" type="checkbox"> C.枚举名命名建议带上<code>Enum</code>，枚举成员名称需要全大写，单词用<code>_</code>分割。</li><li><input disabled="" type="checkbox"> D.定义星期一至星期日这种范围固定的信息，不推荐使用枚举类型。</li></ul></li><li><p>【多选】关于使用<code>iBATIS</code>操作数据，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.如果表中字段和<code>DO</code>中的字段名完全一致，可直接用<code>DO</code>作为<code>resultClass</code>。</li><li><input disabled="" type="checkbox"> B.<code>iBATIS</code>中自带了<code>queryForList(String statementName, int start, int size)</code>的分页接口，可直接使用，无需再自行封装。</li><li><input checked="" disabled="" type="checkbox"> C.不要定义大而全的数据更新接口，对整个<code>DO</code>进行更新。必须按需更新。</li><li><input checked="" disabled="" type="checkbox"> D.<code>sqlmap</code>中写<code>update</code>语句时，必须包含对记录中<code>gmt_modified</code>字段的更新。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，以下哪些字段属于表的必备字段：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>id</code></li><li><input checked="" disabled="" type="checkbox"> B.<code>gmt_modified</code></li><li><input disabled="" type="checkbox"> C.<code>parent id</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>gmt_create</code></li></ul></li><li><p>【多选】防止<code>NPE</code>，是程序员的基本修养，对于可能产生<code>NPE</code>的场景，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.数据库的查询结果可能为<code>null</code></li><li><input disabled="" type="checkbox"> B.集合只需要判断<code>isNotEmpty</code>，对取出的数据元素不需要判断是否为<code>null</code></li><li><input checked="" disabled="" type="checkbox"> C.远程调用返回对象，一律要求进行<code>NPE</code>判断。</li><li><input checked="" disabled="" type="checkbox"> D.对于<code>Session</code>中获取的数据，建议<code>NPE</code>检查，避免空指针。</li></ul></li><li><p>【多选】<code>Hashtable</code>，<code>HashlMap</code>，<code>ConcurrentHashMap</code>都是Map的实现类，它们在处理mul值的存储上有细微的区别，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Hashtable</code>的<code>KV</code>都不可以为<code>null</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>HashlMap</code>的<code>KV</code>都可以为<code>null</code>。</li><li><input disabled="" type="checkbox"> C.<code>HashMap</code>的<code>K</code>不可以为<code>null</code>，<code>V</code>可以为<code>null</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>ConcurentHashlMap</code>的<code>KV</code>都不可以为<code>null</code></li></ul></li><li><p>【多选】关于数据库是与否概念的列的命名方式，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.对于是与否概念的列名，必须使用<code>can_abc</code>来表示。</li><li><input checked="" disabled="" type="checkbox"> B.对于是与否概念的列名，必须使用<code>is_abc</code>来表示。</li><li><input disabled="" type="checkbox"> C.数据类型是<code>varchar(1)</code>（<code>Y</code>表示是，<code>N</code>表示否）。</li><li><input checked="" disabled="" type="checkbox"> D.数据类型是<code>unsigned tiny int</code>.（<code>1</code>表示是，<code>0</code>表示否）。</li></ul></li><li><p>【多选】关于<code>count</code>相关的使用，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.不要使用<code>count(列名)</code>或<code>count(常量)</code>来替代<code>count(*)</code>。</li><li><input disabled="" type="checkbox"> B.<code>count(列名)</code>会统计值为<code>NULL</code>的行，而<code>count(*)</code>不会统计。</li><li><input checked="" disabled="" type="checkbox"> C.当某一列的值全是<code>NULL</code>时，<code>count(列名)</code>返回0。</li><li><input checked="" disabled="" type="checkbox"> D.在程序代码中写分页查询逻辑时，若<code>count</code>为<code>0</code>应直接返回，以避免执行后面的分页语句。</li></ul></li><li><p>【多选】关于二方库依赖的解析命令，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>mvn dependency:resolve</code>打印出已仲裁依赖的列表。</li><li><input checked="" disabled="" type="checkbox"> B.<code>mvn dependency.tree</code>打印工程整个的依赖树结构。</li><li><input checked="" disabled="" type="checkbox"> C.<code>mvn dependency:tree -Dverbose -Dincludes=commons-lang</code>打印出与<code>commons-lang</code>相关的详细依赖。</li><li><input disabled="" type="checkbox"> D.<code>mvn clean install</code>打印工程整个的依赖树结构，并部署到本地仓库中。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，数据库的表设计允许适当沉余，以提升SQL查询的性能，避免表的关联查询，下列哪些字段<strong>不允许沉余</strong>：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>text</code>类型的字段。</li><li><input disabled="" type="checkbox"> B.基本固定不变的类目名称。</li><li><input checked="" disabled="" type="checkbox"> C.<code>varchar(2500)</code>的段。</li><li><input checked="" disabled="" type="checkbox"> D.需要频繁修改的字段。</li></ul></li><li><p>【多选】为了更方便地进行单元测试，被测试的业务代码应避免以下哪些情况？</p><ul><li><input checked="" disabled="" type="checkbox"> A.构造方法中做的事情过多。</li><li><input checked="" disabled="" type="checkbox"> B.存在过多的全局变量和静态方法。</li><li><input checked="" disabled="" type="checkbox"> C.存在过多的外部依赖。</li><li><input checked="" disabled="" type="checkbox"> D.存在过多的条件语句。</li></ul></li><li><p>【多选】关于方法的返回值是否可以为null，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.方法的返回值可以为null，如果是集合，必须返回空集合。</li><li><input checked="" disabled="" type="checkbox"> B.方法的返回值可以为null，不强制返回空集合，或者空对象等。</li><li><input checked="" disabled="" type="checkbox"> C.方法实现者必须添加注释，充分说明什么情况下会返回null值。</li><li><input checked="" disabled="" type="checkbox"> D.防止NPE是调用者的责任。</li></ul></li><li><p>【多选】关于索引效率，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.使用索引的效率一定高于全表扫描的效率。</li><li><input disabled="" type="checkbox"> B.关于<code>explain</code>的结果，<code>type=index</code>的索引效率好于<code>type=ref</code>。</li><li><input checked="" disabled="" type="checkbox"> C.SQL查询条件<code>where a like &#39;%阿里%&#39;</code>，不会走索引。</li><li><input checked="" disabled="" type="checkbox"> D.SQL查询条件<code>where a like &#39;阿里%&#39;</code>，a列创建了索引，一般会使用索引进行检索。</li></ul></li><li><p>【多选】关于Integer值的比较，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Integer a = 3; Integer b = 3;</code>那么条件表达式<code>(a==b)</code>返回的结果是<code>true</code>。</li><li><input disabled="" type="checkbox"> B.<code>Integer a = 3; Integer b = 3;</code>那么条件表达式<code>(a==b)</code>返回的结果是<code>false</code>。</li><li><input disabled="" type="checkbox"> C.<code>Integer a = 273; Integer b = 273;</code>那么条件表达式<code>(a==b)</code>返回的结果是<code>true</code>。</li><li><input checked="" disabled="" type="checkbox"> D.<code>Integer a = 273; Integer b = 273;</code>那么条件表达式(a==b)返回的结果是<code>false</code>。</li></ul></li><li><p>【单选】关于测试代码的覆盖率，下列哪些说法是正确的？</p><ul><li><input disabled="" type="checkbox"> A.路径覆盖是最强覆盖，符合路径覆盖且测试全部通过，程序绝对没有问题。</li><li><input checked="" disabled="" type="checkbox"> B.语句覆盖度是最弱的覆盖度量方式。</li><li><input disabled="" type="checkbox"> C.分支覆盖与条件覆盖其实是一回事。</li><li><input disabled="" type="checkbox"> D.判定条件覆盖与路径覆盖其实是一回事。</li></ul></li><li><p>【多选】关于Java的方法使用，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Object#equals</code>方法容易抛空指针，使用常量或确定有值的对象来调用<code>.equals()</code>方法。</li><li><input checked="" disabled="" type="checkbox"> B.所有的相同类型的包装类对象之间值的比较，全部使用<code>.equals()</code>方法比较。</li><li><input disabled="" type="checkbox"> C.<code>DO / VO</code>等领域模型类不需要覆写<code>Object#toString()</code>方法，没啥用处。</li><li><input checked="" disabled="" type="checkbox"> D.慎用<code>Object#clone()</code>方法来拷贝对象。</li></ul></li><li><p>【多选】通过集合<code>A.subList()</code>获取子集合B，下列说法哪些是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.返回的集合B没有实现<code>Serializable</code>接口，不能被序列化，所以不能应用于<code>RPC</code>场景。</li><li><input checked="" disabled="" type="checkbox"> B.在B集合中添加某个元素，那么A集合也会添加进去此元素。</li><li><input disabled="" type="checkbox"> C.集合A中元素的修改不会影响到集合B的任何操作。</li><li><input checked="" disabled="" type="checkbox"> D.对A元素个数的修改，会导致集合B的遍历产生<code>ConcurrentModificationException</code>异常。</li></ul></li><li><p>【多选】对于索引的基本原理，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.索引的数据结构主要有<code>B-Tree</code>、<code>Hash</code>、<code>R-Tree</code>、<code>Full-Text</code>等。</li><li><input checked="" disabled="" type="checkbox"> B.从物理存储来看，主要分为聚集(clustered)和非聚集(non-clustered)索引。</li><li><input checked="" disabled="" type="checkbox"> C.MySQL的表是聚集索引组织表(index of table)。</li><li><input checked="" disabled="" type="checkbox"> D.聚簇索引的叶子节点存放的是数据，非聚簇索引的叶子节点存放的是非聚集索引的key和主键值。</li></ul></li><li><p>【单选】关于二方库升级，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.升级二方库只是改个版本号，不需要关联功能的回归。</li><li><input checked="" disabled="" type="checkbox"> B.升级二方库需要比对仲裁结果的差异，谨慎评估。</li><li><input disabled="" type="checkbox"> C.升级二方库，绝对不会影响到其它二方库的版本号。</li><li><input disabled="" type="checkbox"> D.只要此二方库负责人保证说不会有任何影响，即可大胆升级，直接发布上线。</li></ul></li><li><p>【多选】关于maven依赖、仲裁、规则，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>&lt;dependencies&gt;</code>的依赖会默认传递给子项目。</li><li><input disabled="" type="checkbox"> B.<code>&lt;dependencies&gt;</code>的依赖绝对不会传递给子项目。</li><li><input checked="" disabled="" type="checkbox"> C.在<code>&lt;dependencyManagement&gt;</code>中指定版本号。</li><li><input checked="" disabled="" type="checkbox"> D.避免在不同的子项目，声明同一个二方库的不同版本号。</li></ul></li><li><p>【多选】针对<code>TCP</code>协议，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.<code>TCP</code>链接主动关闭的一方，在完成四次挥手协议后，即会立即关闭并释放<code>socket</code>，</li><li><input disabled="" type="checkbox"> B.处于<code>time_wait</code>状态的<code>socket</code>，其实是已经关闭状态，当需要新建连接时，可以被马上复用。</li><li><input checked="" disabled="" type="checkbox"> C.当大量<code>socket</code>于<code>time_wait</code>状态时，会导致可用<code>socket</code>资源稀缺，从而导致服务器并发能力下降。</li><li><input checked="" disabled="" type="checkbox"> D.通过修改<code>/etc/sysctl.conf</code>配置文件，减小<code>time_wait</code>的超时时间，可以降低<code>time_wait</code>状态的<code>socket</code>数量，从而提升服务器并发能力。</li></ul></li><li><p>【多选】关于<code>try-catch</code>的使用方式，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.推荐用<code>try-catch</code>来做流程控制、条件控制。</li><li><input checked="" disabled="" type="checkbox"> B.捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</li><li><input disabled="" type="checkbox"> C.对大段代码进行<code>try-catch</code>，利用<code>Throwable</code>来捕捉，万无一失。</li><li><input checked="" disabled="" type="checkbox"> D.对大段代码进行<code>try-catch</code>，这是不负责任的表现，分清稳定代码和非稳定代码，对非稳定的代码做对应的异常处理。</li></ul></li><li><p>【多选】关于系统安全，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A非<code>SEO URL</code>必须配置为禁止爬虫访问。</li><li><input checked="" disabled="" type="checkbox"> B.用户生成内容的场景，如发帖评论等，必须实现防刷。</li><li><input checked="" disabled="" type="checkbox"> C.使用平台资源，比如短信、邮件等功能，避免被滥刷资损，同时防止对用户造成骚扰。</li><li><input checked="" disabled="" type="checkbox"> D.文本内容必须进行违禁词过滤。</li></ul></li><li><p>【多选】关于并发处理，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li><li><input checked="" disabled="" type="checkbox"> B.同步处理时，能锁部分代码区块的情况下不要锁整个方法；高并发时，同步调用应该考虑到性能损耗。</li><li><input checked="" disabled="" type="checkbox"> C.创建线程或线程池时，推荐给线程指定一个有意义的名称，方便出错时回溯。</li><li><input disabled="" type="checkbox"> D.推荐使用<code>Executors.newFixedThreadPool(int x)</code>生成指定大小的线程池。</li></ul></li><li><p>【单选】在定义<code>DO/DTO/V0/</code>等<code>POJO</code>类时，对属性默认值的设定，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.String类型的默认值设定为空字符串。</li><li><input disabled="" type="checkbox"> B.Date类型的默认值设定为<code>new Date()</code>。</li><li><input disabled="" type="checkbox"> C.集合类型的默认值设定为<code>Collections.EMPTY_LIST</code>。</li><li><input checked="" disabled="" type="checkbox"> D.不要设定任何属性默认值。</li></ul></li><li><p>【单选】集合在遍历过程中，有时需要对符合一定条件的元素进行删除，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.在<code>foreach</code>循环里进行元素的<code>remove</code>操作。</li><li><input checked="" disabled="" type="checkbox"> <strong>B.使用<code>Iterator</code>方式，如果有并发，需要对<code>iterator</code>对象加锁。</strong></li><li><input disabled="" type="checkbox"> C.<code>iterator</code>进行元素的删除操作，绝对是线程安全的。</li><li><input disabled="" type="checkbox"> D.Java无法实现在遍历时，进行册删除元素操作。</li></ul></li><li><p>【多选】关于二方库的<code>snapshot</code>与<code>release</code>的区别，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>snapshot</code>在本地编译时，都会到中央仓库下载最新的二方库。</li><li><input checked="" disabled="" type="checkbox"> B.<code>release</code>在本地编译时，如果已经存在相同的版本号，即使中央仓库有最新相同版本的二方库也不会拉取。</li><li><input disabled="" type="checkbox"> C.应用使用了A的<code>release</code>版本二方库，A依赖了B的<code>snapshot</code>二方库，应用本地编译时，并不会拉取B最新的<code>snapsho</code>二方库。</li><li><input checked="" disabled="" type="checkbox"> D.应用发布尽量使用<code>release</code>版本的二方库，此举是为了保证发布的幂等性。</li></ul></li><li><p>【多选】关于多线程并行处理定时任务的情况，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.推荐使用<code>Timer</code>方式处理。</li><li><input checked="" disabled="" type="checkbox"> B.推荐使用<code>ScheduledExecutorService</code>方式处理。</li><li><input checked="" disabled="" type="checkbox"> C.<code>Timer</code>运行多个<code>TimeTask</code>时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行。</li><li><input checked="" disabled="" type="checkbox"> D.<code>ScheduledExecutorService</code>并发运行多个定时任务时，其中某线程抛出异常，不会影响到其它线程的继续运行。</li></ul></li><li><p>【多选】关于构造方法，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在<code>init</code>方法中。</li><li><input checked="" disabled="" type="checkbox"> B.当一个类有多个构造方法，应该按顺序放置在一起，便于阅读。</li><li><input checked="" disabled="" type="checkbox"> C.如果不允许外部直接通过<code>new</code>来创建对象，那么构造方法必须是<code>private</code>。</li><li><input disabled="" type="checkbox"> D.构造方法中可以有业务实现代码，如对成员变量的简单运算、业务判断等。</li></ul></li><li><p>【多选】关于注释，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.方法内部单行注释，在被注释语句上方另起一行，使用<code>//</code>注释。</li><li><input checked="" disabled="" type="checkbox"> B.所有的类都必须添加创建者信息。</li><li><input checked="" disabled="" type="checkbox"> C.相比较使用“半吊子”英文来注释，用中文注释把问题说清楚更合适。</li><li><input checked="" disabled="" type="checkbox"> D.所有的枚举类型字段必须要有注释，说明每个数据项的用途。</li></ul></li><li><p>【多选】关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.跨应用共享常量：放置在二方库中，通常是<code>client.jar</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> B.应用内共享常量：通常放置在一方库的<code>modules</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> C.子工程内部共享常量：即在当前子工程的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> D.类内常量：直接在类内部<code>private static final</code>定义。</li></ul></li><li><p>【多选】关于基本数据类型与包装数据类型的使用标准，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.所有的<code>POJO</code>类属性必须使用包装数据类型。</li><li><input checked="" disabled="" type="checkbox"> B.<code>RPC</code>方法的返回值和参数必须使用包装数据类型。</li><li><input disabled="" type="checkbox"> C.因为JAVA的自动装箱与拆箱机制，不需要根据场景来区分数据类型。</li><li><input checked="" disabled="" type="checkbox"> D.所有的局部变量推荐使用基本数据类型。</li></ul></li><li><p>【多选】关于线程池管理线程的好处，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.能够减少在创建和销毁线程上所花的时间以及系统资源的开销。</li><li><input disabled="" type="checkbox"> B.使用线程池一定能避免<code>OOM</code>问题。</li><li><input checked="" disabled="" type="checkbox"> C.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</li><li><input disabled="" type="checkbox"> D.线程池能够根据资源等待情况，自动调整线程优先级并解决死锁问题。</li></ul></li><li><p>【多选】关于生产环境的日志文件，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.应用的日志文件统一保存在：<code>/home/admin/应用名/logs/路径下</code>，便于统一维护以及认知统一。</li><li><input checked="" disabled="" type="checkbox"> B.日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。</li><li><input checked="" disabled="" type="checkbox"> C.避免重复打印日志，浪费磁盘空间，务必在<code>log4j.xml</code>中设置<code>additivity=false</code>。</li><li><input checked="" disabled="" type="checkbox"> D.错误日志和业务日志尽量分开存放。</li></ul></li><li><p>【多选】关于二方库的依赖处理，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.依赖于一个二方库群时，必须定义一个统一版本变量，避免各子二方库版本号不一致。</li><li><input disabled="" type="checkbox"> B.可以允许子项目的<code>pom</code>依赖中出现相同的<code>Groupld</code>，相同的<code>Artifactld</code>，但是不同的<code>Version</code>。</li><li><input checked="" disabled="" type="checkbox"> C.所有<code>pom</code>文件中的依赖声明放在<code>&lt;dependencies&gt;</code>语句块中，所有版本仲裁放在<code>&lt;dependencyManagemet&gt;</code>语句块中。</li><li><input checked="" disabled="" type="checkbox"> D.线上应用不要依赖<code>SNAPSHOT</code>版本（安全包除外）。</li></ul></li><li><p>【多选】关于数据库中<code>NULL</code>的描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.<code>NULL=NULL</code>的返回结果为<code>true</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>NULL</code>与任何值的比较结果都为<code>NULL</code>。</li><li><input disabled="" type="checkbox"> C.<code>NULL&lt;&gt;1</code>的返回结果为<code>true</code>。</li><li><input checked="" disabled="" type="checkbox"> D.当某一列的值全是NULL时，<code>sum(col)</code>的返回结果为<code>NULL</code>。</li></ul></li><li><p>【多选】关于表字段和索引，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.表字段注释，如果修改字段含义或对字段表示的状态追加时，需要及时更新。</li><li><input checked="" disabled="" type="checkbox"> B.合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</li><li><input disabled="" type="checkbox"> C.针对表的每个字段都增加索引，加快查询速度。</li><li><input checked="" disabled="" type="checkbox"> D.字段的区分度越高，索引的查找速度越快。</li></ul></li><li><p>【多选】关于参数校验，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.批量处理接口必须做好接口入参保护。</li><li><input checked="" disabled="" type="checkbox"> B.需要极高稳定性和可用性的方法需要对参数进行校验。</li><li><input checked="" disabled="" type="checkbox"> C.底层的方法，在上层调用中参数多半已经被校验过，可以考虑不校验。</li><li><input checked="" disabled="" type="checkbox"> D.对外提供的开放接口，都要进行参数检验。</li></ul></li><li><p>【多选】关于二方库GroupID和ArtifactID格式，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.GroupID格式为：com.{公司/子公司}.业务线[.子业务]。</li><li><input disabled="" type="checkbox"> B.GroupID格式为：com.{公司/子公司}.业务线.子业务线.子模块。</li><li><input disabled="" type="checkbox"> C.ArtifactlD格式为：产品线名_模块名或者产品线.模块名。</li><li><input checked="" disabled="" type="checkbox"> D.ArtifactID格式为：产品线名-模块名。</li></ul></li><li><p>【多选】关于应用与数据库之间的操作，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.对外提供一个大而全的接口进行POJO的update更新，这样比较省事，省代码。</li><li><input checked="" disabled="" type="checkbox"> B.使用事务回滚的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</li><li><input disabled="" type="checkbox"> C.应用服务器与数据库之间是短连接。</li><li><input checked="" disabled="" type="checkbox"> D.应用服务器与数据库之间是长连接。</li></ul></li><li><p>【多选】关于MySQL性能优化的描述，下列哪些说法是正确的</p><ul><li><input checked="" disabled="" type="checkbox"> A.主键查询优先于二级索引查询。</li><li><input checked="" disabled="" type="checkbox"> B.表连接有一定的代价，故表连接数量越少越好。</li><li><input checked="" disabled="" type="checkbox"> C.一般情况下，二级索引扫描优先于全表扫描。</li><li><input checked="" disabled="" type="checkbox"> D.可以使用通过索引避免排序代价。</li></ul></li><li><p>【多选】关于<code>checked/unchecked exception</code>，下列哪些说法是正确的</p><ul><li><input disabled="" type="checkbox"> A.继承<code>java.lang.Error</code>的类属于<code>checked exception</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>checked</code>异常继承<code>java.lang.Exception</code>类。</li><li><input checked="" disabled="" type="checkbox"> C.<code>unchecked</code>异常继承<code>java.lang.RuntimeException</code>类。</li><li><input checked="" disabled="" type="checkbox"> D.<code>NullPointerException</code>、<code>llegalArgumentException</code>属于<code>unchecked exception</code>。</li></ul></li><li><p>【多选】关于领域模型命名，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.数据对象命名：<code>xxxDO</code>，<code>xxx</code>即为数据表名，例如：<code>ResellerAccountDO</code>。</li><li><input checked="" disabled="" type="checkbox"> B.数据传输对象：<code>xxxDTO</code>，<code>xxx</code>为业务领域相关的名称，例如<code>ProductDTO</code>。</li><li><input checked="" disabled="" type="checkbox"> C.展示层对象：<code>xxxVO</code>，<code>xxx</code>一般为网页名称，例如<code>RecommendProductVO</code>。</li><li><input disabled="" type="checkbox"> D.<code>POJO</code>是<code>DO</code>/<code>DTO</code>/<code>BO</code>/<code>VO</code>的统称，命名成<code>xxxPOJO</code>。</li></ul></li><li><p>【多选】以下关于命名规约内容说明，正确的是：</p><ul><li><input disabled="" type="checkbox"> A.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，并且使用复数形式，例如：应用工具类包名为<code>com.albaba.mpp.utils</code></li><li><input checked="" disabled="" type="checkbox"> B.类名使用<code>UperCamelCase</code>，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）<code>DO</code>/<code>DTO</code>/<code>VO</code>/<code>DA0</code>等。</li><li><input checked="" disabled="" type="checkbox"> C.抽象类命名使用<code>Abstract</code>域<code>Base</code>开头；异常类命名使用<code>Exception</code>结尾；测试类命名以它要测试的类的名称开始，以<code>Test</code>结尾。</li><li><input checked="" disabled="" type="checkbox"> D.枚举类名建议带上<code>Enum</code>后缀，枚举成员名称需要全大写，单词间用下划发隔开。</li></ul></li><li><p>【多选】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量，那么下列说法正确的是</p><ul><li><input checked="" disabled="" type="checkbox"> A.Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。</li><li><input checked="" disabled="" type="checkbox"> B.Correct，正确的输入，并得到预期的结果。</li><li><input checked="" disabled="" type="checkbox"> C.Design，与设计文档相结合，来编写单元测试。</li><li><input disabled="" type="checkbox"> D.Equal，单元测试环境必须与线上生产环境一致。「ERROR」</li></ul></li><li><p>【多选】在多线程并发读写的情况下，下列哪些处理方式能保证对象的线程安全：</p><ul><li><input disabled="" type="checkbox"> A.使用<code>volatile</code>关键字。「<code>volatile</code>解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题；但是如果多写，同样无法解决线程安全问题。」</li><li><input checked="" disabled="" type="checkbox"> B.使用<code>synchronized</code>关键字给对象的读写操作加锁。</li><li><input checked="" disabled="" type="checkbox"> C.如果是基本类型，推荐使用<code>java.util.concurent.atomic</code>包下面提供的线程安全的基本类型包装类，例如<code>Atomiclnteger</code>。</li><li><input checked="" disabled="" type="checkbox"> D.如果是集合，推荐使用<code>java.util.concurent</code>提供的并发集合类，例如：<code>ConcurrentHashMap</code>。</li></ul></li><li><p>【多选】关于接口使用抛异常还是返回错误码，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.向公司外提供的<code>http</code>/<code>api</code>接口，推荐使用<code>错误码</code>方式返回异常或者错误信息。</li><li><input checked="" disabled="" type="checkbox"> B.对于应用内部的方法调用，推荐使用<code>抛出异常</code>的方式处理异常或者错误信息。</li><li><input checked="" disabled="" type="checkbox"> C.跨应用的<code>RPC</code>调用，推荐使用将<code>错误码</code>和<code>错误简短信息</code>封装成<code>Result</code>的方式进行返回。</li><li><input checked="" disabled="" type="checkbox"> D.对外提供的接口，一定要保证逻辑健壮性：尽量避免空指针等技术类异常；对于业务类异常要做好错误码或者异常信息的封装。</li></ul></li><li><p>【多选】关于<code>join</code>的描述，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>join</code>的字段，数据类型须保持绝对一致。</li><li><input checked="" disabled="" type="checkbox"> B.<code>join</code>列必须有索引。</li><li><input checked="" disabled="" type="checkbox"> C.优先<code>where</code>过滤，其次再<code>join</code>关联。</li><li><input disabled="" type="checkbox"> D.只要满足业务需求和，<code>join</code>表的个数不受限制。</li></ul></li><li><p>【多选】关于参数有效性验证，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.防止<code>page size</code>过大导致内存溢出。</li><li><input checked="" disabled="" type="checkbox"> B.防止正则输入源串拒绝服务<code>ReDOS</code>。</li><li><input checked="" disabled="" type="checkbox"> C.防止任意重定向。</li><li><input checked="" disabled="" type="checkbox"> D.预防SQL注入。</li></ul></li><li><p>【单选】关于日志的打印，下列哪些写法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.<code>System.out(&quot;xxx&quot;+e.getMessage())</code>。</li><li><input disabled="" type="checkbox"> B.<code>System.err(&quot;xxx&quot;+e.getMessage())</code>。</li><li><input disabled="" type="checkbox"> C.<code>e.printStackTrace()</code>。</li><li><input checked="" disabled="" type="checkbox"> D.<code>logger.error(&quot;exception happens product info:&quot; + product.toString() + &quot;_&quot; + e.getMessage() e)</code>。</li></ul></li><li><p>【多选】关于异常的处理方式，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.为防止<code>obj</code>对象本身空指针异常，书写代码时应该注意加异常捕获处理，例1：<code>try{objmethod()} catcth(NullPointerException) {.…}</code>。</li><li><input checked="" disabled="" type="checkbox"> B.方法签名中，抛给调用者的关键字为<code>throws</code></li><li><input disabled="" type="checkbox"> C.方法内部，抛出异常实对象为<code>throws</code></li><li><input checked="" disabled="" type="checkbox"> D.自定义异常要做到“认知对等”，即：抛出者和接收者要保持对自定义异常的认知统一，接收方需要知道这种异常的含义和对应的处理方案。</li></ul></li><li><p>【单选】关于使用<code>explain</code>对数据库性能进行优化分析，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>SQL</code>性能优化的目标：至少要达到<code>range</code>级别，要求是<code>ref</code>级别，如果可以是<code>consts</code>最好。</li><li><input disabled="" type="checkbox"> B.<code>index</code>级别走的是扫描索引，所以速度会比<code>ref</code>快。</li><li><input disabled="" type="checkbox"> C.<code>range</code>级别是指对表进行范围索引。</li><li><input disabled="" type="checkbox"> D.<code>ref</code>级别是指使用主键或者唯一索引。</li></ul></li><li><p>【多选】关于异常处理，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>try</code>块放到了事务代码中，<code>catch</code>异常后，如果需要回滚事务，必须要手动回滚事务。</li><li><input checked="" disabled="" type="checkbox"> B.在<code>fnally</code>块必须对文件流进行关闭。</li><li><input checked="" disabled="" type="checkbox"> C.不能在<code>finaly</code>块使用<code>return</code>，<code>finally</code>块中的<code>return</code>返回后方法结束执行，不会再执行<code>try</code>块中的<code>return</code>语句。</li><li><input checked="" disabled="" type="checkbox"> D.循环体中避免不必要的<code>try-catch</code>操作。</li></ul></li><li><p>【多选】关于客户数据展示，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.客户的密码，密钥及密保问题答案等信息禁止展示。</li><li><input checked="" disabled="" type="checkbox"> B.客户的银行卡号只显示后四位。</li><li><input checked="" disabled="" type="checkbox"> C.客户的证件号码只显示第一位和最后一位，在必要业务场景下，经多因子强验证后可完整展示。</li><li><input checked="" disabled="" type="checkbox"> D.涉及有完整展示客户信息的页面均需要接入防爬系统。</li></ul></li><li><p>【多选】数组使用<code>Arrays.asList()</code>转化为集合，下列说法哪些正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.数组元素的修改，会影响到转化过来的集合。</li><li><input disabled="" type="checkbox"> B.数组元素的修改，不会影响到转化过来的集合。</li><li><input checked="" disabled="" type="checkbox"> C.对于转换过来的集合，它的<code>add</code>/<code>remove</code>/<code>clear</code> 方法会抛出：<code>UnsupportedOperationException</code>。</li><li><input checked="" disabled="" type="checkbox"> D.<code>Arrays.asList()</code>体现的是适配器模式，只是转换接口，后台的数据仍是数组。</li></ul></li><li><p>【多选】关于数据库查询的描述，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.当需要获取数据表所有字段的值映射到<code>DO</code>时，可使用<code>select *</code>来查询。</li><li><input checked="" disabled="" type="checkbox"> B.绝对禁止左模糊和全模糊查询；限制使用右模糊查询。全模糊或左模糊搜索的需求走搜索引擎实现。</li><li><input checked="" disabled="" type="checkbox"> C.禁止使用存储过程来查询返回数据。</li><li><input checked="" disabled="" type="checkbox"> D.在表查询中，需<code>order by</code>排序时，优先使用主键列，索引列。</li></ul></li><li><p>【多选】关于Java代码的设计和开发注意事项，下列哪些说法符合《集合开发规约》</p><ul><li><input checked="" disabled="" type="checkbox"> A.禁止将URL、文件名、系统参数、数据库连接地址、业务规则的可变参数，硬编码在工程中。</li><li><input checked="" disabled="" type="checkbox"> B.<code>long</code>或者<code>Long</code>初始赋值时，必须是大写<code>L</code>，不能小写。</li><li><input checked="" disabled="" type="checkbox"> C.当一个类有多个构造方法，或是多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</li><li><input checked="" disabled="" type="checkbox"> D.相同参数类型，同等业务含义，才可以使用Java的可变参数，参数的类型尽量避免使用<code>Object</code>。</li></ul></li><li><p>【多选】好的单元测试必须遵守<code>AlR</code>原则，那么<code>AlR</code>原则具体是指：</p><ul><li><input checked="" disabled="" type="checkbox"> A.单元测试应该是全自动执行的，并且非交互式的。</li><li><input disabled="" type="checkbox"> B.单元测试必须在线上环境能够全部被正确地编译。</li><li><input checked="" disabled="" type="checkbox"> C.为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</li><li><input checked="" disabled="" type="checkbox"> D.单元测试是可以重复执行的。</li></ul></li><li><p>【多选】关于数据库索引的命名，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.主键索引（<code>primary key</code>），字段类型为<code>unsigned bigint</code>、单表时推荐自增、步长为1。</li><li><input disabled="" type="checkbox"> B.主键索引（<code>primary key</code>），字段类型为<code>unsigned bigint</code>、单表时推荐自增、步长为2。</li><li><input checked="" disabled="" type="checkbox"> C.唯一索引（<code>unique key</code>），命名规则为<code>uk_</code>字段名（如果多个字段继续下划线）。</li><li><input checked="" disabled="" type="checkbox"> D.普通索引（<code>normal index</code>），标记成<code>idx_</code>字段名（如果多个继续下划线）。</li></ul></li><li><p>【多选】关于异常处理的注意事项，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.事务场景中，抛出异常被<code>catch</code>后，如果需要回滚，一定要手动回滚事务。</li><li><input checked="" disabled="" type="checkbox"> B.在<code>finally</code>块必须对文件流进行关闭。</li><li><input disabled="" type="checkbox"> C.推荐在<code>finally</code>块使用<code>return</code>语句。</li><li><input disabled="" type="checkbox"> D.在<code>try</code>块内，可以不用对可能为<code>null</code>的对象做非空判断，因为如果抛掷<code>NPE</code>，会被<code>catch</code>块捕获并处理。</li></ul></li><li><p>【多选】关于数据库中表相关的命名，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.表名、字段名禁止出现数字开头，禁止两个下划线中间只出现数字。</li><li><input checked="" disabled="" type="checkbox"> B.表名不使用复数名词。</li><li><input disabled="" type="checkbox"> C.表必备三字段命名：<code>id</code>，<code>gmt_create</code>，<code>gmt_modify</code>。</li><li><input checked="" disabled="" type="checkbox"> D.表必备三字段命名：<code>id</code>，<code>gmt_create</code>，<code>gmt_modified</code>。</li></ul></li><li><p>【多选】对于索引的基本原理，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.索引的数据结构主要有<code>B-Tree</code>、<code>Hash</code>、<code>R-Tree</code>、<code>Full-Text</code>等。</li><li><input checked="" disabled="" type="checkbox"> B.从物理存储来看，主要分为聚集（clustered）和非聚集（non-clustered）索引。</li><li><input checked="" disabled="" type="checkbox"> C.MySQL的表是聚集索引组织表（index of table）。</li><li><input checked="" disabled="" type="checkbox"> D.聚簇索引的叶子节点存放的是数据，非聚簇索引的叶子节点存放的是非聚集索引的key和主键值。</li></ul></li><li><p>【多选】关于应用中可以直接依赖的日志框架，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input disabled="" type="checkbox"> A.<code>Log4j</code>。</li><li><input checked="" disabled="" type="checkbox"> B.<code>SLF4J</code>。</li><li><input checked="" disabled="" type="checkbox"> C.<code>JCL</code>（Jakarta Commons Logging）。</li><li><input disabled="" type="checkbox"> D.<code>Logback</code>。</li></ul></li><li><p>【多选】关于线程安全，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>SimpleDateFormat</code>是线程不安全的类。</li><li><input disabled="" type="checkbox"> B.<code>SimpleDateFormat</code>是线程安全的类。</li><li><input checked="" disabled="" type="checkbox"> C.一般不要定义<code>SimpleDateFormat</code>的static变量，如果定义为static，必须保证线程安全。</li><li><input checked="" disabled="" type="checkbox"> D.推荐使用Apache封装好的<code>DateUtils</code>和<code>DateFormatUtils</code>工具类，来处理时间日期转换问题。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，以下哪些字段属于表的必备字段：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>id</code></li><li><input checked="" disabled="" type="checkbox"> B.<code>gmt_modified</code></li><li><input disabled="" type="checkbox"> C.<code>parent_id</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>gmt_create</code></li></ul></li><li><p>【多选】下面的例子代码和描述，哪些是有不正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.单行字符数限制不超过140个，超出需要换行</li><li><input disabled="" type="checkbox"> B.IDE的<code>text file encoding</code>设置为<code>GBK</code>；IDE中文件的换行符使用Unix格式，不要使用windows格式。</li><li><input checked="" disabled="" type="checkbox"> C.大括号与<code>if</code>，<code>else</code>，<code>for</code>，<code>do</code>，<code>while</code>语句一起使用，即使只有一条语句（或是空），也应该把大括号写上。 </li><li><input checked="" disabled="" type="checkbox"> D.大括号的使用约定。如果是大括号内为空，则简洁地写成即可，不需要换行；</li></ul></li><li><p>【多选】关于分页查询，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.分页查询，当统计的count为0时，应该直接返回，不要再执行分页查询语句。</li><li><input checked="" disabled="" type="checkbox"> B.iBATIS自带的<code>queryForList(String statementName，int start，int size)</code>分页接口有性能隐患，不允许使用。</li><li><input checked="" disabled="" type="checkbox"> C.定义明确的SQL查询语句，通过传入参数<code>start</code>和<code>size</code>来实现分页逻辑。</li><li><input disabled="" type="checkbox"> D.可使用存储过程写分页逻辑，提高效率。</li></ul></li><li><p>【多选】关于类和方法，下列哪些符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.任何类、方法、严控访问范围。因为过宽泛的访问范围，不利于模块解耦。</li><li><input checked="" disabled="" type="checkbox"> B.对外暴露的接囗签名，原则上不允许修改，宁可新增，避免对依赖端产生影响。</li><li><input checked="" disabled="" type="checkbox"> C.如果新增一个功能完全相同的新接口，过时接口必须加<code>@deprecated</code>注释。</li><li><input checked="" disabled="" type="checkbox"> D.所有过时的类与方法不得使用。</li></ul></li><li><p>【多选】关于建表规约，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.字段为非负数，必须定义为<code>unsigned</code>。</li><li><input checked="" disabled="" type="checkbox"> B.存储的字符数几乎完全相等的字段，推荐定义为char类型存储。</li><li><input disabled="" type="checkbox"> C.varchar会预先分配存储空间。</li><li><input checked="" disabled="" type="checkbox"> D.不得使用级联与外键，一切外键概念必须在应用层解决。</li></ul></li><li><p>【多选】关于常量的命名，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.常量命名应该全部大写，单词间用下划线隔开。</li><li><input checked="" disabled="" type="checkbox"> B.常量的定义要力求语义表达完整清楚，让别人能从常量名称上大致了解含义，例如：<code>MAX STOCK_COUNT</code>。</li><li><input disabled="" type="checkbox"> C.常量命名，可以使用拼音与英文的混合方式。</li><li><input checked="" disabled="" type="checkbox"> D.在使用缩写时要注意：杜绝不规范的缩写。</li></ul></li><li><p>【多选】关于代码书写格式，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.换行时相对上一行缩进2个空格。</li><li><input checked="" disabled="" type="checkbox"> B.运算符与下文一起换行，方法调用的点符号与下文一起换行。</li><li><input checked="" disabled="" type="checkbox"> C.在多个参数超长，逗号后进行换行。</li><li><input checked="" disabled="" type="checkbox"> D.在括号前不要换行。</li></ul></li><li><p>【单选】<code>List</code>子类使用<code>toArray</code>方法实现集合向数组转换，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.<code>Vector</code>无法使用<code>toArray</code>转换成数组。</li><li><input checked="" disabled="" type="checkbox"> B.优先推荐：调用集合类的方法<code>toArray(T[] a)</code>，传入的是类型完全一样的数组，大小就是集合的<code>size()</code>。</li><li><input disabled="" type="checkbox"> C.集合的修改，会影响到数组元素的改变。</li><li><input disabled="" type="checkbox"> D.数组的修改，会影响到集合元素的改变。</li></ul></li><li><p>【单选】关于类的序列化，下列说法哪些是正确的：</p><ul><li><input disabled="" type="checkbox"> A.类的序列化与<code>serialVersionUID</code>毫无关系。</li><li><input disabled="" type="checkbox"> B.如果完全不兼容升级，不需要修改<code>serialVersionUID</code>值。</li><li><input disabled="" type="checkbox"> C.<code>POJO</code>类的<code>seriaVersionUID</code>不一致会编译出错。</li><li><input checked="" disabled="" type="checkbox"> D.<code>POJO</code>类的<code>serialVersionUID</code>不一致会抛出序列化运行时异常。</li></ul></li><li><p>【多选】关于<code>hashcode</code>和<code>equals</code>，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.<code>hashcode</code>是<code>Class</code>的方法，<code>equals</code>是<code>Object</code>的方法。</li><li><input checked="" disabled="" type="checkbox"> B.<code>hashcode</code>决定（如：<code>HashMap</code>）存储位置；<code>equals</code>决定是否需要覆盖（同一<code>hash</code>下）集合元素。</li><li><input checked="" disabled="" type="checkbox"> C.类重写<code>hashcode</code>，必须重写<code>equals</code>。</li><li><input disabled="" type="checkbox"> D.两者是否需要重写，没有必然联系。</li></ul></li><li><p>【多选】关于二方库版本号的命名方式，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.版本号命名格式：<code>主版本号.次版本号.修订号</code>。</li><li><input checked="" disabled="" type="checkbox"> B.主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。</li><li><input checked="" disabled="" type="checkbox"> C.次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。</li><li><input checked="" disabled="" type="checkbox"> D.修订号：保持完全兼容性，修复BUG、新增次要功能特性等。</li></ul></li><li><p>【单选】<code>sort</code>表示元素在存入集合时进行了排序，数据遍历的结果是按某个排序规则输出的；而<code>order</code>表示每次遍历的序列都是一样的，元素前后关系每次遍历都是确定的，那么下列哪些集合既是<code>sort</code>，又是<code>order</code>的：</p><ul><li><input disabled="" type="checkbox"> A.<code>HashSet</code></li><li><input disabled="" type="checkbox"> B.<code>LinkedList</code></li><li><input disabled="" type="checkbox"> C.<code>HashMap</code></li><li><input checked="" disabled="" type="checkbox"> D.<code>Treset</code></li></ul></li><li><p>【多选】关于常量定义，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.跨应用共享常量：放置在二方库中，通常是<code>client.jar</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> B.应用内共享常量：通常放置在一方库的<code>modules</code>中的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> C.子工程内部共享常量：即在当前子工程的<code>const</code>目录下。</li><li><input checked="" disabled="" type="checkbox"> D.类内常量：直接在类内部<code>private static final</code>定义。</li></ul></li><li><p>【多选】关于注释，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.方法头定义签名上的注释可以使用<code>//</code>（双划线）简单说明，不必要遵守javadoc规范。</li><li><input checked="" disabled="" type="checkbox"> B.类定义开始部分，一般都用javadoc注释程序的总体描述以及作者信息。</li><li><input checked="" disabled="" type="checkbox"> C.方法头定义签名上的注释必须遵守javadoc规范，使用<code>/**</code>回车来生成，不得在方法定义上方使用<code>//</code>（双划线）简单说明。</li><li><input disabled="" type="checkbox"> D.方法头定义签名上的注释，可以使用<code>// XXX</code>的形式</li></ul></li><li><p>针对tcp协议，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.tcp链接主动关闭的一方，在完成四次挥手协议后，即会立即关闭并释放socket。</li><li><input disabled="" type="checkbox"> B.处于time_wait状态的socket，其实是已经关闭状态，当需要新建连接时，可以被马上复用。</li><li><input checked="" disabled="" type="checkbox"> C.当大量socket处于time_wait状态时，会导致可用socket资源稀缺，从而导致服务器并发能力下降。</li><li><input checked="" disabled="" type="checkbox"> D.通过修改<code>etc/sysctl.conf</code>配置文件，减小time_wait的超时时间，可以降低time_wait状态的socket数量，从而提升服务器并发能力。</li></ul></li><li><p>【多选】关于控制语句，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.推荐if-else的方式可以改写成卫语句的形式。</li><li><input checked="" disabled="" type="checkbox"> B.尽量减少try-catch块内的逻辑，定义对象、变量、获取数据库连接等操作可以移到try-catch块外处理</li><li><input disabled="" type="checkbox"> C.<code>if(condition) statements;</code>单行语句不需要使用大括号。</li><li><input checked="" disabled="" type="checkbox"> D.在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。</li></ul></li><li><p>【单选】关于Map类型集合的遍历方式，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.Map类型的实现类都同时实现了lterator接口。</li><li><input disabled="" type="checkbox"> B.使用foreach进行遍历。</li><li><input disabled="" type="checkbox"> C.推荐使用keySet进行遍历。</li><li><input checked="" disabled="" type="checkbox"> D.推荐使用entrySet进行遍历。</li></ul></li><li><p>【多选】关于数据库命名规则，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.数据库库名和表名没有规定，可任意取名，只要方便记忆即可。</li><li><input checked="" disabled="" type="checkbox"> B.库名应该尽量与应用名称保持一致，表的命名最好是<code>业务名称_表名</code>的方式。</li><li><input checked="" disabled="" type="checkbox"> C.无论是库名还是表名都禁用保留字，如desc、match、range等。</li><li><input checked="" disabled="" type="checkbox"> D.表名、字段名必须使用小写字母或数字。</li></ul></li><li><p>【单选】单元测试代码写在Java工程的哪个地方最为合适？</p><ul><li><input disabled="" type="checkbox"> A.写在业务代码体里边，方便调试。</li><li><input disabled="" type="checkbox"> B.写在业务代码同一个包下，方便归类查找。</li><li><input checked="" disabled="" type="checkbox"> C.写在<code>src/test/java</code>目录下。</li><li><input disabled="" type="checkbox"> D.写在<code>src/java</code>目录下。</li></ul></li><li><p>【多选】关于加锁，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.可以只锁代码区块的情况下，就不要锁整个方法体。</li><li><input checked="" disabled="" type="checkbox"> B.高并发的业务场景下，要考虑加锁及同步处理带来的性能损耗，能用无锁数据结构，就不要用锁。</li><li><input checked="" disabled="" type="checkbox"> C.能用对象锁的情况下，就不要用类锁。</li><li><input checked="" disabled="" type="checkbox"> D.加锁时需要保持一致的加锁顺序，否则可能会造成死锁。</li></ul></li><li><p>【多选】利用索引进行排序，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.查询语句<code>WHERE a = 10 ORDER BY b</code>，可以利用索引(a, b)来进行索引排序。</li><li><input checked="" disabled="" type="checkbox"> B.查询语句<code>WHERE a &gt; 10 ORDER BY b</code>，不可以利用索引(a, b)来进行索引排序。</li><li><input disabled="" type="checkbox"> C.查询语句<code>WHERE a lN（10, 11）ORDER BY b</code>，可以利用索引(a, b)来进行索引排序。</li><li><input checked="" disabled="" type="checkbox"> D.查询语句<code>WHERE a &gt; 10 AND b = 20 ORDER BY a</code>，可以利用索引(b, a)来进行索引排序。</li></ul></li><li><p>【多选】如何处理单元测试产生的数据，下列哪些说法是正确的？</p><ul><li><input checked="" disabled="" type="checkbox"> A.测试数据入库时加特殊前缀标识。</li><li><input checked="" disabled="" type="checkbox"> B.测试数据使用独立的测试库。</li><li><input checked="" disabled="" type="checkbox"> C.自动回滚单元测试产生的脏数据。</li><li><input disabled="" type="checkbox"> D.无须区别，统一在业务代码中进行判断和识别。</li></ul></li><li><p>【多选】关于Java代码的设计和开发注意事项，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.所有的覆写方法，必须是强制加<code>@Override</code>。</li><li><input checked="" disabled="" type="checkbox"> B.setter方法中，参数名称与类成员变量名称一致，<code>this.成员名 = 参数名</code>。</li><li><input checked="" disabled="" type="checkbox"> C.在getter方法中，尽量不要增加逻辑判断，因为添加了逻辑判断后，会增加排查问题难度。</li><li><input checked="" disabled="" type="checkbox"> D.避免用<code>BeanUtil</code>进行属性的copy。</li></ul></li><li><p>【多选】关于线程池的创建，下列哪些说法符合《阿里巴巴/ava开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.线程池不允许使用<code>Executors</code>去创建，而是通过<code>ThreadPoolExecutor</code>的方式。</li><li><input checked="" disabled="" type="checkbox"> B.<code>newFixedThreadPool</code>和<code>newSingleThreadExecutor</code>的主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li><li><input checked="" disabled="" type="checkbox"> C.<code>newCachedThreadPool</code>和<code>newScheduledThreadPool</code>的主要问题是线程数最大数是<code>Integer.MAX_VALUE</code>，可能会创建数量非常多的线程，甚至OOM。</li><li><input disabled="" type="checkbox"> D.我们的机器运算速度够快，所以线程池的创健并不需要特别的约定。</li></ul></li><li><p>【多选】使用<code>CountDownLatch</code>进行异步转同步操作时，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.每个线程退出前必须调用<code>countDown()</code>方法。</li><li><input checked="" disabled="" type="checkbox"> B.线程执行代码注意catch异常，确保<code>countDowm()</code>方法可以被执行。</li><li><input disabled="" type="checkbox"> C.子线程抛出异常堆钱，直接就可以在主线程catch到。</li><li><input checked="" disabled="" type="checkbox"> D.主线程必须在启动其他线程后调用<code>await()</code>方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</li></ul></li><li><p>【多选】关于索引的使用，下列哪些说法是正确的：</p><ul><li><input disabled="" type="checkbox"> A.查询语句<code>WHERE a+1 = 5</code>可以利用a索引。</li><li><input checked="" disabled="" type="checkbox"> B.查询语句<code>WHERE date_format(gmt_create, &#39;%Y-%m-%d&#39;) = &#39;2016-11-11&#39;</code>无法利用gmt_create索引。</li><li><input checked="" disabled="" type="checkbox"> C.当c列类型为char时，查询语句<code>WHERE c = 5</code>无法利用c索引。</li><li><input checked="" disabled="" type="checkbox"> D.索引字段使用时不能进行函数运算。</li></ul></li><li><p>【多选】关于代码注释，下列哪些说法符合《阿里巴巴Java开发手册》</p><ul><li><input checked="" disabled="" type="checkbox"> A.所有的抽象方法（包括接口中的方法）必须要用javadoc注释。</li><li><input disabled="" type="checkbox"> B.所有的方法，包括私有方法，最好都增加注释，有总比没有强。</li><li><input checked="" disabled="" type="checkbox"> C.过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</li><li><input checked="" disabled="" type="checkbox"> D.我的命名和代码结构非常好，可以减少注释的内容。</li></ul></li><li><p>【多选】关于日志的条件输出和占位符的方式，下列哪些说法是正确的：</p><ul><li><input checked="" disabled="" type="checkbox"> A.对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。</li><li><input checked="" disabled="" type="checkbox"> B.条件输出方式可以避免log参数中字符串拼接的开销。</li><li><input checked="" disabled="" type="checkbox"> C.占位符输出格式可以和条件输出一样避免参数中字符串拼接开销。</li><li><input disabled="" type="checkbox"> D.因为设置了日志输出级别，所以无需使用条件输出方式。</li></ul></li><li><p>【多选】关于二方库使用枚举类型，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.二方库里可以定义枚举类型。</li><li><input checked="" disabled="" type="checkbox"> B.二方库里接口的入参可以使用枚举类型。</li><li><input disabled="" type="checkbox"> C.二方库里接口的返回值不能使用枚举类型，但可以包含枚举类型。</li><li><input checked="" disabled="" type="checkbox"> D.二方库里接口的返回值是枚举类型或包含枚举类型时，当二方库的枚举值升级（增加枚举值）时，可能会导致接口调用时出现枚举对象序列化异常。</li></ul></li><li><p>【多选】关于组合索引，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.查询条件<code>where a=&#39;0&#39; and b=&#39;1&#39;</code>，当组合索引为(b, a)的时候能进行索引扫描。</li><li><input disabled="" type="checkbox"> B.查询条件<code>where a=&#39;0&#39; and b=&#39;1&#39;</code>，当组合索引为(c, a, b)的时候能进行索引扫描。</li><li><input checked="" disabled="" type="checkbox"> C.查询<code>select b from table where a=&#39;0&#39;</code>，当组合索引为(a, b)的时候会进行索引扫描。</li><li><input disabled="" type="checkbox"> D.查询条件<code>where a&gt;0 order by b</code>，当组合索引为(a, b)时会利用索引进行排序。</li></ul></li><li><p>【多选】关于系统安全，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input disabled="" type="checkbox"> A.表单、AJAX提交不需要进行CSRF安全过滤。</li><li><input checked="" disabled="" type="checkbox"> B.表单、AJAX提交必须执行CSRF安全过滤。</li><li><input checked="" disabled="" type="checkbox"> C.URL外部重定向传入的目标地址必须执行白名单过滤。</li><li><input checked="" disabled="" type="checkbox"> D.用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。</li></ul></li><li><p>【多选】根据《阿里巴巴Java开发手册》，以下功能必须进行水平权限控制校验的有：</p><ul><li><input checked="" disabled="" type="checkbox"> A.订单详情页面。</li><li><input checked="" disabled="" type="checkbox"> B.类目管理后台。</li><li><input checked="" disabled="" type="checkbox"> C.店铺装修后台。</li><li><input checked="" disabled="" type="checkbox"> D.订单付款页面。</li></ul></li><li><p>【多选】关于ORM的规则，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.数据库中，表达是与否概念的字段，必须使用<code>is_xxx</code>的方式命名。</li><li><input disabled="" type="checkbox"> B.推荐使用iBATIS自带的<code>queryForList(String statementName, int start, int size)</code>进行分页查询。</li><li><input disabled="" type="checkbox"> C.为避免写resultMap，可以直接拿HashMap与HashTable作为查询结果集的输出。</li><li><input checked="" disabled="" type="checkbox"> D.不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义。</li></ul></li><li><p>【多选】以下关于格式规约的说法，正确的有哪些：</p><ul><li><input checked="" disabled="" type="checkbox"> A.代码块缩进4个空格，如果使用tab缩进，请设置成1个tab为4个空格；</li><li><input disabled="" type="checkbox"> B.代码块缩进5个空格，如果使用tab缩进，请设置成1个tab为5个空格。</li><li><input disabled="" type="checkbox"> C.为了保特代码美观，《手册》强烈推荐增加若干空格，使某一行的变量与相邻对应位置的变量对齐。</li><li><input checked="" disabled="" type="checkbox"> D.方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间推荐插入一个空行；相同业务逻辑和语义之间不需要插入空行。</li></ul></li><li><p>【多选】以下关于格式规约的说法，正确的有哪些：</p><ul><li><input checked="" disabled="" type="checkbox"> A.左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格，例1：<code>if(f1ag == 1) {System.out.println(&quot;world&quot;);}</code></li><li><input checked="" disabled="" type="checkbox"> B.if / for / while / switch / do等保留字与左右括号之间都必须加空格；</li><li><input disabled="" type="checkbox"> C.while这个保留字比较特殊，使用时左右括号之间可以不用加空格，例1：<code>while(true){...}</code></li><li><input checked="" disabled="" type="checkbox"> D.任何运算符左右必须加一个空格，运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</li></ul></li><li><p>【多选】关于索引的设计，下列哪些说法符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.对varchar类型的字段建立索引，必须指定索引长度。</li><li><input disabled="" type="checkbox"> B.对varchar类型的字段建立索引，不需要指定索引长度，这样索引区分度最好。</li><li><input checked="" disabled="" type="checkbox"> C.业务上具有唯一特性的字段（含组合字段），必须指定唯一索引。</li><li><input checked="" disabled="" type="checkbox"> D.建复合索引时，一般选择区分度高的字段放在最左列。</li></ul></li><li><p>【多选】关于类和方法，下列哪些符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.任何类、方法、严控访问范围。因为过宽泛的访问范围，不利于模块解耦。</li><li><input checked="" disabled="" type="checkbox"> B.对外暴露的接口签名，原则上不允许修改，宁可新增，避免对依赖端产生影响。</li><li><input checked="" disabled="" type="checkbox"> C.如果新增一个功能完全相同的新接口，过时接口必须加@deprecated注释。</li><li><input checked="" disabled="" type="checkbox"> D.所有过时的类与方法不得使用。</li></ul></li><li><p>【多选】关于变量和常量定义，下列哪些符合《阿里巴巴Java开发手册》：</p><ul><li><input checked="" disabled="" type="checkbox"> A.<code>Long a=2L</code>；//大写的L</li><li><input disabled="" type="checkbox"> B.<code>Long a=2l</code>; //小写的l</li><li><input disabled="" type="checkbox"> C.常量只定义一次，不再赋值，所以不需要命名规范。</li><li><input checked="" disabled="" type="checkbox"> D.不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> p3c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>130-如何实现一个自己的显式锁Lock精讲下（让锁具备超时功能）</title>
      <link href="/wang-thread/130-custom-lock-timedout/"/>
      <url>/wang-thread/130-custom-lock-timedout/</url>
      
        <content type="html"><![CDATA[<h2 id="上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG"><a href="#上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG" class="headerlink" title="上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG"></a>上一节中的问题：违规非法操作，导致运行混乱。巨大的BUG</h2><pre><code class="java">public static void main(String[] args) throws InterruptedException {    final BooleanLock booleanLock = new BooleanLock();    new Thread(() -&gt; {        try {            booleanLock.lock();            Optional.of(Thread.currentThread().getName() + &quot; have the lock Monitor.&quot;).ifPresent(System.out::println);            work();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            booleanLock.unlock();        }      }, &quot;T1&quot;);    // 问题：违规非法操作，导致运行混乱    Thread.sleep(100);    booleanLock.unlock();}</code></pre><p>锁booleanLock由线程T1中加锁<code>lock()</code>，就只能由T1解锁<code>unlock()</code>。</p><p>解决：</p><pre><code class="java">private Thread currentThread;@Overridepublic synchronized void lock() throws InterruptedException {    ...    this.currentThread = Thread.currentThread();}@Overridepublic synchronized void unlock() {    // 释放锁    if (Thread.currentThread() == currentThread) {        ...    }}</code></pre><p>synchronized机制导致的一个问题：synchronized不能被打断，导致其他线程抢不到锁。</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {    new Thread(SynchronizedProblem::run, &quot;T1&quot;).start();    Thread.sleep(1000);    Thread t2 = new Thread(SynchronizedProblem::run, &quot;T2&quot;);    t2.start();    Thread.sleep(2000);    t2.interrupt();    System.out.println(t2.isInterrupted());// true，但是并没有中断t2}private synchronized static void run() {    System.out.println(Thread.currentThread().getName());    while (true) { }}</code></pre><p><code>t2.isInterrupted()</code>返回值为true，但是并没有中断t2，此时就需要让锁具备超时功能，即<code>void lock(long mills)</code>，mills时间拿不到锁就会超时，同时抛出<code>TimeOutException</code>异常。</p><h2 id="让锁具备超时功能"><a href="#让锁具备超时功能" class="headerlink" title="让锁具备超时功能"></a>让锁具备超时功能</h2><p>调用的方法一直阻塞，但是还有其他工作需要执行，此时放弃调用方法需要使用<code>void lock(long mills)</code>。等待锁指定时间，一旦时间超过就抛出<code>TimeOutException</code></p><pre><code class="java">@Overridepublic synchronized void lock(long mills) throws InterruptedException, TimeOutException {    if (mills &lt;= 0) {        lock();    }    long hasRemaining = mills;    long endTime = System.currentTimeMillis() + mills;    while (initValue) {        if (hasRemaining &lt;= 0) {            throw new TimeOutException(&quot;Time Out&quot;);        }        blockedThreadCollection.add(Thread.currentThread());        this.wait(mills);        hasRemaining = endTime - System.currentTimeMillis();    }    this.initValue = true;    this.currentThread = Thread.currentThread();}</code></pre><p><code>void wait()</code>需要synchronized，需要添加一个Monitor锁</p><p>Java5之后JUC并发包提供了相同的功能。由大神Doug Lea开发，使Java性能更加接近于C/C++。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>129-如何实现一个自己的显式锁Lock精讲上</title>
      <link href="/wang-thread/129-custom-lock/"/>
      <url>/wang-thread/129-custom-lock/</url>
      
        <content type="html"><![CDATA[<p>synchronized的机制导致的一个问题：当线程A调用使用synchronized加锁的线程B时，如果线程B的运行时间很长，则调用者线程A将会进入阻塞状态，且不可打断，也不能立即返回。</p><h2 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h2><pre><code class="java">/** * 自定义显式锁 */public interface Lock {    class TimeOutException extends Exception {        public TimeOutException(String message) {            super(message);        }    }    void lock() throws InterruptedException;    void lock(long mills) throws InterruptedException, TimeOutException;    void unlock();    Collection&lt;Thread&gt; getBlockedThread();    int getBlockedSize();}</code></pre><h2 id="BooleanLock实现类"><a href="#BooleanLock实现类" class="headerlink" title="BooleanLock实现类"></a>BooleanLock实现类</h2><pre><code class="java">public class BooleanLock implements Lock {    /**     * The initValue is true indicated the lock has been get.     * The initValue is false indicated the lock is free (other thread can get this).     */    private boolean initValue;    private Collection&lt;Thread&gt; blockedThreadCollection = new ArrayList&lt;&gt;();    public BooleanLock() {        this.initValue = false;    }    @Override    public synchronized void lock() throws InterruptedException {        // 锁已经被其他线程使用        while (initValue) {            blockedThreadCollection.add(Thread.currentThread());            this.wait();        }        // 锁未被使用，抢到锁立即设置initValue的值        this.initValue = true;        blockedThreadCollection.remove(Thread.currentThread());    }    @Override    public void lock(long mills) throws InterruptedException, TimeOutException {}    @Override    public synchronized void unlock() {        // 释放锁        this.initValue = false;        Optional.of(Thread.currentThread().getName() + &quot; release the lock monitor.&quot;).ifPresent(System.out::println);        this.notifyAll();    }    @Override    public Collection&lt;Thread&gt; getBlockedThread() {        // 可以直接返回，但是不安全。此处返回的是一个实例，调用者可以随意更改（null，clear()等操作）。        return Collections.unmodifiableCollection(blockedThreadCollection);    }    @Override    public int getBlockedSize() {        return blockedThreadCollection.size();    }}</code></pre><h2 id="测试调用方法"><a href="#测试调用方法" class="headerlink" title="测试调用方法"></a>测试调用方法</h2><pre><code class="java">public static void main(String[] args) throws InterruptedException {    final BooleanLock booleanLock = new BooleanLock();    Stream.of(&quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;, &quot;T4&quot;).forEach(name -&gt; {        new Thread(() -&gt; {            try {                booleanLock.lock();                Optional.of(Thread.currentThread().getName() + &quot; have the lock Monitor.&quot;).ifPresent(System.out::println);                work();            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                booleanLock.unlock();            }        }, name).start();    });    // 问题：违规非法操作，导致运行混乱    Thread.sleep(100);    booleanLock.unlock();}private static void work() throws InterruptedException {    Optional.of(Thread.currentThread().getName() + &quot; is working...&quot;).ifPresent(System.out::println);    Thread.sleep(10_000);}</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>违规非法操作，导致运行混乱。巨大的BUG</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {    final BooleanLock booleanLock = new BooleanLock();    ...    // 问题：违规非法操作，导致运行混乱    Thread.sleep(100);    booleanLock.unlock();}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128-线程生产者消费者的综合实战结合Java8语法</title>
      <link href="/wang-thread/128-prod-cons-case/"/>
      <url>/wang-thread/128-prod-cons-case/</url>
      
        <content type="html"><![CDATA[<p>数据采集功能：利用多个线程采集多台服务器运行状态信息。当服务器数量较少时，可以采取一个线程采集一台服务器；但是服务器数量非常大时，将不可能采取这种方式，可以开启一定数量的线程采集完成后再采集其他服务器，即运行的线程始终保持着稳定数量。</p><p>操作系统可以支持一个应用开启的线程数量是有限制的，取决于stack size。多线程的性能是有一个峰值的，超过峰值性能反而会下降。这是因为线程数量过大时，应用的上下文切换会消耗很大一部分资源。</p><pre><code class="java">public class CaptureService {    private static final LinkedList&lt;Control&gt; CONTROLS = new LinkedList&lt;&gt;();    private static final int MAX_WORKER = 5;    public static void main(String[] args) {        List&lt;Thread&gt; worker = new ArrayList&lt;&gt;();        Stream.of(&quot;M1&quot;, &quot;M2&quot;, &quot;M3&quot;, &quot;M4&quot;, &quot;M5&quot;, &quot;M6&quot;, &quot;M7&quot;, &quot;M8&quot;, &quot;M9&quot;, &quot;M10&quot;)                .map(CaptureService::createCaptureService)                .forEach(t -&gt; {                    t.start();                    worker.add(t);                });        worker.forEach(t -&gt; {            t.join();        });        Optional.of(&quot;All of capture work finished.&quot;).ifPresent(System.out::println);    }    public static Thread createCaptureService(String name) {        return new Thread(() -&gt; {            Optional.of(&quot;The worker [&quot; + Thread.currentThread().getName() + &quot;] BEGIN capture data.&quot;).ifPresent(System.out::println);            synchronized (CONTROLS) {                while (CONTROLS.size() &gt; MAX_WORKER) {                    CONTROLS.wait();                }                CONTROLS.addLast(new Control());            }            Optional.of(&quot;The worker [&quot; + Thread.currentThread().getName() + &quot;] is WORKING...&quot;).ifPresent(System.out::println);            Thread.sleep(10_000);            synchronized (CONTROLS) {                Optional.of(&quot;The worker [&quot; + Thread.currentThread().getName() + &quot;] END capture data.&quot;).ifPresent(System.out::println);                CONTROLS.removeFirst();                CONTROLS.notifyAll();            }        }, name);    }    private static class Control {}}</code></pre><p>Optional可以防止NPE空指针异常</p><p>解决的问题：</p><ol><li>多个线程上下文切换带来的损耗问题</li><li>多个线程占多个资源，比如同时创建多个数据库连接、打开多个文件（文件句柄是有限的）。</li></ol><p>学习了线程池之后，可以不必这么麻烦啦。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>127-wait和sleep的本质区别是什么，深入分析（面试常见问题）</title>
      <link href="/wang-thread/127-wait-sleep/"/>
      <url>/wang-thread/127-wait-sleep/</url>
      
        <content type="html"><![CDATA[<p>The difference of sleep and wait:</p><ol><li>sleep is the method of Thread, but wait is the method of Object.</li><li>sleep will not release the Object monitor(LOCK), but the wait will be release the monitor and add to the Object monitor waiting queue.</li><li>Use sleep not depend on the monitor(synchronized), but wait need.</li><li>The sleep method not need be wakeup, but wait need. except wait(long timeout)</li></ol><p>验证不同点3：</p><pre><code class="java">public static void m1() {    Thread.sleep(2_000);}public static void m2() {    synchronized (LOCK) {        LOCK.wait();    }}</code></pre><p><code>LOCK.wait();</code>没有使用<code>synchronized</code>则会抛出<code>java.lang.IllegalMonitorStateException</code>异常</p><p>验证不同点2：</p><pre><code class="java">// 两个线程依次运行public static void m3() {    synchronized (LOCK) {        System.out.println(&quot;The Thread &quot; + Thread.currentThread().getName() + &quot; enter.&quot;);        Thread.sleep(20_000);    }}// 两个线程几乎同时运行，两个线程最终都加入到了LOCK的waiting queuepublic static void m4() {    synchronized (LOCK) {        System.out.println(&quot;The Thread &quot; + Thread.currentThread().getName() + &quot; enter.&quot;);        LOCK.wait();    }}</code></pre><pre><code class="java">public static void main(String[] args) {    Stream.of(&quot;T1&quot;, &quot;T2&quot;).forEach(name -&gt; new Thread(DifferenceOfWaitAndSleep::m4, name).start());}</code></pre><p>使用<code>sleep()</code>两个线程将会依次运行；使用<code>wait()</code>两个线程几乎同时运行，最终都加入到了LOCK的waiting queue</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>126-多线程下的生产者消费者模型，以及详细介绍notifyAll方法</title>
      <link href="/wang-thread/126-multi-thread-notifyall/"/>
      <url>/wang-thread/126-multi-thread-notifyall/</url>
      
        <content type="html"><![CDATA[<p><code>public final void wait()</code>方法</p><blockquote><p>使当前线程等待，直到另一个线程为此对象调用<code>notify()</code>方法或<code>notifyAll()</code>方法。此方法的行为就像完全执行调用<code>wait(0)</code>一样。</p><p>当前线程必须拥有该对象的监视器。线程释放此监视器的所有权，并等待直到另一个线程通过调用notify方法或notifyAll方法通知等待在此对象监视器上等待的线程唤醒。然后，线程等待，直到它可以重新获得监视器的所有权并恢复执行（即可运行状态）。</p></blockquote><p><code>public final void notify()</code>方法</p><blockquote><p>唤醒正在此对象的监视器上等待的单个线程。如果有任何线程在此对象上等待，则选择其中一个唤醒。选择是任意的，并且可以根据实现情况进行选择。线程通过调用其中一个wait方法在对象的监视器上等待。</p></blockquote><p><code>public final void notifyAll()</code>方法</p><blockquote><p>唤醒正在此对象的监视器上等待的所有线程。线程通过调用其中一个wait方法在对象的监视器上等待。</p></blockquote><p>改造多线程下的生产者-消费者模型：</p><pre><code class="java">public void produce() {    synchronized (LOCK) {        // 分析此处为什么使用while，而不是用if？        while (isProduced) {            LOCK.wait();        }        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + (++i));        LOCK.notifyAll();        isProduced = true;    }}</code></pre><pre><code class="java">public void consume() {    synchronized (LOCK) {        while (!isProduced) {            LOCK.wait();        }        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i);        LOCK.notifyAll();        isProduced = false;    }}</code></pre><pre><code class="java">public static void main(String[] args) {    ProduceConsumerVersion3 pc = new ProduceConsumerVersion3();    Stream.of(&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;).forEach(n -&gt; new Thread(new Runnable() {        @Override        public void run() {            while (true) {                pc.produce();                Thread.sleep(10);            }        }    }, n).start());    Stream.of(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;).forEach(n -&gt; new Thread(() -&gt; {        while (true) {            pc.consume();            Thread.sleep(10);        }    }, n).start());}</code></pre><p>分析此处为什么使用while，而不是用if？</p><pre><code class="java">while (isProduced) {    LOCK.wait();}</code></pre><p><code>notifyAll()</code>方法将会唤醒所有的生产者线程。</p><p>如果使用<code>if()</code>：线程A先抢到锁，运行时判断有没有生产数据，无则生产数据并运行完成，当它再次抢锁运行时发现已经生产过数据则会进行<code>wait()</code>操作；线程B抢到锁运行时将<u>会跳过判断</u>直接生产数据，从而造成了消费者还没有消费完数据又重复生产。</p><p>例：生产两次消费一次，生产一次消费两次</p><pre><code>P2-&gt;2P3-&gt;3C3-&gt;3P1-&gt;4C4-&gt;4C2-&gt;4</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125-多Produce多Consume之间的通讯导致出现程序假死的原因分析</title>
      <link href="/wang-thread/125-multi-prod-cons/"/>
      <url>/wang-thread/125-multi-prod-cons/</url>
      
        <content type="html"><![CDATA[<p>多个生产者、消费者线程运行时，会产生一些问题</p><pre><code class="java">Stream.of(&quot;P1&quot;, &quot;P2&quot;).forEach(n -&gt;        new Thread(() -&gt; {            while (true) {                pc.produce();            }        }, n).start());Stream.of(&quot;C1&quot;, &quot;C2&quot;).forEach(n -&gt;        new Thread(() -&gt; {            while (true) {                pc.consume();            }        }, n).start());</code></pre><p>此时运行程序会先正常运行一段时间，然后卡住。使用<code>jstack</code>查看程序也并没有发生死锁。那么，产生的原因是什么？</p><p><strong>分析</strong>：在消费者1消费完成后进行<code>notify()</code>操作时，并没有指定唤醒哪个线程，此时有可能唤醒的是消费者2线程。然后消费者2唤醒后发现后并没有可以消费的数据，又自行wait，此时所有生产者线程也是处于wait状态，所有线程都BLOACKED,在等待被唤醒，进而造成了线程假死的情况。</p><p><code>notify()</code>唤醒的是持有同样MONITOR锁的线程，且只唤醒一个线程。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>124-线程间通信快速入门，使用wait和notify进行线程间的数据通信</title>
      <link href="/wang-thread/124-wait-notify/"/>
      <url>/wang-thread/124-wait-notify/</url>
      
        <content type="html"><![CDATA[<p>线程通信例子：线程A负责从数据库读取数据，线程B负责分析处理数据。当线程A获取到数据并放入内存后需要通知线程B去处理数据。线程A为<strong>生产者</strong>，线程B为<strong>消费者</strong>。</p><p>版本1：生产者一直负责生产，消费者一直负责消费。没有进行通信，生产者生产完毕没有通知消费者，消费者也不知道是否是最新数据、是否已经消费过。</p><pre><code class="java">public class ProduceConsumerVersion1 {    private int i = 1;    private final Object LOCK = new Object();    private void produce() {        synchronized (LOCK) {            System.out.println(&quot;P-&gt;&quot; + (i++));        }    }    private void consume() {        synchronized (LOCK) {            System.out.println(&quot;C-&gt;&quot; + (i));        }    }    public static void main(String[] args) {        ProduceConsumerVersion1 pc = new ProduceConsumerVersion1();        new Thread(() -&gt; {            while (true) {                pc.produce();            }        }, &quot;P&quot;).start();        new Thread(() -&gt; {            while (true) {                pc.consume();            }        }, &quot;C&quot;).start();    }}</code></pre><p>运行代码会发现，有些时候线程P不断生产数据，而线程C没有消费；而有些时候线程C只消费最新的数据，并且不断重复的消费最新数据。</p><p>造成这种情况的原因是：线程间没有进行通信。</p><p>版本2：生产者负责生产，生产完毕之后通知消费者，如果没有消费则不再进行生产。消费者负责消费，有数据则进行消费，没有数据则进行等待。</p><pre><code class="java">public class ProduceConsumerVersion2 {    private int i = 0;    private final Object LOCK = new Object();    // 是否已经消费    private volatile boolean isProduced = false;    public void produce() {        synchronized (LOCK) {            if (isProduced) {                LOCK.wait();            } else {                System.out.println(&quot;P-&gt;&quot; + (++i));                LOCK.notify();                isProduced = true;            }        }    }    public void consume() {        synchronized (LOCK) {            if (isProduced) {                System.out.println(&quot;C-&gt;&quot; + i);                LOCK.notify();                isProduced = false;            } else {                LOCK.wait();            }        }    }    public static void main(String[] args) {        ProduceConsumerVersion2 pc = new ProduceConsumerVersion2();        new Thread(() -&gt; {            while (true) {                pc.produce();            }        }, &quot;P&quot;).start();        new Thread(() -&gt; {            while (true) {                pc.consume();            }        }, &quot;C&quot;).start();    }}</code></pre><p>此代码实现了简单的生产者-消费者模型，但是在多个生产者、消费者线程运行时，会产生一些问题。思考问题是什么？欲知后事如何，且听下回分解。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>123-多线程死锁分析，案例介绍</title>
      <link href="/wang-thread/123-deadlock-case/"/>
      <url>/wang-thread/123-deadlock-case/</url>
      
        <content type="html"><![CDATA[<p>死锁。多个锁相互交叉锁定代码</p><p>当线程T1持有资源A，线程T2持有资源B。此时线程T1想要获取资源B，并且线程T2想要获取资源A。两个线程都想要获取对方手中的资源，自己又不肯让出已有资源，一直僵持不下就形成了死锁。</p><p>程序在运行时什么事都没做（不输出日志、CPU内存等都没有发生变化），此时极有可能发生了死锁。需要查看程序运行情况。</p><ol><li><p>案例</p><p>线程T1：</p><pre><code class="java">public class DeadLock {    private OtherService otherService;    public void setOtherService(OtherService otherService) {        this.otherService = otherService;    }    // DeadLock的实例的锁-资源A    private final Object LOCK = new Object();    public void m1() {        synchronized (LOCK) {            System.out.println(&quot;********m1********&quot;);            otherService.s1();        }    }    public void m2() {        synchronized (LOCK) {            System.out.println(&quot;********m2********&quot;);        }    }}</code></pre><p>线程T2：</p><pre><code class="java">public class OtherService {    private DeadLock deadLock;    public void setDeadLock(DeadLock deadLock) {        this.deadLock = deadLock;    }    // OtherService的实例的锁-资源B    private final Object LOCK = new Object();    public void s1() {        synchronized (LOCK) {            System.out.println(&quot;========s1========&quot;);        }    }    public void s2() {        synchronized (LOCK) {            System.out.println(&quot;========s2========&quot;);            deadLock.m2();        }    }}</code></pre><p>测试调用方法：</p><pre><code class="java">public static void main(String[] args) {    DeadLock deadLock = new DeadLock();    OtherService otherService = new OtherService();    deadLock.setOtherService(otherService);    otherService.setDeadLock(deadLock);    new Thread(() -&gt; {        while (true) {            deadLock.m1();        }    }, &quot;T1&quot;).start();    new Thread(() -&gt; {        while (true) {            otherService.s2();        }    }, &quot;T2&quot;).start();}</code></pre></li><li><p>查看死锁</p><p>当程序运行时产生死锁，通过代码会很难分析出死锁在哪里产生。此时应通过工具jstack查看程序运行状态。</p><ol><li><p>获取程序进程id（pid）。<code>jps</code></p><pre><code>2086 DeadLockTest2007 KotlinCompileDaemon2106 Jps1194 1213 RemoteMavenServer36</code></pre></li><li><p>查看程序运行状态。<code>jstack 2086</code></p><pre><code>Found one Java-level deadlock:=============================&quot;T2&quot;:  waiting to lock monitor 0x00007fe848005758 (object 0x000000076adb9730, a java.lang.Object),  which is held by &quot;T1&quot;&quot;T1&quot;:  waiting to lock monitor 0x00007fe8480042b8 (object 0x000000076adbd6a0, a java.lang.Object),  which is held by &quot;T2&quot;Java stack information for the threads listed above:===================================================&quot;T2&quot;:    at com.tuyrk.chapter8.DeadLock.m2(DeadLock.java:28)    - waiting to lock &lt;0x000000076adb9730&gt; (a java.lang.Object)    at com.tuyrk.chapter8.OtherService.s2(OtherService.java:29)    - locked &lt;0x000000076adbd6a0&gt; (a java.lang.Object)    at com.tuyrk.chapter8.DeadLockTest.lambda$main$1(DeadLockTest.java:24)    at com.tuyrk.chapter8.DeadLockTest$$Lambda$2/2094548358.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;T1&quot;:    at com.tuyrk.chapter8.OtherService.s1(OtherService.java:22)    - waiting to lock &lt;0x000000076adbd6a0&gt; (a java.lang.Object)    at com.tuyrk.chapter8.DeadLock.m1(DeadLock.java:22)    - locked &lt;0x000000076adb9730&gt; (a java.lang.Object)    at com.tuyrk.chapter8.DeadLockTest.lambda$main$0(DeadLockTest.java:19)    at com.tuyrk.chapter8.DeadLockTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)Found 1 deadlock.</code></pre><p>T2持有0x000000076adbd6a0，想要获取0x000000076adb9730；</p><p>而T1持有0x000000076adb9730，想要获取0x000000076adbd6a0。</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xcrun:error:invalid active developer path</title>
      <link href="/macOS-update-git/"/>
      <url>/macOS-update-git/</url>
      
        <content type="html"><![CDATA[<p>macOS更新系统后git出现错误：xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missingxcrun at: /Library/Developer /CommandLineTools /usr/bin/xcrun。如图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e747jombj30nu08ujt4.jpg" alt="Git异常" style="zoom:50%;" /><p>解决方法：</p><p>在终端运行：</p><pre><code class="shell">xcode-select --install</code></pre><p>出现：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9e7bmvbjnj30po09smys.jpg" style="zoom:45%;" /><p>点击安装，然后点击同意协议。</p><p>等待安装，点击完成即可。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>122-通过实验分析Class锁的存在</title>
      <link href="/wang-thread/122-class-lock/"/>
      <url>/wang-thread/122-class-lock/</url>
      
        <content type="html"><![CDATA[<p>静态方法、静态代码块加锁，锁的MONITOR是什么东西？</p><ol><li><p>顺序访问。两个线程抢占同一个锁。（Class锁）</p><pre><code class="java">public synchronized static void m1() {}</code></pre><pre><code class="java">public synchronized static void m2() {}</code></pre><p>其到底是什么锁呢？</p><p><strong>静态方法加的锁其实是Class锁。</strong></p></li><li><p>增加静态代码块，判定锁MONITOR是什么。</p><ul><li><p>暂未添加静态代码块时：</p><pre><code class="java">public static void m3() {}</code></pre><p><code>m3()</code>为静态非加锁方法，启动程序会立即运行，此时<code>m1()</code>会同时运行。</p></li><li><p>添加静态代码块后：</p><pre><code class="java">static {    synchronized (SynchronizedStatic.class) {}}</code></pre><p>先进行一次实例化，运行静态代码块，运行完成才执行<code>m3()</code>和<code>m1()</code></p></li></ul><p><strong>静态代码块加的锁其实是Class锁。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121-通过实验分析This锁的存在</title>
      <link href="/wang-thread/121-this-lock/"/>
      <url>/wang-thread/121-this-lock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>this锁就是通过一个实例作为MONITOR，然后进行加锁。</p></blockquote><ol><li><p>同时访问。</p><pre><code class="java">public synchronized void m1() {}</code></pre><pre><code class="java">public void m2() {}</code></pre></li><li><p>顺序访问。两个线程运行方法时抢占同一个this锁。</p><p>一个线程必须等待另一个线程访问的方法执行完成才能访问。</p><pre><code class="java">public synchronized void m1() {}</code></pre><pre><code class="java">public synchronized void m2() {}</code></pre></li><li><p>同时访问。两个线程抢占的锁不一样。m1为this锁；m2为LOCK锁。</p><pre><code class="java">public synchronized void m1() {}</code></pre><pre><code class="java">private final Object LOCK = new Object();public void m2() {    synchronized (LOCK) {}}</code></pre></li><li><p>顺序访问。两个线程抢占同一个锁，即LOCK</p><pre><code class="java">private final Object LOCK = new Object();</code></pre><pre><code class="java">public void m1() {    synchronized (LOCK) {}}</code></pre><pre><code class="java">public void m2() {    synchronized (LOCK) {}}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>120-同步代码块以及同步方法之间的区别和关系</title>
      <link href="/wang-thread/120-sync-codeblock-method/"/>
      <url>/wang-thread/120-sync-codeblock-method/</url>
      
        <content type="html"><![CDATA[<p>synchronized关键字同步方法的使用</p><p>代码：</p><pre><code class="java">// 单线程运行synchronized方法里边的内容@Overridepublic synchronized void run() {    while (true) {        // 1        if (index &gt; MAX) {            break;        }        try {            Thread.sleep(5);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));        // 2    }}</code></pre><p><strong>运行结果：只有线程t1运行并输出信息。</strong></p><p>分析：三个线程同时去争抢synchronized的方法锁，此时线程t1争抢到锁然后进入同步方法运行程序，一直到运行完成；然后线程t2争抢到锁并进入同步方法，但是此时<code>index &gt; MAX</code>只能跳出程序。线程t3亦是如此。</p><p>注：同步代码块的锁为LOCK锁；同步方法的锁为this锁</p><p>此时，应该如何使用synchronized同步方法来实现同步运行呢？</p><pre><code class="java">@Overridepublic void run() {    while (true) {        if (ticket()) {            break;        }    }}private synchronized boolean ticket() {    // 1. getField    if (index &gt; MAX) {        return true;    }    Thread.sleep(5);        // index++; =&gt; index = index + 1;    // 1. get Field index.    // 2. index = index + 1;    // 3. put Field index.    System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));    return false;}private boolean ticket2() {    synchronized (this) {        if (index &gt; MAX) {            return true;        }        try {            Thread.sleep(5);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));        return false;    }}</code></pre><p>使用同步代码块的原则：使用synchronized关键字应尽量小地给共享数据加锁</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>119-结合jconsole,jstack以及汇编指令认识synchronized关键字</title>
      <link href="/wang-thread/119-synchronized/"/>
      <url>/wang-thread/119-synchronized/</url>
      
        <content type="html"><![CDATA[<p>上一节使用的synchronized到底是什么呢？</p><p>例子：在动物园检票的时候（前提：只有一台检票机，游客没有排队），每次只能有一位游客通过检票机进入动物园。游客类比多个线程，检票机类比synchronized。此时synchronized内部为单线程，<strong>串行化运行程序代码</strong></p><p>目的：让synchronized代码块里边的代码串行化运行，让共享数据串行被操作。</p><p>代码：</p><pre><code class="java">public class SynchronizedTest {    // 代码规范：final命名的变量需要使用大写    private static final Object LOCK = new Object();    public static void main(String[] args) {        // 任务        Runnable runnable = () -&gt; {            synchronized (LOCK) {                Thread.sleep(500_000);            }        };        // 创建并启动线程        Thread t1 = new Thread(runnable);        Thread t2 = new Thread(runnable);        Thread t3 = new Thread(runnable);        t1.start();t2.start();t3.start();    }}</code></pre><h2 id="jconsole工具"><a href="#jconsole工具" class="headerlink" title="jconsole工具"></a>jconsole工具</h2><ol><li><p>在终端输入命令：<code>jconsole</code>。打开Java监视和管理控制台，并选择名为SynchronizedTest的本地进程</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9996491lpj30z80u04am.jpg" alt="Java监视和管理控制台" style="zoom:40%;" /></li><li><p>点击线程，查看Thread0、Thread1、Thread2</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g999atar2vj30s40nyq8k.jpg" alt="线程Thread信息" style="zoom:50%;" /><p>Thread-0：状态: TIMED_WAITING</p><p>Thread-1：状态: java.lang.Object@20a5a1a4上的BLOCKED, 拥有者: Thread-0</p><p>Thread-2：状态: java.lang.Object@20a5a1a4上的BLOCKED, 拥有者: Thread-0</p></li></ol><h2 id="jstack工具"><a href="#jstack工具" class="headerlink" title="jstack工具"></a>jstack工具</h2><ol><li><p>在终端输入命令：<code>jps</code></p><pre><code class="shell">1488 Launcher1489 SynchronizedTest1491 Jps500 570 RemoteMavenServer36814 KotlinCompileDaemon</code></pre></li><li><p>在终端输入命令：<code>jstack 1489</code></p><pre><code class="shell">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):&quot;Thread-2&quot; #21 prio=5 os_prio=31 tid=0x00007f968c0aa800 nid=0x9f03 waiting for monitor entry [0x0000700008441000]   java.lang.Thread.State: BLOCKED (on object monitor)    at com.tuyrk.chapter07.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)    - waiting to lock &lt;0x000000076adb5948&gt; (a java.lang.Object)    at com.tuyrk.chapter07.SynchronizedTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;Thread-1&quot; #20 prio=5 os_prio=31 tid=0x00007f968c0a9800 nid=0x6a03 waiting for monitor entry [0x000070000833e000]   java.lang.Thread.State: BLOCKED (on object monitor)    at com.tuyrk.chapter07.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)    - waiting to lock &lt;0x000000076adb5948&gt; (a java.lang.Object)    at com.tuyrk.chapter07.SynchronizedTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;Thread-0&quot; #19 prio=5 os_prio=31 tid=0x00007f968c0a9000 nid=0x6903 waiting on condition [0x000070000823b000]   java.lang.Thread.State: TIMED_WAITING (sleeping)    at java.lang.Thread.sleep(Native Method)    at com.tuyrk.chapter07.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)    - locked &lt;0x000000076adb5948&gt; (a java.lang.Object)    at com.tuyrk.chapter07.SynchronizedTest$$Lambda$1/500977346.run(Unknown Source)    at java.lang.Thread.run(Thread.java:748)&quot;Monitor Ctrl-Break&quot; #5 daemon prio=5 os_prio=31 tid=0x00007f9690127000 nid=0x3c03 runnable [0x000070000730e000]   java.lang.Thread.State: RUNNABLE</code></pre><p>线程锁LOCK即为MONITOR（监视器）</p></li></ol><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><ol><li><p>在终端输入命令：<code>javap -c 01-thread-base/target/classes/com/tuyrk/chapter07/TicketWindowRunnable.class</code></p><pre><code class="shell">Compiled from &quot;TicketWindowRunnable.java&quot;public class com.tuyrk.chapter07.TicketWindowRunnable implements java.lang.Runnable {  public com.tuyrk.chapter07.TicketWindowRunnable();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: aload_0       5: iconst_1       6: putfield      #2                  // Field index:I       9: aload_0      10: new           #3                  // class java/lang/Object      13: dup      14: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      17: putfield      #4                  // Field MONITOR:Ljava/lang/Object;      20: return  public void run();    Code:       0: aload_0       1: getfield      #4                  // Field MONITOR:Ljava/lang/Object;       4: dup       5: astore_1       6: monitorenter       7: aload_0       8: getfield      #2                  // Field index:I      11: sipush        500      14: if_icmple     22      17: aload_1      18: monitorexit      19: goto          93      22: ldc2_w        #6                  // long 5l      25: invokestatic  #8                  // Method java/lang/Thread.sleep:(J)V      28: goto          36      31: astore_2      32: aload_2      33: invokevirtual #10                 // Method java/lang/InterruptedException.printStackTrace:()V      36: getstatic     #11                 // Field java/lang/System.out:Ljava/io/PrintStream;      39: new           #12                 // class java/lang/StringBuilder      42: dup      43: invokespecial #13                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V      46: invokestatic  #14                 // Method java/lang/Thread.currentThread:()Ljava/lang/Thread;      49: invokevirtual #15                 // Method java/lang/Thread.getName:()Ljava/lang/String;      52: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      55: ldc           #17                 // String  的号码是：      57: invokevirtual #16                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;      60: aload_0      61: dup      62: getfield      #2                  // Field index:I      65: dup_x1      66: iconst_1      67: iadd      68: putfield      #2                  // Field index:I      71: invokevirtual #18                 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;      74: invokevirtual #19                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;      77: invokevirtual #20                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V      80: aload_1      81: monitorexit      82: goto          90      85: astore_3      86: aload_1      87: monitorexit      88: aload_3      89: athrow      90: goto          0      93: return    Exception table:       from    to  target type          22    28    31   Class java/lang/InterruptedException           7    19    85   any          22    82    85   any          85    88    85   any}</code></pre><p>getfield、putfield</p><p>monitorenter、monitorexit</p></li></ol><pre><code class="shell">javap --help</code></pre><pre><code class="shell">用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括:  -help  --help  -?        输出此用法消息  -version                 版本信息  -v  -verbose             输出附加信息  -l                       输出行号和本地变量表  -public                  仅显示公共类和成员  -protected               显示受保护的/公共类和成员  -package                 显示程序包/受保护的/公共类                           和成员 (默认)  -p  -private             显示所有类和成员  -c                       对代码进行反汇编  -s                       输出内部类型签名  -sysinfo                 显示正在处理的类的                           系统信息 (路径, 大小, 日期, MD5 散列)  -constants               显示最终常量  -classpath &lt;path&gt;        指定查找用户类文件的位置  -cp &lt;path&gt;               指定查找用户类文件的位置  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>118-数据同步的引入与Synchronized的简单介绍</title>
      <link href="/wang-thread/118-sync-base/"/>
      <url>/wang-thread/118-sync-base/</url>
      
        <content type="html"><![CDATA[<p>逻辑执行单元-任务</p><pre><code class="java">private int index = 1;private static final int MAX = 500;@Overridepublic void run() {    while (true) {        if (index &gt; MAX) {            break;        }        Thread.sleep(5);        System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));    }}</code></pre><p>线程调用</p><pre><code class="java">// 一个runnable实例被多个线程共享TicketWindowRunnable ticketWindow = new TicketWindowRunnable();Thread windowThread1 = new Thread(ticketWindow, &quot;一号窗口&quot;);Thread windowThread2 = new Thread(ticketWindow, &quot;二号窗口&quot;);Thread windowThread3 = new Thread(ticketWindow, &quot;三号窗口&quot;);windowThread1.start();windowThread2.start();windowThread3.start();</code></pre><p>运行结果：</p><pre><code>...二号窗口 的号码是：501三号窗口 的号码是：502</code></pre><p>分析为什么会出现这种情况？</p><p>当index=499的时候，三个线程均不满足index &gt; MAX，同时三个线程均还未执行完成index++，三个线程都不会进入if，所以都可以执行后边的输出语句。</p><p>解决方法：使用synchronized同步方法。</p><pre><code class="java">synchronized (MONITOR) {    if (index &gt; MAX) {        break;    }    try {        Thread.sleep(5);    } catch (InterruptedException e) {        e.printStackTrace();    }    System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>117-Thread API综合实战，编写ThreadService实现暴力结束线程的综合实战</title>
      <link href="/wang-thread/117-force-stop-thread/"/>
      <url>/wang-thread/117-force-stop-thread/</url>
      
        <content type="html"><![CDATA[<p>思考：</p><p>在读操作的过程中线程被阻塞住blocked。此时没有机会打断或读flag，线程不能监听到打断操作。这种情况如何停止线程？暴力。</p><pre><code class="java">@Overridepublic void run() {    // connection or read file}</code></pre><p>此时，在JDK提供的方法中只有stop()可能通过暴力的方式关闭线程，但是stop()已经被官方不推荐使用。可以通过一些小技巧来实现，操作方法如下。</p><p>JDK提供的方法不能使用，此时自己封装一个Service。</p><p>思路：把任务线程设置为调用线程的守护线程，通过main来启动调用线程，从而执行任务线程。当需要停止线程的时候只需要中断调用线程即可，调用线程生命周期结束时，为守护线程的任务线程会自动停止。</p><pre><code class="java">public class ThreadService {    // 调用线程    private Thread executeThread;    private boolean finished = false;    /**     * 执行线程     * @param task 任务     */    public void execute(Runnable task) {        this.executeThread = new Thread(() -&gt; {            // 任务执行线程            Thread runner = new Thread(task);            runner.setDaemon(true);            runner.start();            try {                runner.join();                finished = true;            } catch (InterruptedException e) {}        });        this.executeThread.start();    }    /**     * 关闭线程     * @param mills 线程最长执行时间（单位：毫秒）     */    public void shutdown(long mills) {        long currentTime = System.currentTimeMillis();        // 当任务未完成执行。        while (!finished) {            // 如果超时。            if (System.currentTimeMillis() - currentTime &gt;= mills) {                System.out.println(&quot;任务超时，需要结束线程！&quot;);                executeThread.interrupt();                break;            }            // 既未完成任务，也没超时            try {                Thread.sleep(0, 1);            } catch (InterruptedException e) {                System.out.println(&quot;执行线程被打断！&quot;);                break;            }        }        finished = false;    }}</code></pre><p>通过main调用实现启动线程和中断线程。</p><pre><code class="java">public static void main(String[] args) {    ThreadService service = new ThreadService();    long startTime = System.currentTimeMillis();    service.execute(() -&gt; {        // 1. load a very heavy resource.        /*while (true) {        }*/        // 2. 线程执行5s后结束        try {            Thread.sleep(5_000);        } catch (InterruptedException e) {        }    });    service.shutdown(10_000);    long endTime = System.currentTimeMillis();    System.out.println(&quot;执行时间为：&quot; + (endTime - startTime));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>116-采用优雅的方式结束线程生命周期</title>
      <link href="/wang-thread/116-graceful-stop-thread/"/>
      <url>/wang-thread/116-graceful-stop-thread/</url>
      
        <content type="html"><![CDATA[<p>Graceful thread stop</p><ol><li><p>使用开关变量控制是否启动</p><pre><code class="java">private volatile boolean start = true;@Overridepublic void run() {    while (start) {        // ...    }}public void shutdown() {    this.start = false;}</code></pre><pre><code class="java">worker.start();Thread.sleep(3_000);worker.shutdown();</code></pre><p>实用场景：当程序需要批量获取数据的时候，可以开辟多个线程执行任务，每个线程获取一部分数据，当程序执行完成后需要释放资源，即关闭线程。但是某些线程可能会出现问题导致无法正常关闭，此时需要使用开关变量来控制线程关闭。JVM中的线程主要是放在栈内存中，但是栈空间并不是很大，如果线程一直存在并越来越多可能出现栈内存溢出的情况。</p></li><li><p>通过打断的方式实现</p><ul><li><p>打断sleep()</p><pre><code class="java">@Overridepublic void run() {    while (true) {        // 1. sleep()        try {            Thread.sleep(1);        } catch (InterruptedException e) {            break;// return;        }    }    // ... catch中使用break;可以在while()后执行其他操作    System.out.println(&quot;break-opera after while&quot;);}</code></pre></li><li><p>打断if</p><pre><code class="java">@Overridepublic void run() {    while (true) {        // 2. if        if (Thread.interrupted()) {            break;// return;        }    }    // ... catch中使用break;可以在while()后执行其他操作    System.out.println(&quot;break-opera after while&quot;);}</code></pre></li></ul><pre><code class="java">worker.start();Thread.sleep(3_000);worker.interrupt();</code></pre></li></ol><p>思考：</p><p>在读操作的过程中线程被阻塞住blocked。此时没有机会打断或读flag，线程不能监听到打断操作。这种情况如何停止线程？暴力。</p><pre><code class="java">@Overridepublic void run() {    // connection or read file}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1043-Kafka流处理平台</title>
      <link href="/imooc/1043-Kafka/"/>
      <url>/imooc/1043-Kafka/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1043" target="_blank" rel="noopener">https://www.imooc.com/learn/1043</a></p><p>简介：Kafka是目前主流的流处理平台，同时作为消息队列家族的一员，其高吞吐性作为很多场景下的主流选择。同时作为流处理平台，在大数据开发中，作为黏合剂串联各个系统。本课分为四大部分：第一部分介绍Kafka相关概念和基本信息；第二部分则从Kafka的结构出发，代领大家了解Kafka的设计与思想；第三部分则从实战出发，结合Kafka的应用场景，一步一步结合代码掌握Kafka的用法。最后，我们学习和探究Kafka的高级特性，融会贯通并争取可以在日常其他开发工作中使用Kafka给我们带来的技术能量。课程配套代码参考：<a href="https://github.com/AnAngryMan/KafkaSimpleExample" target="_blank" rel="noopener">https://github.com/AnAngryMan/KafkaSimpleExample</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>课程介绍</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92kvgdkiuj30vi0q2795.jpg" alt="Kafka数据流" style="zoom:30%;" /><p>课程安排：</p><ul><li>Kafka概念解析</li><li>Kafka结构设计</li><li>Kafka场景与应用</li><li>Kafka高级特性</li></ul><h2 id="第2章-什么是Kafka"><a href="#第2章-什么是Kafka" class="headerlink" title="第2章 什么是Kafka"></a>第2章 什么是Kafka</h2><blockquote><p>本章节讲解Kafka的由来，Kafka的定位和基本概念。</p></blockquote><h3 id="2-1-什么是kafka"><a href="#2-1-什么是kafka" class="headerlink" title="2-1 什么是kafka"></a>2-1 什么是kafka</h3><p>LinkedIn开源</p><ul><li>分布式数据同步系统 Databus</li><li>高性能计算引擎 Cubert</li><li>Java异步处理框架 ParSeq</li><li>Kafka流处理平台</li></ul><p>Kafka前世今生</p><ul><li>LinkedIn开发</li><li>2011年初开源，加入Apache基金会</li><li>2012年从Apache Incubator毕业</li><li>Apache顶级开源项目</li></ul><p>streaming platform has three key capabilities：</p><ul><li>Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system.</li><li>Store streams of records in a fault-tolerant durable way.</li><li>Process streams of records as they occur.</li></ul><p>Kafka is generally used for two broad classes of applications：</p><ul><li>Building real-time streaming data pipelines that reliably get data between systems or applications.</li><li>Building real-time streaming applications that transform or react to the streams of data.</li></ul><h2 id="第3章-Kafka的设计和结构"><a href="#第3章-Kafka的设计和结构" class="headerlink" title="第3章 Kafka的设计和结构"></a>第3章 Kafka的设计和结构</h2><blockquote><p>本章节讲解Kafka的部署结构、内部设计结构和设计，让你了解Kafka高效而可靠的原因</p></blockquote><h3 id="3-1-kafka基本概念"><a href="#3-1-kafka基本概念" class="headerlink" title="3-1 kafka基本概念"></a>3-1 kafka基本概念</h3><blockquote><p>物理概念</p><p>逻辑概念</p></blockquote><ul><li><p>Producer：消息和数据的生产者，向Kafka的一个topic发布消息的进程/代码/服务</p></li><li><p>Consumer：消息和数据的消费者，订阅数据（Topic）并且处理其发布的消息的进程/代码/服务</p></li><li><p>Consumer Group：逻辑概念。对于同一个Topic，会广播给不同的group，一个group中，只有一个consumer可以消费该消息。</p></li><li><p>Broker：物理概念。Kafka集群中的每个Kafka节点</p></li><li><p>Topic：逻辑概念。Kafka消息的类别，对数据进行区分、隔离</p></li><li><p>Partition：物理概念。Kafka下数据存储的基本单元。一个Topic数据，会被分散存储到多个Partition，每一个Partition是有序的。</p></li><li><p>Replication：同一个Partition可能会有多个Replica，多个Replica之间的数据是一样的。</p></li><li><p>Replication Leader：一个Partition的多个Replica上，需要一个Leader负责该Partition上与Producer和Consumer交互</p></li><li><p>ReplicaManager：负责管理当前broker所有分区和副本的信息，处理KafkaController发起的一些请求，副本状态的切换、添加/读取消息等</p></li></ul><h3 id="3-2-kafka概念延伸"><a href="#3-2-kafka概念延伸" class="headerlink" title="3-2 kafka概念延伸"></a>3-2 kafka概念延伸</h3><p>Partition：</p><ul><li>每一个Topic被切分为多个Partitions</li><li>消费者数目小于或等于Partition的数目</li><li>Broker Group中的每一个Broker保存Topic的一个或多个Partitions</li><li>Consumer Group中的仅有一个Consumer读取Topic的一个或多个Partitions，并且是唯一的Consumer</li></ul><p>Replication：</p><ul><li>当集群中有Broker挂掉的情况，系统可以主动地使Replicas提供服务</li><li>系统默认设置每一个Topic的Replication的系数为1，可以在创建Topic时单独设置。</li></ul><p>Replication特点：</p><ul><li>Replication的基本单位是Topic的Partition</li><li>所有的读和写都从Leader进，Followers只是作为备份</li><li>Followers必须能够及时复制Leader的数据</li><li>增加容错性与可扩展性</li></ul><h3 id="3-3-kafka基本结构"><a href="#3-3-kafka基本结构" class="headerlink" title="3-3 kafka基本结构"></a>3-3 kafka基本结构</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92ml4h2z8j30sm0ni0z0.jpg" alt="Kafka基本结构" style="zoom:35%;" /><ul><li>Producer API</li><li>Consumer API</li><li>Streams API</li><li>Connectors API</li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92mn3gn8uj31ka0r44oe.jpg" alt="Kafka基本结构" style="zoom:30%;" /><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g92mo6igjyj31r805gwic.jpg" alt="Kafka消息结构" style="zoom:50%;" /><ul><li><p>Offset：</p></li><li><p>Length：</p></li><li><p>CRC32：</p></li><li><p>Magic：</p></li><li><p>attributes：</p></li><li><p>Timestamp：</p></li><li><p>Key Length：</p></li><li><p>Key：</p></li><li><p>Value Length：</p></li><li><p>Value：</p></li></ul><h3 id="3-4-kafka特点"><a href="#3-4-kafka特点" class="headerlink" title="3-4 kafka特点"></a>3-4 kafka特点</h3><p>分布式</p><blockquote><p>多分区、多副本、多订阅者、基于Zookeeper调度</p></blockquote><p>高性能</p><blockquote><p>高吞吐量、低延迟、高并发、时间复杂度为O(1)</p></blockquote><p>持久性与扩展性</p><blockquote><p>数据可持久化、容错性、支持在线水平扩展、消息自动平衡</p></blockquote><h2 id="第4章-Kafka的应用场景和实战"><a href="#第4章-Kafka的应用场景和实战" class="headerlink" title="第4章 Kafka的应用场景和实战"></a>第4章 Kafka的应用场景和实战</h2><blockquote><p>本章节带领大家了解Kafka的一些应用场景，然后从简单案例和复杂案例两个案例学习掌握Kafka的用法。</p></blockquote><h3 id="4-1-kafka应用场景"><a href="#4-1-kafka应用场景" class="headerlink" title="4-1 kafka应用场景"></a>4-1 kafka应用场景</h3><blockquote><p>消息队列、行为跟踪、元信息监控、日志收集、流处理、事件源、持久性日志（commit log）</p></blockquote><h3 id="4-2-kafka简单案例"><a href="#4-2-kafka简单案例" class="headerlink" title="4-2 kafka简单案例"></a>4-2 kafka简单案例</h3><ul><li>环境启动</li><li>简单生产者</li><li>简单消费者</li></ul><p>下载与安装</p><ul><li><p>Zookeeper下载</p><p><a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html#download</a></p></li><li><p>Kafka下载</p><p><a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a></p></li><li><p>安装：解压，配置环境变量</p></li><li><p>Mac便捷安装：<code>brew install kafka</code></p></li></ul><pre><code class="shell"># bash1 启动zookeeperzookeeper-server-start /usr/local/etc/kafka/zookeeper.properties# bash2 启动Kafkakafka-server-start /usr/local/etc/kafka/server.properties</code></pre><pre><code class="shell"># bash3 创建topickafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 3 --topic tuyrk-kafka-topic# 查看Kafka topickafka-topics --list --zookeeper localhost:2181# 创建生产者kafka-console-producer --broker-list localhost:9092 --topic tuyrk-kafka-topic</code></pre><pre><code class="shell"># bash4 创建消费者kafka-console-consumer --bootstrap-server localhost:9092 --topic tuyrk-kafka-topic --from-beginning</code></pre><ul><li><code>from-beginning</code>：从开始重新接收消息</li></ul><h3 id="4-3-kafka代码案例"><a href="#4-3-kafka代码案例" class="headerlink" title="4-3 kafka代码案例"></a>4-3 kafka代码案例</h3><ul><li>工程结构</li><li>基础代码</li></ul><p>教师源码：<a href="https://github.com/AnAngryMan/KafkaSimpleExample" target="_blank" rel="noopener">https://github.com/AnAngryMan/KafkaSimpleExample</a></p><p>学习源码（springboot+kafka）：<a href="https://github.com/tuyrk/learn-imooc" target="_blank" rel="noopener">https://github.com/tuyrk/learn-imooc</a></p><h2 id="第5章-Kafka高级特性"><a href="#第5章-Kafka高级特性" class="headerlink" title="第5章 Kafka高级特性"></a>第5章 Kafka高级特性</h2><blockquote><p>本章节学习Kafka的消息事务和零拷贝，前者学习Kafka如何保证数据一致性，后者学习Kafka消息传递的高效性。</p></blockquote><h3 id="5-1-kafka高级特性之消息事务"><a href="#5-1-kafka高级特性之消息事务" class="headerlink" title="5-1 kafka高级特性之消息事务"></a>5-1 kafka高级特性之消息事务</h3><p>为什么要支持事务？</p><ul><li>满足“读取-处理-写入”模式</li><li>流处理需求的不断增强</li><li>不准确的数据处理的容忍度降低</li></ul><p>数据传输的事务定义</p><ul><li>最多一次：消息不会被重复发送，最多被传输一次，但也有可能一次不传输</li><li>最少一次：消息不会被漏发送，最少被传输一次，但也有可能被重复传输</li><li>精确的一次（Exactly once）：不会漏传输也不会重复传输，每个消息都被传输一次且仅仅传输一次。这是大家所期望的情况。</li></ul><p>事务保证</p><ul><li><p>内部重试问题：Procedure幂等处理</p></li><li><p>多分区原子写入</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g978niwdtvj31ac0gwgos.jpg" alt="多分区原子写入" style="zoom:30%;" /></li></ul><p>事务保证-避免僵尸实例</p><ul><li>每个事务Produce分配一个transaction.id，在进程重新启动时能够识别相同的Producer实例</li><li>Kafka增加了一个与transaction.id相关的epoch，存储每个transaction.id内部元数据</li><li>一旦epoch被触发，任何具有相同的transaction.id和更旧的epoch的Producer被视为僵尸，Kafka会拒绝来自这些Producer的后续事务性写入</li></ul><h3 id="5-2-kafka高级特性之零拷贝"><a href="#5-2-kafka高级特性之零拷贝" class="headerlink" title="5-2 kafka高级特性之零拷贝"></a>5-2 kafka高级特性之零拷贝</h3><p>零拷贝简介：</p><ul><li>网络传输持久性日志块</li><li>Java NIO <code>channel.transforTo()</code>方法</li><li>Linux sendfile系统调用</li></ul><p>文件传输到网络的公共数据路径</p><ul><li>操作系统将数据从磁盘读入到内核空间的页缓存</li><li>应用程序将数据从内核空间读入到用户空间缓存中</li><li>应用程序将数据写回到内核空间的socket缓存中</li><li>操作系统将数据从socket缓冲区复制到网卡缓冲区，以便将数据经网络发出</li></ul><p>零拷贝过程</p><ul><li>操作系统将数据从磁盘读入到内核空间的页缓存</li><li>将数据的位置和长度的信息的描述符增加至内核空间（socket缓冲区）</li><li>操作系统将数据从内核拷贝到网卡缓冲区，以便将数据经网络发出</li></ul><p>文件传输到网络的公共数据路径演变</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g979vkbrulj31u00lutb5.jpg" alt="文件传输到网络的公共数据路径演变" style="zoom:50%;" /><h2 id="第6章-课程总结"><a href="#第6章-课程总结" class="headerlink" title="第6章 课程总结"></a>第6章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="6-1-课程总结"><a href="#6-1-课程总结" class="headerlink" title="6-1 课程总结"></a>6-1 课程总结</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g979ws24pej31ke0u0nka.jpg" alt="Kafka课程总结" style="zoom:25%;" /><ol><li>基础概念与结构</li><li>三维特点</li><li>应用场景</li><li>应用案例</li><li>高级特性</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1193-前端面试加分福音--node基础</title>
      <link href="/imooc/1193-node-base/"/>
      <url>/imooc/1193-node-base/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1193" target="_blank" rel="noopener">https://www.imooc.com/learn/1193</a></p><p>简介：系统的学习NodeJS的基础，熟练使用Node的核心API，了解node的运行过程，学会搭建自己的服务器，并实现我们常见的登录、注册功能，揭开后端开发的神秘面纱。</p></blockquote><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><h3 id="1-1-课程简介-08-47"><a href="#1-1-课程简介-08-47" class="headerlink" title="1-1 课程简介 (08:47)"></a>1-1 课程简介 (08:47)</h3><p>为什么要学node</p><ul><li>使自己更全面，有大局观</li><li>提升话语权</li><li>升职加薪的筹码</li></ul><p>Node的作用和应用</p><ul><li>脱离浏览器运行JS</li><li>后台API编写</li><li>Webpack、Gulp、Npm等等</li><li>中间层：服务器中负责IO读写的中间层服务器</li></ul><p>Node的优点：</p><ul><li>性能、异步IO、处理数据、安全性</li></ul><h3 id="1-2-学习目标-03-35"><a href="#1-2-学习目标-03-35" class="headerlink" title="1-2 学习目标 (03:35)"></a>1-2 学习目标 (03:35)</h3><p>登陆、注册案例</p><p>前置知识：HTML+CSS、JavaScript</p><h2 id="第2章-Node介绍"><a href="#第2章-Node介绍" class="headerlink" title="第2章 Node介绍"></a>第2章 Node介绍</h2><h3 id="2-1-Node的优势-05-36"><a href="#2-1-Node的优势-05-36" class="headerlink" title="2-1 Node的优势 (05:36)"></a>2-1 Node的优势 (05:36)</h3><ul><li>便于前端开发入门</li><li>性能高</li><li>利于前端代码的整合</li></ul><h3 id="2-2-Node环境搭建和运行-06-35"><a href="#2-2-Node环境搭建和运行-06-35" class="headerlink" title="2-2 Node环境搭建和运行 (06:35)"></a>2-2 Node环境搭建和运行 (06:35)</h3><p>Node官网：<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></p><p>Node环境搭建</p><ul><li>官网上下载node-v-xx.msi傻瓜式的安装包。一路下一步安装完成。</li><li>检测是否安装成功：<code>node -v</code></li><li>运行程序：<code>node xxx.js</code></li></ul><h3 id="2-3-npm和包-13-20"><a href="#2-3-npm和包-13-20" class="headerlink" title="2-3 npm和包 (13:20)"></a>2-3 npm和包 (13:20)</h3><p>NPM包管理器：</p><blockquote><p>NPM：node package management</p></blockquote><ul><li>package.json</li><li>NPM、CNPM</li><li>npm常用命令</li></ul><p>没有包管理器的时候：</p><pre><code class="html">&lt;script src=&quot;js/jquery.js&quot;/&gt;&lt;script src=&quot;js/swiper.js&quot;/&gt;&lt;script src=&quot;js/fastclick.js&quot;/&gt;</code></pre><p>CNPM安装</p><pre><code class="shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>NPM常用命令：</p><pre><code class="shell">npm init # 初始化npm install xxx # 安装npm i xxxnpm uninstall xxx # 删除npm un xxxnpm update xxx # 更新npm install # 安装npm i</code></pre><h2 id="第3章-Node的模块"><a href="#第3章-Node的模块" class="headerlink" title="第3章 Node的模块"></a>第3章 Node的模块</h2><blockquote><ol><li>全局模块（对象）process</li><li>系统模块</li><li>自定义模块</li></ol></blockquote><h3 id="3-1-Node中的模块：全局模块-10-34"><a href="#3-1-Node中的模块：全局模块-10-34" class="headerlink" title="3-1 Node中的模块：全局模块 (10:34)"></a>3-1 Node中的模块：全局模块 (10:34)</h3><blockquote><p>定义：何时何地都能访问，不需要引用</p></blockquote><ol><li><p><strong>process.env：环境变量</strong></p><ul><li><p>代码</p><pre><code class="javascript">console.log(process.env);</code></pre></li><li><p>命令</p><pre><code class="shell">node index.js</code></pre></li><li><p>结果</p><pre><code class="json">{  TERM: &#39;xterm-256color&#39;,  SHELL: &#39;/bin/bash&#39;,  CLICOLOR: &#39;1&#39;,  TMPDIR: &#39;/var/folders/jd/4db9g3vs0c57f0_fwtj6nkfc0000gn/T/&#39;,  Apple_PubSub_Socket_Render: &#39;/private/tmp/com.apple.launchd.gNREVjs4ne/Render&#39;,  USER: &#39;tuyuankun&#39;,  SSH_AUTH_SOCK: &#39;/private/tmp/com.apple.launchd.rYrS6hZYR9/Listeners&#39;,  __CF_USER_TEXT_ENCODING: &#39;0x1F5:0x19:0x34&#39;,  LSCOLORS: &#39;gxfxaxdxcxegedabagacad&#39;,  PATH: &#39;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Develop/applications/apache-maven-3.6.2/bin:/Develop/applications/elasticsearch-7.3.1/bin:/Develop/applications/elasticsearch-head&#39;,  TERMINAL_EMULATOR: &#39;JetBrains-JediTerm&#39;,  PWD: &#39;/Develop/learn-imooc/1193-node-base&#39;,  XPC_FLAGS: &#39;0x0&#39;,  XPC_SERVICE_NAME: &#39;0&#39;,  M2_HOME: &#39;/Develop/applications/apache-maven-3.6.2&#39;,  SHLVL: &#39;1&#39;,  HOME: &#39;/Users/tuyuankun&#39;,  LOGNAME: &#39;tuyuankun&#39;,  LC_CTYPE: &#39;zh_CN.UTF-8&#39;,  OLDPWD: &#39;/Develop/learn-imooc/1193-node-base/js&#39;,  _: &#39;/usr/local/bin/node&#39;}</code></pre></li></ul></li><li><p><strong>process.argv：运行参数</strong></p><ul><li><p>代码</p><pre><code class="javascript">console.log(process.argv);</code></pre></li><li><p>命令</p><pre><code class="shell">node index.js a b c</code></pre></li><li><p>结果</p><pre><code class="json">[  &#39;/usr/local/Cellar/node/12.10.0/bin/node&#39;,  &#39;/Develop/learn-imooc/1193-node-base/index.js&#39;,  &#39;a&#39;,  &#39;b&#39;,  &#39;c&#39;]</code></pre></li></ul><p>简易计算器：</p><pre><code class="javascript">let num1 = parseInt(process.argv[2]);let num2 = parseInt(process.argv[3]);console.log(num1 + num2);</code></pre><pre><code class="shell">node index.js 34 43</code></pre><pre><code class="shell">77</code></pre></li><li><p><strong>__dirname：当前目录名称</strong></p></li></ol><h3 id="3-2-Node中的模块：系统模块-13-54"><a href="#3-2-Node中的模块：系统模块-13-54" class="headerlink" title="3-2 Node中的模块：系统模块 (13:54)"></a>3-2 Node中的模块：系统模块 (13:54)</h3><blockquote><p>定义：需要require()，但不需要单独下载</p></blockquote><ol><li><p><strong>path：用于处理文件路径和目录路径的实用工具</strong></p><pre><code class="javascript">var path = require(&#39;path&#39;);</code></pre><pre><code class="javascript">path.dirname(&quot;/node/a/c/c/1.jpg&quot;)// 文件夹名称path.basename(&quot;/node/a/c/c/1.jpg&quot;)// 文件名称path.extname(&quot;/node/a/c/c/1.jpg&quot;)// 文件后缀名称path.resolve(&quot;/node/a/b/c&quot;, &quot;../../&quot;, &quot;d&quot;)// /node/a/dpath.resolve(__dirname, &quot;index.js&quot;)// index.js的绝对路径</code></pre></li><li><p>f s：用于文件读写操作</p><pre><code class="javascript">var fs = require(&quot;fs&quot;);</code></pre><ul><li><p>写操作：</p><pre><code class="javascript">fs.writeFile(&quot;fs.write.txt&quot;, &quot;刚下飞机&quot;, function (err) {    if (err) {        throw err;    }});// 同步fs.writeFileSync(&quot;fs.writeSync.txt&quot;, &quot;分割线&quot;);</code></pre></li><li><p>读操作：</p><pre><code class="javascript">fs.readFile(&quot;js/helloworld.js&quot;, function (err, data) {        if (err) {            console.log(err);        } else {            console.log(data.toString());        }    });// 同步var data = fs.readFileSync(&quot;js/helloworld.js&quot;);</code></pre></li><li><p>追加文件</p><pre><code class="javascript">fs.writeFile(&quot;fs.write.txt&quot;, &quot;年入百万&quot;, {flag: &quot;a&quot;}, function (err) {    if (err) {        throw err;    }});</code></pre><pre><code class="javascript">fs.appendFile(&quot;fs.write.txt&quot;, &quot;泻药&quot;, function (err) {    if (err) {        throw err;    }});</code></pre></li></ul></li></ol><h3 id="3-3-Node中的模块：自定义模块-07-23"><a href="#3-3-Node中的模块：自定义模块-07-23" class="headerlink" title="3-3 Node中的模块：自定义模块 (07:23)"></a>3-3 Node中的模块：自定义模块 (07:23)</h3><blockquote><p>定义：require自己封装的模块</p></blockquote><ul><li>exports</li><li>module</li><li>require</li></ul><pre><code class="javascript">/* mod.js */// 1. 参数/*exports.a = 1;exports.b = 2;var c = 3;*/// 2. 对象/*module.exports = {    a: 1,    b: 2};*/// 3. 方法/*module.exports = function () {    console.log(&quot;module.exports function&quot;);};*/// 4. 类module.exports = class {    constructor(name) {        this.name = name;    }    show() {        console.log(this.name);    }};</code></pre><pre><code class="javascript">/* exports.js */const mod = require(&quot;./mod&quot;);/*console.log(mod.a);// 1console.log(mod.b);// 2console.log(mod.c);// undefined*//*mod();*/let tuyrk = new mod(&quot;tuyrk&quot;);tuyrk.show();</code></pre><p><code>require()</code></p><ol><li>如果有路径，就去路径里面找</li><li>没有的话就去node_modules里面找</li><li>路径下没有模块，就去node的安装目录里面找。</li></ol><h3 id="3-4-核心：http模块-11-21"><a href="#3-4-核心：http模块-11-21" class="headerlink" title="3-4 核心：http模块 (11:21)"></a>3-4 核心：http模块 (11:21)</h3><blockquote><p>服务器对象：<code>http.createServer()</code></p></blockquote><pre><code class="javascript">let fs = require(&quot;fs&quot;);let path = require(&quot;path&quot;);let http = require(&quot;http&quot;);http.createServer((req, res) =&gt; {    /*console.log(&quot;我来了。&quot;);*/    /*res.write(&quot;index&quot;);    res.end();*/    console.log(req.url);    fs.readFile(`./${req.url}`, (err, data) =&gt; {        if (err) {            console.log(err);            res.writeHead(404);            res.end(&quot;404 not found&quot;);        } else {            res.writeHead(200);            res.end(data);        }    });}).listen(8888);</code></pre><pre><code class="html">&lt;p&gt;我是http.html&lt;/p&gt;&lt;img src=&quot;../imgs/avatar.jpeg&quot; alt=&quot;avatar.jpeg&quot;&gt;</code></pre><h2 id="第4章-Node中的数据交互"><a href="#第4章-Node中的数据交互" class="headerlink" title="第4章 Node中的数据交互"></a>第4章 Node中的数据交互</h2><h3 id="4-1-GET请求-13-32"><a href="#4-1-GET请求-13-32" class="headerlink" title="4-1 GET请求 (13:32)"></a>4-1 GET请求 (13:32)</h3><p>客户端与服务器交互的东西称为报文。</p><p>报文分为：报文头（信息，&lt;=32K）、报文体（数据&lt;2G）。</p><p>请求方式：GET、POST、PUT、DELETE</p><p>GET请求</p><ul><li>什么是GET请求？主要是获取数据。一次性传输数据</li><li>数据是放在URL里面进行传输。报文头。</li><li>容量小：&lt;32K</li></ul><pre><code class="javascript">let http = require(&quot;http&quot;);let url = require(&quot;url&quot;);http.createServer(((req, res) =&gt; {    console.log(req.url);    // 1. 无url模块，原始处理方法    /*let [url, query] = req.url.split(&#39;?&#39;);    console.log(url, query);*/    // 2. 使用url模块处理路径与参数    let {pathname, query} = url.parse(req.url, true);    console.log(pathname, query);})).listen(8888);</code></pre><pre><code class="html">&lt;form action=&quot;http://localhost:8888/aaa&quot; method=&quot;get&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre><h3 id="4-2-POST请求-12-34"><a href="#4-2-POST请求-12-34" class="headerlink" title="4-2 POST请求 (12:34)"></a>4-2 POST请求 (12:34)</h3><p>POST请求</p><ul><li><p>分段传输数据</p></li><li><p>数据是放在body里边进行传输。报文体</p></li><li><p>容量大：2G</p></li></ul><pre><code class="javascript">let http = require(&quot;http&quot;);let querystring = require(&quot;querystring&quot;);http.createServer(((req, res) =&gt; {    let result = [];    req.on(&quot;data&quot;, buffer =&gt; {        result.push(buffer);// 分段传输数据，多次执行添加    });    req.on(&quot;end&quot;, () =&gt; {// 数据处理完成        let data = Buffer.concat(result).toString();// 数组转buffer        console.log(querystring.parse(data));// 处理queryString    })})).listen(8888);</code></pre><pre><code class="html">&lt;form action=&quot;http://localhost:8888/aaa&quot; method=&quot;post&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;</code></pre><p>总结：</p><ol><li>GET<ul><li>url?username=xxx&amp;password=xxx</li><li>32K</li><li>url模块</li><li><code>url.parse(req.url, true)</code></li></ul></li><li>POST<ul><li>放在请求体</li><li>2G</li><li>querystring模块</li><li><code>querystring.parse(data)</code></li></ul></li></ol><h2 id="第5章-案例"><a href="#第5章-案例" class="headerlink" title="第5章 案例"></a>第5章 案例</h2><h3 id="5-1-接口（API）-05-59"><a href="#5-1-接口（API）-05-59" class="headerlink" title="5-1 接口（API） (05:59)"></a>5-1 接口（API） (05:59)</h3><p>登录框：登陆、注册</p><p>接口设计</p><ul><li>什么是接口（API）：不同功能层之间的通信规则称为接口</li><li>参数、返回值</li></ul><p>登陆：</p><pre><code class="shell">GET &#39;/login&#39;username, password</code></pre><pre><code class="json">{  err: 1,  msg: &quot;密码错误&quot;}</code></pre><p>注册：</p><pre><code class="shell">POST &#39;/reg&#39;</code></pre><h3 id="5-2-项目：实现登录和注册-30-08"><a href="#5-2-项目：实现登录和注册-30-08" class="headerlink" title="5-2 项目：实现登录和注册 (30:08)"></a>5-2 项目：实现登录和注册 (30:08)</h3><p>后台：</p><pre><code class="javascript">/*login.js*/const http = require(&quot;http&quot;);const url = require(&quot;url&quot;);const querystring = require(&quot;querystring&quot;);const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);let user = {    admin: &quot;123456&quot;};http.createServer(((req, res) =&gt; {    // 获取数据    let uri, get, post;    if (req.method === &quot;GET&quot;) {        let {pathname, query} = url.parse(req.url, true);        uri = pathname, get = query;        complete();    } else if (req.method === &quot;POST&quot;) {        let arr = [];        uri = req.url;        req.on(&quot;data&quot;, buffer =&gt; {            arr.push(buffer);        });        req.on(&quot;end&quot;, () =&gt; {            post = querystring.parse(Buffer.concat(arr).toString());            complete();        });    }    // 业务操作    // function complete() {}    // 设置状态码、编码    function setHead() {        res.writeHead(200, {            &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;        });    }})).listen(8888);</code></pre><p>页面：</p><pre><code class="html">&lt;!--login.html--&gt;&lt;form&gt;    用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot;&gt;&lt;br&gt;    密码：&lt;input type=&quot;password&quot; id=&quot;password&quot;&gt;&lt;br&gt;    &lt;button id=&quot;login&quot;&gt;登陆&lt;/button&gt;    &lt;button id=&quot;reg&quot;&gt;注册&lt;/button&gt;&lt;/form&gt;</code></pre><h2 id="第6章-课程回顾与总结"><a href="#第6章-课程回顾与总结" class="headerlink" title="第6章 课程回顾与总结"></a>第6章 课程回顾与总结</h2><h3 id="6-1-总结扩展-11-45"><a href="#6-1-总结扩展-11-45" class="headerlink" title="6-1 总结扩展 (11:45)"></a>6-1 总结扩展 (11:45)</h3><p>作用：</p><ol><li>写Web API</li><li>中间层</li><li>前端工程化的一些工具（webpack、gulp）</li></ol><p>优势：</p><ol><li>性能高</li><li>便于前端入手</li></ol><p>npm命令：</p><blockquote><p>package.json</p></blockquote><pre><code class="shell">npm i xxxnpm un xxx</code></pre><p>三大模块</p><ol><li>全剧模块</li><li>系统模块 require引入</li><li>自定义模块 自己封装 module.export</li></ol><p><strong>重点：http模块</strong></p><pre><code class="javascript">http.createServer((req, res) =&gt; {    // ...})</code></pre><p>数据通信：</p><ol><li><p>GET请求</p><ul><li><p>url模块</p><pre><code class="javascript">url.parse(req.url, true);</code></pre></li></ul></li><li><p>POST请求</p></li></ol><ul><li><pre><code class="javascript">let arr = [];req.on(&quot;data&quot;, buffer =&gt; {    arr.push(buffer);   // ...});req.on(&quot;end&quot;, () =&gt; {    Buffer.concat(arr).toString();});querystring.parse(req.url); // username=tuyrk&amp;password=123</code></pre></li></ul><p><strong>登陆、注册</strong></p><p>接口API、设计API</p><ul><li><p>GET ‘/login’</p></li><li><p>参数：username,password string object</p></li><li><p>返回值：</p><pre><code class="json">{  err: 0,  msg: &quot;xxx&quot;}</code></pre></li></ul><p>深入学习：express/koa2、MongoDB</p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115-Thread中断Interrupt方法详细讲解</title>
      <link href="/wang-thread/115-thread-interrupt/"/>
      <url>/wang-thread/115-thread-interrupt/</url>
      
        <content type="html"><![CDATA[<ul><li><p>interrupt()</p><p>中断此线程</p></li><li><p>interrupted()</p><p>测试<strong>当前线程</strong>是否已被中断。</p></li><li><p>isInterrupted()</p><p>测试<strong>此线程</strong>是否已被中断。</p></li></ul><p><code>interrupt()</code>仅仅是修改interrupt的状态。必须是<code>wait()</code>、<code>join()</code>、<code>sleep()</code>的时候才会抛出异常中断线程。</p><pre><code class="java">Thread t1 = new Thread(&quot;t1&quot;) {    @Override    public void run() {        while (true) {            // todo...        }    }};t1.start();// start之后处于runnable，并不一定马上就会running。所以设置短暂休眠等待t1启动Thread.sleep(100);System.out.println(t1.isInterrupted());// falset1.interrupt();System.out.println(t1.isInterrupted());// true</code></pre><ol><li><p>线程状态改变，不会捕获到打断信号</p><pre><code class="java">System.out.println(&quot;&gt;&gt;&quot; + this.isInterrupted());</code></pre></li><li><p><code>sleep()</code>。线程状态改变，且捕获到打断信号</p><pre><code class="java">try {    Thread.sleep(1_000);} catch (InterruptedException e) {    System.out.println(&quot;收到打断信号。&quot;);    e.printStackTrace();}</code></pre></li><li><p><code>wait()</code>。线程状态改变，且捕获到打断信号</p><p>使用<code>wait()</code>必须给一个monitor，monitor需使用synchronized包裹。</p><pre><code class="java">private static final Object MONITOR = new Object();</code></pre><pre><code class="java">synchronized (MONITOR) {    try {        MONITOR.wait(1_000);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre></li><li><p><code>join()</code>。线程状态改变，且捕获到打断信号</p><p>注意：<code>t3.join();</code>这里join的不是t3线程，而是main线程。所以需要对main线程进行<code>interrupt()</code></p><pre><code class="java">Thread t3 = new Thread(() -&gt; {    while (true) {}}, &quot;t3&quot;);t3.start();Thread main = Thread.currentThread();Thread t31 = new Thread(() -&gt; {    try {        Thread.sleep(100);    } catch (InterruptedException e) {        e.printStackTrace();    }    main.interrupt();});t31.start();try {    // 这里join的不是t3线程，而是main线程    t3.join();} catch (InterruptedException e) {    e.printStackTrace();}</code></pre></li></ol><p>非静态<code>isInterrupted()</code>和静态<code>interrupted()</code>区别：</p><ul><li><p>在实现Runnable接口创建任务实例时，<code>isInterrupted()</code>将不能被获取</p><pre><code class="java">Thread t2 = new Thread(() -&gt; {    while (true) {        synchronized (MONITOR) {            try {                MONITOR.wait(1_000);            } catch (InterruptedException e) {                // 获取不到isInterrupted()                // System.out.println(&quot;wait()-&gt;&quot; + isInterrupted());                System.out.println(&quot;wait()-&gt;&quot; + Thread.interrupted());                e.printStackTrace();            }        }    }}, &quot;t2&quot;);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>114-Thread的join方法详细介绍，结合一个典型案例</title>
      <link href="/wang-thread/114-thread-join/"/>
      <url>/wang-thread/114-thread-join/</url>
      
        <content type="html"><![CDATA[<p><code>join()</code>方法</p><blockquote><p>调用线程一直等待被调用线程的执行，直到被调用线程死亡。</p></blockquote><pre><code class="java">Thread t1 = new Thread(() -&gt; {    IntStream.range(1, 1000).forEach(i -&gt;            System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i)    );}, &quot;t1&quot;);t1.start();t1.join();IntStream.range(1, 1000).forEach(i -&gt;        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</code></pre><p>注：<code>join()</code>必须放在<code>start()</code>之后。</p><pre><code class="java">Thread t1 = new Thread(() -&gt; {    IntStream.range(1, 9000).forEach(i -&gt;            System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i)    );}, &quot;t1&quot;);Thread t2 = new Thread(() -&gt; {    IntStream.range(1, 9000).forEach(i -&gt;            System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i)    );}, &quot;t2&quot;);t1.start();t2.start();t1.join();t2.join();Optional.of(&quot;All of tasks finish done.&quot;).ifPresent(System.out::println);IntStream.range(1, 1000).forEach(i -&gt;        System.out.println(Thread.currentThread().getName() + &quot;-&gt;&quot; + i));</code></pre><p>注意：</p><ul><li><p>t1、t2交替执行</p><pre><code class="java">t1.start();t2.start();t1.join();t2.join();</code></pre></li><li><p>先执行t1，在执行t2。此时t1加入join，t2还没启动。</p><pre><code class="java">t1.start();t1.join();t2.start();t2.join();</code></pre></li></ul><p>问题：一些嵌入式的HTTP Server，比如jetty，为什么把任务启动，一会之后会自动挂掉？<br>原因：在主线程退出之后会把http server挂掉（守护线程），避免占用端口、浪费资源。<br>解决：使用<code>Thread.currentThread().join();</code>。让当前线程执行，直到当前线程死掉</p><pre><code class="java">public static void main(String[] args) {    // 一直等待main线程结束,直到main线程结束。    // 结果main线程一直运行。    Thread.currentThread().join();}</code></pre><p>例：采集服务器节点的信息的例子。</p><p>问题：多个线程如何得到唯一的采集结束时间？</p><p>提示：使用<code>join()</code>方法</p><pre><code class="java">public class ThreadJoin3 {    public static void main(String[] args) throws InterruptedException {        long startTimestamp = System.currentTimeMillis();        // 假设有三台机器，开启三个线程。        Thread m1 = new Thread(new CaptureRunnable(&quot;M1&quot;, 10_000L));        Thread m2 = new Thread(new CaptureRunnable(&quot;M2&quot;, 30_000L));        Thread m3 = new Thread(new CaptureRunnable(&quot;M3&quot;, 15_000L));        m1.start();m2.start();m3.start();        m1.join();m2.join();m3.join();        long endTimestamp = System.currentTimeMillis();        System.out.printf(&quot;Save data begin timestamp is %s, end timestamp is %s\n&quot;, startTimestamp, endTimestamp);        System.out.printf(&quot;Spend time is %s&quot;, endTimestamp - startTimestamp); // 30000    }}/** * 采集服务器节点的任务。 */@Dataclass CaptureRunnable implements Runnable {    // 机器节点的名称    private String machineName;    // 采集花费时间    private long spendTime;    public CaptureRunnable(String machineName, long spendTime) {        this.machineName = machineName;        this.spendTime = spendTime;    }    @Override    public void run() {        // do the really capture data.        Thread.sleep(spendTime);        System.out.printf(machineName + &quot; completed data capture at timestamp [%s] and successful.\n&quot;, System.currentTimeMillis());    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>113-线程ID，优先级讲解</title>
      <link href="/wang-thread/113-thread-id-priority/"/>
      <url>/wang-thread/113-thread-id-priority/</url>
      
        <content type="html"><![CDATA[<p>Thread中一些简单的API</p><pre><code class="java">Thread t1 = new Thread(() -&gt; {    Optional.of(&quot;Hello&quot;).ifPresent(System.out::println);    try {        Thread.sleep(1_000);    } catch (InterruptedException e) {        e.printStackTrace();    }}, &quot;t1&quot;);</code></pre><pre><code class="java">// 线程名称。Optional.of(t1.getName()).ifPresent(System.out::println);// 线程ID。++threadSeqNumberOptional.of(t1.getId()).ifPresent(System.out::println);// 线程优先级，默认为5.Optional.of(t1.getPriority()).ifPresent(System.out::println);</code></pre><p>线程优先级范围是1-10，默认为5，通过修改线程优先级可以企图<strong>改变</strong>线程的执行顺序。</p><p>线程不一定会按照指定的优先级执行。</p><pre><code class="java">Thread.MAX_PRIORITY// 最高优先级，10Thread.NORM_PRIORITY// 默认优先级，5Thread.MIN_PRIORITY// 最低优先级，1</code></pre><p>例：线程t1、t2、t3交替运行。</p><pre><code class="java">Thread t1 = new Thread(() -&gt; {    for (int i = 0; i &lt; 1000; i++) {        Optional.of(Thread.currentThread().getName() + &quot;-Index-&quot; + i).ifPresent(System.out::println);    }}, &quot;t1&quot;);t1.setPriority(Thread.MAX_PRIORITY);Thread t2 = new Thread(() -&gt; {    for (int i = 0; i &lt; 1000; i++) {        Optional.of(Thread.currentThread().getName() + &quot;-Index-&quot; + i).ifPresent(System.out::println);    }}, &quot;t2&quot;);t2.setPriority(Thread.NORM_PRIORITY);Thread t3 = new Thread(() -&gt; {    for (int i = 0; i &lt; 1000; i++) {        Optional.of(Thread.currentThread().getName() + &quot;-Index-&quot; + i).ifPresent(System.out::println);    }}, &quot;t3&quot;);t3.setPriority(Thread.MIN_PRIORITY);t1.start();t2.start();t3.start();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112-Daemon线程的创建以及使用场景分析</title>
      <link href="/wang-thread/112-daemon/"/>
      <url>/wang-thread/112-daemon/</url>
      
        <content type="html"><![CDATA[<p>Runnable不是线程，它只是一个接口，只是一个任务执行单元。它的作用是把<strong>线程控制</strong>和<strong>业务逻辑</strong>分开。真正代表线程的只有Thread。</p><p>ThreadGroup的好处：可以统一管理Thread线程。</p><p>在JDK1.7之后可以将数据<code>10000</code>写为<code>10_000</code></p><ol><li><p>main线程此时逻辑单元已经结束，为什么还没有退出程序呢？</p><p>因为此时ThreadGroup中还有线程Thread-0处于active状态。</p><pre><code class="java">public class DeamonThread {    public static void main(String[] args) throws InterruptedException {        // new        Thread t = new Thread() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName() + &quot; running&quot;);                Thread.sleep(1_000_000);                System.out.println(Thread.currentThread().getName() + &quot; done&quot;);            }        };        // runnable -&gt; running| -&gt; blocked -&gt; dead        t.start();        System.out.println(Thread.currentThread().getName());    }}</code></pre></li><li><p><code>t.setDaemon(true);</code>在main结束后自动结束所有线程</p><p>守护线程Daemon有什么作用呢？</p><blockquote><p>例：建立网络连接。<br>从A到B建立了一个长连接，长连接在一定间隔时间会发送心跳包以证明连接是可用的。比如A为客户端，B为服务器，A不断向B发送心跳包，B向A返回心跳响应。<br>当前工作线程创建了一个连接后，要维护这个长连接，但是当前工作线程的业务逻辑、发送数据等操作与维护连接并没有关系，此时就可以创建一个守护线程daemonThread来进行心跳检测工作。<br>当工作线程已经结束工作而死亡，非守护线程并不会自动死亡，而此时再去进行长连接心跳检测并没有任何意义，所以将其设置为守护线程可以在工作线程死亡时自动死亡。</p></blockquote></li></ol><p>思考：</p><ol><li><p>在非守护线程A里创建守护线程B，当线程A结束后，线程B会自动结束么？</p><p>线程B会自动结束</p></li><li><p>在非守护线程A里创建非守护线程B，当线程A结束后，线程B会自动结束么，JVM可以正常退出么？</p><p>线程B不会自动结束，仍然在运行。</p></li><li><p>在守护线程A里创建守护线程B，当线程A结束后，线程B会自动结束么？</p><p>会。</p></li><li><p>在守护线程A里创建非守护线程B，当线程A结束后，线程B会自动结束么，JVM可以正常退出么？</p><p>会。</p><pre><code class="java">Thread thread = new Thread(() -&gt; {    Thread innerThread = new Thread(() -&gt; {        while (true) {            System.out.println(&quot;innerThread do something for health check.&quot;);            Thread.sleep(1_000);        }    }, &quot;innerThread&quot;);    // innerThread.setDaemon(true);    innerThread.start();    Thread.sleep(1_000);    System.out.println(&quot;thread finish done.&quot;);}, &quot;thread&quot;);// innerThread.setDaemon(true);thread.start();</code></pre></li></ol><p>总结：</p><ol><li>线程默认为非守护线程。其实main线程是一个非守护线程。</li><li>当运行的所有线程都是守护程序线程时，Java虚拟机才退出。 </li></ol><p><strong>注意</strong>：必须在线程<code>start()</code>启动之前调用<code>setDaemon()</code>方法。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111-Thread构造函数StackSize详细讲解-续</title>
      <link href="/wang-thread/111-thread-stacksize2/"/>
      <url>/wang-thread/111-thread-stacksize2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</p></blockquote><p>默认的stackSize是多大呢？</p><ul><li>JDK源码中stackSize默认为0，代表该变量值被忽略。把传入的stackSize赋值给类变量，然后在代码中未找到引用，可能是在JVM中被引用了。</li></ul><p>构造Thread的时候传入stackSize代表着该线程占用的stack的大小。如果没有指定stackSize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI函数去使用。需要注意：该参数在某些平台（操作系统）可能无效。通过JVM参数显式设置：<code>-Xms10M</code></p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110-Thread构造函数StackSize详细讲解</title>
      <link href="/wang-thread/110-thread-stacksize1/"/>
      <url>/wang-thread/110-thread-stacksize1/</url>
      
        <content type="html"><![CDATA[<p>不要过分压榨应用的性能，应用服务压力建议最大达到应用性能峰值的80%。超过80%可以通过横向扩展应用以减缓压力。现在分布式应用那么普遍。</p><p>验证：JVM启动时创建的栈空间不变，由于线程的栈空间占用了很大虚拟机栈内存，所以在main主线程里，JVM能允许创建的线程数也会相应减少。</p><pre><code class="java">public class CreateThread5 {    private static int counter = 0;    public static void main(String[] args) {        try {            // 不断循环创建Thread            for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {                counter++;                // 1. 默认stackSize。                /*new Thread(() -&gt; {                    // 增大栈针的宽度                    byte[] data = new byte[1024 * 1024 * 2];                    while (true) {}                }).start();*/                // 2. 修改stackSize。                new Thread(null, () -&gt; {                    // 增大栈针的宽度                    byte[] data = new byte[1024 * 1024 * 2];                    while (true) {}                }, &quot;stackSizeTest&quot;, 1 &lt;&lt; 32).start();            }        } catch (Error e) {            e.printStackTrace();        }        System.out.println(&quot;Total create thread nums =&gt; &quot; + counter);    }}</code></pre><p>输出结果：</p><ol><li><p>默认stackSize。</p><pre><code class="shell">java.lang.OutOfMemoryError: unable to create new native thread    at java.lang.Thread.start0(Native Method)    at java.lang.Thread.start(Thread.java:717)    at com.tuyrk.chapter03.CreateThread5.main(CreateThread5.java:28)Total create thread nums =&gt; 4060</code></pre></li><li><p>stackSize = 1 &lt;&lt; 32</p><pre><code class="shell">java.lang.OutOfMemoryError: unable to create new native thread    at java.lang.Thread.start0(Native Method)    at java.lang.Thread.start(Thread.java:717)    at com.tuyrk.chapter03.CreateThread5.main(CreateThread5.java:28)Total create thread nums =&gt; 4060</code></pre></li></ol><p>结论：<strong>有待考证。暂认不成立</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>109-多线程与JVM内存结构的关系，虚拟机栈实验</title>
      <link href="/wang-thread/109-thread-with-memory/"/>
      <url>/wang-thread/109-thread-with-memory/</url>
      
        <content type="html"><![CDATA[<p>Java内存结构-简：</p><ul><li><p>栈（非堆）</p></li><li><p>堆</p><p>栈存储基本数据类型，引用类型<br>堆存储对象</p></li></ul><p>Java内存结构</p><ul><li><p>栈内存</p><ol><li>方法区（线程共享）</li></ol></li></ul><ol start="2"><li>虚拟机栈（线程私有）<br>  栈针（若干）：局部变量表、操作栈、动态链接库、方法出口/入口<ol start="3"><li>本地方法区C++：执行引擎、本地库接口<code>.so</code>、本地方法</li></ol></li><li>程序计数器</li></ol><ul><li><p>堆内存</p><ol><li>对象实体（栈只保存变量的引用）</li></ol></li></ul><p>不断压栈操作将会导致栈溢出，从而程序崩溃并抛出<code>java.lang.StackOverflowError</code></p><p>Java多线程与内存堆栈关系。虚拟机栈</p><ul><li><p>main主线程。</p><pre><code class="java">public class CreateThread3 {    private static int counter = 0;    // JVM will create a thread named &quot;main&quot;    public static void main(String[] args) {        // create a JVM stack        try {            add(0);        } catch (Error e) {            e.printStackTrace();// java.lang.StackOverflowError            System.out.println(counter);// 21325        }    }    private static void add(int i) {        counter++;        add(i + 1);    }}</code></pre></li><li><p>用户子线程</p><pre><code class="java">public class CreateThread4 {    private static int counter = 0;    public static void main(String[] args) {        Thread t = new Thread(new Runnable() {            @Override            public void run() {                try {                    add(0);                } catch (Error e) {                    e.printStackTrace();// java.lang.StackOverflowError                    System.out.println(counter);// 18455                }            }            private void add(int i) {                counter++;                add(i + 1);            }        });        t.start();    }}</code></pre></li></ul><p>通过stackSize构造方法改变线程的栈内存大小，避免抛出<code>java.lang.StackOverflowError</code>。<del>但是JVM启动时创建的栈空间不变，由于线程的栈空间占用了很大虚拟机栈内存，所以在main主线程里，JVM能允许创建的线程数也会相应减少。</del></p><pre><code class="java">public class CreateThread4 {    private static int counter = 0;    public static void main(String[] args) {        Thread t = new Thread(null, new Runnable() {            @Override            public void run() {                try {                    add(0);                } catch (Error e) {                    e.printStackTrace();                    System.out.println(counter);                }            }            private void add(int i) {                counter++;                add(i + 1);            }        }, &quot;stackSizeTest&quot;, 1 &lt;&lt; 24);        t.start();    }}</code></pre><p>扩展：</p><ol><li><p>编写一个抛出<code>java.lang.StackOverflowError</code>的例子</p></li><li><p>编写一个抛出<code>java.lang.OutOfMemoryError</code>的例子</p><blockquote><p>StackOverFlowError一般是由于栈深度大于虚拟机提供的最大栈深度导致的</p><p>OutOfMemoryError一般是由于虚拟机在扩展堆栈时无法申请到足够的内存，可以通过<code>--xms</code> 和<code>--xmx</code>来设定虚拟机的最大可扩展内存</p></blockquote></li><li><p>JVM之–Java内存结构</p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/9747207" target="_blank" rel="noopener">JVM之—Java内存结构（第一篇）</a></p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/9751487" target="_blank" rel="noopener">JVM之—Java内存结构（第二篇）</a></p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/9774579" target="_blank" rel="noopener">JVM之—Java内存结构（第三篇）</a></p><p><a href="https://blog.csdn.net/wangwenjun69/article/details/10044575" target="_blank" rel="noopener">JVM之—Java内存分配参数（第四篇）</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108-构造Thread对象你也许不知道的几件事</title>
      <link href="/wang-thread/108-construct-thread/"/>
      <url>/wang-thread/108-construct-thread/</url>
      
        <content type="html"><![CDATA[<p>构造函数：</p><ul><li>构造方法没有传入ThreadGroup，是否会创建默认的ThreadGroup</li><li>如果传入ThreadGroup为null，是否会使用其他默认的ThreadGroup</li><li>ThreadGroup和Thread之间的关系是什么</li><li>线程和栈的关系</li></ul><pre><code class="java">Thread()Thread(String name)Thread(Runnable target)Thread(Runnable target, String name)Thread(ThreadGroup group, String name)Thread(ThreadGroup group, Runnable target)Thread(ThreadGroup group, Runnable target, String name)Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></pre><ul><li><p>Thread()</p><p>创建线程对象Thread，默认有一个线程名，以Thread-开头，从0开始计数</p><pre><code class="java">Thread t1 = new Thread();</code></pre><p>如果在构造Thread的时候没有传递Runnable或者没有复写Thread的<code>run()</code>方法，该Thread将不会调用任何东西，如果传递了Runnable的实例，或者复写了Thread的<code>run()</code>方法，则会执行该方法的逻辑单元（逻辑代码）</p><pre><code class="java">Thread t2 = new Thread() {    @Override    public void run() {        System.out.println(&quot;================&quot;);    }};</code></pre><p>如果构造线程对象时未传入ThreadGroup，Thread会默认获取父线程的ThreadGroup作为该线程的ThreadGroup。此时子线程和父线程将会在同一个ThreadGroup中。</p><pre><code class="java">System.out.println(t1.getThreadGroup()); // mainSystem.out.println(Thread.currentThread().getName()); // mainSystem.out.println(Thread.currentThread().getThreadGroup().getName()); // main</code></pre><p>通过ThreadGroup对象可以获得该线程组中有多少个线程</p><pre><code class="java">ThreadGroup threadGroup = Thread.currentThread().getThreadGroup();Thread[] threads = new Thread[threadGroup.activeCount()];threadGroup.enumerate(threads);Arrays.stream(threads).forEach(System.out::println);// main,Thread-0,Monitor</code></pre></li><li><p>Thread(String name)</p><pre><code class="java">Thread t3 = new Thread(&quot;MyName&quot;);</code></pre></li><li><p>Thread(Runnable target)</p><pre><code class="java">Thread t4 = new Thread(() -&gt; {    System.out.println(&quot;Runnable...&quot;);});</code></pre></li><li><p>Thread(Runnable target, String name)</p><pre><code class="java">Thread t5 = new Thread(() -&gt; {    System.out.println(&quot;Runnable...&quot; + Thread.currentThread().getName());}, &quot;RunnableThread&quot;);</code></pre></li><li><p>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</p><p>stackSize：The stack size is the approximate number of bytes of address space that the virtual machine is to allocate for this thread’s stack.<strong>The effect of the <code>stackSize</code> parameter, if any, is highly platform dependent.On some platforms, the value of the <code>stackSize</code> parameter may have no effect whatsoever.</strong></p><p>构造Thread的时候传入stackSize代表着该线程占用的stack的大小。如果没有指定stackSize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI函数去使用。需要注意：该参数在某些平台（操作系统）可能无效。通过JVM参数显式设置：<code>-Xms10M</code></p><pre><code class="java">Thread t = new Thread(null, new Runnable() {    @Override    public void run() {        try {            add(0);        } catch (Error e) {            e.printStackTrace();            System.out.println(counter);        }    }    private void add(int i) {        counter++;        add(i + 1);    }}, &quot;stackSizeTest&quot;, 1 &lt;&lt; 24);</code></pre><pre><code>java.lang.StackOverflowError</code></pre></li></ul><p><strong>总结</strong>：</p><ol><li>创建线程对象Thread，默认有一个线程名，以Thread-开头，从0开始计数</li><li>如果在构造Thread的时候没有传递Runnable或者没有复写Thread的<code>run()</code>方法，该Thread将不会调用任何东西，如果传递了Runnable的实例，或者复写了Thread的<code>run()</code>方法，则会执行该方法的逻辑单元（逻辑代码）</li><li>如果构造线程对象时未传入ThreadGroup，Thread会默认获取父线程的ThreadGroup作为该线程的ThreadGroup。此时子线程和父线程将会在同一个ThreadGroup中。</li><li>构造Thread的时候传入stackSize代表着该线程占用的stack的大小。如果没有指定stackSize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI函数去使用。需要注意：该参数在某些平台（操作系统）可能无效。通过JVM参数显式设置：<code>-Xms10M</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>107-*策略模式在Thread和Runnable中的应用分析</title>
      <link href="/wang-thread/107-Strategy-in-thread/"/>
      <url>/wang-thread/107-Strategy-in-thread/</url>
      
        <content type="html"><![CDATA[<p>Runnable接口与多线程中的哪种设计模式比较接近？</p><ul><li>策略模式</li></ul><p>举例：税收计算器。需多看代码示例，深入理解策略模式。</p><ol><li><p>税收计算器接口。策略模式</p><pre><code class="java">@FunctionalInterfacepublic interface CalculatorStrategy {    /**     * 计算税率     *     * @param salary 薪水     * @param bonus 奖金     * @return 税收     */    double calculate(double salary, double bonus);}</code></pre></li><li><p>税收计算器实现类</p><pre><code class="java">public class SimpleCalculatorStrategy implements CalculatorStrategy {    private final static double SALARY_RATE = 0.1;    private final static double BONUS_RATE = 0.15;    // 计算税率：工资*0.1 + 奖金*0.15    @Override    public double calculate(double salary, double bonus) {        return salary * SALARY_RATE + bonus * BONUS_RATE;    }}</code></pre></li><li><p>税务计算器。Runnable与多线程设计模式</p><pre><code class="java">@Datapublic class TaxCalculator {    // 薪水    private final double salary;    // 奖金    private final double bonus;    private CalculatorStrategy calculatorStrategy;    public TaxCalculator(double salary, double bonus) {        this.salary = salary;        this.bonus = bonus;    }    public TaxCalculator(double salary, double bonus, CalculatorStrategy calculatorStrategy) {        this.salary = salary;        this.bonus = bonus;        this.calculatorStrategy = calculatorStrategy;    }    // 计算税率    protected double calcTax() {        return calculatorStrategy.calculate(salary, bonus);    }    // 计算    public double calculate() {        return this.calcTax();    }}</code></pre></li><li><p>税务计算器测试类</p><pre><code class="java">public class TaxCalculatorMain {    // 1. 模版方法    @Test    public void test1() {        TaxCalculator calculator = new TaxCalculator(10000d, 2000d) {            @Override            protected double calcTax() {                return getSalary() * 0.1 + getBonus() * 0.15;            }        };        System.out.println(calculator.calculate());    }    // 2.1 策略模式    @Test    public void test2() {        TaxCalculator calculator = new TaxCalculator(10000d, 2000d);        CalculatorStrategy strategy = new SimpleCalculatorStrategy();        calculator.setCalculatorStrategy(strategy);        System.out.println(calculator.calculate());    }    // 2.2 策略模式-Java8Lambda-1    @Test    public void test3() {        TaxCalculator calculator = new TaxCalculator(10000d, 2000d);        calculator.setCalculatorStrategy((s, b) -&gt; s * 0.1 + b * 0.15);        System.out.println(calculator.calculate());    }    // 2.2 策略模式-Java8Lambda-2    @Test    public void test4() {        TaxCalculator calculator = new TaxCalculator(10000d, 2000d, (s, b) -&gt; s * 0.1 + b * 0.15);        System.out.println(calculator.calculate());    }}</code></pre></li></ol><p>通过策略模式的思想改造<code>BankRunnable.java</code></p><ul><li><p>银行大厅</p><pre><code class="java">public class BankRunnable {    private final static int MAX = 50;    private int index = 1;    public static void main(String[] args) {        // 1. 一个runnable实例被多个线程共享        /*TicketWindowRunnable ticketWindow = new TicketWindowRunnable();*/        // 2. 策略模式思想改造runnable实例线程        Runnable ticketWindow = new BankRunnable().getTicketWindow();        Thread windowThread1 = new Thread(ticketWindow, &quot;一号窗口&quot;);        Thread windowThread2 = new Thread(ticketWindow, &quot;二号窗口&quot;);        Thread windowThread3 = new Thread(ticketWindow, &quot;三号窗口&quot;);        windowThread1.start();        windowThread2.start();        windowThread3.start();    }    private Runnable getTicketWindow() {        return () -&gt; {            while (index &lt;= MAX) {                System.out.println(Thread.currentThread() + &quot; 的号码是:&quot; + (index++));                Thread.sleep(100);            }        };    }}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>106-用Runnable接口将线程的逻辑执行单元从控制中抽取出来</title>
      <link href="/wang-thread/106-runnable-bank-queue/"/>
      <url>/wang-thread/106-runnable-bank-queue/</url>
      
        <content type="html"><![CDATA[<p>课程目标：</p><ul><li><p><strong>让业务数据和线程逻辑分离</strong>。Runnable。@FunctionalInterface</p><p><code>run()</code>方法为线程的逻辑代码块</p></li></ul><ol><li><p>叫号机。继承Runnable接口</p><pre><code class="java">public class TicketWindowRunnable implements Runnable {    private int index = 1;    private static final int MAX = 50;    @Override    public void run() {        while (index &lt;= MAX) {            System.out.println(Thread.currentThread().getName() + &quot; 的号码是：&quot; + (index++));        }    }}</code></pre></li><li><p>银行大厅，柜台，业务处理窗口。</p><pre><code class="java">public class BankRunnable {    public static void main(String[] args) {        TicketWindowRunnable ticketWindow1 = new TicketWindowRunnable();        Thread windowThread1 = new Thread(ticketWindow1, &quot;一号窗口&quot;);        Thread windowThread2 = new Thread(ticketWindow1, &quot;二号窗口&quot;);        Thread windowThread3 = new Thread(ticketWindow1, &quot;三号窗口&quot;);        windowThread1.start();        windowThread2.start();        windowThread3.start();    }}</code></pre></li></ol><p>不管定义多少个线程，业务逻辑的数据实例只有一个，不像Thread类中业务逻辑数据和线程混淆在一起，每一次<code>new Thread()</code>就会新创建一份业务逻辑数据。</p><p>三个线程使用同一份业务数据实例，此时很有可能发生数据安全问题。比如，将MAX=1，可能有以下输出：</p><pre><code>一号窗口 的号码是：1二号窗口 的号码是：2</code></pre><p>想一想Runnable接口与多线程中的哪种设计模式比较接近？</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105-采用多线程方式模拟银行排队叫号</title>
      <link href="/wang-thread/105-thread-bank-queue/"/>
      <url>/wang-thread/105-thread-bank-queue/</url>
      
        <content type="html"><![CDATA[<p>课程目标：</p><ul><li>通过继承Thread类实现线程的创建</li><li>并且知道使用Runnable的必要性，使用它的原因是什么。</li></ul><p>案例：</p><blockquote><p>实现银行排队叫号功能（粗糙版）。银行有多个柜台，当一个人需要去办理业务的时候，先到叫号机上领取一个号码。当银行柜员处理完成当前客户就会使用叫号器呼叫下一位客户到窗口办理业务。</p></blockquote><ol><li><p>叫号机。实现Thread类TicketWindowThread.java</p><pre><code class="java">public class TicketWindowThread extends Thread {    private final String name;    private static final int MAX = 50;    private static int index = 1;    public TicketWindowThread(String name) {        this.name = name;    }    @Override    public void run() {        // 当当前号码数小于最大号码时，进行售票操作        while (index &lt;= MAX) {            System.out.println(&quot;柜台：&quot; + name + &quot;，当前的号码是：&quot; + (index++));        }    }}</code></pre></li><li><p>银行大厅，柜台，业务处理窗口</p><pre><code class="java">/** *  */public class BankThread {    public static void main(String[] args) {        TicketWindowThread ticketWindow1 = new TicketWindowThread(&quot;一号柜台&quot;);        ticketWindow1.start();        TicketWindowThread ticketWindow2 = new TicketWindowThread(&quot;二号柜台&quot;);        ticketWindow2.start();        TicketWindowThread ticketWindow3 = new TicketWindowThread(&quot;三号柜台&quot;);        ticketWindow3.start();    }}</code></pre><p>此时三个线程出现的结果是：每个线程分别执行1-50号，拥有独立的index，并没有达到三个线程共同使用一个index的效果。</p><p>怎们达到共享index变量，使用同一份资源的效果呢？</p><ul><li><p>给index设置为静态变量static。此时变量始终只会实例化一次。</p><p>使用static实现了共享变量的效果，但是static也有一个问题。就是static生命周期较长，伴随JVM的启动，一直到销毁；从类加载就会开始存在，即使是类实例销毁之后也不会销毁，static不是在类中堆栈空间的信息，它有自己独立的一份存储空间。<a href="https://www.cnblogs.com/hf-cherish/p/4970267.html" target="_blank" rel="noopener">java 静态变量生命周期（类生命周期）</a></p></li></ul></li></ol><p>本节通过继承Thread类实现了多线程方式模拟银行排队叫号的粗糙版，接下来将会实现比较友好的银行排队叫号功能，<strong>把业务和线程分离出来</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104-线程生命周期以及start方法源码剖析</title>
      <link href="/wang-thread/104-thread-lifecycle/"/>
      <url>/wang-thread/104-thread-lifecycle/</url>
      
        <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8u9nc9l7qj30y20fewgo.jpg" alt="线程生命周期简图" style="zoom:50%;" /><p>线程生命周期共有6种状态：</p><ol><li><p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</p></li><li><p>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br> 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p></li><li><p>阻塞(BLOCKED)：表示线程阻塞于锁。</p></li><li><p>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p></li><li><p>终止(TERMINATED)：表示该线程已经执行完毕。</p> <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8uagny1khj30w30lf0tx.jpg" alt="线程状态图" style="zoom:80%;" /> <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8uafgd9wbj30sx0eejrw.jpg" alt="线程生命周期" style="zoom:80%;" /></li></ol><p><code>start()</code></p><blockquote><pre><code class="java">public void start()</code></pre><p>Causes this thread to begin execution; the Java Virtual Machine calls the <code>run</code> method of this thread.</p><p>The result is that two threads are running concurrently: the current thread (which returns from the call to the <code>start</code> method) and the other thread (which executes its <code>run</code> method).</p><p><strong>It is never legal to start a thread more than once.</strong> In particular, a thread may not be restarted once it has completed execution.</p></blockquote><ul><li>程序启动会创建两个线程：main主线程、run用户子线程</li><li><code>start()</code>不能被执行两次：IllegalThreadStateException</li></ul><p>不执行<code>start()</code>方法，而直接执行<code>run()</code>方法，此时没有启动线程，只是调用了一个实例方法而已。这是使用了模版方法的技巧。</p><pre><code class="java">Thread t1 = new Thread(&quot;READ-Thread&quot;) {  @Override  public void run() {    println(Thread.currentThread().getName());    readFromDataBase();  }};t1.run();</code></pre><p>此时输出的线程名称为：<code>main</code></p><p>模版方法：</p><p>例：在实际程序中，算法已经基本固定，但是其中有一些逻辑可能是多变的，此时将其抽象出去并让子类去实现。</p><pre><code class="java">public abstract class BaseTemplateMethod {    public static void main(String[] args) {        BaseTemplateMethod t1 = new BaseTemplateMethod() {            @Override            protected void wrapPrint(String message) {                System.out.println(&quot;*&quot; + message + &quot;*&quot;);            }        };        t1.print(&quot;Hello Thread&quot;);        BaseTemplateMethod t2 = new BaseTemplateMethod() {            @Override            protected void wrapPrint(String message) {                System.out.println(&quot;+&quot; + message + &quot;+&quot;);            }        };        t2.print(&quot;Hello Thread&quot;);    }    public final void print(String message) {        System.out.println(&quot;#####################&quot;);        wrapPrint(message);        System.out.println(&quot;#####################&quot;);    }    protected abstract void wrapPrint(String message);}</code></pre><p>注：真正的Template方法需要写成抽象类，并把<code>print()</code>方法写成<code>final</code>方法（必须为<code>final</code>方法），<code>wrapPrint()</code>方法写成抽象方法。</p><p>总结：</p><ol><li>Java应用程序的main函数是一个线程，是被JVM启动的时候调用，线程的名字叫main</li><li>实现一个线程必须创建Thread实例，override重写<code>run()</code>方法，并且调用<code>start()</code>方法</li><li>在JVM启动后，实际上有多个线程，但是至少有一个非守护线程（main线程）</li><li>当你调用一个线程的<code>start()</code>方法的时候，此时至少有两个线程，一个是调用你的线程（main方法），还有一个是执行<code>run()</code>方法的线程</li><li>线程的生命周期分为：New、Runnable、Running、Block、Terminate</li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103-创建并启动线程</title>
      <link href="/wang-thread/103-create-thread/"/>
      <url>/wang-thread/103-create-thread/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * 读数据 */private static void readFromDataBase() {    // read data from database and handle it    try {        println(&quot;Begin read data from db.&quot;);        Thread.sleep(1000 * 5L);        println(&quot;Read data done and start handle it.&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }    println(&quot;The data handle finish and successfully.&quot;);}</code></pre><pre><code class="java">/** * 写数据 */private static void writeDataToFile() {    // write data to file    try {        println(&quot;Begin write data to file.&quot;);        Thread.sleep(1000 * 10L);        println(&quot;Write data done and start handle it.&quot;);    } catch (InterruptedException e) {        e.printStackTrace();    }    println(&quot;The data handle finish and successfully.&quot;);}</code></pre><ol><li><p>顺序执行，而非交替执行</p><pre><code class="java">// 例1readFromDataBase();writeDataToFile();// 例2for (int i = 0; i &lt; 100; i++) {    println(&quot;Task i=&gt;&quot; + i);}for (int j = 0; j &lt; 100; j++) {    println(&quot;Task j=&gt;&quot; + j);}</code></pre></li><li><p>交替执行</p><pre><code class="java">Thread t1 = new Thread(&quot;Custom-Thread&quot;) {    @Override    public void run() {        for (int i = 0; i &lt; 100; i++) {            println(&quot;Task i=&gt;&quot; + i);            try {                Thread.sleep(1000 * 1L);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }};t1.start();for (int j = 0; j &lt; 100; j++) {    println(&quot;Task j=&gt;&quot; + j);}</code></pre><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8u68chvj9j30p00kwgnk.jpg" alt="Custom-Thread线程情况" style="zoom:50%;" /></li><li><p>交替执行读写操作</p><pre><code class="java">new Thread(&quot;READ-Thread&quot;) {    @Override    public void run() {        readFromDataBase();    }}.start();new Thread(&quot;WRITE-Thread&quot;) {    @Override    public void run() {        writeDataToFile();    }}.start();</code></pre></li></ol><ul><li><p>创建线程后不调用<code>start()</code>方法，此时他是一个线程么？</p><p>不是。涉及到线程的生命周期。Thread被new出来之后只是一个Java实例，和其他普通Java实例一模一样。只有<code>.start()</code>启动之后才会变为一个线程，而且启动是立即返回的，不是BLOCKED阻塞。</p></li></ul><p>JDK文档：<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p><p>查看<code>java.lang.Thread</code></p><p>A <em>thread</em> is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</p><p>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon.</p><p>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named <code>main</code> of some designated class).</p><p>There are two ways to create a new thread of execution. One is to declare a class to be a subclass of <code>Thread</code>. This subclass should override the <code>run</code> method of class <code>Thread</code>. An instance of the subclass can then be allocated and started. </p><p>验证启动程序后JVM会自动创建main线程：</p><ol><li><p>编写程序并运行</p><pre><code class="java">public static void main(String[] args) {    try {        Thread.sleep(1000 * 100L);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre></li><li><p>显示当前所有Java进程pid</p><pre><code class="shell">jps</code></pre></li><li><p>基于JMX的可视化监视、管理工具。实时的监控Java程序在运行过程中的内存、CPU、线程的使用情况，并可以对加载的相关类进行分析</p><pre><code class="shell">jconsole &lt;thread_pid&gt;</code></pre><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8u5g8s2ucj30p00kumz4.jpg" a lt="jconsole查看线程" style="zoom:50%;" /></li><li><p>总结：</p><p>JVM启动时：</p><ul><li>非守护线程：<code>main()</code>整个程序的入口。</li><li>守护线程：<code>Finalizer()</code>垃圾回收器、<code>Reference Handler</code>引用具柄、<code>Signal Dispatcher</code>接收系统信号命令、JMX、RMI</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102-简单介绍什么是线程</title>
      <link href="/wang-thread/102-what-is-thread/"/>
      <url>/wang-thread/102-what-is-thread/</url>
      
        <content type="html"><![CDATA[<p>课程大纲：</p><ol><li>线程介绍</li><li>创建并启动线程</li><li>线程的生命周期</li><li>Runnable接口介绍</li><li>Thread API详细介绍</li><li>线程同步，锁技术</li><li>如何优雅的停止线程</li><li>线程间通讯</li><li>线程组详细介绍</li><li>线程池原理以及实现一个简单的线程池</li><li>线程异常捕获以及线程堆栈信息详细讲解</li><li>FIFO队列以及多线程环境下的运行</li><li>BoolenLock锁实现</li><li>常用设计模式在多线程环境下的使用</li><li>查缺补漏</li></ol><p>其他课程：</p><ol><li>PowerMock实战视频（10集）</li><li>Concordion实战视频（10集）</li><li>Apache Sqoop实战视频（12集）</li><li>Apache Flume实战视频（42集）</li><li>Java 8 实战视频（40集）</li><li>Scala实战视频（160集）</li></ol><p>进程-线程-协程</p><p>线程（Thread）是操作系统能够进行运算调度的最小单位，是独立调度和分派的基本单位。它被包含在进程之中，是进程中的实际运作单位。</p><p>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在单个程序中同时运行多个线程完成不同的工作，成为多线程。</p><p>并行：多核操作系统中，一个CPU执行一个线程</p><p>并发：程序同时（时间段非时间点）执行多个线程，有线程上下文切换</p>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101-课程大纲及主要内容介绍</title>
      <link href="/wang-thread/101-syllabus/"/>
      <url>/wang-thread/101-syllabus/</url>
      
        <content type="html"><![CDATA[<ol><li>Java多线程介绍</li><li>多线程编程入门</li><li>线程创建与启动以及线程状态</li><li>Runnable接口详细详解</li><li>线程优先级以及守护线程详解</li><li>线程同步</li><li>线程间通讯</li><li>线程组详解</li><li>自运行对象详解</li><li>线程异常回调</li><li>线程池详解</li><li>等待线程完成任务</li><li>阻塞IO和多线程详解</li><li>如何优雅的结束线程</li><li>自定义线程锁详解</li><li>FIFO队列与线程</li><li>多线程API查漏补缺</li></ol><p>例子：</p><ol><li><p>需求：一个系统去采集其他所有服务器节点的IO、磁盘等连接情况。</p><p>分析：这里不可能去一个一个地采集，应该用到多线程。每一个线程采集一个服务器节点。每一轮采集完成都需要将数据写入到DB数据库。</p><p>总表：批次、采集开始时间，采集结束时间</p><p>详情表：节点ID，CPU、内存、IO、应用进程数等，关联ID</p><p>思考：</p><ul><li><p>多个线程如何得到唯一的采集结束时间？</p></li><li><p>如果服务器节点数目达到100台，那么则需要100个线程？此时系统会因为线程过多出现CPU、内存、系统资源分配不足而崩溃</p><p>始终保持20个线程去执行任务，每当一个线程执行完成任务，则新开启一个任务再去采集其他服务器节点</p></li><li><p>启动主线程如何知道子线程是否调用成功，回调。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100-Java多线程基础知识目录</title>
      <link href="/wang-thread/100-catalog/"/>
      <url>/wang-thread/100-catalog/</url>
      
        <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8szj5cfvoj31600sd11b.jpg" alt="Java并发编程" style="zoom:100%;" /><ol><li>课程大纲及主要内容介绍</li><li>简单介绍什么是线程</li><li>创建并启动线程</li><li>线程生命周期以及start方法源码剖析</li><li>采用多线程方式模拟银行排队叫号</li><li>用Runnable接口将线程的逻辑执行单元从控制中抽取出来</li><li>策略模式在Thread和Runnable中的应用分析</li><li>构造Thread对象你也许不知道的几件事</li><li>多线程与JVM内存结构的关系，虚拟机栈实验</li><li>Thread构造函数StackSize详细讲解</li><li>Thread构造函数StackSize详细讲解-续</li><li>Daemon线程的创建以及使用场景分析</li><li>线程ID，优先级讲解</li><li>Thread的join方法详细介绍，结合一个典型案例</li><li>Thread中断Interrupt方法详细讲解</li><li>采用优雅的方式结束线程生命周期</li><li>Thread API综合实战，编写ThreadService实现暴力结束线程的综合实战</li><li>数据同步的引入与Synchronized的简单介绍</li><li>结合jconsole,jstack以及汇编指令认识synchronized关键字</li><li>同步代码块以及同步方法之间的区别和关系</li><li>通过实验分析This锁的存在</li><li>通过实验分析Class锁的存在</li><li>多线程死锁分析，案例介绍</li><li>线程间通信快速入门，使用wait和notify进行线程间的数据通信</li><li>多Produce多Consume之间的通讯导致出现程序假死的原因分析</li><li>多线程下的生产者消费者模型，以及详细介绍notifyAll方法</li><li>wait和sleep的本质区别是什么，深入分析（面试常见问题）</li><li>线程生产者消费者的综合实战结合Java8语法</li><li>如何实现一个自己的显式锁Lock精讲上</li><li>如何实现一个自己的显式锁Lock精讲下（让锁具备超时功能）</li><li>如何给你的应用程序注入钩子程序，Linux下演示</li><li>如何捕获线程运行期间的异常</li><li>ThreadGroup API介绍之一</li><li>ThreadGroup API介绍之二</li><li>线程池原理与自定义线程池</li><li>自定义个简单的线程池并且测试</li><li>给线程池增加拒绝策略以及停止方法</li><li>给线程池增加自动扩充线程数量，以及闲时自动回收的功能</li><li>课程结束，内容回顾，下季内容预告</li></ol>]]></content>
      
      
      <categories>
          
          <category> 汪文君 </category>
          
          <category> 多线程第一季 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1186-Java并发编程的“基石”——多线程概念初识</title>
      <link href="/imooc/1186-thread-base/"/>
      <url>/imooc/1186-thread-base/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1186" target="_blank" rel="noopener">https://www.imooc.com/learn/1186</a></p><p>简介：并发是程序员永恒的命题。并发易学难精，没有稳扎稳打的第一步，前路坎坷易弃坑。本课程邀请慕课广受好评的《Java并发核心知识体系精讲》课程的悟空老师带领小伙伴构建清晰的理论基石，涵盖线程、进程、多线程、并发、高并发、同步、异步、阻塞、非阻塞等，还有高频面试点拨。一句话：浓缩2小时的高质精品并发入门课，你绝对值得拥有~</p></blockquote><p>@[TOC]</p><h2 id="第1章-踏上Java并发征途"><a href="#第1章-踏上Java并发征途" class="headerlink" title="第1章 踏上Java并发征途"></a>第1章 踏上Java并发征途</h2><blockquote><p>理清本课程学习目的，构建知识脉络，纵览全局。</p></blockquote><h3 id="1-1-序-本课综述-05-11"><a href="#1-1-序-本课综述-05-11" class="headerlink" title="1-1 序-本课综述 (05:11)"></a>1-1 序-本课综述 (05:11)</h3><p>并发编程的“基石”——多线程概念建立</p><p>晦涩难懂的概念：</p><ul><li>线程、进程</li><li>串行、并行、并发</li><li>多线程、高并发</li><li>同步异步、阻塞非阻塞</li></ul><p>问题：</p><ol><li>线程和进程的相同和不同？</li><li>并行和并发有什么区别？</li><li>多线程就是高并发么？相反，高并发就是多线程么？</li><li>同步阻塞和异步非阻塞的关系？</li></ol><h3 id="1-2-从思维导图看并发脉络-08-13"><a href="#1-2-从思维导图看并发脉络-08-13" class="headerlink" title="1-2 从思维导图看并发脉络 (08:13)"></a>1-2 从思维导图看并发脉络 (08:13)</h3><p><a href="https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd" target="_blank" rel="noopener">https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd</a></p><p>附：</p><ul><li><p>并发编程的“基石”——多线程概念建立：</p><p><a href="http://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd" target="_blank" rel="noopener">http://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd</a></p></li><li><p>线程8大核心基础：</p><p><a href="http://naotu.baidu.com/file/07f437ff6bc3fa7939e171b00f133e17" target="_blank" rel="noopener">http://naotu.baidu.com/file/07f437ff6bc3fa7939e171b00f133e17</a></p></li><li><p>Java内存模型——底层原理：</p><p><a href="http://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9" target="_blank" rel="noopener">http://naotu.baidu.com/file/60a0bdcaca7c6b92fcc5f796fe6f6bc9</a></p></li><li><p>死锁——从产生到消除：</p><p><a href="http://naotu.baidu.com/file/ec7748c253f4fc9d88ac1cc1e47814f3" target="_blank" rel="noopener">http://naotu.baidu.com/file/ec7748c253f4fc9d88ac1cc1e47814f3</a> </p></li><li><p>二级大纲（复习用） 成体系的Java并发多线程核心+内存模型+死锁——从用法到原理，面试必考：</p><p><a href="http://naotu.baidu.com/file/29942292cd032adfae23c09783676004" target="_blank" rel="noopener">http://naotu.baidu.com/file/29942292cd032adfae23c09783676004</a></p></li><li><p>并发工具类分类（本导图对应的课程正在录制中，20年上线）：</p><p><a href="http://naotu.baidu.com/file/3902a010470d7c1cf76fe719be124797" target="_blank" rel="noopener">http://naotu.baidu.com/file/3902a010470d7c1cf76fe719be124797</a></p></li></ul><h2 id="第2章-孪生兄弟：进程和线程"><a href="#第2章-孪生兄弟：进程和线程" class="headerlink" title="第2章 孪生兄弟：进程和线程"></a>第2章 孪生兄弟：进程和线程</h2><blockquote><p>用比喻和实操彻底理解进程和线程的联系和不同，并讲解Java语言和多线程的渊源。</p></blockquote><h3 id="2-1-什么是进程？实操案例：用活动监视器看正在运行的各进程-07-24"><a href="#2-1-什么是进程？实操案例：用活动监视器看正在运行的各进程-07-24" class="headerlink" title="2-1 什么是进程？实操案例：用活动监视器看正在运行的各进程 (07:24)"></a>2-1 什么是进程？实操案例：用活动监视器看正在运行的各进程 (07:24)</h3><p>操作系统、进程、线程的包含关系：</p><blockquote><p>操作系统是包含多个进程的容器，而每个进程又都是容纳多个线程的容器</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8s3qksku6j313i0hqtbj.jpg" alt="操作系统、进程、线程的包含关系" style="zoom:30%;" /><p>Oracle文档的官方定义：</p><blockquote><p><a href="https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html" target="_blank" rel="noopener">https://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html</a></p></blockquote><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Process</td><td>The UNIX environment (such as file descriptors, user ID, and so on) created with the <code>fork(2)</code> system call, which is set up to run a program.</td></tr><tr><td>Thread</td><td>A sequence of instructions executed within the context of a process.</td></tr></tbody></table><ul><li>进程：使用fork(2)系统调用创建的UNIX环境（例如文件描述符、用户ID等），它被设置为运行程序。</li><li>线程：在进程上下文中执行的一系列指令</li></ul><p>什么是进程</p><ul><li>进程的英文是Process，指的是程序的一次执行。在用户下达运行程序的命令后，就会产生进程</li></ul><p>活动监视器演示</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8s3zh26atj313x0u0nc4.jpg" alt="活动监视器" style="zoom:40%;" /><p><strong>总结</strong>：进程就是程序(代码)的真正运行实例，<strong>是资源分配的基本单位</strong></p><h3 id="2-2-什么是线程？实操案例：用代码演示线程数量的实时变化-05-05"><a href="#2-2-什么是线程？实操案例：用代码演示线程数量的实时变化-05-05" class="headerlink" title="2-2 什么是线程？实操案例：用代码演示线程数量的实时变化 (05:05)"></a>2-2 什么是线程？实操案例：用代码演示线程数量的实时变化 (05:05)</h3><p>什么是线程</p><ul><li>线程是<strong>CPU的基本调度单位</strong>，每个线程执行的都是进程代码的某个片段</li></ul><p>实例演示：利用活动监视器的CPU栏目查看Java进程的线程数量的变化</p><pre><code class="java">/** * 创建100个线程，用活动监视器的CPU栏目查看Java进程的线程数量的变化，10秒后线程消失了 */public class Create100Threads {    public static void main(String[] args) {        for (int i = 0; i &lt; 100; i++) {            new Thread(new Runnable() {                @Override                public void run() {                    try {                        Thread.sleep(10 * 1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }).start();        }    }}</code></pre><p>用房子作比喻</p><h3 id="2-3-线程和进程有哪6个不同？生活案例：房子与住户-04-58"><a href="#2-3-线程和进程有哪6个不同？生活案例：房子与住户-04-58" class="headerlink" title="2-3 线程和进程有哪6个不同？生活案例：房子与住户 (04:58)"></a>2-3 线程和进程有哪6个不同？生活案例：房子与住户 (04:58)</h3><ol><li>起源不同：先有进程，后有线程</li><li>概念不同：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位；线程是CPU调度单位</li><li>内存共享方式不同：默认情况下，内存无法与其他进程共享；线程共享由操作系统分配给其父进程的相同内存块</li><li>拥有资源不同：进程拥有独立内存，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。<ul><li>线程共享的内容包括：<ol><li><strong>进程代码段</strong></li><li>进程的公有数据(利用这些共享的数据，线程很容易实现相互的通讯)</li><li>进程打开的文件描述符</li><li>信号的处理器</li><li>进程的当前目录</li><li>进程用户ID与进程组ID</li></ol></li><li>线程独有的内容包括：<ol><li>线程ID</li><li>寄存器组的值</li><li><strong>线程的堆栈</strong></li><li>错误返回码</li><li>线程的信号屏蔽码</li></ol></li></ul></li><li>数量不同：一个程序至少有一个进程,一个进程至少有一个线程</li><li>开销不同：<ol><li>线程的创建、终止时间比进程短</li><li>同一进程内的线程切换时间比进程切换短</li><li>同一进程的各个线程间共享文件和文件资源，可以不通过内核进行通信</li></ol></li><li>相似点：生命周期（就绪、等待、运行等状态）</li></ol><h3 id="2-4-Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用-05-42"><a href="#2-4-Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用-05-42" class="headerlink" title="2-4 Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用 (05:42)"></a>2-4 Java和多线程的渊源-代码演示JVM自启动线程，分析它们的作用 (05:42)</h3><ul><li><p>Java天生支持多线程、语言排名高</p></li><li><p>Java线程会一对一映射到操作系统</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tvvmls2pj31ai0lon38.jpg" alt="Java虚拟机与操作系统线程关系图" style="zoom:35%;" /></li></ul><p>JVM自动启动线程：</p><blockquote><p>即使代码中不显示创建线程，在运行main时，JVM也会自动启动其他的线程</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8s60yzc0rj30l80gkmzu.jpg" alt="JVM自动启动线程" style="zoom:50%;" /><ul><li><code>Signal Dispatcher</code>：把操作系统发来的信号分发给适当的处理程序。连接操作系统和应用程序</li><li><code>Finalizer</code>：负责对象的<del>finalize()</del>方法</li><li><code>Reference Handler</code>：和GC、引用相关的线程</li><li><code>main</code>：主线程，用户程序的入口</li></ul><h2 id="第3章-多线程比线程复杂在哪里？"><a href="#第3章-多线程比线程复杂在哪里？" class="headerlink" title="第3章 多线程比线程复杂在哪里？"></a>第3章 多线程比线程复杂在哪里？</h2><blockquote><p>讲解什么是多线程，并讲解需要多线程的原因、局限。</p></blockquote><h3 id="3-1-什么是多线程？生活案例：“合租室友”和“吃火锅”-09-02"><a href="#3-1-什么是多线程？生活案例：“合租室友”和“吃火锅”-09-02" class="headerlink" title="3-1 什么是多线程？生活案例：“合租室友”和“吃火锅” (09:02)"></a>3-1 什么是多线程？生活案例：“合租室友”和“吃火锅” (09:02)</h3><p>多线程的概念</p><blockquote><p>多线程是指在单个进程中运行多个线程。如果一个程序允许允许两个或以上的线程，那么它就是多线程程序。</p></blockquote><p>比喻：</p><ol><li>老友记的比喻<ul><li>客厅：公共空间</li><li>厕所：锁</li><li>独立房间：线程独享空间</li><li>花园浇花：线程合作</li></ul></li><li>火锅的比喻<ul><li>大火锅一个人吃：就是单进程单线程</li><li>大火锅多人吃：就是单进程多线程</li><li>分开吃小火锅：就是多进程多线程</li><li>我吃火锅，别人吃火锅底料：那就是我拥有锁，别人拿不到锁</li></ul></li></ol><p>多线程实例：抢火车票</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t0no9wyrj314q0k243y.jpg" alt="多线程实例：抢火车票" style="zoom:25%;" /><table><thead><tr><th>相互独立的任务</th><th>资源共享的任务</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t0p5x9wsj314q0p2gtl.jpg" style="zoom:25%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t0qiwv02j30xe0tegv5.jpg" style="zoom:25%;" /></td></tr></tbody></table><h3 id="3-2-为什么需要多线程？3大原因-06-54"><a href="#3-2-为什么需要多线程？3大原因-06-54" class="headerlink" title="3-2 为什么需要多线程？3大原因 (06:54)"></a>3-2 为什么需要多线程？3大原因 (06:54)</h3><ol><li><p>最主要的目的就是提高CPU利用率</p><ul><li><p>提高处理速度</p></li><li><p>避免无效等待（IO的时候可以做别的事）</p></li><li><p>提高用户体验：避免卡顿、缩短等待时间</p><ol><li><p>并行处理，提高性能。通常是服务器领域（例如Tomcat），用多个线程去接收进来的HTTP请求，而不是排队等待单一的线程处理</p></li><li><p>在Android开发中，主线程的重要任务之一是绘制屏幕界面，该线程中不允许进行IO操作或网络请求，目的就是避免卡顿，影响用户的交互</p></li></ol></li></ul></li><li><p>便于编程建模</p><p>把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p></li><li><p>计算机性能定律：摩尔定律失效，阿姆达尔定律登上舞台</p><ul><li><p>摩尔定律</p><blockquote><p>当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。</p></blockquote></li><li><p>阿姆达尔定律</p><blockquote><p>一般情况下，处理器越多，程序执行的速度就会越快，但是会有一个上限，上限取决于程序中串行部分的比例，并行的比例越高，多处理器的效果越明显。</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t15hbqmqj310o0twtji.jpg" alt="阿姆达尔定律" style="zoom:40%;" /></li></ul></li></ol><h3 id="3-3-什么场景需要多线程？有哪些局限？-04-07"><a href="#3-3-什么场景需要多线程？有哪些局限？-04-07" class="headerlink" title="3-3 什么场景需要多线程？有哪些局限？ (04:07)"></a>3-3 什么场景需要多线程？有哪些局限？ (04:07)</h3><p>什么场景中会用到多线程?</p><ol><li><p>什么时候需要新开线程</p><p>通常在需要进行耗时任务的时候，例如执行磁盘IO读写，或者从网络获取信息的时候。</p></li><li><p>为了同时做多件不同的事</p><p>开网页同时听音乐</p><p>后台线程：比如执行定时任务quartz</p></li><li><p>为了提高工作效率、处理能力</p><p>tomcat：每次有一个新的请求过来的时候，tomcat会把这个请求交给一个新的线程去处理，。</p><p>多线程后台并行下载文件</p><p>NIO和AIO</p></li><li><p>需要同时有很大并发量的时候</p><p>压测</p></li></ol><p>多线程的局限</p><ol><li><p>性能问题：上下文切换带来的消耗</p></li><li><p>异构化任务（任务结构不一样）很难高效并行</p></li><li><p>带来线程安全问题</p><p>数据安全问题。a++数据错误</p><p>线程带来的活跃性问题。线程饥饿、死锁</p></li></ol><h2 id="第4章-并行和并发傻傻分不清楚？"><a href="#第4章-并行和并发傻傻分不清楚？" class="headerlink" title="第4章 并行和并发傻傻分不清楚？"></a>第4章 并行和并发傻傻分不清楚？</h2><blockquote><p>讲解并行、串行、并发的含义，并说明操作系统、处理器、编程语言的发展使得并发“飞入寻常百姓家”。</p></blockquote><h3 id="4-1-并行和并发傻傻分不清楚？一图胜千言-10-07"><a href="#4-1-并行和并发傻傻分不清楚？一图胜千言-10-07" class="headerlink" title="4-1 并行和并发傻傻分不清楚？一图胜千言 (10:07)"></a>4-1 并行和并发傻傻分不清楚？一图胜千言 (10:07)</h3><p>串行和并行</p><blockquote><p>串行是大家排队一个个来，并行是大家一起来</p></blockquote><p>一图胜千言</p><table><thead><tr><th>线程的串行并行</th><th>通讯的串行并行</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1jyy0nej30z70u048c.jpg" style="zoom:25%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1lt89b4j30se0w2n9q.jpg" style="zoom:25%;" /></td></tr></tbody></table><p>并发和并行</p><p>一图胜千言</p><ul><li><p>并发：同一时刻仅有一个线程</p><p>Concurrency：</p><ol><li>Single Processor</li></ol></li></ul><ol start="2"><li>Logically simultaneous processing</li></ol><ul><li><p>并行：同一时刻可以有多个线程</p><p>Parallelism：</p><ol><li>Multiprocessores,Multicore</li><li>Physically simultaneous processing</li></ol><table><thead><tr><th>并发</th><th>并行</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1ukp6jbj30ta0kqgun.jpg" style="zoom:25%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t1w7tzf6j30t20iyq9i.jpg" style="zoom:25%;" /></td></tr></tbody></table></li></ul><ul><li><p>实例：排队买咖啡</p><ol><li><p>并发（Concurrent），一台咖啡机，两个等待队列</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t22yj3eaj312w08k0zm.jpg" alt="一台咖啡机，两个等待队列" style="zoom:40%;" /></li><li><p>并行（Parallel），两台咖啡机，两个等待队列</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t242hyojj310q08s45z.jpg" alt="两台咖啡机，两个等待队列" style="zoom:40%;" /></li></ol></li></ul><p>并行的概念：</p><blockquote><p>在<strong>同一时刻</strong>，有多个任务同时执行</p></blockquote><ul><li>真正的“同时”运行——在<strong>同一时刻</strong>，有多个任务同时执行</li><li>例如，在多核处理器上，有两个线程同时执行一段代码</li><li>可见，单核处理器是无法实现并行的，因为单核处理器无法在同一时刻执行多个任务</li></ul><p>并发的概念：</p><blockquote><ol><li>两个或多个任务可以在重叠的<strong>时间段内</strong>启动、运行和完成</li><li>对“并发性”的简称</li></ol></blockquote><ol><li><p>形容多个任务的执行状态</p><ul><li><p>两个或多个任务可以在重叠的<strong>时间段内</strong>启动、运行和完成</p></li><li><p>并行(两个线程同时执行)一定是并发，并发不一定是并行</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2gpqwa9j30pa0p2qa7.jpg" alt="并发并行的包含关系" style="zoom:25%;" /></li></ul><table><thead><tr><th>并发<br />Concurrency<br />（Single-Core CPU）</th><th>并行且并发<br />Concurrency+Parallelism<br />（Multi-Core CPU）</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2iw85hij30y80dmq6a.jpg" style="zoom:35%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2m40uzyj30zg0jiwgn.jpg" style="zoom:35%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2ptq9fzj308w0ncmxv.jpg" style="zoom:30%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2qusdalj308w0nq3zy.jpg" style="zoom:30%;" /></td></tr></tbody></table><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8t2wbimw3j319u0u0djb.jpg" alt="并行与并发的关系" style="zoom:30%;" /></li><li><p>程序的不同部分具有可以同时执行的性质</p><ul><li>“并发性”是一种程序的性质。如果一个程序具有并发性，说明这个程序的不同的部分可以无序或同时执行，且不影响最终的执行结果。</li><li>在不同核心数的计算机上的不同表现。此时，并行和并发的概念不在同一维度上</li></ul><p>并发性是并发执行或并行执行的前提条件和必要条件</p></li></ol><h3 id="4-2-并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗-06-56"><a href="#4-2-并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗-06-56" class="headerlink" title="4-2 并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗 (06:56)"></a>4-2 并发的第二种概念——生活场景举例：打游戏时女朋友来电话查岗 (06:56)</h3><ol><li><p>打游戏时，女朋友来电话</p><p>同时打游戏和接电话。并发</p><p>关掉游戏，专心接电话。串行</p></li><li><p>单核CPU</p><p>程序具备并发性，但不并行执行。单核并发程序</p><p>程序具备并发性，且并行执行：多核并发程序</p><p>既不并行执行，也不具备并发性：单核串行程序</p><p>并行执行，但程序不具备并发性：不可能</p></li></ol><h3 id="4-3-是什么让并发和并行成为了可能？-03-48"><a href="#4-3-是什么让并发和并行成为了可能？-03-48" class="headerlink" title="4-3 是什么让并发和并行成为了可能？ (03:48)"></a>4-3 是什么让并发和并行成为了可能？ (03:48)</h3><ul><li><p>操作系统</p></li><li><p>多核CPU</p></li><li><p>编程语言</p></li></ul><h2 id="第5章-高并发只是并发的升级版吗？"><a href="#第5章-高并发只是并发的升级版吗？" class="headerlink" title="第5章 高并发只是并发的升级版吗？"></a>第5章 高并发只是并发的升级版吗？</h2><blockquote><p>用业界场景说明高并发不仅仅是并发的升级版，也不能简单地理解为就是多线程。高并发和多线程相互成就</p></blockquote><h3 id="5-1-什么是高并发？企业案例：双11、春晚-04-21"><a href="#5-1-什么是高并发？企业案例：双11、春晚-04-21" class="headerlink" title="5-1 什么是高并发？企业案例：双11、春晚 (04:21)"></a>5-1 什么是高并发？企业案例：双11、春晚 (04:21)</h3><p>高并发</p><blockquote><p>同时有很多个请求发送给服务器系统，因此服务器就会并行处理</p></blockquote><ul><li><p>双11天猫</p></li><li><p>春晚微信摇一摇</p></li></ul><h3 id="5-2-高并发和多线程的关系？相互成就-04-47"><a href="#5-2-高并发和多线程的关系？相互成就-04-47" class="headerlink" title="5-2 高并发和多线程的关系？相互成就 (04:47)"></a>5-2 高并发和多线程的关系？相互成就 (04:47)</h3><p>多线程和高并发是什么：解决方案、状态</p><p>多线程和高并发的关系：多线程是对应高并发场景的一种解决方案。为了解决高并发带来的问题，如数据错乱、程序访问慢、服务器死机，从而使用多线程编程提高硬件利用率，获取到更多资源。</p><p>高并发并不意味着是多线程：Redis缓存层</p><h3 id="5-3-高并发有哪些重要指标？-03-58"><a href="#5-3-高并发有哪些重要指标？-03-58" class="headerlink" title="5-3 高并发有哪些重要指标？ (03:58)"></a>5-3 高并发有哪些重要指标？ (03:58)</h3><ul><li>QPS（Queries Per Second）：每秒请求数</li><li>带宽：峰值流量和页面的平均大小</li><li>PV（Page View）：24小时的页面浏览量</li><li>UV（Unique Visitor）：独立用户访问量</li><li>吞吐率（Requests per second）</li><li>并发连接数（The number of concurrent connections）：某个时刻服务器接受请求的数目</li><li>服务器平均请求等待时间（Time per request: across all concurrent requests）：服务器处理一个请求需要花费的时间</li></ul><p>IP和UV的区别</p><ul><li>UV是用户cookies数量</li><li>IP与UV数量关系不确定</li></ul><h2 id="第6章-你真的懂同步与异步？阻塞与非阻塞？"><a href="#第6章-你真的懂同步与异步？阻塞与非阻塞？" class="headerlink" title="第6章 你真的懂同步与异步？阻塞与非阻塞？"></a>第6章 你真的懂同步与异步？阻塞与非阻塞？</h2><blockquote><p>把同步异步、阻塞和非阻塞用烧水壶和买书的例子讲解清楚</p></blockquote><h3 id="6-1-一图胜千言：同步、异步是什么含义？-08-47"><a href="#6-1-一图胜千言：同步、异步是什么含义？-08-47" class="headerlink" title="6-1 一图胜千言：同步、异步是什么含义？ (08:47)"></a>6-1 一图胜千言：同步、异步是什么含义？ (08:47)</h3><ul><li>同步与异步：被调用者，调用结束后是否主动返回结果</li><li>阻塞和非阻塞：调用者，调用后是否可以去做别的事</li></ul><p>一图胜千言</p><table><thead><tr><th>Synchronous Execution</th><th>Asynchronous Execution</th></tr></thead><tbody><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ttuwc30pj313s0lyn67.jpg" style="zoom:40%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ttwcrqrvj313o0n6dpx.jpg" style="zoom:40%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu00xrw8j30py0v4n0w.jpg" style="zoom: 30%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu1xfumij30q00v2gqh.jpg" style="zoom:30%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu3zcjy1j30ic0o6418.jpg" style="zoom:40%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu6enri2j30iw0o40vx.jpg" style="zoom: 40%;" /></td></tr><tr><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu7z769oj30m80nw0xl.jpg" style="zoom:40%;" /></td><td><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8tu92dappj30lm0na797.jpg" style="zoom:40%;" /></td></tr></tbody></table><p>同步</p><ul><li><p>同步指的是，客户端发出一个请求后，在没有得到结果之前，服务端就不返回任何结果。但是一旦服务端返回，那返回的就是客户端想要的结果（而不是告诉客户端再等等之类的内容）。</p></li><li><p>被调用者主动告诉调用者结果</p></li><li><p>被调用者（也就是服务器）的行为，而不是请求方的行为。</p></li></ul><p>异步</p><ul><li><p>不实时处理</p></li><li><p>调用在发出之后，服务端会立刻返回，告诉调用方“我收到你的请求了，我会处理的”</p></li><li><p>调用发出后，等服务端计算完毕后，服务端会通过发消息等途径来通知调用者，或通过回调函数处理这个调用。</p></li></ul><p>同步与异步的例子</p><ul><li><p>烧水壶</p><p>同步：盯着水壶</p><p>异步：声音提醒</p></li><li><p>买书，打电话问书店老板</p><p>同步：现场查询</p><p>异步：后续回电</p></li></ul><p>阻塞和非阻塞</p><ul><li><p>我是调用者，我调用一个东西的后，结果返回前，是否还能做别的事</p></li><li><p>站在<strong>线程状态</strong>的角度</p></li><li><p>站在<strong>线程发出请求</strong>(通常是HTTP请求)的角度</p></li></ul><p>阻塞非阻塞的例子</p><ul><li><p>烧水壶</p><p>阻塞：坐在水壶面前不能动</p><p>非阻塞：等的时候去客厅看电视</p></li><li><p>打电话问书店老板</p><p>阻塞式调用：你会一直把自己“挂起”，直到得到这本书有没有的结果；</p><p>非阻塞式调用：你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。</p><p>在这里<strong>阻塞与非阻塞与是否同步异步无关</strong>。<strong>跟老板通过什么方式回答你无关</strong>。</p></li></ul><h3 id="6-2-4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞-05-38"><a href="#6-2-4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞-05-38" class="headerlink" title="6-2 4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 (05:38)"></a>6-2 4种组合：同步阻塞、同步非阻塞、异步阻塞、异步非阻塞 (05:38)</h3><p>同步异步、阻塞非阻塞的综合例子</p><ul><li>同步阻塞：坐在普通水壶前</li><li>同步非阻塞：水烧开之前我们先去客厅看电视了，但是水壶不会主动通知我们，需要我们时不时的去厨房看一下水有没有烧开</li><li>异步阻塞：带有提醒功能的水壶烧水，我们坐着等</li><li>异步非阻塞：带有提醒功能的水壶烧水。在水烧发出提醒之前我们先去客厅看电视了，等水壶发出声音提醒我们。</li></ul><h2 id="第7章-面试问题检验学习成果"><a href="#第7章-面试问题检验学习成果" class="headerlink" title="第7章 面试问题检验学习成果"></a>第7章 面试问题检验学习成果</h2><blockquote><p>面试常见问题，用和本课息息相关的8个常见面试问题来检验同学们的学习收获。</p></blockquote><h3 id="7-1-常见面试问题-04-33"><a href="#7-1-常见面试问题-04-33" class="headerlink" title="7-1 常见面试问题 (04:33)"></a>7-1 常见面试问题 (04:33)</h3><ol><li><p>进程和线程的相同和不同？</p><p>起源不同、概念不同（进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位；线程是CPU调度单位）、内存共享方式不同、拥有资源不同、数量不同、开销不同</p><p>生命周期（就绪、等待、运行等状态）相似</p></li><li><p>并行和并发的异同？</p><p>并发：同一时刻仅有一个线程；</p><p>并行：同一时刻可以有多个线程</p><p>并行(两个线程同时执行)一定是并发，并发不一定是并行</p></li><li><p>高并发是不是就意味着多线程？有什么反例？</p><p>多线程是对应高并发场景的一种解决方案。为了解决高并发带来的问题，如数据错乱、程序访问慢、服务器死机，从而使用多线程编程提高硬件利用率，获取到更多资源，迅速化解高并发带来的压力</p><p>解决高并发不仅只有多线程，比如系统整体架构、Redis缓存层、MQ</p></li><li><p>多线程可以提高程序执行效率，你知不知道有有哪些弊端？</p><ul><li><p>上下文切换带来的消耗</p></li><li><p>异构化任务（任务结构不一样）很难高效并行</p></li><li><p>带来线程安全问题</p><p>数据安全问题。a++数据错误</p><p>线程带来的活跃性问题。线程饥饿、死锁</p></li></ul></li><li><p>什么是同步，什么是异步，什么是阻塞，什么是非阻塞？</p><p>同步与异步：被调用者，调用结束后是否主动返回结果</p><p>阻塞和非阻塞：调用者，调用后是否可以去做别的事</p></li><li><p>在单核CPU上运行多线程程序有意义吗？</p><p>有意义。单CPU多线程，是尽力在压榨CPU的使用率，如果有IO操作，很多线程会休息，如果单线程，那么CPU就休息。如果CPU已经被挤满，那么并不是说在单核CPU上运行多线程程序没有意义，而是说，线程的数量设置不合理，应该减少线程的数量。</p></li></ol><h2 id="第8章-全程回顾"><a href="#第8章-全程回顾" class="headerlink" title="第8章 全程回顾"></a>第8章 全程回顾</h2><blockquote><p>用思维导图进行全课总结，温故知新，更上一层。</p></blockquote><h3 id="8-1-思维导图总结、实战课展望-16-11"><a href="#8-1-思维导图总结、实战课展望-16-11" class="headerlink" title="8-1 思维导图总结、实战课展望 (16:11)"></a>8-1 思维导图总结、实战课展望 (16:11)</h3><p><a href="https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd" target="_blank" rel="noopener">https://naotu.baidu.com/file/b8a70ff9e7f3af1437594b2d0fb4ebfd</a></p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1129-玩转Vim 从放弃到爱不释手</title>
      <link href="/imooc/1129-vim/"/>
      <url>/imooc/1129-vim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1129" target="_blank" rel="noopener">https://www.imooc.com/learn/1129</a></p><p>简介：Vim作为一个强大的编辑器，是很多巨佬的不二之选，但因为其较高的入门学习门槛劝退了很多人。中文的系统教程少之又少，讲vim插件使用的更是屈指可数，本课程从vim最基础的操作和概念开始讲起，带领大家学会使用和配置 vim，安装强大的 vim 插件，真正掌握编辑器之神 vim 的使用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-玩转vim-从放弃到爱不释手"><a href="#第1章-玩转vim-从放弃到爱不释手" class="headerlink" title="第1章 玩转vim 从放弃到爱不释手"></a>第1章 玩转vim 从放弃到爱不释手</h2><blockquote><p>课程导学</p></blockquote><h3 id="1-1-玩转vim-从放弃到爱不释手-课程导学-09-43"><a href="#1-1-玩转vim-从放弃到爱不释手-课程导学-09-43" class="headerlink" title="1-1 玩转vim 从放弃到爱不释手-课程导学 (09:43)"></a>1-1 玩转vim 从放弃到爱不释手-课程导学 (09:43)</h3><p>什么是Vim？</p><blockquote><p>Linux下两大编辑神器之一：Vim</p></blockquote><ul><li>Linux/Unix下使用最多的编辑器</li><li>Vi的改进版</li><li>可能是最难上手的编辑器之一</li></ul><p>为什么要学习Vim？</p><blockquote><p>都21世纪了，为什么还要学习Vim？</p></blockquote><ul><li>只要你用服务器，Vim就是一个必备技能</li><li>后端和运维工程师必须掌握的编辑器，不然服务器上操作很尴尬</li><li>可以纯键盘⌨️编辑，提升编辑效率</li></ul><p>痛点</p><blockquote><p>Vim难上手，学习曲线陡</p></blockquote><ul><li>Vim视频学习资料很少，网上很多博客讲解零散、不够直观</li><li>缺少系统的教程。Vim命令众多，难以学习和记忆</li><li>Vim学习曲线比较陡，需要较长时间才能上手，劝退很多初学者</li></ul><p>课程目的</p><blockquote><p>帮你驯服Vim</p></blockquote><ul><li>了解和掌握Vim中的基本概念</li><li>熟悉Vim基本使用方法，能够做到日常编辑（纯键盘编辑）</li><li>知道如何自定义Vim，安装插件无限扩充Vim的功能</li></ul><p>课程内容</p><blockquote><p>如何学习Vim？Vim经常被诟病难易上手和使用</p></blockquote><ul><li>Vim的概念和基本操作，比如移动和增删改查</li><li>如何配置Vim，编写自己的vimrc文件</li><li>如何安装和使用插件，无限扩充Vim的功能</li></ul><p>受众</p><blockquote><p>哪些人可以从本门课程受益呢？</p></blockquote><ul><li>运维工程师、后端工程师等</li><li>Linux用户</li><li>对Vim感兴趣，想要提升开发效率的开发者,甚至普通用户</li></ul><p>预备知识</p><blockquote><p>不要求掌握Vim的基础知识，但最好使用Linux/Unix系统</p></blockquote><ul><li>熟悉基本的命令行操作（一般Vim多在Linux服务器上使用）</li><li>知道如何安装Vim</li><li>有其他编辑器使用经验。几乎所有流行IDE和编辑器都有Vim扩展</li></ul><p>课程特色</p><blockquote><p>学习Vim非一日之功，得靠肌肉记忆</p></blockquote><ul><li>由浅入深，循序渐进。从基本的概念和操作讲起</li><li>授人以🐟，同时授人以渔。学会了插件自己扩充Vim功能</li><li>大量实践技巧（所有演示均使用按键回显工具，让你看得更明白）</li></ul><h2 id="第2章-初识-Vim，想说爱你不容易"><a href="#第2章-初识-Vim，想说爱你不容易" class="headerlink" title="第2章 初识 Vim，想说爱你不容易"></a>第2章 初识 Vim，想说爱你不容易</h2><blockquote><p>从基础的 Vim 操作讲起，学习 Vim 操作和涉及到的 Vim 概念。</p></blockquote><h3 id="2-1-初识-Vim，想说爱你不容易-11-50"><a href="#2-1-初识-Vim，想说爱你不容易-11-50" class="headerlink" title="2-1 初识 Vim，想说爱你不容易 (11:50)"></a>2-1 初识 Vim，想说爱你不容易 (11:50)</h3><p>下载与安装</p><blockquote><p>作为开发者的你，安装Vim应该很简单</p></blockquote><ul><li>Linux/Unix(Mac)自带Vim，直接终端里输入<code>vim</code>即可进入</li><li>Windows用户可以下载安装Gvim等体验</li><li>建议Windows用户可以尝试使用虚拟机来体验Linux下的Vim</li></ul><p>初识Vim</p><blockquote><p>据说StackOverflow帮助过上百万开发者退出过Vim！</p></blockquote><ul><li><p>输入<code>vim</code>命令进入Vim</p><pre><code>~                              VIM - Vi IMproved                                ~                                                                               ~                               version 8.0.1283                                ~                           by Bram Moolenaar et al.                            ~                 Vim is open source and freely distributable                   ~                                                                               ~                        Become a registered Vim user!                          ~                type  :help register&lt;Enter&gt;   for information                  ~                                                                          ~                type  :q&lt;Enter&gt;               to exit~                type  :help&lt;Enter&gt;  or  &lt;F1&gt;  for on-line help~                type  :help version8&lt;Enter&gt;   for version info</code></pre></li><li><p>进去之后似乎没法输入东西，起始默认进去是普通(normal)模式</p></li><li><p>使用<code>:q</code>可以退出Vim</p></li></ul><p>开始编辑</p><blockquote><p>进入编辑模式就可以像其他编辑器一样编辑了</p></blockquote><ul><li><p>使用<code>i</code>进入编辑模式，开始输入文字</p></li><li><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>insert before character</td></tr><tr><td><code>a</code></td><td>append after character</td></tr><tr><td><code>o</code></td><td>open a line below</td></tr><tr><td><code>I</code></td><td>insert before line</td></tr><tr><td><code>A</code></td><td>append after line</td></tr><tr><td><code>O</code></td><td>open a line above</td></tr></tbody></table></li><li><p>使用<code>Esc</code>又可以回到普通(normal)模式。使用<code>:wq</code>保存退出</p><p>insert -&gt; normal：<code>Esc</code></p></li></ul><p>课后练习</p><blockquote><p>用Vim靠的是肌肉记忆，赶紧自己操作练习一下吧</p></blockquote><ul><li>通过搜索引擎学习如何安装，并在你的操作系统中安装好Vim</li><li>进入Vim，使用<code>i</code>/<code>a</code>/<code>o</code>进入编辑(insert)模式输入文本</li><li>退回到默认的普通(normal)模式，保存并退出Vim</li></ul><h3 id="2-2-Vim，为什么你有这么多模式-09-15"><a href="#2-2-Vim，为什么你有这么多模式-09-15" class="headerlink" title="2-2 Vim，为什么你有这么多模式 (09:15)"></a>2-2 Vim，为什么你有这么多模式 (09:15)</h3><p>“怪异的Vim模式”</p><blockquote><p>Vim和其他很多编辑器的区别在于多种模式</p></blockquote><ul><li><p>进入Vim默认是普通(normal)模式？为什么不是编辑模式呢？</p><p>答：在日常开发中更多的是浏览代码，而不是编辑代码</p></li><li><p>使用<code>i</code>(insert)/<code>a</code>(append)等进入编辑模式</p></li><li><p>还有<code>:cmd</code>命令模式和<code>v</code>(visual)可视化模式</p></li></ul><ol><li>为什么进入Vim不能插入—普通(Normal)模式</li></ol><blockquote><p>奇怪的是，为什么Vim进入之后不能像其他编辑器一样直接插入？</p></blockquote><ul><li>进入Vim默认是普通(normal)模式。使用<code>Esc</code>从插入模式回到普通模式</li><li>普通模式下可以进行各种命令操作和移动</li><li>大部分情况下，你是在浏览而不是编辑。所以Vim默认是普通(normal)模式</li></ul><ol start="2"><li>插入(Insert)模式</li></ol><blockquote><p>插入模式下Vim可以直接编辑，和其他编辑器一样</p></blockquote><ul><li>使用<code>i</code>(insert)/<code>a</code>(append)/<code>o</code>(open a line below)进入插入模式</li><li>使用<code>Esc</code>退出插入模式到普通(normal)模式</li><li>你来试试<code>I</code>/<code>A</code>/<code>O</code>如何进入插入模式的？</li></ul><ol start="3"><li>命令(Command)模式</li></ol><blockquote><p>普通(Normal)模式下输入<code>:</code>之后执行命令，比如保存退出<code>:wq</code>，一气呵成</p></blockquote><ul><li>顾名思义，执行Vim命令。比如保存<code>:w</code>、退出<code>:q</code></li><li>比如分屏：<code>:vs</code>(vertical split)、<code>:sp</code>(split)</li><li>比如使用<code>:% s/java/python/g</code>全局替换，将<code>java</code>替换为<code>python</code></li></ul><ol start="4"><li>可视化(Visual)模式</li></ol><blockquote><p>可视化(Visual)模式一般用来块状选择文本</p></blockquote><ul><li>普通模式下，使用<code>v</code>进入字符选择</li><li>使用<code>V</code>选择行</li><li>使用<code>Ctrl+v</code>进入方块♦️选择</li></ul><p>课后练习</p><blockquote><p>理解和使用Vim常用的4种模式</p></blockquote><ul><li>找一个文件编辑，在插入模式和普通模式之间切换</li><li>使用命令模式替换单词</li><li>尝试使用可视化(Visual)模式，想想它的使用场景是？</li></ul><h3 id="2-3-Vim-插入模式小技巧-08-08"><a href="#2-3-Vim-插入模式小技巧-08-08" class="headerlink" title="2-3 Vim 插入模式小技巧 (08:08)"></a>2-3 Vim 插入模式小技巧 (08:08)</h3><p>如何快速纠错？</p><blockquote><p>代码就像人生，总是经常出错，需要我们快速修正</p></blockquote><ul><li><p>进入Vim之后，首先使用<code>i</code>/<code>a</code>/<code>o</code>进入插入模式</p></li><li><p>尝试抛弃退格键，使用<code>Ctrl</code>快捷键来完成编辑删除工作</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+h</code></td><td>删除上一个字符</td></tr><tr><td><code>Ctrl+w</code></td><td>删除上一个单词</td></tr><tr><td><code>Ctrl+u</code></td><td>删除当前行</td></tr></tbody></table></li><li><p>以上几个快捷键可以用在很多地方，比如<strong><em>终端</em></strong></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl+a</code></td><td>快速移动到开头</td></tr><tr><td><code>Ctrl+e</code></td><td>快速移动到结尾</td></tr><tr><td><code>Ctrl+b</code></td><td>前移动</td></tr><tr><td><code>Ctrl+f</code></td><td>后移动</td></tr></tbody></table></li></ul><p>快速切换普通(Normal)模式和编辑(Insert)模式</p><blockquote><p>很多键盘的键位设置，<code>Esc</code>按起来不方便，不方便切换到普通模式</p></blockquote><ul><li>使用<code>Ctrl+c</code>代替<code>Esc</code>（但是可能会中断某些插件）、<code>Ctrl+[</code></li><li><strong><code>gi</code>快速跳转到最后一次编辑的地方，并进入插入模式</strong></li><li>在配置章节，我们会讲解如何映射方便的快捷键来代替<code>Esc</code></li></ul><p>让键盘适应工具</p><blockquote><p>键盘的选择会影响你的编辑速度</p></blockquote><ul><li>选择<code>Esc</code>和<code>Ctrl</code>比较容易触碰到的键盘</li><li>使用Vim，你可以使用HHKB或者Poker2这种迷你键盘</li><li>使用软件修改键位，比如<code>CapsLock</code>改成频繁使用到的<code>Ctrl</code></li></ul><ul><li><p>码农神器之HHKB—专为Linux下Vim/Emacs设计</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg8zp9kyj31jw0kojwp.jpg" alt="码农神器之HHKB" style="zoom:50%;" /></li><li><p>发烧之选—Poker2</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg90lb5nj31gi0i0dis.jpg" alt="发烧之选---Poker2" style="zoom:50%;" /></li></ul><h3 id="2-4-Vim-快速移动大法-15-11"><a href="#2-4-Vim-快速移动大法-15-11" class="headerlink" title="2-4 Vim 快速移动大法 (15:11)"></a>2-4 Vim 快速移动大法 (15:11)</h3><p>众所周知，vim normal模式使用了反人类的hjkl来移动</p><ul><li>编辑器作者在编写vim的时候，键盘还没流行上下左右按键</li><li>左（<code>h</code>），下（<code>j</code>），上（<code>k</code>），右（<code>l</code>）。移动也不会让手指脱离主键盘区</li><li>逼着自己使用hjkl一段时间之后，便会体会到它非常有效率</li></ul><p>在单词之间「飞舞」</p><blockquote><p>在单词之间移动是我们浏览操作中最常使用的命令</p></blockquote><ul><li><code>w</code>/<code>W</code>移动到下一个word/WORD开头。<code>e</code>/<code>E</code>移动到下一个word/WORD结尾</li><li><code>b</code>/<code>B</code>回到上一个word/WORD开头，可以理解为backword</li><li>word指的是以非空白符分割的单词，WORD指的是以空白符分割的单词</li></ul><p><code>synyax on</code>：打开高亮显示</p><p>行间搜索移动</p><blockquote><p>同一行快速移动的方式其实是：搜索一个字符并且移动到该字符</p></blockquote><ul><li>使用<code>f{char}</code>可以移动到char字符上，<code>t{char}</code>移动到char的前一个字符</li><li>如果第一次没搜到，可以用分号<code>;</code>/逗号<code>,</code>继续搜索该行的下一个/上一个</li><li>大写的<code>F</code>表示反过来搜索前面的字符</li></ul><p>如何快速移动到一行的行首或者行尾呢？</p><ul><li><code>0</code>移动到行首第一个字符，<code>^</code>移动到行首第一个非空白字符</li><li><code>$</code>移动到行尾，<code>_g</code>移动到行尾非空白字符</li><li>记住常用的<code>0</code>和<code>$</code>就可以满足日常需求了。</li></ul><p>Vim垂直移动</p><blockquote><p>在句子（sentence）和段落（paragraph）间移动。（不常用）</p></blockquote><ul><li>使用小括号<code>()</code>在句子间移动，可以使用<code>:help (</code>来查看帮助文档</li><li>使用大括号<code>{}</code>在段落间移动</li><li>插件章节会讲到如何使用easy-motion插件移动，这些命令就都不用记忆了</li></ul><p>Vim页面移动</p><ul><li><code>gg</code>/<code>G</code>移动到文件开头和结尾，可以使用<code>ctrl+o</code>快速返回</li><li><code>H</code>/<code>M</code>/<code>L</code>跳转到屏幕的开头（Head）、中间（Middle）、结尾（Lower）</li><li><code>ctrl+u</code>、<code>ctrl+f</code>上下翻页（upward/forward）。<code>zz</code>把光标当前行置为屏幕中间</li></ul><h3 id="2-5-Vim快速增删改查-13-29"><a href="#2-5-Vim快速增删改查-13-29" class="headerlink" title="2-5 Vim快速增删改查 (13:29)"></a>2-5 Vim快速增删改查 (13:29)</h3><p>Vim增加字符</p><ul><li>进入插入模式编辑文本</li><li><code>a</code>/<code>i</code>/<code>o</code>、<code>A</code>/<code>I</code>/<code>O</code></li></ul><p>Vim快速删除</p><ul><li>Vim在normal模式下使用<code>x</code>快速删除一个字符</li><li>使用<code>d</code>（delete）配合文本对象快速删除一个单词<code>daw</code>（d around word）</li><li><code>d</code>和<code>x</code>都可以搭配数字来执行多次</li></ul><p>Vim快速修改</p><ul><li><p><code>r{char}</code>（replace）、<code>c</code>（change）、<code>s</code>（substitute）</p></li><li><p>normal模式下使用<code>r{char}</code>可以替换一个字符char。<code>s</code>替换并进入插入模式</p><p><code>R</code>进入插入模式，将光标所在的字符直接替换为输入的字符。<code>S</code>删除整行，进入插入模式</p></li><li><p>使用<code>c</code>配合文本对象可以快速进行修改。例如：<code>ciw</code>、<code>caw</code>、<code>ct&quot;</code></p><p><code>C</code>删除整行，进入插入模式（不包含行首的非空白字符）</p></li></ul><p>Vim查询</p><ul><li>使用<code>/</code>或者<code>?</code>进行前向或者反向搜索</li><li>使用<code>n</code>/<code>N</code>跳转到下一个或者上一个匹配</li><li>使用<code>*</code>或者<code>#</code>进行当前光标所在单词的前向或者后向匹配</li></ul><h3 id="2-6-Vim-如何搜索替换-07-15"><a href="#2-6-Vim-如何搜索替换-07-15" class="headerlink" title="2-6 Vim 如何搜索替换 (07:15)"></a>2-6 Vim 如何搜索替换 (07:15)</h3><p>Vim替换命令：</p><blockquote><p>substitute命令允许查找并且替换文本，并且支持正则表达式</p></blockquote><ul><li><code>:[range] s[ubstitute]/{pattern}/{string}/[flags]</code></li><li><code>range</code>表示范围。 比如：<code>10,20</code>表示10-20行，<code>%</code>表示全部</li><li><code>pattern</code>是要替换的模式，<code>string</code>是替换后的文本，<code>flags</code>是替换标志位</li></ul><p>替换标志位</p><ul><li><code>g</code>(flobal)表示全局范围内执行</li><li><code>c</code>(confirm)表示确认，可以确认或者拒绝修改</li><li><code>n</code>(number)报告匹配到的次数而不替换，可以用来查询匹配次数</li></ul><p>例：</p><pre><code class="shell"># 在全局范围内将self替换为this:% s/self/this/g# 在1-6行将self替换为this:1,6 s/self/this/g# 统计1-6行匹配到self的次数:1,6 s/self//n# 利用正则，将quack替换为jiao，而不替换do_quack:% s/\&lt;quack\&gt;/jiao/g</code></pre><p><code>u</code>：撤销操作</p><p><code>Ctrl+r</code>：反向撤销</p><p>课后练习：</p><ul><li>如何批量替换多个文件中的匹配呢？</li><li>延伸：使用插件来批量搜索替换多个文件中的匹配</li></ul><h3 id="2-7-Vim-多文件操作-15-01"><a href="#2-7-Vim-多文件操作-15-01" class="headerlink" title="2-7 Vim 多文件操作 (15:01)"></a>2-7 Vim 多文件操作 (15:01)</h3><p>Buffer Window Tab：</p><ul><li><p>Buffer是指打开的一个文件的内存缓冲区</p></li><li><p>Window是Buffer可视化的分割区域</p></li><li><p>Tab可以组织Window为一个工作区</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg91qg8bj31dh0u0qag.jpg" alt="Buffer Window Tab" style="zoom:40%;" /></li></ul><p>Buffer（缓冲区）</p><ul><li>Vim打开一个文件后会加载文件内容到缓冲区</li><li>之后的修改都是针对内存中的缓冲区，并不会直接保存到文件</li><li>直到执行<code>:w</code>（write）的时候才会把修改的内容写入到文件里</li></ul><p>Buffer切换</p><ul><li>使用<code>:ls</code>会列举出当前缓冲区，然后使用<code>:b n</code>跳转到第n个缓冲区</li><li><code>bpre</code>、<code>bnext</code>、<code>bfirst</code>、<code>blast</code></li><li><code>:b buffer_name</code>、<code>:b filename</code>，<code>tab</code>会自动补全<code>buffer_name</code></li></ul><p><code>:e b.txt</code>：编辑(edit)b.txt</p><p>Window窗口：</p><ul><li>一个缓冲区可以分割成多个窗口，每个窗口也可以打开不同的缓冲区</li><li><code>&lt;Ctrl+w&gt;s</code>水平分割，<code>&lt;Ctrl+w&gt;v</code>垂直分割。或者<code>:sp</code>、<code>:vs</code></li><li>每个窗口可以继续被无限分割（屏幕是否足够大）</li></ul><p>分割窗口示例：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gg933wfnj30vi0lqwfr.jpg" alt="Window分割窗口示例" style="zoom:40%;" /><p>如何切换窗口：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Ctrl+w&gt;w</code></td><td>在窗口间循环切换</td></tr><tr><td><code>&lt;Ctrl+w&gt;h</code></td><td>切换到左边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;j</code></td><td>切换到下边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;k</code></td><td>切换到上边的窗口</td></tr><tr><td><code>&lt;Ctrl+w&gt;l</code></td><td>切换到右边的窗口</td></tr></tbody></table><p><code>&lt;Ctrl+w&gt;L</code>：将当前窗口移动到右边</p><p><code>&lt;Ctrl+w&gt;H</code>：将当前窗口移动到左边</p><p>如何重排窗口？</p><blockquote><p>重排窗口可以改变窗口的大小<code>:h window-resize</code>查看文档</p></blockquote><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>&lt;Ctrl+w&gt;=</code></td><td>使所有窗口等宽、等高</td></tr><tr><td><code>&lt;Ctrl+w&gt;_</code></td><td>最大化活动窗口的高度</td></tr><tr><td>`&lt;Ctrl+w&gt;</td><td>`</td></tr><tr><td><code>[n] &lt;Ctrl+w&gt;_</code></td><td>把活动窗口的高度设为[n]行</td></tr><tr><td>`[n] &lt;Ctrl+w&gt;</td><td>`</td></tr></tbody></table><p>Tab（标签页）将窗口分组</p><blockquote><p>Tab是可以容纳一系列窗口的容器<code>:h tabpage</code></p></blockquote><ul><li>Vim的Tab和其他编辑器有所不同，可以将其想象为Linux的虚拟桌面</li><li>比如一个Tab全用来编辑Python文件，一个Tab全是HTML文件</li><li>相比窗口，Tab一般使用较少，Tab太多管理起来也比较麻烦</li></ul><p>Tab操作</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:tabnew {filename}</code></td><td>在新标签中打开{filename}</td></tr><tr><td><code>:tabe[dit] {filename}</code></td><td>在新标签中打开{filename}</td></tr><tr><td><code>&lt;Ctrl+w&gt;T</code></td><td>把当前窗口移动到一个新标签页</td></tr><tr><td><code>:tabc[lose]</code></td><td>关闭当前标签页及其中的所有窗口</td></tr><tr><td><code>tabo[nly]</code></td><td>只保留活动标签页，关闭其他所有标签页</td></tr></tbody></table><p>Tab切换操作</p><table><thead><tr><th>Ex命令</th><th>普通模式命令</th><th>用途</th></tr></thead><tbody><tr><td><code>:tabn[ext] {N}</code></td><td><code>{N} gt</code></td><td>切换到标签为{N}的标签页</td></tr><tr><td><code>:tabn[ext]</code></td><td><code>gt</code></td><td>切换到下一个标签页</td></tr><tr><td><code>tabp[revious]</code></td><td><code>gT</code></td><td>切换到上一个标签页</td></tr></tbody></table><p><code>:vs c.txt</code>：垂直分割打开c.txt</p><p><code>:tabnew duck.py</code>：在新的标签页打开duck.py</p><p>课后练习</p><ul><li>尝试打开Vim一次操作多个文件</li><li>窗口分割可以非常方便的查看代码，比如查看整个调用链</li><li>延伸：插件篇会配合<code>ctrlp</code>插件和<code>nerdtree</code>快速操作多个文件</li></ul><h3 id="2-8-什么是-Vim-的-text-object-06-49"><a href="#2-8-什么是-Vim-的-text-object-06-49" class="headerlink" title="2-8 什么是 Vim 的 text object (06:49)"></a>2-8 什么是 Vim 的 text object (06:49)</h3><p>Text Object（文本对象）</p><ul><li>Vim里文本也有对象的概念，比如一个单词、一段句子、一个段落</li><li>很多其他编辑器经常只能操作单个字符来修改文本，比较低效</li><li>通过操作文本对象来修改要比只操作单个字符高效</li></ul><p>文本对象操作方式</p><blockquote><p>之前已经使用过文本对象了，比如<code>dw</code>删除一个单词</p></blockquote><ul><li><code>[number] &lt;command&gt; [text object]</code>。次数+命令+文本对象</li><li><code>number</code>表示次数，<code>command</code>表示命令：<code>d</code>(delete)、<code>c</code>(chage)、<code>y</code>(yank)</li><li><code>text object</code>是要操作的文本对象，比如单词<code>w</code>、句子<code>s</code>、段落<code>p</code></li></ul><p><code>iw</code>：表示inner word。<code>viw</code>命令首先<code>v</code>进入选择模式，<code>iw</code>将选中当前单词</p><p><code>aw</code>：表示around word。它不但会选中当前单词，还会包含单词之后的空格</p><p><code>ci&quot;</code>：删除<code>&quot;&quot;</code>中的内容，并进入插入模式。另外还有<code>()</code>、<code>{}</code>、<code>[]</code>等。</p><p>课后练习</p><blockquote><p>摆脱低效的字符操作，使用文本对象提升效率</p></blockquote><ul><li>如何删除一个单词？</li><li>在Vim中尝试使用文本对象快速增、删、改一个单词</li><li>延伸：有些插件扩展了文本对象。比如<code>vim-go</code>可以使用<code>f</code>表示一个函数</li></ul><h3 id="2-9-Vim复制粘贴与寄存器的使用-16-51"><a href="#2-9-Vim复制粘贴与寄存器的使用-16-51" class="headerlink" title="2-9 Vim复制粘贴与寄存器的使用 (16:51)"></a>2-9 Vim复制粘贴与寄存器的使用 (16:51)</h3><p>Normal模式复制粘贴</p><ul><li><p>normal模式下复制粘贴分别使用<code>y</code>(yank)和<code>p</code>(put)，剪贴<code>d</code>和<code>p</code></p></li><li><p>可以使用<code>v</code>(visual)命令选中所要复制的地方，然后使用<code>p</code>粘贴</p></li><li><p>配合文本对象。比如使用<code>viw</code>复制一个单词，<code>yy</code>复制一行</p><p>Vim里的<strong>剪贴</strong>(cut)<strong>复制</strong>(copy)<strong>粘贴</strong>(paste)分别是<strong>delete</strong>/<strong>yank</strong>/<strong>put</strong></p></li></ul><p>Insert模式下的复制粘贴</p><ul><li>和其他文本编辑器一样，使用<code>Ctrl+v</code>或者<code>cmd+v</code>粘贴，但是粘贴代码有个坑</li><li>很多人在<code>.vimrc</code>中设置了<code>autoindent</code>，粘贴Python代码缩进错乱</li><li>这个时候需要在粘贴前后使用<code>:set paste</code>和<code>:set nopaste</code>解决、使用系统剪贴板寄存器<code>:&quot;</code>也可以解决</li></ul><p>什么是Vim的寄存器？</p><ul><li>Vim里操作的是寄存器而不是系统剪贴板。</li><li>默认使用<code>d</code>删除或者<code>y</code>复制的内容都放到了“无名寄存器”</li><li>用<code>x</code>删除一个字符放到无名寄存器，然后<code>p</code>粘贴，可以调换两字符</li></ul><p>深入寄存器（register）</p><blockquote><p>Vim不使用单一剪贴板进行剪贴、复制与粘贴，而是多组寄存器</p></blockquote><ul><li>通过<code>&quot;{register}</code>前缀可以指定寄存器，不指定则默认使用无名寄存器</li><li>比如使用<code>&quot;ayiw</code>复制一个单词到寄存器<code>a</code>中，<code>&quot;bdd</code>删除当前行到寄存器<code>b</code>中</li><li>Vim中，<code>&quot;&quot;</code>表示无名寄存器,缺省使用，<code>&quot;&quot;p</code>其实就等同于<code>p</code>。<code>&quot;+</code>系统剪贴板。</li></ul><p><code>:reg a</code>：查看寄存器<code>a</code></p><p>其他常见寄存器</p><blockquote><p>除了有名寄存器a-Z，Vim中还有一些其他常见寄存器</p></blockquote><ul><li><p>复制专用寄存器<code>&quot;0</code>，使用<code>y</code>复制文本同时会被拷贝到复制寄存器<code>0</code></p></li><li><p>系统剪贴板<code>&quot;+</code>，可以在复制前加上<code>&quot;+</code>复制到系统剪贴板。</p><p>查看是否开启系统剪贴板：<code>:echo has(&#39;clipboard&#39;)</code></p><p>设置<code>:set clipboard=unnamed</code></p></li><li><p>其他寄存器，比如<code>&quot;%</code>当前文件名，<code>&quot;.</code>上次插入的文本</p></li></ul><p><code>:e!</code>：舍弃当前修改并重新加载文本内容</p><p>课后练习</p><blockquote><p>了解normal/insert模式复制粘贴的方法，常见寄存器的用法</p></blockquote><ul><li>找一段Python代码，尝试在Vim里粘贴进入</li><li>试试将Vim中的内容复制到系统粘贴板</li><li>尝试在服务器的Vim里粘贴系统剪贴板的内容</li></ul><h3 id="2-10-Vim-如何用宏完成强大的批量操作-10-23"><a href="#2-10-Vim-如何用宏完成强大的批量操作-10-23" class="headerlink" title="2-10 Vim 如何用宏完成强大的批量操作 (10:23)"></a>2-10 Vim 如何用宏完成强大的批量操作 (10:23)</h3><p>从需求说起</p><blockquote><p>从一个需求说起，给多行URL链接加上双引号</p></blockquote><pre><code>https://www.zhihu.com/question/54919485https://www.zhihu.com/explorehttps://www.zhihu.com/topichttps://www.zhihu.com/topic/19601308https://www.zhihu.com/topic/19607351https://www.zhihu.com/topic/19630716https://www.zhihu.com/topic/19637932https://www.zhihu.com/people/weikexin-67https://www.zhihu.com/questton/267339149/answer/325252706https://www.zhihu.com/question/267339149/answer/523371968https://www.zhihu.com/people/zhang-jia-hao-15https://www.zhihu.com/question/48510028https://www.zhihu.com/question/267339149/answer/323414411https://www.zhihu.com/people/ming-ming 0701https://www.zhihu.com/question/267339149/answer/519709724https://www.zhihu.com/question/answer/519709724https://www.zhihu.com/question/22897152https://www.zhihu.com/question/22130215https://www.zhihu.com/question/19823813</code></pre><p>什么是Vim宏（macro）</p><ul><li>宏可以看成是一系列命令的集合</li><li>可以使用宏「录制」一系列操作，然后用于「回放」</li><li>宏可以非常方便地把一系列命令用在多行文本上</li></ul><p>如何使用宏</p><blockquote><p>宏的使用分为录制和回放，与拍电影类似。</p></blockquote><ul><li>Vim使用<code>q</code>来录制，同时也是使用<code>q</code>结束录制</li><li>使用<code>q{register}</code>选择要保存的寄存器，把录制的命令保存其中</li><li>使用<code>@{register}</code>回放寄存器中保存的一系列命令</li></ul><p>使用宏解决提出的问题</p><ul><li><p>先给一行加上双引号，然后再回放到其他所有行</p></li><li><p>先使用<code>q</code>开始录制，给一行加上双引号，之后使用<code>q</code>退出</p></li><li><p>在剩下所有行中回放录制的宏</p><p>录制：</p><pre><code class="shell">qaI&quot;&lt;Esc&gt;A&quot;&lt;Esc&gt;jq</code></pre><p>调用方式一：</p><pre><code>10@a</code></pre><p>调用方式二：</p><pre><code>VGG:normal @a</code></pre></li></ul><p>课后练习</p><blockquote><p>知道什么是宏，如何使用宏完成日常需求</p></blockquote><ul><li>想象一下编辑代码或者文本什么时候会使用到宏？</li><li>想一下还有没有其他方式来完成这个批量加引号的编辑需求</li><li>尝试亲自操作一下宏命令编辑。</li></ul><h3 id="2-11-Vim-补全大法-07-33"><a href="#2-11-Vim-补全大法-07-33" class="headerlink" title="2-11 Vim 补全大法 (07:33)"></a>2-11 Vim 补全大法 (07:33)</h3><p>什么是补全？</p><blockquote><p>只要手速快，补全什么的都是浮云。</p></blockquote><ul><li>补全是根据当前环境上下文由编辑器「猜」用户想要输入的内容</li><li>比如补全一个单词、文件名，或者代码中的函数名、变量名等</li><li>Vim中提供了多种补全功能，还可以由插件扩展功能实现代码补全</li></ul><p>Vim中常见的补全：</p><table><thead><tr><th>命令</th><th>补全类型</th></tr></thead><tbody><tr><td><code>&lt;C-n&gt;</code></td><td>普通关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-n&gt;</code></td><td><strong>当前缓冲区关键字</strong></td></tr><tr><td><code>&lt;C-x&gt;&lt;C-i&gt;</code></td><td>包含文件关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-]&gt;</code></td><td>标签文件关键字</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-k&gt;</code></td><td>字典查找</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-l&gt;</code></td><td>整行补全</td></tr><tr><td><code>&lt;C-x&gt;&lt;C-f&gt;</code></td><td><strong>文件名补全</strong></td></tr><tr><td><code>&lt;C-x&gt;&lt;C-o&gt;</code></td><td><strong>全能（Omni）补全</strong></td></tr></tbody></table><p><strong>常见的三种补全类型：</strong></p><ul><li><p>使用<code>&lt;Ctrl+n&gt;</code>和<code>&lt;Ctrl+p&gt;</code>补全单词</p><p><code>Ctrl+n</code>：n(next)代表下一个补全的选项</p><p><code>Ctrl+p</code>：p(previous)代表上一个补全的选项</p></li><li><p>使用<code>&lt;Ctrl+x&gt;</code>+<code>&lt;Ctrl+f&gt;</code>补全文件名</p><p><code>Ctrl+w</code>：回删一个单词</p></li><li><p>使用<code>&lt;Ctrl+x&gt;</code>和<code>&lt;Ctrl+o&gt;</code>补全代码，需要开启文件类型检查，安装插件</p><p><code>:filetype on</code>：开启文件类型检查</p><p><code>:set filetype</code>：查看当前文件类型</p></li></ul><p><code>:r! echo %</code>：当前文件名（文件名）。<code>&quot;%p</code>也可输出文件名</p><p><code>:r! echo %:p</code>：当前文件名称（文件路径+文件名）</p><p>For more info：</p><pre><code>:help read:help filename-modifiers</code></pre><p>课后练习：</p><blockquote><p>知道如何在Vim中使用补全，补全的几种常见类型</p></blockquote><ul><li>尝试使用Vim中的补全方式来补全单词</li><li>在Vim中输入文件名的时候尝试补全，想想如何输入现有的文件名？</li><li>延伸：目前补全都是基于文本匹配的，插件可是实现代码补全。</li></ul><h3 id="2-12-给-Vim-换个配色-06-32"><a href="#2-12-给-Vim-换个配色-06-32" class="headerlink" title="2-12 给 Vim 换个配色 (06:32)"></a>2-12 给 Vim 换个配色 (06:32)</h3><p>Vim更换颜色</p><ul><li>使用<code>:colorscheme</code>显示当前的主题配色，默认是<code>default</code></li><li>使用<code>:colorscheme &lt;Ctrl+d&gt;</code>可以显示所有的配色</li><li>有中意的配色后，使用<code>:colorscheme 配色名</code>就可以修改颜色</li></ul><p><code>vim duck.go duck.py -O</code>：打开两个文件并垂直分割。在一个窗口的一个Tab页中</p><p>从网上下载配色</p><blockquote><p>默认的配色没有喜欢的怎们办？</p></blockquote><ul><li><p>从网络上寻找更好看的配色</p></li><li><p><a href="http://github.com/flazz/vim-colorschemes" target="_blank" rel="noopener">http://github.com/flazz/vim-colorschemes</a></p><p><a href="http://github.com/w0ng/vim-hybrid" target="_blank" rel="noopener">http://github.com/w0ng/vim-hybrid</a></p></li><li><p>安装之后就有大量的主题可以更换了</p><pre><code>git clone https://github.com/w0ng/vim-hybrid.gitmkdir -p ~/.vim/colorscp vim-hybrid/colors/hybrid.vim ~/.vim/colors</code></pre></li></ul><p>课后练习</p><ul><li>尝试更改Vim的配色方案，想要持久化配置需要写到<code>.vimrc</code>中</li><li>在网上选一个喜欢的配色方案，下载并使用它，比如<code>hybird</code></li><li>下载多个配色方案到<code>.vim/colors</code>并且随时更换</li></ul><h3 id="2-13-本章小结：裸-Vim-也很强-02-37"><a href="#2-13-本章小结：裸-Vim-也很强-02-37" class="headerlink" title="2-13 本章小结：裸 Vim 也很强 (02:37)"></a>2-13 本章小结：裸 Vim 也很强 (02:37)</h3><p>裸的Vim</p><blockquote><p>本节没使用配置过的Vim，而是用裸的Vim演示，目的何在？</p></blockquote><ul><li>很多初学者Vim基本命令都不熟练就开始找一些复杂的强大配置</li><li>不利于熟悉Vim，一旦出问题了还不知道怎们修复</li><li>建议初学者从裸的Vim开始学习。有些场景，比如服务器或者容器上无法配置Vim</li></ul><p>裸的Vim也很强</p><blockquote><p>学习Vim之前，先用正确打字指法和盲打</p></blockquote><ul><li>编辑代码，脑子🧠一般比手👋快，盲打有利于跟上你的大脑速度</li><li>裸的Vim也有很多强大的功能和使用方式</li><li>学会了使用Vim，可以在任何IDE上安装Vim插件，几乎所有流行的编辑器和IDE工具都支持Vim插件</li></ul><p>下一步该学习什么？</p><blockquote><p>前提是已经无障碍使用Vim，并且没有那么痛苦纠结了。</p></blockquote><ul><li>学习<strong>Vim配置</strong>，我的Vim我做主</li><li>Vim也在与时俱进，探索学习各种炫酷和方便的<strong>插件</strong></li><li>用中学，学中用。慢慢就有了肌肉记忆</li></ul><h2 id="第3章-编写-Vim-配置，我的-Vim-我做主"><a href="#第3章-编写-Vim-配置，我的-Vim-我做主" class="headerlink" title="第3章 编写 Vim 配置，我的 Vim 我做主"></a>第3章 编写 Vim 配置，我的 Vim 我做主</h2><blockquote><p>学习如何编写Vim 的配置文件，自定义 Vim。</p></blockquote><h3 id="3-1-编写-vim-配置，我的-vim-我做主-17-09"><a href="#3-1-编写-vim-配置，我的-vim-我做主-17-09" class="headerlink" title="3-1 编写 vim 配置，我的 vim 我做主 (17:09)"></a>3-1 编写 vim 配置，我的 vim 我做主 (17:09)</h3><p>什么是Vim配置</p><blockquote><p>什么是Vim的配置，为什么要使用它呢？</p></blockquote><ul><li>Vim里有非常多常用的设置，比如<code>:set number</code>设置行号</li><li>之前的使用都是在Vim里临时设置，没法持久化，每次打开文件都需要设置</li><li><code>.vimrc</code>提供了一种持久化配置的方式，让用户自定义配置</li></ul><p>如何编写Vim配置文件</p><ul><li>Linux/Unix下新建一个隐藏文件<code>vim ~/.vimrc</code></li><li>Windows系统<code>vim $MYVIMRC</code>，通过环境变量编辑配置文件</li><li>接着就可以开始自定义配置</li></ul><p>Vim配置都包含什么？</p><ul><li>常用设置。比如：<code>set number</code>设置行号、<code>colorscheme hybrid</code>设置主题</li><li>常用的Vim映射。比如：<code>noremap &lt;leader&gt;w :w&lt;cr&gt;</code>保存文件</li><li>自定义的<code>vimscript</code>函数(vim高手)和插件的配置(插件篇)</li></ul><p>常用设置：</p><ul><li>可以把常用的设置写到<code>.vimrc</code>里，避免每次打开Vim重新设置</li><li>比如设置行号<code>set number</code>、设置主题<code>colorscheme hybrid</code></li><li>Vim里有非常多的配置，可以参考大佬的配置</li></ul><p>Vim中的映射</p><blockquote><p>Vim中的映射比较复杂，源于Vim有多种模式</p></blockquote><ul><li>设置一下<code>&lt;leader&gt;</code>键，<code>let mapleader = &#39;,&#39;</code>，常用的是逗号<code>,</code>或者空格<code>&lt;Space&gt;</code></li><li>比如用<code>inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;</code>在插入模式保存</li><li>Vim中的映射概念稍微复杂，但是非常强大</li></ul><p>Tmux使用<code>Ctrl+B+%</code>实现垂直分割屏幕</p><p>​    <code>zt</code>：将光标所在行定位于屏幕顶部</p><p>​    <code>zz</code>：将光标所在行定位于屏幕中部</p><p>​    <code>jj</code>：映射<code>&lt;Esc&gt;</code>键，退到普通normal模式</p><p>​    <code>:FormatJSON</code>：格式化JSON代码</p><p>​    <code>Ctrl+h/j/k/l</code>：映射<code>&lt;Ctrl-w&gt;+h/j/k/l</code>，光标在分屏窗口中移动</p><p>​    <code>xp</code>：普通模式下，对调字符</p><p>​    <code>:h option-list</code>：查看指令列表</p><p>Vim插件</p><blockquote><p>现代化的Vim可以通过Vim插件管理器安装插件</p></blockquote><ul><li>通过插件用户可以无限扩充Vim的功能</li><li>想要使用插件需要具备一定的Vim配置知识</li></ul><p>Vim脚本</p><blockquote><p>Vim有自己的脚本语言<code>Vimscript</code></p></blockquote><ul><li>Vim脚本对于Vim高级玩家来说可以实现强大的Vim插件</li><li>初学者知道有这个概念就好，Vim脚本是一种简单的脚本语言</li><li>可以通过<code>vimscript</code>实现更多Vim的控制，开发自己的插件</li></ul><p>课后练习</p><blockquote><p>掌握Vim配置需要对Vim本身很熟悉</p></blockquote><ul><li><p>尝试自己建立一个<code>~/.vimrc</code>文件，加入常见的设置选项</p></li><li><p>研究一下GitHub上<code>vim-go</code>教程<code>vim-go-tutoial</code>的<code>.vimrc</code>文件</p><p><a href="https://github.com/fatih/vim-go-tutorial/blob/master/vimrc" target="_blank" rel="noopener">https://github.com/fatih/vim-go-tutorial/blob/master/vimrc</a></p></li><li><p>拿来主义、网上、很多人开源了自己的配置(dotfiles)可参考学习</p><p><strong>通过把<code>.vimrc</code>配置文件放到git版本库可以同步到其他电脑或者服务器上</strong></p></li></ul><p>课程讲师的<code>.vimrc</code>文件：</p><pre><code class="shell">&quot; 常用设置&quot; 设置行号set numbercolorscheme hybrid&quot; 按F2进入粘贴模式set pastetoggle=&lt;F2&gt;&quot; 高亮搜索set hlsearch&quot; 设置折叠方式set foldmethod=indent&quot; 一些方便的映射let mapleader=&#39;,&#39;let g:mapleader=&#39;,&#39;&quot; 使用 jj 进入 normal模式inoremap jj &lt;Esc&gt;`^&quot; 使用 &lt;leader&gt;+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;noremap &lt;leader&gt;w :w&lt;cr&gt;&quot; 切换 buffernnoremap &lt;silent&gt; [p :bprevious&lt;cr&gt;nnoremap &lt;silent&gt; [n :bnext&lt;cr&gt;&quot; use ctrl+h/j/k/l switch windownoremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l&quot; Sudo to writecnoremap w!! w !sudo tee % &gt;/dev/null&quot; json 格式化com! FormatJSON %!python3 -m json.tool&quot; 插件设置，这里使用了 vim-plugcall plug#begin(&#39;~/.vim/plugged&#39;)&quot; 安装插件只需要把 github 地址放到这里重启后执行 :PlugInstall 就好了Plug &#39;mhinz/vim-startify&#39;Plug &#39;scrooloose/nerdtree&#39;call plug#end()&quot; 插件相关配置&quot; 禁止 stratify 自动切换目录let g:startify_change_to_dir = 0&quot; nerdtreenmap ,v :NERDTreeFind&lt;cr&gt;nmap ,g :NERDTreeToggle&lt;cr&gt;&quot; 定义函数SetTitle，自动插入文件头func SetTitle()    if &amp;filetype == &#39;python&#39;        call setline(1, &quot;\#!/usr/bin/env python&quot;)        call setline(2, &quot;\# -*- coding:utf-8 -*-&quot;)        normal G        normal o        normal o        call setline(5, &quot;if __name__ == &#39;__main__&#39;:&quot;)        call setline(6, &quot;    pass&quot;)    endifendfunc</code></pre><h3 id="3-2-Vim-映射迷人眼-14-53"><a href="#3-2-Vim-映射迷人眼-14-53" class="headerlink" title="3-2 Vim 映射迷人眼 (14:53)"></a>3-2 Vim 映射迷人眼 (14:53)</h3><p>什么是Vim映射</p><blockquote><p>Vim映射就是把「一个操作」映射到「另一个操作」</p></blockquote><ul><li>如果你不满意现在的按键设置，比如Vim本来的命令</li><li>或者想要映射一些方便的快捷键</li><li>按照用户意愿定制Vim</li></ul><p>基本映射</p><blockquote><p>基本映射指的是在普通normal模式下的映射，当然还有其他模式的映射</p></blockquote><ul><li><p>使用<code>map</code>就可以实现映射。比如：<code>:map - x</code>按<code>-</code>就会删除字符</p><p>取消<code>map</code>映射使用<code>:unmap -</code></p></li><li><p><strong><code>:map &lt;space&gt; viw</code>按空格键<code>&lt;space&gt;</code>就会选中光标所在的整个单词</strong></p></li><li><p><code>:map &lt;C-d&gt; dd</code>按<code>Ctrl+d</code>执行<code>dd</code>删除一行</p></li></ul><p>模式映射</p><blockquote><p>Vim常用模式normal/visual/insert都可以定义映射</p></blockquote><ul><li><p>用<code>nmap</code>/<code>vmap</code>/<code>imap</code>定义映射,只在normal/visual/insert分别有效</p></li><li><p><code>:vmap \ U</code>：把在visual模式下选中的文本大小写(u(小写)/U(大写)转化大小写)</p></li><li><p>想想如何在insert模式下映射<code>Ctrl+d</code>来删除一行</p><p><code>:imap &lt;C-d&gt; &lt;Esc&gt;ddi</code></p></li></ul><p><strong>现有映射的问题？</strong></p><blockquote><pre><code>:nmap - dd:nmap \ -</code></pre><p>当按下<code>\</code>时，Vim会解析<code>\</code>为<code>-</code>；因为又映射了<code>-</code>，Vim会继续解析<code>-</code>为<code>dd</code>，即最终按下<code>\</code>会删除整行。（类似于递归解析映射）</p></blockquote><p>递归映射和非递归映射</p><blockquote><p><strong><code>*map</code>系列命令有递归的风险</strong></p></blockquote><ul><li>如果用户安装了一个插件，插件映射了同一个按键的不同行为，有冲突就会有一个失效</li><li>想要保证插件映射没有冲突会非常痛苦</li><li>解决方案就是使用非递归映射</li></ul><p>非递归映射</p><blockquote><p>Vim提供了非递归映射，这些命令不会递归解析</p></blockquote><ul><li>使用<code>*map</code>对应的<code>nnoremap</code>/<code>vnoremap</code>/<code>inoremap</code></li><li>何时使用递归映射<code>*map</code>？何时使用非递归映射<code>*noremap</code>呢？</li><li>「任何」时候都应该使用非递归映射，拯救自己同时也拯救了插件作者</li></ul><p><strong>``^<code>：光标回到最后一次插入模式停止时光标的位置。</code>:help <code>^</code>查看帮助。</strong></p><p>课后练习</p><ul><li><p>尝试在<code>.vimrc</code>文件中定义一些映射，提升工作效率</p></li><li><p>参考一些开源的Vim配置，看看哪些映射可以拿来使用</p></li><li><p>阅读《笨方法学Vimscript》书中关于映射的章节。</p><p><a href="http://learnvimscriptthehardway.onefloweroneworld.com/" target="_blank" rel="noopener">http://learnvimscriptthehardway.onefloweroneworld.com/</a></p></li></ul><h3 id="3-3-本章小结：配置-Vim，让她更顺手-01-16"><a href="#3-3-本章小结：配置-Vim，让她更顺手-01-16" class="headerlink" title="3-3 本章小结：配置 Vim，让她更顺手 (01:16)"></a>3-3 本章小结：配置 Vim，让她更顺手 (01:16)</h3><p>学习和使用配置</p><blockquote><p>学习和使用Vim配置是Vim玩家进阶的必修之路</p></blockquote><ul><li>了解常见的配置选项</li><li>学习和使用Vim映射，用得不爽我就改</li><li>Vim进阶需要学习Vimscript。《笨发放学Vimscript》</li></ul><p>下一步该学什么？</p><blockquote><p>强大的Vim插件</p></blockquote><ul><li>Vim也在与时俱进，发布了Vim8，还有Neovim</li><li>知道如何配置Vim之后，开始探索各种强大的Vim插件</li><li>打好<strong>Vim配置</strong>和<strong>映射</strong>的基础，开始学习如何安装和使用插件</li></ul><h2 id="第4章-Vim-安装和使用插件"><a href="#第4章-Vim-安装和使用插件" class="headerlink" title="第4章 Vim 安装和使用插件"></a>第4章 Vim 安装和使用插件</h2><blockquote><p>学会如何安装和使用常见的 Vim 插件，增强 Vim 的功能。</p></blockquote><h3 id="4-1-Vim-安装插件，竟如此简单-08-40"><a href="#4-1-Vim-安装插件，竟如此简单-08-40" class="headerlink" title="4-1 Vim 安装插件，竟如此简单 (08:40)"></a>4-1 Vim 安装插件，竟如此简单 (08:40)</h3><p>什么是插件？</p><blockquote><p>和其他现代流行编辑器一样，Vim同样支持强大的插件扩展</p></blockquote><ul><li>Vim插件是使用vimscript或者其他语言编写的vim功能扩展</li><li>编辑器自带的功能有限，有了插件之后几乎可以无限扩充其功能</li><li>网络上比如GitHub.com等有很多开源的Vim插件可以使用</li></ul><p>如何安装插件？</p><blockquote><p>原始的方式是直接clone插件代码，如今Vim有很多插件管理器</p></blockquote><ul><li><p>目前Vim有很多插件管理器可供选择</p></li><li><p>常见的有：<code>vim-plug</code>、<code>Vundle</code>、<code>Pathogen</code>、<code>Dein.Vim</code>、<code>volt</code>等</p></li><li><p>综合性能、易用性、文档等几个方面，推荐使用<code>vim-plug</code></p><p><a href="https://www.slant.co/topics/1224/~best-plugin-managers-for-vim" target="_blank" rel="noopener">https://www.slant.co/topics/1224/~best-plugin-managers-for-vim</a></p></li></ul><p>使用<code>vim-plug</code>安装插件</p><ul><li><p><a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">https://github.com/junegunn/vim-plug</a></p></li><li><p>学习一个新东西的最好方式就是看官方文档</p></li><li><p>按照官方的教程，就可以非常容易地了解它的使用方式</p><pre><code class="shell">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre></li></ul><p>安装第一个插件<code>vim-startify</code></p><blockquote><p>一个好用的vim开屏插件</p></blockquote><ul><li><p><a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">https://github.com/mhinz/vim-startify</a></p></li><li><p>修改<code>.vimrc</code>配置文件，增加该插件的名称</p></li><li><p>重新启动vim或者执行<code>:source ~/.vimrc</code>，执行<code>:PlugInstall</code></p><pre><code class="shell">call plug#begin(&#39;~/.vim/plugged&#39;)Plug &#39;mhinz/vim-startify&#39;call plug#end()</code></pre><p><code>:source ~/.vimrc</code></p><p><code>:PlugInstall</code></p></li><li><p>如果已经安装完成，退出并重新打开Vim查看效果</p></li></ul><p>课后练习</p><blockquote><p>打开Vim操练起来，首先下载vim-plug并浏览其文档</p></blockquote><ul><li>安装vim-plug插件管理器</li><li>安装vim插件vim-startify、nerdtree，看看能否生效</li></ul><h3 id="4-2-如何寻找自己需要的插件-06-42"><a href="#4-2-如何寻找自己需要的插件-06-42" class="headerlink" title="4-2 如何寻找自己需要的插件 (06:42)"></a>4-2 如何寻找自己需要的插件 (06:42)</h3><ul><li><p>Google关键词搜索</p></li><li><p><a href="https://github.com/vim-awesome/vim-awesome" target="_blank" rel="noopener">https://github.com/vim-awesome/vim-awesome</a></p><p><a href="https://vimawesome.com/" target="_blank" rel="noopener">https://vimawesome.com/</a></p></li><li><p>浏览网上开源的vim配置，借鉴想要的插件</p></li></ul><h3 id="4-3-vim美化插件，让你的-vim-与众不同-09-57"><a href="#4-3-vim美化插件，让你的-vim-与众不同-09-57" class="headerlink" title="4-3 vim美化插件，让你的 vim 与众不同 (09:57)"></a>4-3 vim美化插件，让你的 vim 与众不同 (09:57)</h3><p>vim美化插件</p><blockquote><p>更改vim的外观</p></blockquote><ul><li><p>修改启动界面：<a href="https://github.com/mhinz/vim-startify" target="_blank" rel="noopener">https://github.com/mhinz/vim-startify</a></p><p><code>:Startify</code></p></li><li><p>状态栏美化：<a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener">https://github.com/vim-airline/vim-airline</a></p><p><a href="https://github.com/vim-airline/vim-airline-themes" target="_blank" rel="noopener">https://github.com/vim-airline/vim-airline-themes</a></p></li><li><p>增加代码缩进线条：<a href="https://github.com/Yggdroot/indentLine" target="_blank" rel="noopener">https://github.com/Yggdroot/indentLine</a></p></li></ul><p>vim配色方案</p><ul><li>vim-hybrid配色：<a href="https://github.com/w0ng/vim-hybrid" target="_blank" rel="noopener">https://github.com/w0ng/vim-hybrid</a></li><li>solarized配色：<a href="https://github.com/altercation/vim-colors-solarized" target="_blank" rel="noopener">https://github.com/altercation/vim-colors-solarized</a></li><li>gruvbox配色：<a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener">https://github.com/morhetz/gruvbox</a></li></ul><p>课后练习</p><ul><li>尝试使用vim-stratify快速打开最近使用的文件</li><li>安装vim-airline美化状态栏</li><li>安装indentline给vim增加代码缩进线</li></ul><h3 id="4-4-Vim文件目录和搜索插件，跳转文件so-easy-12-20"><a href="#4-4-Vim文件目录和搜索插件，跳转文件so-easy-12-20" class="headerlink" title="4-4 Vim文件目录和搜索插件，跳转文件so easy (12:20)"></a>4-4 Vim文件目录和搜索插件，跳转文件so easy (12:20)</h3><p><strong>文件目录树</strong>：</p><blockquote><p>默认的文件目录管理比较简陋，nerdtree弥补了这个问题</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gj3vo85oj311w0o87le.jpg" alt="文件目录树" style="zoom:45%;" /><p>文件管理器nerdtree</p><blockquote><p>使用nerdtree插件进行文件目录树管理</p></blockquote><ul><li><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">https://github.com/scrooloose/nerdtree</a></p><p><code>:NERDTree</code></p><p><code>:NERDTreeFind</code></p><p><code>:NERDTreeToggle</code></p></li><li><p><code>autocmd vimenter * NERDTree</code>可以在启动vim的时候打开NERDTree‘</p></li><li><p><code>map &lt;leader&gt;v :NERDTreeFind&lt;CR&gt;</code>查找文件位置</p></li></ul><p><strong>快速搜索文件</strong>：</p><blockquote><p>如何根据文件名快速查找打开一个文件</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gk4xgm5mj316e0m0137.jpg" alt="快速搜索文件" style="zoom:45%;" /><p>模糊搜索器</p><blockquote><p>使用ctrlp插件快速查找并且打开文件</p></blockquote><ul><li><a href="https://github.com/ctrlpvim/ctrlp.vim" target="_blank" rel="noopener">https://github.com/ctrlpvim/ctrlp.vim</a></li><li><code>let g:ctrlp_map = &#39;&lt;c-p&gt;&#39;</code></li><li>使用<Ctrl-p>，然后输入少量字符就可以开始搜索</li></ul><p>课后练习</p><blockquote><p>快速定位文件是常用操作，需牢牢掌握提升效率</p></blockquote><ul><li>安装nerdtree插件，加入快捷键映射</li><li>安装ctrlp插件，然后使用快速定位文件</li><li>改变自己之前低效的操作方式，适应新的操作方式</li></ul><h3 id="4-5-Vim快速定位插件，文件位置任我行-05-58"><a href="#4-5-Vim快速定位插件，文件位置任我行-05-58" class="headerlink" title="4-5 Vim快速定位插件，文件位置任我行 (05:58)"></a>4-5 Vim快速定位插件，文件位置任我行 (05:58)</h3><p>Vim移动命令：</p><blockquote><p>在基础篇学习了很多Vim移动的命令</p></blockquote><ul><li>比如，<code>w</code>/<code>e</code>基于单词移动，<code>gg</code>/<code>G</code>文件首尾，<code>0</code>/<code>$</code>行首尾，<code>f{char}</code>查询字符</li><li><code>Ctrl+f</code>、<code>Ctrl+u</code>前后翻屏</li><li>如果需要快速跳转到当前窗口显示区的任意位置需要怎们做？</li></ul><p>如何快速移动到任意位置</p><blockquote><p>可以使用vim的搜索/加上n跳转，但是使用easymotion更方便</p></blockquote><ul><li><a href="https://github.com/easymotion/vim-easymotion" target="_blank" rel="noopener">https://github.com/easymotion/vim-easymotion</a></li><li>官方文档较长，其实一个映射就能应付</li><li><code>nmap ss &lt;Plug&gt;(easymotion-s2)</code></li></ul><p>课后练习</p><blockquote><p>安装并使用easymotion插件</p></blockquote><ul><li>回忆一下vim里常用的移动操作</li><li>安装easymotion插件</li><li>使用easymotion练习在文件窗口的任意位置跳转</li></ul><h3 id="4-6-Vim-surround，编辑也要成双成对-05-27"><a href="#4-6-Vim-surround，编辑也要成双成对-05-27" class="headerlink" title="4-6 Vim-surround，编辑也要成双成对 (05:27)"></a>4-6 Vim-surround，编辑也要成双成对 (05:27)</h3><p>vim-surround</p><blockquote><p> 如何快速更换一对单引号为双引号?</p></blockquote><ul><li><p>一个一个查找然后替换</p></li><li><p><a href="https://github.com/tpope/vim-surround" target="_blank" rel="noopener">https://github.com/tpope/vim-surround</a></p></li></ul><p>vim-surround使用</p><blockquote><p>normal模式下增加、删除、修改成对内容</p></blockquote><ul><li><code>ds</code>（delete a surrounding）</li><li><code>cs</code>（change a surrounding）</li><li><code>ys</code>（you add a surrounding）</li></ul><p>例子：</p><ul><li><code>ysiw&quot;</code>：给单词增加<code>&quot;</code></li><li><code>cs&quot;&#39;</code>：修改<code>&quot;</code>为<code>&#39;</code></li><li><code>cs(]</code>：修改<code>(</code>为<code>]</code>，替换后的括号需要使用后括号，前括号会产生空格</li><li><code>ds&#39;</code>：删除<code>&#39;</code></li><li><code>ds(</code>：删除<code>(</code></li></ul><p>课后练习</p><blockquote><p>vim-surround大法好</p></blockquote><ul><li>使用vim-plug安装vim-surround插件</li><li>使用练习修改成对的内容，比如修改单引号为双引号</li><li>多练习几次，使用插件提升编辑效率</li></ul><h3 id="4-7-强大的Vim模糊搜索与替换插件-08-26"><a href="#4-7-强大的Vim模糊搜索与替换插件-08-26" class="headerlink" title="4-7 强大的Vim模糊搜索与替换插件 (08:26)"></a>4-7 强大的Vim模糊搜索与替换插件 (08:26)</h3><p>模糊搜索</p><blockquote><p>经常需要在一个代码项目中模糊搜索一些文本，怎们办？</p></blockquote><ul><li>vim自带的搜索可以搜索当前文件，但是项目有很多个文件</li><li>需要使用插件来模糊搜索多个文件内容</li><li>使用Ag.vim或者fzf.vim，都可以很好的支持模糊搜索</li></ul><p>fzf与fzf.vim</p><blockquote><p>fzf是一个强大的命令行模糊搜索工具，fzf.vim集成到了vim里</p></blockquote><ul><li><p><a href="https://github.com/junegunn/fzf.vim" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim</a></p></li><li><p>安装</p><pre><code class="shell">Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;</code></pre></li><li><p>使用<code>Ag [PATTERN]</code>模糊搜索字符串</p></li><li><p>使用<code>Files [PATH]</code>模糊搜索目录</p></li><li><p>更多命令：<a href="https://github.com/junegunn/fzf.vim#commands" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim#commands</a></p></li></ul><p>例子：</p><p><code>:Files .</code>：查看当前目录下的所有文件，再输入文件名实现搜索</p><p><code>:Ag {PATTERN}</code>：查找文本内容。</p><p>此处遇到了一个问题：ag is not found</p><p>解决方法参考：<a href="https://github.com/junegunn/fzf.vim/issues/440" target="_blank" rel="noopener">https://github.com/junegunn/fzf.vim/issues/440</a></p><p>搜索替换插件far.vim</p><blockquote><p>如果想要批量搜索替换，可以使用far.vim</p></blockquote><ul><li><p><a href="https://github.com/brooth/far.vim" target="_blank" rel="noopener">https://github.com/brooth/far.vim</a></p></li><li><p>使用</p><pre><code class="shell">:Far foo bar **/*.py:Fardo</code></pre></li><li><p>比如在代码重构的时候会经常使用到</p></li><li><p><code>:Far foo bar **/*.py</code></p></li></ul><p>课后练习</p><blockquote><p>模糊搜索和替换是一个非常常用的操作</p></blockquote><ul><li>使用vim-plug安装fzf.vim和far.vim</li><li>使用fzf.vim在一个项目中搜索想要的文本</li><li>使用far.vim批量替换一个项目下的文本</li></ul><h3 id="4-8-愉快写-golang-之vim-go插件-10-19"><a href="#4-8-愉快写-golang-之vim-go插件-10-19" class="headerlink" title="4-8 愉快写 golang 之vim-go插件 (10:19)"></a>4-8 愉快写 golang 之vim-go插件 (10:19)</h3><p>编辑器 VS IDE</p><blockquote><p>IDE一代又一代，经典的编辑器却长久不衰</p></blockquote><ul><li>除了Java，很多人用vim编写shell/php/golang/python/ruby</li><li>前端很多人使用VSCode，sublime/Atom有没落之势</li><li>很多后端和运维工程师使用vim，微信后台和阿里飞天系统很多代码出自在服务器上使用vim的工程师</li></ul><p>vim-go</p><blockquote><p>功能强大的golang插件vim-go</p></blockquote><ul><li><p><a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">https://github.com/fatih/vim-go</a></p></li><li><p>代码补全、重构、跳转、自动格式化、自动导入等功能</p></li><li><p>基本可以满足golang日常开发</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;Ctrl-x&gt;&lt;Ctrl-o&gt;</code></td><td>打开补全列表</td></tr><tr><td><code>&lt;Ctrl-p&gt;</code></td><td>向上选择补全</td></tr><tr><td><code>&lt;Ctrl-n&gt;</code></td><td>向下选择补全</td></tr><tr><td><code>&lt;Ctrl-]&gt;</code></td><td>跳转到定义的方法</td></tr><tr><td><code>&lt;Ctrl-o&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-i&gt;</code></td><td>跳转到上一次的地方</td></tr></tbody></table><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:GoFmt</code></td><td>格式化代码</td></tr><tr><td><code>:GoRename</code></td><td>重构名称</td></tr><tr><td><code>:GoImports</code></td><td>自动带入包</td></tr><tr><td><code>:GoRun</code></td><td>运行代码</td></tr><tr><td><code>:w</code></td><td>保存文件自动格式化代码</td></tr></tbody></table></li><li><p>vimrc配置：</p><pre><code class="shell">autocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4</code></pre></li></ul><p>课后练习</p><ul><li>安装vim-go插件，阅读vim-go-tutorial教程</li><li>使用vim-go编写Go语言代码</li><li>如果遇到了问题，请查看vim-go-tutorial教程或者vim-go文档</li></ul><h3 id="4-9-python-mode把-vim-打造成轻量-Python-IDE-07-11"><a href="#4-9-python-mode把-vim-打造成轻量-Python-IDE-07-11" class="headerlink" title="4-9 python-mode把 vim 打造成轻量 Python IDE (07:11)"></a>4-9 python-mode把 vim 打造成轻量 Python IDE (07:11)</h3><p>Python-mode</p><blockquote><p>Python插件使用比较多的是jedi-vim和Python-mode</p></blockquote><ul><li><a href="https://github.com/python-mode/python-mode" target="_blank" rel="noopener">https://github.com/python-mode/python-mode</a></li><li>Python-mode具备基本的补全、跳转、重构、格式化功能</li><li>即使是在服务器上也能方便的调试Python代码</li></ul><ul><li><p>查看是否支持python：<code>vim --version | grep python</code>：</p></li><li><p>vimrc配置</p><pre><code class="shell">let g:pymode_python = &#39;python3&#39;let g:pymode_trim_whitespaces = 1let g:pymode_doc = 1let g:pymode_doc_bind = &#39;K&#39;let g:pymode_rope_goto_definition_bind = &#39;&lt;C-]&gt;&#39;let g:pymode_lint = 1let g:pymode_lint_checkers = [&#39;pyflakes&#39;, &#39;pep8&#39;, &#39;mccabe&#39;, &#39;pylint&#39;]let g:pymode_options_max_line_length = 120</code></pre></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;Ctrl-x&gt;&lt;Ctrl-o&gt;</code></td><td>打开补全列表</td></tr><tr><td><code>&lt;Ctrl-p&gt;</code></td><td>向上选择补全</td></tr><tr><td><code>&lt;Ctrl-n&gt;</code></td><td>向下选择补全</td></tr><tr><td><code>&lt;Ctrl-]&gt;</code></td><td>跳转到定义的方法</td></tr><tr><td><code>&lt;Ctrl-o&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-i&gt;</code></td><td>跳转到上一次的地方</td></tr><tr><td><code>&lt;Ctrl-C&gt;ro</code></td><td>整理导入包的顺序</td></tr></tbody></table><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:PymodeLintAuto</code></td><td>自动Lint整理格式代码</td></tr><tr><td><code>:w</code></td><td>保存文件时做文件静态检查，并提示相应错误</td></tr></tbody></table><p>课后练习：</p><ul><li>安装python-mode插件</li><li>使用python-mode编写Python代码</li><li>如果遇到了问题，尝试查询python-mode文档解决</li></ul><h3 id="4-10-Vim-tagbar，更愉快地浏览代码-11-14"><a href="#4-10-Vim-tagbar，更愉快地浏览代码-11-14" class="headerlink" title="4-10 Vim tagbar，更愉快地浏览代码 (11:14)"></a>4-10 Vim tagbar，更愉快地浏览代码 (11:14)</h3><p>tagbar</p><blockquote><p>代码大纲，支持多种编程语言</p></blockquote><ul><li><p><a href="https://github.com/majutsushi/tagbar" target="_blank" rel="noopener">https://github.com/majutsushi/tagbar</a></p></li><li><p>需要安装Universal Ctags生成对应的tag文件</p></li><li><p>快速浏览当前文件代码结构，并且搜索跳转到对应代码块</p></li><li><p>vimrc配置</p><pre><code class="shell">nnoremap &lt;leader&gt;t :TagbarToggle&lt;CR&gt;</code></pre></li></ul><p>安装ctags：</p><ul><li><p>Universal Ctags：<a href="https://ctags.io/" target="_blank" rel="noopener">https://ctags.io/</a></p></li><li><p><a href="https://docs.ctags.io/en/latest/osx.html#building-with-homebrew" target="_blank" rel="noopener">https://docs.ctags.io/en/latest/osx.html#building-with-homebrew</a></p><pre><code class="shell">brew tap universal-ctags/universal-ctagsbrew install --HEAD universal-ctags</code></pre></li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>:Tagbar</code></td><td>显示Tagbar</td></tr><tr><td><code>:TagbarToggle</code></td><td>显示Tagbar并定位到当前方法的目录</td></tr><tr><td><code>:ls</code></td><td>查看buffer</td></tr><tr><td><code>:b duck.py</code></td><td>跳转到duck.py的buffer</td></tr></tbody></table><p>vim-interestingwords</p><blockquote><p>高亮感兴趣的单词，浏览代码很有用</p></blockquote><ul><li><a href="https://github.com/lfv89/vim-interestingwords" target="_blank" rel="noopener">https://github.com/lfv89/vim-interestingwords</a></li><li>浏览代码的时候经常需要知道一个变量的使用方式</li><li>可以使用这个插件同时高亮多个单词</li></ul><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;leader&gt;k</code></td><td>高亮单词</td></tr><tr><td><code>u</code>/<code>U</code></td><td>下/上一个高亮</td></tr><tr><td><code>&lt;leader&gt;K</code></td><td>取消所有高亮</td></tr></tbody></table><p>课后练习</p><ul><li>安装tagbar，开启文件代码大纲</li><li>安装interestingwords，高亮感兴趣的单词</li><li>如果遇到了问题，尝试查询插件的官方文档/Google搜索/vim help解决</li></ul><h3 id="4-11-强大的-vim-代码补全插件-07-16"><a href="#4-11-强大的-vim-代码补全插件-07-16" class="headerlink" title="4-11 强大的 vim 代码补全插件 (07:16)"></a>4-11 强大的 vim 代码补全插件 (07:16)</h3><p>deoplete.nvim</p><blockquote><p>一个强大的neovim/vim8异步补全插件</p></blockquote><ul><li><a href="https://github.com/Shougo/deoplete.nvim" target="_blank" rel="noopener">https://github.com/Shougo/deoplete.nvim</a></li><li>多编程语言的支持，支持模糊匹配</li><li>需要安装对应编程语言的扩展</li></ul><p>安装：</p><pre><code class="shell">if has(&#39;nvim&#39;)  Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }else  Plug &#39;Shougo/deoplete.nvim&#39;  Plug &#39;roxma/nvim-yarp&#39;  Plug &#39;roxma/vim-hug-neovim-rpc&#39;endif</code></pre><p>如若报错请安装依赖：</p><pre><code class="shell">pip3 install --user pynvim</code></pre><p>配置：</p><pre><code class="shell">let g:deoplete#enable_at_startup = 1</code></pre><p>其他代码补全插件</p><ol><li><p>deoplete-jedi：</p><blockquote><p>Python语言代码补全，可以补全自己所写的库</p><p><a href="https://github.com/deoplete-plugins/deoplete-jedi" target="_blank" rel="noopener">https://github.com/deoplete-plugins/deoplete-jedi</a></p></blockquote></li><li><p>deoplete-go：</p><blockquote><p>Go语言代码补全</p><p><a href="https://github.com/deoplete-plugins/deoplete-go" target="_blank" rel="noopener">https://github.com/deoplete-plugins/deoplete-go</a></p></blockquote></li></ol><p>coc.nvim</p><blockquote><p>一个强大的neovim/vim8补全插件。LSP支持</p><p>LSP（Language-Server-Protocol）</p></blockquote><ul><li><a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">https://github.com/neoclide/coc.nvim</a></li><li>full language server protocol support as VSCode</li><li>多语言插件支持</li></ul><p>课后练习</p><ul><li>安装deoplete.nvim和coc.nvim</li><li>安装对应的编程语言扩展</li><li>vim/neovim补全插件很多，有些支持异步。</li></ul><h3 id="4-12-Vim代码格式化与静态检查-09-43"><a href="#4-12-Vim代码格式化与静态检查-09-43" class="headerlink" title="4-12 Vim代码格式化与静态检查 (09:43)"></a>4-12 Vim代码格式化与静态检查 (09:43)</h3><p>格式化与静态检查</p><blockquote><p>为什么需要这些工具呢？能让工具做的就不用让人去费心</p></blockquote><ul><li>把精力集中在代码逻辑本身，而不是整理格式这些浪费精力的事情上</li><li>静态检查是为了让编写的代码更加规范。golint/pylint/eslint等</li><li>无论编写何种编程语言，最好都加上自动格式化和静态检查</li></ul><p>Neoformat</p><blockquote><p>vim-autoformat和Neoformat是两种使用较多的格式化插件，这里使用neoformat</p></blockquote><ul><li><a href="https://github.com/sbdchd/neoformat" target="_blank" rel="noopener">https://github.com/sbdchd/neoformat</a></li><li>需要安装对应语言的格式化库。python的autopep8、javascript的prettier等</li></ul><p>安装依赖：</p><pre><code class="shell">pip3 install autopep8</code></pre><p><code>:Neoformat</code>：格式化Python代码</p><p>静态检查Lint</p><blockquote><p>neomake和ale是两种常见的lint插件，这里使用ale</p></blockquote><ul><li><a href="https://github.com/dense-analysis/ale" target="_blank" rel="noopener">https://github.com/dense-analysis/ale</a></li><li>需要安装对应语言的lint库。比如golint/pylint/eslint等</li><li>vim8/neovim支持异步检查，不会影响vim编辑，推荐使用</li></ul><p>安装依赖：</p><pre><code class="shell">pip3 install pylint</code></pre><p>课后练习</p><blockquote><p>让插件帮助完成代码的格式化和静态检查吧。</p></blockquote><ul><li>安装noeformat插件和相关的格式化库，格式化代码</li><li>安装ale和对应语言的lint库，修复代码的缺陷</li><li>需要自定义检查功能（比如忽略某些检查错误），参考官方文档</li></ul><h3 id="4-13-Vim快速注释代码-03-06"><a href="#4-13-Vim快速注释代码-03-06" class="headerlink" title="4-13 Vim快速注释代码 (03:06)"></a>4-13 Vim快速注释代码 (03:06)</h3><p>vim-commentary</p><blockquote><p>vim注释插件有很多，推荐使用轻量的vim-commentary</p></blockquote><ul><li><a href="https://github.com/tpope/vim-commentary" target="_blank" rel="noopener">https://github.com/tpope/vim-commentary</a></li><li>记住常用的命令：gc注释和取消注释</li><li>插件会根据不同的文件类型使用不同注释。python(#)、golang(//)</li></ul><p>行注释：</p><ul><li><code>gcc</code>：注释代码</li><li><code>gcgc</code>：取消注释代码</li></ul><p>块注释：</p><ul><li><code>gc</code>：注释/取消注释代码</li></ul><p>课后练习</p><ul><li>安装vim-commentary插件</li><li>尝试打开Python文件并快速注释一段代码</li><li>打开不同类型的文件，比如go文件，试试注释一段代码或文字</li></ul><h3 id="4-14-vim和git，强强联手-07-11"><a href="#4-14-vim和git，强强联手-07-11" class="headerlink" title="4-14 vim和git，强强联手 (07:11)"></a>4-14 vim和git，强强联手 (07:11)</h3><p>Fugitive</p><blockquote><p>在vim里使用git</p></blockquote><ul><li><a href="https://github.com/tpope/vim-fugitive" target="_blank" rel="noopener">https://github.com/tpope/vim-fugitive</a></li><li>Gedit、Gdiff、Gblame、Gcommit等</li><li>使用tmux新开一个窗口来使用git</li></ul><p>vim-gitgutter</p><blockquote><p>在vim里显示文件变动</p></blockquote><ul><li><a href="https://github.com/airblade/vim-gitgutter" target="_blank" rel="noopener">https://github.com/airblade/vim-gitgutter</a></li><li>当修改文件之后可以显示当前文件的变动</li><li>哪些行新增，哪些行修改，哪些行删除</li></ul><p>配置：</p><pre><code class="shell">set updatetime = 100</code></pre><p>gv.vim</p><blockquote><p>在命令行查看提交记录，命令行工具tig</p></blockquote><ul><li><p><a href="https://github.com/junegunn/gv.vim" target="_blank" rel="noopener">https://github.com/junegunn/gv.vim</a></p></li><li><p>使用<code>:GV</code>命令调用</p></li><li><p>可以浏览代码提交变更</p></li></ul><p>tig</p><ul><li><p><a href="https://github.com/jonas/tig" target="_blank" rel="noopener">https://github.com/jonas/tig</a></p></li><li><p><a href="https://www.jianshu.com/p/d9f60c0abbf7" target="_blank" rel="noopener">tig — 让 git 命令行可视化</a></p></li></ul><p>课后练习</p><ul><li>安装三个git插件</li><li>使用<code>:Gblame</code>等命令</li><li>vim和tmux配合使用</li></ul><h3 id="4-15-本章小结：授人以渔，寻找自己需要的插件-02-29"><a href="#4-15-本章小结：授人以渔，寻找自己需要的插件-02-29" class="headerlink" title="4-15 本章小结：授人以渔，寻找自己需要的插件 (02:29)"></a>4-15 本章小结：授人以渔，寻找自己需要的插件 (02:29)</h3><p>Vim插件千千万</p><blockquote><p>本章介绍了如何安装使用常用的插件</p></blockquote><ul><li>Vim插件很多，不可能都全部介绍。学会自己寻找个安装</li><li>通过搜索引擎Google关键词、vimawesome、参考开源配置寻找插件</li><li>学会阅读插件的README文件和doc里的帮助文件，学习插件使用</li></ul><p>缺什么就找什么插件吧！</p><h2 id="第5章-与时俱进的-Vim"><a href="#第5章-与时俱进的-Vim" class="headerlink" title="第5章 与时俱进的 Vim"></a>第5章 与时俱进的 Vim</h2><blockquote><p>介绍如何安装和使用现有的开源配置，什么是 Neovim 等，站在巨人的肩膀上。</p></blockquote><h3 id="5-1-Vim和Tmux-天作之合-08-27"><a href="#5-1-Vim和Tmux-天作之合-08-27" class="headerlink" title="5-1 Vim和Tmux,天作之合 (08:27)"></a>5-1 Vim和Tmux,天作之合 (08:27)</h3><p>Tmux</p><blockquote><p>强大的终端复用工具。通过brew(Mac)、apt-get(ubuntu)安装</p></blockquote><ul><li>可以复用终端、分屏、托管进程等</li><li>在服务器上即使退出服务器也不会被kill，托管进程也很方便</li><li>可以方便地分割屏幕，实现多个进程公用屏幕</li></ul><p>Tmux使用文章：<a href="https://zhuanlan.zhihu.com/p/43687973" target="_blank" rel="noopener">手把手教你使用终端复用神器 Tmux，丢掉鼠标不是梦</a></p><p><code>&lt;Ctrl-b&gt;%</code>：垂直分屏</p><p><code>&lt;Ctrl-b&gt;&quot;</code>：水平分屏</p><p><code>&lt;Ctrl-b&gt;c</code>：创建新tmux窗口</p><p><code>&lt;Ctrl-b&gt;n</code>：跳转到下一个tmux窗口</p><p><code>&lt;Ctrl-b&gt;p</code>：跳转到上一个tmux窗口</p><p><code>&lt;Ctrl-b&gt;h</code>：向左切换分屏</p><p><code>&lt;Ctrl-b&gt;l</code>：向右切换分屏</p><p><code>&lt;Ctrl-b&gt;s</code>：查看所有会话</p><p><code>&lt;Ctrl-b&gt;d</code>：脱离当前会话。d(etach）</p><p><code>tmux ls</code>：查看会话列表</p><p><code>tmux new -s &lt;session_name&gt;</code>：创建会话</p><p><code>tmux att -t &lt;session_name&gt;</code>：链接会话。att(ach)</p><p>课后练习</p><blockquote><p>在系统或者服务器上安装tmux</p></blockquote><ul><li>使用tmux分割屏幕</li><li>尝试一个窗口编写代码，另一个窗口使用shell命令</li><li>尝试退出和重新attach到一个tmux的会话</li></ul><h3 id="5-2-无处不在的-vim，让-vim-嵌入你的开发工具-01-42"><a href="#5-2-无处不在的-vim，让-vim-嵌入你的开发工具-01-42" class="headerlink" title="5-2 无处不在的 vim，让 vim 嵌入你的开发工具 (01:42)"></a>5-2 无处不在的 vim，让 vim 嵌入你的开发工具 (01:42)</h3><p>几乎流行的编辑器和IDE都支持VIM插件</p><blockquote><p>让vim嵌入开发工具，甚至Chrome都有vimium插件</p></blockquote><ul><li>即使不用vim作为主力编辑器，依然可以使用它的编辑方式</li><li>几乎流行的开发工具都支持vim插件，以vim的方式编辑</li><li>比如VSCode/Atom/PyCharm等都支持安装vim插件</li></ul><p>课后练习</p><ul><li>搜索相应开发工具的vim插件</li><li>安装vim插件到开发工具里</li><li>尝试在各种开发工具中使用vim的方式编辑提升效率</li></ul><h3 id="5-3-与时俱进的-vim-之-neovim-02-07"><a href="#5-3-与时俱进的-vim-之-neovim-02-07" class="headerlink" title="5-3 与时俱进的 vim 之 neovim (02:07)"></a>5-3 与时俱进的 vim 之 neovim (02:07)</h3><p>Neovim</p><blockquote><p>一个新的vim版本，支持异步特性（vim8也支持）</p></blockquote><ul><li><a href="https://neovim.io/" target="_blank" rel="noopener">https://neovim.io/</a></li><li><a href="https://github.com/neovim/neovim" target="_blank" rel="noopener">https://github.com/neovim/neovim</a></li><li>开发更活跃，更丰富的特性和扩展异步支持</li><li>neovim的设计可以嵌入到很多GUI里，加上好看的外壳</li></ul><p>感兴趣的同学可以使用neovim代替vim啦！</p><h3 id="5-4-站在巨人的肩膀上，使用强大的开源配置-03-37"><a href="#5-4-站在巨人的肩膀上，使用强大的开源配置-03-37" class="headerlink" title="5-4 站在巨人的肩膀上，使用强大的开源配置 (03:37)"></a>5-4 站在巨人的肩膀上，使用强大的开源配置 (03:37)</h3><p>开箱即用</p><blockquote><p>如果你已经熟悉了vim配置，可以从网上直接使用一些开源配置</p></blockquote><ul><li><a href="https://github.com/SpaceVim/SpaceVim" target="_blank" rel="noopener">https://github.com/SpaceVim/SpaceVim</a></li><li><a href="https://github.com/pegasuswang/vim-config" target="_blank" rel="noopener">https://github.com/pegasuswang/vim-config</a></li><li>其他开源配置。不推荐新手直接使用，越复杂的配置上手成本越高</li></ul><p>课后练习</p><ul><li>找到一个合适的开源配置，尝试安装它</li><li>阅读其他文档，了解使用方式。一般开源配置都安装了很多插件</li><li>对于新手来说，配置太复杂太强大有时候可能会出现很多小问题</li></ul><h2 id="第6章-Vim虐我千百遍，我待Vim如初恋"><a href="#第6章-Vim虐我千百遍，我待Vim如初恋" class="headerlink" title="第6章 Vim虐我千百遍，我待Vim如初恋~"></a>第6章 Vim虐我千百遍，我待Vim如初恋~</h2><blockquote><p>Vim虐我千百遍，我待Vim如初恋~</p></blockquote><h3 id="6-1-课程总结-vim虐我千百遍，我待-vim-如初恋-03-17"><a href="#6-1-课程总结-vim虐我千百遍，我待-vim-如初恋-03-17" class="headerlink" title="6-1 课程总结-vim虐我千百遍，我待 vim 如初恋 (03:17)"></a>6-1 课程总结-vim虐我千百遍，我待 vim 如初恋 (03:17)</h3><p>可以用一生的编辑器</p><blockquote><p>vim从诞生到现在已经走过了快30个年头</p></blockquote><ul><li>几十年之间，无数的编辑器或者开发工具昙花一现</li><li>但是vim一直到现在依然有很多人在使用，甚至嵌入到各种开发工具</li><li>如今vim/neovim依然在活跃开发，很多开发者贡献插件</li></ul><p>学习方法</p><blockquote><p>熟悉vim靠的是肌肉记忆。脱离鼠标编辑能提升编辑效率</p></blockquote><ul><li>讲了很多，但是vim中依然有很多东西没有讲到，时不时发现一些使用技巧</li><li>在学中练，在练中学。熟能生巧，肌肉记忆</li><li>衡量投入产出比，是点到为止还是继续深入</li></ul><p>继续练级</p><blockquote><p>网络上有很多vim的资源，甚至练习的小游戏</p></blockquote><ul><li>《Practical vim》、中文版《Vim实用技巧》</li><li>《笨方法学vimscript》</li><li>学习和开发自己的插件</li></ul><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><pre><code class="shell">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;                                 Sample vimrc                                 &quot;&quot;                                                                              &quot;&quot;                                 Provided by:                                 &quot;&quot;                                     Tuyk                                     &quot;&quot;                                                                              &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax on &quot; 自动语法高亮&quot; colorscheme xcode-default &quot; 更换主题配色&quot; ======================...Basic Start...====================== &quot;&quot; Turn on line numbering &quot; 显示行号set number&quot; Save 1,000 items in history &quot; 设置历史行号set history=1000&quot; Show the line and column number of the cursor position &quot; 设置光标的位置值set ruler&quot; Display the incomplete commands in the bottom right-hand side of your screen.  set showcmd&quot; Display completion matches on your status lineset wildmenu&quot; Show a few lines of context around the cursorset scrolloff=5&quot; Highlight search matches &quot; 设置查找的值高亮显示set hlsearch&quot; Enable incremental searching &quot; 设置边搜索边高亮set incsearch&quot; Ignore case when searching &quot; 设置忽略查找选项的大小写set ignorecase&quot; Override the &#39;ignorecase&#39; option if the search pattern contains upper case characters.set smartcase&quot; Turn on file backupsset backup&quot; Don&#39;t line wrap mid-word.set lbr&quot; Copy the indentation from the current line. &quot; 设置自动复制上一行的缩进到下一行set autoindent&quot; Enable smart autoindenting. &quot; 设置自动识别“{}”缩进，写代码非常有用set smartindent&quot; Use spaces instead of tabs &quot; 使用空格替换tabset expandtab&quot; Enable smart tabsset smarttab&quot; Make a tab equal to 4 spacesset shiftwidth=4 &quot; 默认缩进4个空格set tabstop=4 &quot; tab 代表4个空格set softtabstop=4 &quot; 使用tab时 tab空格数&quot; 按F2进入粘贴模式set pastetoggle=&lt;F2&gt;&quot; 设置折叠方式&quot; set foldmethod=indent&quot; 开启系统剪贴板set clipboard=unnamed&quot; 解决中文乱码set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8&quot; Tell vim what background you are using &quot; 设置背景颜色&quot; set bg=light&quot; set bg=dark&quot; 退格删除键不能用set backspace=indent,eol,start&quot; ======================...Basic End...====================== &quot;&quot; ======================...Mapping Start...====================== &quot;&quot; Map Y to act like D and C, i.e. yank until EOL, rather than act like yy &quot; Map 映射&quot; map Y y$&quot; Remap VIM 0 to first non-blank character&quot; map 0 ^noremap &lt;space&gt; viw&quot; change the mapleader from \ to , &quot; 一些方便的映射&quot; NOTE: This has to be set before &lt;leader&gt; is used.let mapleader=&#39;,&#39;let g:mapleader=&#39;,&#39;&quot; 使用 jj 进入 normal模式inoremap jj &lt;Esc&gt;`^&quot; 使用 &lt;leader&gt;+w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w!&lt;cr&gt;noremap &lt;leader&gt;w :w!&lt;cr&gt;&quot; 切换 buffernnoremap &lt;silent&gt; [p :bprevious&lt;cr&gt;nnoremap &lt;silent&gt; [n :bnext&lt;cr&gt;&quot; use ctrl+h/j/k/l switch windownoremap &lt;C-h&gt; &lt;C-w&gt;hnoremap &lt;C-j&gt; &lt;C-w&gt;jnoremap &lt;C-k&gt; &lt;C-w&gt;knoremap &lt;C-l&gt; &lt;C-w&gt;l&quot; Sudo to writecnoremap w!! w !sudo tee % &gt;/dev/null&quot; NERDTreemap &lt;leader&gt;v :NERDTreeFind&lt;CR&gt;map &lt;leader&gt;g :NERDTreeToggle&lt;CR&gt;&quot; ctrlp.vimlet g:ctrlp_map = &#39;&lt;c-p&gt;&#39;&quot; vim-easymotionnmap ss &lt;Plug&gt;(easymotion-s2)&quot; vim-goautocmd BufNewFile,BufRead *.go setlocal noexpandtab tabstop=4 shiftwidth=4&quot; python-modelet g:pymode_python = &#39;python3&#39;let g:pymode_trim_whitespaces = 1let g:pymode_doc = 1let g:pymode_doc_bind = &#39;K&#39;let g:pymode_rope_goto_definition_bind = &#39;&lt;C-]&gt;&#39;let g:pymode_lint = 1let g:pymode_lint_checkers = [&#39;pyflakes&#39;, &#39;pep8&#39;, &#39;mccabe&#39;, &#39;pylint&#39;]let g:pymode_options_max_line_length = 120&quot; tagbarnnoremap &lt;leader&gt;t :TagbarToggle&lt;CR&gt;&quot; deoplete.nvimlet g:deoplete#enable_at_startup = 1set completeopt -=preview &quot; 关闭预览窗口&quot; vim-gitgutterset updatetime =100&quot; ======================...Mapping End...====================== &quot;&quot; ============================================================================== &quot;&quot; json 格式化com! FormatJSON %!python3 -m json.tool&quot; ============================================================================== &quot;&quot; ======================...Plugins Start...====================== &quot;&quot; 插件设置，这里使用了 vim-plugcall plug#begin(&#39;~/.vim/plugged&#39;)&quot; 安装插件只需要把 github 地址放到这里重启后执行 :PlugInstall 就好了Plug &#39;mhinz/vim-startify&#39;Plug &#39;vim-airline/vim-airline&#39;Plug &#39;vim-airline/vim-airline-themes&#39;Plug &#39;Yggdroot/indentLine&#39;Plug &#39;scrooloose/nerdtree&#39;Plug &#39;ctrlpvim/ctrlp.vim&#39;Plug &#39;easymotion/vim-easymotion&#39;Plug &#39;tpope/vim-surround&#39;Plug &#39;junegunn/fzf&#39;, { &#39;dir&#39;: &#39;~/.fzf&#39;, &#39;do&#39;: &#39;./install --all&#39; }Plug &#39;junegunn/fzf.vim&#39;Plug &#39;ggreer/the_silver_searcher&#39;Plug &#39;brooth/far.vim&#39;Plug &#39;fatih/vim-go&#39;, { &#39;do&#39;: &#39;:GoUpdateBinaries&#39; }Plug &#39;python-mode/python-mode&#39;, { &#39;for&#39;: &#39;python&#39;, &#39;branch&#39;: &#39;develop&#39; }Plug &#39;majutsushi/tagbar&#39;Plug &#39;lfv89/vim-interestingwords&#39;if has(&#39;nvim&#39;)  Plug &#39;Shougo/deoplete.nvim&#39;, { &#39;do&#39;: &#39;:UpdateRemotePlugins&#39; }else  Plug &#39;Shougo/deoplete.nvim&#39;  Plug &#39;roxma/nvim-yarp&#39;  Plug &#39;roxma/vim-hug-neovim-rpc&#39;endifPlug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}Plug &#39;sbdchd/neoformat&#39;Plug &#39;dense-analysis/ale&#39;Plug &#39;tpope/vim-commentary&#39;Plug &#39;tpope/vim-fugitive&#39;Plug &#39;airblade/vim-gitgutter&#39;Plug &#39;junegunn/gv.vim&#39;call plug#end()&quot; 插件相关配置&quot; 禁止 stratify 自动切换目录let g:startify_change_to_dir = 0&quot; 启动时自动打开NERDTree&quot; autocmd vimenter * NERDTree&quot; ======================...Plugins End...====================== &quot;&quot; ======================...Function Start...====================== &quot;&quot; 定义函数SetTitle，自动插入文件头func SetTitle()    if &amp;filetype == &#39;python&#39;        call setline(1, &quot;\#!/usr/bin/env python&quot;)        call setline(2, &quot;\# -*- coding:utf-8 -*-&quot;)        normal G        normal o        normal o        call setline(5, &quot;if __name__ == &#39;__main__&#39;:&quot;)        call setline(6, &quot;    pass&quot;)    endifendfunc&quot; ======================...Function End...====================== &quot;&quot; For more options see &quot;:help option-list&quot; and &quot;:options&quot;.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1049-优雅玩转Vim</title>
      <link href="/imooc/1049-vim/"/>
      <url>/imooc/1049-vim/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1049" target="_blank" rel="noopener">https://www.imooc.com/learn/1049</a></p><p>简介：Vim作为Linux 平台首选编辑器，无论是运维还是开发等IT人员都应该系统地学习下这款优秀经典的上古神器。本课程系统提炼vim 的精华、通过抛砖引玉把它展现到你的面前，更能让你的工作如虎添翼、事半功倍。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>Vim课程介绍。</p></blockquote><h3 id="1-1-课程简介-04-34"><a href="#1-1-课程简介-04-34" class="headerlink" title="1-1 课程简介 (04:34)"></a>1-1 课程简介 (04:34)</h3><p>在所有的类Unix操作系统中都会默认内置Vi/Vim文本编辑器</p><ol><li><p>Vim简介</p><ul><li>Vim和Vi的区别</li><li>Vimrc配置</li><li>Vim四种模式</li></ul></li><li><p>基础入门</p><ul><li>Vim寄存器（类似于Windows的粘贴板）</li><li>增查删改等常规操作（快捷键、按键）</li><li>Vim组合规律</li></ul></li><li><p>高级功能</p><ul><li>缓冲区与多文件编辑</li><li>多窗口与标签分组</li><li>文本对象和宏</li><li>Visual模式</li></ul></li></ol><h2 id="第2章-Vim简介"><a href="#第2章-Vim简介" class="headerlink" title="第2章 Vim简介"></a>第2章 Vim简介</h2><blockquote><p>为什么选择Vim作为编辑器，Vim安装与简洁Vimrc配置</p></blockquote><h3 id="2-1-vim介绍及Vimrc-18-02"><a href="#2-1-vim介绍及Vimrc-18-02" class="headerlink" title="2-1 vim介绍及Vimrc (18:02)"></a>2-1 vim介绍及Vimrc (18:02)</h3><p>Vim介绍：</p><ul><li>Vim是一个Unix以及类Unix文本编辑器</li><li>特点：功能强大、高度可定制(Vimrc、插件等)</li></ul><p>Vim vs Vi：</p><blockquote><p>Vim = Vi + IMproved</p></blockquote><ul><li>多级撤销</li><li>语法加亮和自动补全</li><li>支持多种插件</li><li>通过网络协议（HTTP/SSH）编辑文件</li><li>多文件编辑</li><li>Vim可以编辑压缩格式文件（gzip、zip等）</li></ul><p>Vimrc概述：</p><ul><li>rc = run command</li><li>系统级vimrc和用户级vimrc</li><li>每一行作为一个命令执行</li></ul><p>Vimrc使用：</p><blockquote><p>默认.Vimrc是没有得。需要用户自己手动创建。Vim 会自动搜索到。</p></blockquote><ul><li><p><code>:h vimrc</code> 查看Vimrc文档</p></li><li><p><code>:version</code> 查看vim版本</p></li><li><p><code>vim &lt;filename&gt;</code> 或 <code>:e &lt;filename&gt;</code> 打开文件📃</p></li><li><p><code>“</code> 注释</p></li><li><p>Vimrc-Sample：<a href="https://raw.githubusercontent.com/yangvipguang/vimrc-sample/master/vimrc-sample" target="_blank" rel="noopener">https://raw.githubusercontent.com/yangvipguang/vimrc-sample/master/vimrc-sample</a></p></li></ul><pre><code class="shell">&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;                                 Sample vimrc                                 &quot;&quot;                                                                              &quot;&quot;                                 Provided by:                                 &quot;&quot;                                     Tuyk                                     &quot;&quot;                                                                              &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;syntax on &quot; 自动语法高亮&quot; Save 1,000 items in history &quot; 设置历史行号set history=1000&quot; Show the line and column number of the cursor position &quot; 设置光标的位置值set ruler&quot; Display the incomplete commands in the bottom right-hand side of your screen.  set showcmd&quot; Display completion matches on your status lineset wildmenu&quot; Show a few lines of context around the cursorset scrolloff=5&quot; Highlight search matches &quot; 设置查找的值高亮显示set hlsearch&quot; Enable incremental searching &quot; 设置边搜索边高亮set incsearch&quot; Ignore case when searching &quot; 设置忽略查找选项的大小写set ignorecase&quot; Override the &#39;ignorecase&#39; option if the search pattern contains upper case characters.set smartcase&quot; Turn on line numbering &quot; 显示行号set number&quot; Turn on file backupsset backup&quot; Don&#39;t line wrap mid-word.set lbr&quot; Copy the indentation from the current line. &quot; 设置自动复制上一行的缩进到下一行set autoindent&quot; Enable smart autoindenting. &quot; 设置自动识别“{}”缩进，写代码非常有用set smartindent&quot; Use spaces instead of tabs &quot; 使用空格替换tabset expandtab&quot; Enable smart tabsset smarttab&quot; Make a tab equal to 4 spacesset shiftwidth=4 &quot; 默认缩进4个空格set tabstop=4 &quot; tab 代表4个空格set softtabstop=4 &quot; 使用tab时 tab空格数&quot; Specifiy a color scheme.colorscheme slate&quot; Tell vim what background you are using &quot; 设置背景颜色&quot; set bg=light&quot; set bg=dark&quot; Map Y to act like D and C, i.e. yank until EOL, rather than act like yy &quot; Map 映射&quot; map Y y$&quot; Remap VIM 0 to first non-blank character&quot; map 0 ^&quot; Easily create HTML unorded lists. &quot; map &lt;F3&gt; i&lt;ul&gt;&lt;CR&gt;&lt;Space&gt;&lt;Space&gt;&lt;li&gt;&lt;/li&gt;&lt;CR&gt;&lt;Esc&gt;I&lt;/ul&gt;&lt;Esc&gt;kcit&quot; map &lt;F4&gt; &lt;Esc&gt;o&lt;li&gt;&lt;/li&gt;&lt;Esc&gt;cit&quot; change the mapleader from \ to ,&quot; NOTE: This has to be set before &lt;leader&gt; is used.&quot; let mapleader=&quot;,&quot;&quot; Quickly save your file.&quot; map &lt;leader&gt;w :w!&lt;cr&gt;&quot; For more options see &quot;:help option-list&quot; and &quot;:options&quot;.</code></pre><h3 id="2-2-vim的四种模式-05-22"><a href="#2-2-vim的四种模式-05-22" class="headerlink" title="2-2 vim的四种模式 (05:22)"></a>2-2 vim的四种模式 (05:22)</h3><ol><li>普通模式<ul><li>打开的默认模式</li><li>移查删改</li></ul></li><li>可视化模式<ul><li>对一块区域操作</li></ul></li><li>插入模式<ul><li>添加文本</li></ul></li><li>命令模式<ul><li>和普通模式类似</li></ul></li></ol><p><code>v</code>：进入可视化模式</p><p><code>i</code>：进入插入模式</p><p><code>:</code>：使用命令模式</p><p><code>dd</code>：删除</p><p><code>Esc</code>：返回普通模式</p><p><code>:h vim-modes-intro</code>：查看vim模式文档（7种）</p><h2 id="第3章-Vim基础入门"><a href="#第3章-Vim基础入门" class="headerlink" title="第3章 Vim基础入门"></a>第3章 Vim基础入门</h2><blockquote><p>本章主要讲解移动、跳转与缩进，删除、复制与粘贴，修改、查找与替换相关内容。</p></blockquote><h3 id="3-1-移动、跳转与缩进-07-55"><a href="#3-1-移动、跳转与缩进-07-55" class="headerlink" title="3-1 移动、跳转与缩进 (07:55)"></a>3-1 移动、跳转与缩进 (07:55)</h3><p>Vim布局起源</p><ul><li><p>Vim最初的作者Bill Joy使用的机器ADM-3A终端机</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbdnjipj31bs0fmgod.jpg" alt="ADM-3A终端机" style="zoom:30%;" /><p>注意看上下左右键的位置</p></li></ul><p><strong>光标移动：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>h</code></td><td>左移</td></tr><tr><td><code>l</code></td><td>右移</td></tr><tr><td><code>j</code></td><td>下移</td></tr><tr><td><code>k</code></td><td>上移</td></tr><tr><td><code>shift+6</code>/<code>0</code></td><td>移动到行首<code>^</code>/包含缩进空格</td></tr><tr><td><code>shift+4</code></td><td>移动到行尾<code>$</code></td></tr></tbody></table><p><strong>单词和字符移动：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td>w/W</td><td>正向移动到下一个单词开头(小写识别特殊字符)</td></tr><tr><td>e/E</td><td>正向移动到下一个单词结尾</td></tr><tr><td>b/B</td><td>反向移动到上一个单词开头</td></tr><tr><td>ge</td><td>反向移动到上一个单词结尾</td></tr></tbody></table><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbf4b5oj30ja0asmxt.jpg" alt="单词和字符移动" style="zoom:50%;" /><p><strong>跳转：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>control+b/B</code></td><td>上一页</td></tr><tr><td><code>control+f/F</code></td><td>下一页</td></tr><tr><td><code>control+u/d</code></td><td>向上/下翻半页</td></tr><tr><td><code>gg</code></td><td>跳转到文件📁首行</td></tr><tr><td><code>G</code></td><td>跳转到文件📁尾行</td></tr><tr><td><code>&lt;line_number&gt;gg/G</code></td><td>跳转到指定行</td></tr><tr><td><code>{g}+control+g/G</code></td><td>查看文件信息/{g}更加详细</td></tr></tbody></table><p><strong>缩进：</strong></p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>&gt;&gt;</code>===<code>:&gt;</code></td><td>右缩进(普通模式)</td></tr><tr><td><code>&lt;&lt;</code>===<code>:&lt;</code></td><td>左缩进(普通模式)</td></tr><tr><td><code>:m,n&gt;</code>===<code>:m&gt;(n-m+1)</code></td><td>m到n行缩进(命令行模式)</td></tr><tr><td><code>:m&gt;n</code>===<code>:m,m+n-1&gt;</code></td><td>m行开始,共n行缩进一次(命令行模式)</td></tr></tbody></table><h3 id="3-2-删除、复制与粘贴-25-41"><a href="#3-2-删除、复制与粘贴-25-41" class="headerlink" title="3-2 删除、复制与粘贴 (25:41)"></a>3-2 删除、复制与粘贴 (25:41)</h3><table><thead><tr><th>Windows</th><th>Vim</th><th>不同处</th></tr></thead><tbody><tr><td>cut</td><td>delete</td><td>和剪切相同，而不是直接删除</td></tr><tr><td>copy</td><td>yank</td><td>等同于复制,由于c用于(change)被迫选了yank</td></tr><tr><td>paste</td><td>put</td><td>粘贴完全相同</td></tr></tbody></table><p>Vim特性</p><ul><li><p>寄存器（保存临时数据）</p><table><thead><tr><th align="left">类型</th><th align="center">含义</th><th>表示方式</th><th>举例</th><th>特点</th></tr></thead><tbody><tr><td align="left">无名寄存器</td><td align="center">默认寄存器</td><td>“”</td><td>“” p=p</td><td>会被最后一条覆盖</td></tr><tr><td align="left">数字寄存器</td><td align="center">“+{0-9}缓存最近10次操作</td><td>“0”{1-9}</td><td>“0P<br />“1P</td><td>0用于复制专用<br />1-9用于最近9次行删除或者修改记录</td></tr><tr><td align="left">有名寄存器</td><td align="center">26英文字母命名有名寄存器</td><td>“[a-z]/[A-Z]”</td><td>“ayw</td><td>“A会通过^J追加到”a寄存器中</td></tr><tr><td align="left">黑洞寄存器</td><td align="center">有去无回</td><td>“-</td><td>“_dw</td><td>只想删除而不想覆盖无名寄存器</td></tr></tbody></table><p><code>:register</code>/<code>:reg</code>：进入寄存器</p><p><code>:h reg</code>：查看寄存器文档</p></li></ul><p>基础操作</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td>d = delete = cut</td><td>剪切</td></tr><tr><td>y = yank ≈ copy</td><td>类似于复制</td></tr><tr><td>P/p = put ≈ paste</td><td>粘贴到光标后/前</td></tr><tr><td>u = undo</td><td>撤销之前操作</td></tr><tr><td>Control+r = redo</td><td>重做/恢复之前操作(反撤销)</td></tr></tbody></table><p><code>yy</code>：复制整行。记录到<code>&quot;&quot;</code>默认寄存器/无名寄存器、<code>&quot;0</code>寄存器/复制专用寄存器</p><p><code>dd</code>：剪切整行。记录到<code>&quot;&quot;</code>默认寄存器/无名寄存器、<code>&quot;1</code>寄存器/剪切寄存器</p><p><code>p</code>：粘贴</p><p><code>u</code>：撤销</p><p><code>Control+r</code>：重做(反撤销)</p><p><code>&quot;ayy</code>：复制整行到<code>&quot;a</code>寄存器。记录到默认寄存器，不会记录到复制专用寄存器</p><p><code>&quot;_dd</code>：删除整行。不会记录到任何寄存器。黑洞寄存器</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td>yw</td><td>复制当前光标单词(从光标后开始截取)</td></tr><tr><td>y2w</td><td>复制正向倆个单词(从光标后开始截取)</td></tr></tbody></table><p>调换字符</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Practical vim</td></tr><tr><td>F{space}</td><td>Practical vim</td></tr><tr><td>x</td><td>Practical vim</td></tr><tr><td>p</td><td>Practical vim</td></tr></tbody></table><p><code>x</code>：剪切单个字符。记录到默认寄存器、<code>-</code>寄存器</p><p>行剪切粘贴</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Line1   Line2</td></tr><tr><td>dd</td><td>Line2</td></tr><tr><td>p</td><td>Line2   Line1</td></tr></tbody></table><p>行复制</p><table><thead><tr><th>按键操作</th><th>缓冲区内容</th></tr></thead><tbody><tr><td>{start}</td><td>Line1   Line2</td></tr><tr><td>yy</td><td>Line1   Line2</td></tr><tr><td>p</td><td>Line1   Line2   Line1</td></tr></tbody></table><p>组合删除([count] operation [count] {motion})</p><table><thead><tr><th>操作按键</th><th>定义</th></tr></thead><tbody><tr><td><code>x</code>/<code>X</code></td><td>删除光标下/前单个字符</td></tr><tr><td><code>dw</code>(d = delete,w = word)</td><td>删除一个单词(必须在词首👋)(删除光标处到单词末尾🔚)</td></tr><tr><td><code>d{hjkl}</code></td><td>删除到上下左右一个操作前的字符</td></tr><tr><td><code>d$</code>===<code>D</code></td><td>删除光标到行尾的字符</td></tr><tr><td><code>d^</code></td><td>删除光标到行首的字符</td></tr><tr><td><code>dd</code></td><td>删除当前整行</td></tr><tr><td><code>{n}dd</code></td><td>向下删除n行（包括当前行）</td></tr><tr><td><code>5dw</code></td><td>删除正向单词5次</td></tr><tr><td><code>d3w</code></td><td>正向删除3w 动作</td></tr><tr><td><code>3w</code></td><td>正向移动单词3次</td></tr><tr><td><code>2d3w</code></td><td>正向删除3w 动作 2次</td></tr></tbody></table><h3 id="3-3-修改、查找与替换-15-59"><a href="#3-3-修改、查找与替换-15-59" class="headerlink" title="3-3 修改、查找与替换 (15:59)"></a>3-3 修改、查找与替换 (15:59)</h3><p>插入</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>Shift+i</code>/<code>Shift+a</code></td><td>插入模式并移动到行首/尾</td></tr><tr><td><code>i</code>/<code>a</code></td><td>光标前/后插入</td></tr><tr><td>[n]+<code>O</code>/<code>o</code></td><td>行前/后插入n次</td></tr><tr><td>[n]+<code>i</code></td><td>插入模式重复n次</td></tr></tbody></table><p>转换</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>~</code></td><td>单个字符大小写转换</td></tr><tr><td><code>g ~ w</code></td><td>单词大小写转换</td></tr><tr><td><code>g ~ $</code>/<code>g ~ ~</code></td><td>整行大小写转换(<code>^</code>光标处到行首大小写反转,<code>$</code>光标处到行尾大小写反转)</td></tr><tr><td><code>gUw</code>/<code>guw</code></td><td>单词转换成大小写</td></tr></tbody></table><p><code>.</code>：对上一个操作的重🐛复</p><p>查找</p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>f{char}</code>/<code>F{char}</code></td><td>正向/反向查找某个单词(适用于查找某一行)</td></tr><tr><td><code>t{char}</code></td><td>查找字符前一个字符</td></tr><tr><td><code>dt{char}</code>/<code>df{char}</code></td><td>删除光标到查找字符间的字符</td></tr><tr><td><code>/{char}</code></td><td>命令行查找</td></tr></tbody></table><p><code>/{char}</code>：</p><ul><li><code>n</code>：向下⬇️查找🔎</li><li><code>N</code>：向上⬆️查找🔎</li></ul><p>替换(substitute)</p><p>语法：<code>[range]s[ubstitute]/{pattern}/{string}/[flags]</code></p><table><thead><tr><th>按键操作</th><th>定义</th></tr></thead><tbody><tr><td><code>:s/going/rolling/g</code></td><td>当前行所有going替换成rolling</td></tr><tr><td><code>:%s/going/rolling/g</code></td><td>%匹配所有范围</td></tr><tr><td><code>⇧+r</code>/<code>R</code></td><td>替换模式</td></tr><tr><td><code>r</code></td><td>单个字符替换</td></tr><tr><td><code>cw</code>、<code>c2w</code></td><td>修改单个单词</td></tr><tr><td><code>c$</code>/<code>C</code>类似于<code>d</code>操作符</td><td>修改光标之后行内内容</td></tr></tbody></table><h2 id="第4章-Vim高级功能"><a href="#第4章-Vim高级功能" class="headerlink" title="第4章 Vim高级功能"></a>第4章 Vim高级功能</h2><blockquote><p>本章主要讲解缓冲区与多文件编辑、多窗口操作（分屏）与标签分组、宏和文本对象以及Visual模式。</p></blockquote><h3 id="4-1-缓冲区与多文件编辑-13-25"><a href="#4-1-缓冲区与多文件编辑-13-25" class="headerlink" title="4-1 缓冲区与多文件编辑 (13:25)"></a>4-1 缓冲区与多文件编辑 (13:25)</h3><blockquote><p>缓冲区、标签、窗口</p></blockquote><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbe71ptj31340hcmyi.jpg" alt="缓冲区与多文件编辑" style="zoom:45%;" /><p>编辑操作并不是真正的编辑文件，而是编辑文件在内存中的映射或快照或缓冲区</p><p>缓冲区：就是内容缓存区域。</p><ul><li>Buffer是内存中的一块缓冲区，用于临时存放Vim打开过的文件</li></ul><p>查看缓冲区列表：</p><ul><li><code>:files</code></li><li><code>:buffers</code></li><li><code>:ls</code><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghbeqzfdj31kg0cwgoo.jpg" alt="缓冲区列表" style="zoom:30%;" /></li></ul><p>缓冲区列表指示状态</p><table><thead><tr><th>标记</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>激活缓冲区，缓冲区被加载且显示</td></tr><tr><td>h</td><td>隐藏缓冲区，缓冲区被加载但🥚不显示</td></tr><tr><td>%</td><td>当前缓冲区</td></tr><tr><td>#</td><td>交换缓冲区</td></tr><tr><td>=</td><td>只读缓冲区</td></tr><tr><td>+</td><td>已经更改缓冲区</td></tr><tr><td>-</td><td>不可更改缓冲区，’modifiable’选项不置位</td></tr></tbody></table><p>缓冲区列表操作</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>:bp[revious]</code></td><td>上一个缓冲区</td></tr><tr><td><code>:bn[ext]</code></td><td>下一个缓冲区</td></tr><tr><td><code>:bf[irst]</code></td><td>到第一个缓冲区</td></tr><tr><td><code>:bl[ast]</code></td><td>到最后一个缓冲区</td></tr><tr><td><code>:buffer Number/File_name</code></td><td>指定缓冲区</td></tr><tr><td><code>:ball</code></td><td>编辑所有缓冲区</td></tr><tr><td><code>⌃+^</code>/<code>b#</code></td><td>切换到前一个buffer（交换buffer）</td></tr><tr><td><code>:qall!</code></td><td>退出全部缓冲区</td></tr><tr><td><code>:wall!</code></td><td>写入全部缓冲区</td></tr><tr><td><code>:badd</code></td><td>添加一个新缓冲区，但不设置为当前缓冲区</td></tr><tr><td><code>:bd[elete]</code></td><td>删除缓冲区</td></tr><tr><td><code>:m,nbd</code>/<code>:%db</code></td><td>删除m到n编号/所有的缓冲区文件</td></tr><tr><td><code>:bufdo {CMD}</code></td><td>bufdo set number</td></tr><tr><td><code>:E /:bd</code></td><td>打开文件目录列表/返回到🔙最初的buffer</td></tr></tbody></table><h3 id="4-2-多窗口操作与标签分组-16-57"><a href="#4-2-多窗口操作与标签分组-16-57" class="headerlink" title="4-2 多窗口操作与标签分组 (16:57)"></a>4-2 多窗口操作与标签分组 (16:57)</h3><ul><li>多窗口（分屏）</li></ul><p>分屏操作</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>vim -On</code>/<code>vim -on</code></td><td>垂直/水平分屏（n：数字，o：Open）</td></tr><tr><td><code>⌃+w c/q</code></td><td>关闭当前窗口/最后一个窗口时退</td></tr><tr><td><code>⌃+w s</code></td><td>上下分割当前打开的文件</td></tr><tr><td><code>⌃+w v</code></td><td>左右分割当前打开的文件</td></tr><tr><td><code>:sp filename</code></td><td>上下分割并打开一个新的文件</td></tr><tr><td><code>:vsp filename</code></td><td>左右分割并打开一个新的文件</td></tr></tbody></table><p>移动分屏和尺寸变动</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>⌃+w H</code></td><td>向左⬅️移动</td></tr><tr><td><code>⌃+w J</code></td><td>向下⬇️移动</td></tr><tr><td><code>⌃+w K</code></td><td>向上⬆️移动</td></tr><tr><td><code>⌃+w L</code></td><td>向右➡️移动</td></tr><tr><td><code>⌃+w +</code></td><td>增加高度</td></tr><tr><td><code>⌃+w -</code></td><td>减少高度</td></tr><tr><td><code>⌃+w _</code></td><td>减小到最低高度</td></tr><tr><td><code>⌃+w =</code></td><td>让所有屏的高度一致</td></tr></tbody></table><ul><li><p>标签</p><p>标签就是容纳一系列窗口的容器</p></li></ul><p>标签操作</p><table><thead><tr><th>指令</th><th><code>含义</code></th></tr></thead><tbody><tr><td><code>:tabnew [tab_name]</code></td><td><code>新建标签页</code></td></tr><tr><td><code>:tabfind</code></td><td><code>查找并在新标签中打开文件</code></td></tr><tr><td><code>:tabs</code></td><td>显示已打开标签页的列表</td></tr><tr><td><code>:tabclose</code></td><td>关闭当前标签页</td></tr><tr><td><code>:tabonly</code></td><td>仅保留当前标签页打开</td></tr><tr><td><code>:tabn/p/first/last</code></td><td>跳转到下/上/第一/最后一个标签页</td></tr><tr><td><code>:tabm</code></td><td>将当前标签页放置到指定位置</td></tr></tbody></table><p>标签操作和命令键</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>gt/T</code></td><td>移动到下/上一个标签</td></tr><tr><td><code>{i}gt</code></td><td><strong>跳转到i位置的标签</strong></td></tr><tr><td><code>noremap &lt;C-L&gt; &lt;Esc&gt; :tabnext &lt;CR&gt;</code></td><td>Vimrc中自定义快捷键</td></tr><tr><td><code>noremap &lt;C-H&gt; &lt;Esc&gt; :tabprevious &lt;CR&gt;</code></td><td>Vimrc中自定义快捷键</td></tr><tr><td><code>:tabe</code></td><td>编辑标签中的某个文件</td></tr><tr><td><code>:tabm 0/tabm</code></td><td>移动当前tab到第一个/最后一个</td></tr><tr><td><code>t:abm {i}</code></td><td><strong>移动当前tab到第i+1位置</strong></td></tr></tbody></table><h3 id="4-3-文本对象与宏-18-40"><a href="#4-3-文本对象与宏-18-40" class="headerlink" title="4-3 文本对象与宏 (18:40)"></a>4-3 文本对象与宏 (18:40)</h3><ul><li>文本对象</li></ul><pre><code>{operator} {a} {object}{operator} {i} {object}</code></pre><p>例：</p><ul><li><p>daw = Delete A Word</p><p><code>==a==n object</code>：包含尾部间隔空格</p></li><li><p>ciw = Change Inner Word</p><p><code>==i==nner object</code>：只是内容本身，不包含尾部单词间隔🈳️格</p></li></ul><p>Word/Sentence/Paragraph</p><table><thead><tr><th>textobject</th><th>说明</th></tr></thead><tbody><tr><td>w</td><td>word</td></tr><tr><td>s</td><td>sentence</td></tr><tr><td>p</td><td>paragraph</td></tr></tbody></table><p>块对象</p><table><thead><tr><th>textobject</th><th>说明</th></tr></thead><tbody><tr><td>]/[</td><td><code>[]</code> block</td></tr><tr><td>)/(、b</td><td><code>()</code> block</td></tr><tr><td>&gt;/&lt;、&gt;/&lt;</td><td><code>&lt;&gt;</code> block</td></tr><tr><td>}/{、B</td><td><code>()</code> block</td></tr><tr><td>t</td><td>tag block: <code>&lt;&gt; &lt;/&gt;</code></td></tr></tbody></table><p>Visual mode</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>viw</code></td><td>选中单词</td></tr><tr><td><code>vis</code></td><td>选中句子🍊</td></tr><tr><td><code>vip</code></td><td>选中段落</td></tr><tr><td>vi<code>(</code></td><td>选中<code>()</code>圆括号中的内容</td></tr><tr><td><code>vi[</code></td><td>选中<code>[]</code>中括号中的内容</td></tr><tr><td><code>vit</code></td><td>选中标签中的内容</td></tr></tbody></table><table>    <tr>        <th>指令</th>        <th>说明</th>    </tr>    <tr>        <td>v2i{</td>        <td>          选中两层`{}`大括号之间的所有内容<br/>          数字限制选择的嵌套层数        </td>    </tr>    <tr>        <td>v3aw</td>        <td>选择3⃣️个单词（3个单词➕2个间隔空格）</td>    </tr>    <tr>        <td>v3iw</td>        <td>选择3⃣️个单词（2个单词➕1个间隔空格）</td>    </tr>    <tr>        <td colspan="2" align="center">可将v选择操作指令替换为c(change), x, d(delete), y(yank)等操作符(operator)，来针对文本对象操作</td>    </tr>·</table><ul><li>宏</li></ul><blockquote><p>If you write a thing once, it is okay. However if you’re writing twice or more times, then you should find a better way to do it.</p><p>Vim的Micro就是用来解决重复的问题</p></blockquote><p>宏就是批处理，类似于命令行脚本或者编程中的函数</p><p><code>h: operator</code>：查看操作符文档</p><p>简单操作</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>qa</code></td><td>开始录制⏺️宏到寄存器a🀄️</td></tr><tr><td><code>qA</code></td><td>追加宏，在寄存器a🀄️追加</td></tr><tr><td><code>n@a</code></td><td>执行n遍a寄存器中的操作</td></tr><tr><td><code>@@</code></td><td>再执行一遍上一次操作</td></tr><tr><td><code>:n,mnormal @a</code></td><td>n到m行执行寄存器a宏操作</td></tr><tr><td><code>:let @a= &#39;</code></td><td>编辑宏a寄存器</td></tr></tbody></table><p>宏最佳操作</p><ul><li>规范光标位置：0</li><li>执行编辑和操作</li><li>移动光标到容易回放的位置：j</li></ul><p><code>Ctrl+a</code>：当前数字递增1</p><p>示例步骤：</p><ol><li><p>循环递增插入数字</p><pre><code class="shell"># 添加数字1i1Esc# 开始录制宏,此时光标在数字1行qa # 开始yy # 复制p # 粘贴q # 结束# 执行宏操作10@a</code></pre><pre><code></code></pre></li><li><p>为多行添加注释</p><pre><code class="shell"># 开始录制宏,此时光标在需注释行首qb # 开始i # 进入编辑模式`# ` # 添加注释Esc # 退出编辑模式^ # 移动到行首j # 光标下行移动q # 结束</code></pre></li></ol><p>宏保存</p><ul><li><code>viminfo</code>/<code>vimrc file</code></li><li>保存历史和非空寄存器</li><li>vim启动时读取</li><li>容易被覆盖</li></ul><h3 id="4-4-Visual-模式-15-51"><a href="#4-4-Visual-模式-15-51" class="headerlink" title="4-4 Visual 模式 (15:51)"></a>4-4 Visual 模式 (15:51)</h3><blockquote><p>在可视化模式下，可以对一个文本块的整体进行操作</p></blockquote><p>三种子模式</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>v</code></td><td>激活面向字符的可视化模式</td></tr><tr><td><code>V</code>/<code>shift+v</code></td><td>激活面向行的可视化模式</td></tr><tr><td><code>command+v</code></td><td>激活面向列块的可视化模式</td></tr></tbody></table><p>字符可视化模式=&gt;行可视化模式=&gt;块可视化模式</p><p>可视化模式操作</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>gv</td><td>重选上次的高亮选区</td></tr><tr><td>o</td><td>切换选取边界</td></tr></tbody></table><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="5-1-课程总结-03-18"><a href="#5-1-课程总结-03-18" class="headerlink" title="5-1 课程总结 (03:18)"></a>5-1 课程总结 (03:18)</h3><ol><li><p>Vim模式（四种）</p><p>普通模式、编辑模式、可视化模式、命令行模式</p></li><li><p>Vim组合 {operation}{motion}</p><p>增查删改</p></li><li><p>Vim配置多样性</p><p>配置文件.vimrc、Vim插件</p></li><li><p>Vim视图多样性</p><p>缓冲区、多文件编辑、多窗口、标签分组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1052-Git入门</title>
      <link href="/imooc/1052-Git/"/>
      <url>/imooc/1052-Git/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1052" target="_blank" rel="noopener">https://www.imooc.com/learn/1052</a></p><p>简介：本课程主要通过命令行和图形界面工具来介绍Git的安装、仓库创建、工作流、远程仓库、克隆仓库、标签管理和分支管理等Git的主要内容。</p></blockquote><p>@[TOC]</p><h2 id="第1章-概述"><a href="#第1章-概述" class="headerlink" title="第1章 概述"></a>第1章 概述</h2><blockquote><p>主要介绍Git的作用以及安装过程。</p></blockquote><h3 id="1-1-为什么学习git"><a href="#1-1-为什么学习git" class="headerlink" title="1-1 为什么学习git"></a>1-1 为什么学习git</h3><blockquote><p>作者：Linus Torvalds，同时也是Linux的作者。</p><p>版本控制：记录所有文件的所有版本，可以有效地追踪文件的变化。同时很容易回到之前的状态</p></blockquote><p>为什么学习Git：</p><ul><li>牛通的互联网、牛逼的大神们都在用</li><li>完整的版本控制功能，解决多人协作的问题</li><li>提高开发效率</li><li>如果你是程序猿,请务必学Git，井习惯把日己的代码同步到GitHub上</li></ul><p>注：Git不等于 GitHub大家注意了! Git和GitHub就是球和球场的关系!</p><p>课程安排：</p><blockquote><p>Git介绍<br>Git安装（命令行、图形化界面）<br>Git工作流<br>本地与远程仓库<br>分支管理<br>标签管理</p></blockquote><h3 id="1-2-Git安装"><a href="#1-2-Git安装" class="headerlink" title="1-2 Git安装"></a>1-2 Git安装</h3><p>命令行：</p><ul><li><p>下载Window Git</p></li><li><p>Msysgit <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p></li><li><p>配置用户信息</p><pre><code class="shell"># git bashgit config --global user.name &quot;tyk&quot;git config --global user.email &quot;tyk@163.com&quot;</code></pre></li><li><p>查看用户名邮箱是否配置成功</p><pre><code class="shell">git config --list</code></pre></li></ul><p>图形化界面：</p><ul><li>下载安装SourceTree <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">https://www.sourcetreeapp.com/</a></li><li>注册登录</li></ul><h2 id="第2章-Git仓库创建及工作量"><a href="#第2章-Git仓库创建及工作量" class="headerlink" title="第2章 Git仓库创建及工作量"></a>第2章 Git仓库创建及工作量</h2><blockquote><p>主要介绍Git如何创建仓库以及工作流的内容。</p></blockquote><h3 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2-1 创建仓库"></a>2-1 创建仓库</h3><ul><li><p>初始化版本库</p><pre><code class="shell">git init</code></pre></li><li><p>添加文件到版本库</p><pre><code class="shell">git addgit commit</code></pre></li><li><p>查看仓库状态</p><pre><code class="shell">git status</code></pre></li></ul><p>创建Git仓库：</p><pre><code class="shell">mkdir democd demogit init # 初始化版本库ls -a # 查看所有文件（包含隐藏文件）echo &quot;git repo&quot; &gt;&gt; test.txt # 创建文件并追加输入内容git add test.txt # 添加文件到版本库git commit -m &quot;repo first commit&quot; # 提交文件到本地仓库git status # 查看仓库状态git push -f origin master # 将本地仓库内容同步到远程仓库</code></pre><h3 id="2-2-工作流"><a href="#2-2-工作流" class="headerlink" title="2-2 工作流"></a>2-2 工作流</h3><pre><code class="shell">git add &lt;file&gt;   # 将文件从本地工作区上传到暂存区git commit -m &quot;说明操作内容&quot;  # 将暂存区的文件上传到本地仓库git reset HEAD &lt;file&gt; # 将本地仓库的内容返回到暂存区git checkout -- 文件名 # 清除工作区git log # 查询提交记录的commit号git reset --hard &lt;commit_id&gt; # 将本地仓库和暂存区的内容全部回滚到commit号提交时的内容git rm &lt;file&gt; # 清空文件git rm --cached # 清除工作区里暂存区没有的文件git checkout HEAD &lt;file&gt; # 用最终仓库的文件替换掉暂存区和工作区的</code></pre><p>Git工作流：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigfvzdzj30pk0bzta6.jpg" width="600" alt="Git工作流"/><h2 id="第3章-Git主要功能"><a href="#第3章-Git主要功能" class="headerlink" title="第3章 Git主要功能"></a>第3章 Git主要功能</h2><blockquote><p>主要介绍Git远程仓库、克隆仓库、标签管理和分支管理的主要内容。</p></blockquote><h3 id="3-1-远程仓库"><a href="#3-1-远程仓库" class="headerlink" title="3-1 远程仓库"></a>3-1 远程仓库</h3><p>创建SSH Key</p><pre><code class="shell">ssh-keygen -t rsa -C &quot;github_registry_mail@github.com&quot;cd .ssh/cat id_rsa.pub</code></pre><p>GitHub设置：</p><p>​    [GitHub首页]-[个人头像]-[Settings]-[SSH and GPG keys]-[New SSH key]</p><p>查看本地是否与Github关联</p><pre><code class="shell">ssh -T git@github.com</code></pre><p>添加远程仓库</p><pre><code class="shell">git remote add origin git@github.com:tuyrk/demo.gitgit pull origin master --allow-unrelated-historiesgit push -u origin master</code></pre><p>在GitHub创建新仓库：</p><p>​    [GitHub首页]-[加号]-[New repository]-[Create repository]</p><p>将本地仓库提交到远程</p><pre><code class="shell">echo &quot;# demo&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:tuyrk/demo.gitgit push -u origin master</code></pre><p>将远程仓库克隆到本地</p><pre><code class="shell">git remote add origin git@github.com:tuyrk/demo.gitgit push -u origin master</code></pre><h3 id="3-2-克隆仓库"><a href="#3-2-克隆仓库" class="headerlink" title="3-2 克隆仓库"></a>3-2 克隆仓库</h3><pre><code class="shell">git clone git@github.com:tuyrk/demo.git # 路径为GitHub中SSH路径</code></pre><p>流程：</p><ol><li>将远程仓库GitHub中的代码克隆一份到本地</li><li>在本地进行开发</li><li>开发完之后将代码推送到远程仓库</li></ol><h3 id="3-3-标签管理"><a href="#3-3-标签管理" class="headerlink" title="3-3 标签管理"></a>3-3 标签管理</h3><pre><code class="shell">git tag # 查看所有标签git tag &lt;name&gt; # 创建标签git tag -a &lt;name&gt; -m &quot;comment&quot; # 指定提交信息git tag -d &lt;name&gt; # 删除标签git push origin &lt;name&gt; # 标签发布git checkout &lt;name&gt; # 切换标签-快照git checkout -b &lt;分支名称&gt; &lt;tag标签名称&gt; # 切换标签-编辑</code></pre><h3 id="3-4-分支管理"><a href="#3-4-分支管理" class="headerlink" title="3-4 分支管理"></a>3-4 分支管理</h3><pre><code class="shell">git branch # 查看所有分支，“*”代表当前所在分支git branch &lt;分支名称&gt; # 创建分支git checkout &lt;分支名称&gt; # 切换分支git merge &lt;分支名称&gt; # 合并到master分支。首先需切换到master分支，然后进行合并git branch -d &lt;分支名称&gt; # 删除分支</code></pre><h2 id="第4章-课程总结"><a href="#第4章-课程总结" class="headerlink" title="第4章 课程总结"></a>第4章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="4-1-课程总结"><a href="#4-1-课程总结" class="headerlink" title="4-1 课程总结"></a>4-1 课程总结</h3><ul><li><p>介绍与安装</p></li><li><p>工作流</p><p>[工作区]=&gt;[暂存区]=&gt;[版本库]</p></li><li><p>初始化</p><pre><code class="shell">git initgit addgit commit</code></pre></li><li><p>远程仓库</p><pre><code class="shell">git remote addgit pullgit pushgit clone</code></pre></li><li><p>分支管理</p><pre><code class="shell">git branchgit checkoutgit merge</code></pre></li><li><p>标签管理</p><pre><code class="shell">git taggit push</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>390-版本控制入门 – 搬进 Github</title>
      <link href="/imooc/390-Github/"/>
      <url>/imooc/390-Github/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/390" target="_blank" rel="noopener">https://www.imooc.com/learn/390</a></p><p>简介：版本控制能够大大提高程序员的工作效率，但是通常会涉及到命令行操作，学习曲线陡峭。本课程中使用 Github 网站和图形化客户端来完成版本控制工作，提供一套简单实用的流程，配合图解方式的原理讲解，让大家以最短的时间上手 Git 和 Github 。</p></blockquote><p><a href="https://gitbeijing.com/" target="_blank" rel="noopener">https://gitbeijing.com/</a></p><p>@[TOC]</p><h2 id="第1章-Github课程介绍"><a href="#第1章-Github课程介绍" class="headerlink" title="第1章 Github课程介绍"></a>第1章 Github课程介绍</h2><blockquote><p>阐述本课程的覆盖内容，适合观众。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>Git和Linux之父，Linus</p><blockquote><p>我是个自负的混蛋，所有我的项目都以我自己的名字命名，先有Linux，现在是Git.<br>–Linus</p></blockquote><p>Global Information Tracker：全局信息跟踪器</p><p>Git：版本控制工具</p><p><a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p><h2 id="第2章-浏览器中使用-Github"><a href="#第2章-浏览器中使用-Github" class="headerlink" title="第2章 浏览器中使用 Github"></a>第2章 浏览器中使用 Github</h2><blockquote><p>不会用 Git，其实也可以直接使用 Github 来进行基本的版本控制操作的。</p></blockquote><h3 id="2-1-浏览器中使用Github"><a href="#2-1-浏览器中使用Github" class="headerlink" title="2-1 浏览器中使用Github"></a>2-1 浏览器中使用Github</h3><h2 id="第3章-Github-客户端的使用"><a href="#第3章-Github-客户端的使用" class="headerlink" title="第3章 Github 客户端的使用"></a>第3章 Github 客户端的使用</h2><blockquote><p>以 Mac 系统的客户端 Github For Mac 为例子来讲解，不过 Windows 系统上也有类似的客户端。</p></blockquote><h3 id="3-1-Github客户端的使用"><a href="#3-1-Github客户端的使用" class="headerlink" title="3-1 Github客户端的使用"></a>3-1 Github客户端的使用</h3><h2 id="第4章-简单分支操作"><a href="#第4章-简单分支操作" class="headerlink" title="第4章 简单分支操作"></a>第4章 简单分支操作</h2><blockquote><p>分支操作几乎是所有的 Git 高级操作的基础，本章来学会使用分支。</p></blockquote><h3 id="4-1-Github-简单分支操作"><a href="#4-1-Github-简单分支操作" class="headerlink" title="4-1 Github-简单分支操作"></a>4-1 Github-简单分支操作</h3><h2 id="第5章-分支合并"><a href="#第5章-分支合并" class="headerlink" title="第5章 分支合并"></a>第5章 分支合并</h2><blockquote><p>分支合并过程其实就是代码融合过程，会涉及到处理代码冲突的问题。</p></blockquote><h3 id="5-1-Github-合并分支（上）"><a href="#5-1-Github-合并分支（上）" class="headerlink" title="5-1 Github-合并分支（上）"></a>5-1 Github-合并分支（上）</h3><h3 id="5-2-Github-合并分支（下）"><a href="#5-2-Github-合并分支（下）" class="headerlink" title="5-2 Github-合并分支（下）"></a>5-2 Github-合并分支（下）</h3><h2 id="第6章-团队协作流程"><a href="#第6章-团队协作流程" class="headerlink" title="第6章 团队协作流程"></a>第6章 团队协作流程</h2><blockquote><p>Github 公司内部使用的工作流程 Github Flow，是 Git 多种协作流程中，最简单也是最流行的一套思路。本章来看看在团队内部如何应用这套流程。</p></blockquote><h3 id="6-1-Github-团队协作流程（上）"><a href="#6-1-Github-团队协作流程（上）" class="headerlink" title="6-1 Github-团队协作流程（上）"></a>6-1 Github-团队协作流程（上）</h3><h3 id="6-2-Github-团队协作流程（下）"><a href="#6-2-Github-团队协作流程（下）" class="headerlink" title="6-2 Github-团队协作流程（下）"></a>6-2 Github-团队协作流程（下）</h3><h2 id="第7章-开源项目贡献流程"><a href="#第7章-开源项目贡献流程" class="headerlink" title="第7章 开源项目贡献流程"></a>第7章 开源项目贡献流程</h2><blockquote><p>开源项目由于贡献者互相不认识，所以流程上必然是区别于团队流程的，但是本质上依然是基于 Pull Request 的 Github Flow。</p></blockquote><h3 id="7-1-开源项目贡献流程"><a href="#7-1-开源项目贡献流程" class="headerlink" title="7-1 开源项目贡献流程"></a>7-1 开源项目贡献流程</h3><h2 id="第8章-Github-Issues"><a href="#第8章-Github-Issues" class="headerlink" title="第8章 Github Issues"></a>第8章 Github Issues</h2><blockquote><p>Issues 相当于项目论坛，集中讨论项目新功能，bug 修复以及任何项目相关的事情。会涉及到 Markdown 使用和多种技巧。</p></blockquote><h3 id="8-1-Github-Issues"><a href="#8-1-Github-Issues" class="headerlink" title="8-1 Github Issues"></a>8-1 Github Issues</h3><h2 id="第9章-Github-Pages-搭建网站"><a href="#第9章-Github-Pages-搭建网站" class="headerlink" title="第9章 Github Pages 搭建网站"></a>第9章 Github Pages 搭建网站</h2><blockquote><p>Github 提供了自己搭建项目网站的一套框架，非常的简单实用。</p></blockquote><h3 id="9-1-Github-Pages-搭建网站"><a href="#9-1-Github-Pages-搭建网站" class="headerlink" title="9-1 Github Pages 搭建网站"></a>9-1 Github Pages 搭建网站</h3><p><a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a></p><h2 id="第10章-Github-的秘密机关"><a href="#第10章-Github-的秘密机关" class="headerlink" title="第10章 Github 的秘密机关"></a>第10章 Github 的秘密机关</h2><blockquote><p>为了保证界面的简约美观，Github 的很多功能其实是隐藏的，例如一些非常能够提高工作效率的快捷键。</p></blockquote><h3 id="10-1-Github的秘密机关"><a href="#10-1-Github的秘密机关" class="headerlink" title="10-1 Github的秘密机关"></a>10-1 Github的秘密机关</h3><p>GitHub官网中搜索文件快捷键：T</p><p>GitHub社交化编程</p><p>怎么筛选学习内容？：可以追星</p><h2 id="第11章-Until-Next-Time-Goodbye"><a href="#第11章-Until-Next-Time-Goodbye" class="headerlink" title="第11章 Until Next Time, Goodbye!"></a>第11章 Until Next Time, Goodbye!</h2><blockquote><p>总结和下一步的学习建议。</p></blockquote><h3 id="11-1-Until-Next-Time-Goodbye-01-10"><a href="#11-1-Until-Next-Time-Goodbye-01-10" class="headerlink" title="11-1 Until Next Time, Goodbye! (01:10)"></a>11-1 Until Next Time, Goodbye! (01:10)</h3>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>208-版本管理工具介绍—Git篇</title>
      <link href="/imooc/208-Git/"/>
      <url>/imooc/208-Git/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/208" target="_blank" rel="noopener">https://www.imooc.com/learn/208</a></p><p>简介：本课程主要讲解了git在各平台的安装和基本使用，Git能够帮助我们解决文件的提交、检出、回溯历史、冲突解决、多人协作模式等问题，并且大大提升我们的工作效率。</p></blockquote><p>@[TOC]</p><h2 id="第1章-版本管理工具初探"><a href="#第1章-版本管理工具初探" class="headerlink" title="第1章 版本管理工具初探"></a>第1章 版本管理工具初探</h2><blockquote><p>聊聊版本管理工具是什么，它能为我们做什么。</p></blockquote><h3 id="1-1-版本管理工具简介"><a href="#1-1-版本管理工具简介" class="headerlink" title="1-1 版本管理工具简介"></a>1-1 版本管理工具简介</h3><p>版本管理工具是干什么用的？</p><ul><li>备份文件（类似U盘，网盘）</li><li>记录历史（有各个阶段的代码历史版本）</li><li>回到过去（恢复历史版本）</li><li>多端协作（可以在家工作，也可以在公司）</li><li>团队协作（代码整合，多人共同完成一个项目）</li></ul><h2 id="第2章-工具的历史"><a href="#第2章-工具的历史" class="headerlink" title="第2章 工具的历史"></a>第2章 工具的历史</h2><blockquote><p>聊聊cvs、svn、git、github这些工具的发展历史。</p></blockquote><h3 id="2-1-版本管理工具发展历史"><a href="#2-1-版本管理工具发展历史" class="headerlink" title="2-1 版本管理工具发展历史"></a>2-1 版本管理工具发展历史</h3><ol><li><p>CVS 1985，集中式，始祖（网络环境）</p><p>最早期的版本控制软件，是把文件集中保存到中心服务器</p></li><li><p>SVN 2000，集中式，集大成者（网络环境）</p><p>在CVS的基础上的加强版，可以还原到某个时间点</p></li><li><p>Git 2005，分布式，geek主流（无网环境）</p><p>分布式的版本控制软件</p></li><li><p>GitHub 2008，托管网站，geek社区（程序员托管网站）</p><p>网站托管，基于Git</p></li></ol><p>集中式：服务器。需要联网</p><p>分布式：效率高。拥有版本库即可（Git）</p><h2 id="第3章-如何做个英雄"><a href="#第3章-如何做个英雄" class="headerlink" title="第3章 如何做个英雄"></a>第3章 如何做个英雄</h2><blockquote><p>演示git和github的基本使用，提升工作效率，让我们在独立工作中成为英雄</p></blockquote><h3 id="3-1-Git下载和安装"><a href="#3-1-Git下载和安装" class="headerlink" title="3-1 Git下载和安装"></a>3-1 Git下载和安装</h3><p>安装Git环境一Windows：</p><ul><li>下载Github for Windows：<a href="https://desktop.github.com/" target="_blank" rel="noopener">https://desktop.github.com/</a></li></ul><h3 id="3-2-linux下安装Git环境"><a href="#3-2-linux下安装Git环境" class="headerlink" title="3-2 linux下安装Git环境"></a>3-2 linux下安装Git环境</h3><p>安装Git环境一Linux：</p><pre><code class="shell">yum install gitgit --help</code></pre><h3 id="3-3-github注册"><a href="#3-3-github注册" class="headerlink" title="3-3 github注册"></a>3-3 github注册</h3><p><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><h3 id="3-4-创建一个新的项目"><a href="#3-4-创建一个新的项目" class="headerlink" title="3-4 创建一个新的项目"></a>3-4 创建一个新的项目</h3><p><a href="https://github.com/new" target="_blank" rel="noopener">https://github.com/new</a></p><h3 id="3-5-Linux环境下检出项目到本地"><a href="#3-5-Linux环境下检出项目到本地" class="headerlink" title="3-5 Linux环境下检出项目到本地"></a>3-5 Linux环境下检出项目到本地</h3><pre><code class="shell">git clone https://github.com/tuyrk/demo.git</code></pre><h3 id="3-6-Linux环境下第一次提交项目"><a href="#3-6-Linux环境下第一次提交项目" class="headerlink" title="3-6 Linux环境下第一次提交项目"></a>3-6 Linux环境下第一次提交项目</h3><pre><code class="shell">vi log.txtgit add log.txtgit commit -m &quot;comment&quot;git pushgit config</code></pre><p>忽略修改：</p><ol><li>gitignore添加需要忽略的文件</li></ol><h3 id="3-7-windows下检出项目和提交项目"><a href="#3-7-windows下检出项目和提交项目" class="headerlink" title="3-7 windows下检出项目和提交项目"></a>3-7 windows下检出项目和提交项目</h3><h2 id="第4章-和其他英雄一起工作"><a href="#第4章-和其他英雄一起工作" class="headerlink" title="第4章 和其他英雄一起工作"></a>第4章 和其他英雄一起工作</h2><blockquote><p>演示如何通过git和github，让我们和其他英雄一起工作，减少和解决合作中出现的冲突</p></blockquote><h3 id="4-1-关于代码冲突"><a href="#4-1-关于代码冲突" class="headerlink" title="4-1 关于代码冲突"></a>4-1 关于代码冲突</h3><h3 id="4-2-Linux下如何解决冲突"><a href="#4-2-Linux下如何解决冲突" class="headerlink" title="4-2 Linux下如何解决冲突"></a>4-2 Linux下如何解决冲突</h3><p>解决冲突步骤：</p><ol><li>git pull拉取最新代码</li><li>git diff查看</li><li>手动修改提交哪次冲突</li><li>再次提交</li></ol><pre><code class="shell">git pullgit diffgit add log.txtgit commit -m &quot;解决冲突后提交&quot;git push origin master</code></pre><h3 id="4-3-windows下如何解决冲突"><a href="#4-3-windows下如何解决冲突" class="headerlink" title="4-3 windows下如何解决冲突"></a>4-3 windows下如何解决冲突</h3><h3 id="4-4-如何回到过去"><a href="#4-4-如何回到过去" class="headerlink" title="4-4 如何回到过去"></a>4-4 如何回到过去</h3><p>版本回滚操作步骤：</p><pre><code class="shell">git log # 显示所有提交记录.git reset --hard &lt;提交ID&gt; # 完成回滚操作git pushgit log # 显示新的提交记录</code></pre><p>版本跳转操作步骤：</p><pre><code class="shell">git reflog # 查看该用户的所有操作git reset --hard &lt;提交ID&gt; # 完成跳转到现在</code></pre><h3 id="4-5-建立里程碑"><a href="#4-5-建立里程碑" class="headerlink" title="4-5 建立里程碑"></a>4-5 建立里程碑</h3><p>里程碑，即版本号。标签</p><pre><code class="shell">git tag -a &lt;name&gt; -m &quot;comment&quot; # 创建标签git push origin &lt;name&gt;git checkout &lt;name&gt; # 切换标签git checkout -b &lt;分支名称&gt; &lt;name&gt; # 切换标签git tag -d &lt;name&gt; # 删除标签</code></pre><h3 id="4-6-分支开发之分支合并"><a href="#4-6-分支开发之分支合并" class="headerlink" title="4-6 分支开发之分支合并"></a>4-6 分支开发之分支合并</h3><pre><code class="shell">git branch &lt;分支名称&gt; # 创建分支git checkout &lt;分支名称&gt; # 切换分支git merge &lt;分支名称&gt; # 合并到master分支。首先需切换到master分支，然后进行合并git branch -d &lt;分支名称&gt; # 删除分支</code></pre><h3 id="4-7-分支开发之合并到master"><a href="#4-7-分支开发之合并到master" class="headerlink" title="4-7 分支开发之合并到master"></a>4-7 分支开发之合并到master</h3><p>通过Github网页合并分支</p><h3 id="4-8-关于多人合作的一些经验"><a href="#4-8-关于多人合作的一些经验" class="headerlink" title="4-8 关于多人合作的一些经验"></a>4-8 关于多人合作的一些经验</h3><p><strong>利用工具提升工作效率，而不是去学习工具本身</strong></p><ol><li>多用客户端和工具，少用命令行，除非在linux服务器上直接开发</li><li>每次提交前，diff自己的代码，以免提交错误的代码</li><li>下班回家前，整理好自己的工作区</li><li>并行的项目，使用分支开发</li><li>遇到冲突时，搞明白冲突的原因，千万不要随意丢弃别人的代码</li><li>产品发布后，记得打tag，方便将来拉分支修bug</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo重新发布后GitPages自定义域名失效</title>
      <link href="/hexo-gitpages-invalid/"/>
      <url>/hexo-gitpages-invalid/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 <code>Github Pages</code> 功能将博客托管在了 Github 上，并配置 <code>CNAME</code> 将自己的域名解析了过去，在 <code>Github</code> 的仓库设置中开始 <code>Custom domain</code> 的功能，这时候就可以直接使用自己的域名访问啦。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8felp76szj311g0u00u4.jpg" alt="GitHub Pages" style="zoom:40%;" /><p>但是发现一个问题是，每次配置 <code>Custom domain</code> 之后，再次 <code>hexo deploy</code> 之后，<code>Custom domain</code> 会被重置失效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 <code>hexo</code> 生成的博客的 <code>source</code> 目录下新建一个 <code>CNAME</code> 文件，然后在这个文件中填入你的域名，最后重新部署hexo。这样就不会每次发布之后，<code>Github pages</code> 里的 <code>Custom domain</code> 都被重置掉啦。</p><pre><code class="shell">vim ource/CNAME</code></pre><pre><code class="shell">www.tuyrk.cn</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 同时管理Github和Gitee</title>
      <link href="/git-manage-github-gitee/"/>
      <url>/git-manage-github-gitee/</url>
      
        <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="1-取消git全局配置"><a href="#1-取消git全局配置" class="headerlink" title="1.取消git全局配置"></a>1.取消git全局配置</h2><blockquote><p>取消全局的user.name和user.email</p></blockquote><pre><code class="shell">git config --global --unset user.name &quot;xxx&quot;git config --global --unset user.email &quot;xxx&quot;</code></pre><p>其中<code>xxx</code>是以前配置的信息，可以通过 下边命令查看</p><pre><code class="shell">git config --global --list</code></pre><h2 id="2-生成new的ssh-keys"><a href="#2-生成new的ssh-keys" class="headerlink" title="2.生成new的ssh keys"></a>2.生成new的ssh keys</h2><blockquote><p>如果需要github和gitee都能存在，那么就需要生成github和gitee的id_rsa， 然后放在一起</p></blockquote><ol><li><p>生成Github 和 Gitee的keys</p><pre><code class="shell">ssh-keygen -t rsa -f ~/.ssh/id_rsa.github -C &quot;xxx&quot;</code></pre><p>注：其中<code>xxx</code>是github平台的注册邮箱</p><pre><code class="shell">ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C &quot;...&quot;</code></pre><p>注：其中<code>...</code>是你gitee平台的注邮箱</p></li><li><p>将生成的新keys添加到ssh agent</p><pre><code class="shell">ssh-agent bash</code></pre><pre><code class="shell">ssh-add ~/.ssh/id_rsa.githubssh-add ~/.ssh/id_rsa.giteeexit</code></pre></li><li><p>配置config文件</p><blockquote><p>在.ssh文件夹下面配置config文件</p></blockquote><pre><code class="shell">vim ~/.ssh/config</code></pre><pre><code class="shell"># githubHost github.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.githubPort 443# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa.gitee</code></pre></li></ol><h2 id="3-平台设置SSH"><a href="#3-平台设置SSH" class="headerlink" title="3.平台设置SSH"></a>3.平台设置SSH</h2><blockquote><p>钥匙和配置文件搞定后，就需要将我们的公钥放入到我们的平台中了</p></blockquote><ol><li><p>Github：复制<code>~/.ssh/id_rsa.github.pub</code>的内容到Github公钥</p><p>Settings &gt; SSH and GPG keys &gt; New SSH key</p></li><li><p>Gitee：复制<code>~/.ssh/id_rsa.gitee.pub</code>的内容到Gitee公钥</p><p>设置 &gt; 安全设置 &gt; SSH公钥</p></li></ol><h2 id="4-测试是否成功"><a href="#4-测试是否成功" class="headerlink" title="4.测试是否成功"></a>4.测试是否成功</h2><ol><li><p>Github</p><pre><code class="shell">ssh -T git@github.com</code></pre><p>结果：</p><pre><code>Hi 766564616! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre></li><li><p>Gitee</p><pre><code class="shell">ssh -T git@gitee.com</code></pre><p>结果：</p><pre><code>Hi 神秘的小岛岛! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.</code></pre></li></ol><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol><li><p>Bad owner or permissions on /Users/tuyuankun/.ssh/config</p><pre><code class="shell">sudo chmod 600 config ~/.ssh/config</code></pre></li><li><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>@     WARNING: UNPROTECTED PRIVATE KEY FILE!     @</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>Permissions 0777 for ‘/Users/tuyuankun/.ssh/id_rsa.gitee’ are too open.</p><p>It is required that your private key files are NOT accessible by others.</p><p>This private key will be ignored.</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>@     WARNING: UNPROTECTED PRIVATE KEY FILE!     @</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>Permissions 0777 for ‘/Users/tuyuankun/.ssh/id_rsa.github’ are too open.</p><p>It is required that your private key files are NOT accessible by others.</p><p>This private key will be ignored.</p><pre><code class="shell">sudo chmod 700 ~/.ssh/id_rsa.gitee ~/.ssh/id_rsa.github</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-hexo快捷键说明</title>
      <link href="/3-hexo-shortcuts/"/>
      <url>/3-hexo-shortcuts/</url>
      
        <content type="html"><![CDATA[<p>快捷键为vim风格的。按键可能与vimium（chrome插件）的快捷键有冲突，插件设置屏蔽掉此站的快捷键即可</p><p>如果有比较好的建议，欢迎骚扰。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><table><thead><tr><th align="left">Key</th><th align="left">Descption</th></tr></thead><tbody><tr><td align="left">ESC</td><td align="left">1.如果输入框有内容，清除内容 2.如果输入框无内容，失去焦点</td></tr><tr><td align="left">i/I</td><td align="left">获取焦点</td></tr><tr><td align="left">下</td><td align="left">向下选择文章</td></tr><tr><td align="left">上</td><td align="left">向上选择文章</td></tr><tr><td align="left">回车</td><td align="left">打开当前选中的文章，若没有，则默认打开第一个</td></tr></tbody></table><h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><table><thead><tr><th align="left">Key</th><th align="left">Descption</th></tr></thead><tbody><tr><td align="left">s/S</td><td align="left">全屏/取消全屏</td></tr><tr><td align="left">w/W</td><td align="left">打开/关闭文章目录</td></tr><tr><td align="left">j/J</td><td align="left">向下滑动</td></tr><tr><td align="left">k/K</td><td align="left">向上滑动</td></tr><tr><td align="left">gg/GG</td><td align="left">到最顶端</td></tr><tr><td align="left">shift+G/g</td><td align="left">到最下端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS配置OpenVPN之Tunnelblick</title>
      <link href="/MacOS-OpenVPN/"/>
      <url>/MacOS-OpenVPN/</url>
      
        <content type="html"><![CDATA[<blockquote><p>链接公司内网需要使用到OpenVPN，之前在Windows系统直接使用公司提供的<a href="https://openvpn.net/community-downloads/" target="_blank" rel="noopener">OpenVPN客户端</a>，但是似乎没有Mac版，所以使用了<a href="https://tunnelblick.net/index.html" target="_blank" rel="noopener">Tunnelblick工具</a>，下边记录一下在使用中遇到的一些问题。</p></blockquote><ol><li><p>下载⏬<a href="https://tunnelblick.net/index.html" target="_blank" rel="noopener">Tunnelblick工具</a>，安装</p></li><li><p>准备<code>*.ovpn</code>、<code>*.key</code>、<code>*.crt</code>在同一目录下</p><ul><li><p>问题一：<code>“comp-lzo” 在openvpn 2.4 中已弃用,将会在未来的版本中移除。</code></p><p>解决：<a href="https://github.com/Nyr/openvpn-install/issues/430" target="_blank" rel="noopener">https://github.com/Nyr/openvpn-install/issues/430</a></p><p>在<code>*.ovpn</code>使用<code>compress lzo</code>代替<code>comp-lzo</code> </p></li><li><p>问题二：<code>• &#39;ns-cert-type&#39; 这个选项在 OpenVPN 2.4 版本的配置中是过时的，已经在 OpenVPN 2.5 版本中移除。</code></p><p>解决：在<code>*.ovpn</code>使用<code>remote-cert-tls server</code>代替<code>ns-cert-type server</code></p></li><li><p>问题三：<code>unrecognized option or missing or extra parameter(s) ip-win32 (2.4.7)</code></p><p>解决：由于脚本是公司为Windows系统提供的，所以我在这里直接注释这个。</p><pre><code class="shell"># ip-win32 dynamic -1# route-method exe</code></pre></li></ul></li><li><p>点击<code>*.ovpn</code>、连接</p></li></ol><p><strong>==OpenVPN中不推荐使用的选项==</strong>：<a href="https://community.openvpn.net/openvpn/wiki/DeprecatedOptions" target="_blank" rel="noopener">https://community.openvpn.net/openvpn/wiki/DeprecatedOptions</a></p><p>OpenVPN客户端配置文件详解：<a href="https://blog.faystar.com/openvpn_client/" target="_blank" rel="noopener">https://blog.faystar.com/openvpn_client/</a></p><pre><code class="shell"># 定义是一个客户端client# 定义使用设备类型，与服务端一致;dev tapdev tun# 定义Windows下使用的网卡名称,linux不需要;dev-node 我的连接# 定义使用的协议，与服务端一致;proto tcpproto udp# 指定服务端地址和端口,可以用多行指定多台服务器# 实现负载均衡（从上往下尝试）remote 118.112.188.108 1194;remote my-server-2 1194# 若上面配置了多台服务器，让客户端随机连接;remote-random# 解析服务器域名# Keep trying indefinitely to resolve the# host name of the OpenVPN server.  Very useful# on machines which are not permanently connected# to the internet such as laptops.resolv-retry infinite# 客户端不需要绑定端口# Most clients do not need to bind to# a specific local port number.nobind# 也是为了让Openvpn也nobody运行（安全）# 注意：Windows不能设置;user nobody;group nobody# Try to preserve some state across restarts.persist-keypersist-tun# 若客户端通过HTTP Proxy，在这里设置# 要使用Proxy，不能使用UDP为VPN的通讯协议;http-proxy-retry # retry on connection failures;http-proxy [proxy server] [proxy port #]# 无线网络有很多多余的头文件，设置忽略它;mute-replay-warnings# 重点，就是指定ca和客户端的证书# 注意，下面的两个号是连在一起的，之间没有空格.需同时存在/注释ca &quot;ca.crt&quot;# cert &quot;test-1.crt&quot;# key &quot;test-1.key&quot;# 如果服务端打开了PAM认证模块，如mysql，LDAP数据库验证，客户端需要另其有效;auth-user-pass# 一些安全措施# Verify server certificate by checking# that the certicate has the nsCertType# field set to “server”.  This is an# important precaution to protect against# a potential attack discussed here:# http://openvpn.net/howto.html#mitm## To use this feature, you will need to generate# your server certificates with the nsCertType# field set to “server”.  The build-key-server# script in the easy-rsa folder will do this.remote-cert-tls server# 增强验证加密，如果你在服务器端生成了ta.key，那么这里就需要加上# then every client must also have the key.tls-auth ta.key 1# Select a cryptographic cipher.# If the cipher option is used on the server# then you must also specify it here.;cipher x# 使用lzo压缩，与服务端一致compress lzo# Set log file verbosity.verb 3# Silence repeating messages;mute 20#采用用户名密码方式验证,若不用证书的话,可以考虑这种方式,可以结合LDAP或者mysql;auth-user-pass#windows7上会报错,建议加上此行# route-method exe#强行指定添加路由前的延时route-delay 2#不存储验证缓存auth-nocache#设置IP地址过期时间# ip-win32 dynamic 0 7200</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>714-性能测试之LoadRunner</title>
      <link href="/imooc/714-LoadRunner/"/>
      <url>/imooc/714-LoadRunner/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/714" target="_blank" rel="noopener">https://www.imooc.com/learn/714</a></p><p>简介：性能测试的实施不仅仅是掌握LoadRunner即可，还需要进行性能测试设计与性能测试构建实施等。本课程的目标就是帮助各位朋友提高实战能力，让性能测试落地，接地气，课程中会拿实际案例作为分析手段进行演练，增强动手操作技能。 项目实战进阶推荐课程！！！ 性能测试 LoadRunner 工具实战-慕课网实战 <a href="http://coding.imooc.com/class/127.html" target="_blank" rel="noopener">http://coding.imooc.com/class/127.html</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>通过详细的细分教学，让学生理解什么是性能测试，性能测试的流程，使用Loadrunner做性能测试的步骤</p></blockquote><h3 id="1-1-性能测试学习内容指南-03-52"><a href="#1-1-性能测试学习内容指南-03-52" class="headerlink" title="1-1 性能测试学习内容指南 (03:52)"></a>1-1 性能测试学习内容指南 (03:52)</h3><p>目录：</p><ul><li>第一章 性能测试理论</li><li>第二章 LoadRunner的基本操作</li><li>第三章 系统的监控、分析与调优</li></ul><p>第一章 性能测试理论</p><ul><li>性能测试的<strong>常用术语</strong></li><li>性能测试的<strong>应用领域</strong></li><li>性能测试常用<strong>工具的原理</strong></li></ul><p>第二章 LoadRunner的基本操作</p><ul><li><p>LoadRunner的原理分析</p></li><li><p>LoadRunner脚本的开发流程</p><p>LoadRunner的<strong>三个组件</strong>：</p><ul><li>VuGen：基本设置、检查点、参数化、关联、调试、事务</li><li>Controller：场景设置、场景执行、资源监控、集合点、IP欺骗、负载均衡</li><li>Analysis：摘要报告、常见图分析、结果分析实践</li></ul></li></ul><p>第三章 系统的监控、分析、调优</p><ul><li>Windows/Linux的监控、分析、调优</li><li>数据库的监控、分析、调优</li><li>中间件的监控、分析、调优</li></ul><h2 id="第2章-主要概念介绍"><a href="#第2章-主要概念介绍" class="headerlink" title="第2章 主要概念介绍"></a>第2章 主要概念介绍</h2><blockquote><p>介绍性能测试的衍生史以及特点等。</p></blockquote><h3 id="2-1-性能测试理论-09-17"><a href="#2-1-性能测试理论-09-17" class="headerlink" title="2-1 性能测试理论 (09:17)"></a>2-1 性能测试理论 (09:17)</h3><p>目录：</p><ul><li>性能测试的概念及其分类</li><li>性能测试的流程</li><li>性能测试工具的原理</li></ul><p>软件系统的性能包括：执行效率、资源占用、系统稳定性、安全性、兼容性、可靠性、可扩展性</p><p>性能测试的概念：</p><blockquote><p>性能测试主要通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。</p></blockquote><p>性能测试常见分类：</p><ul><li><p>性能测试（狭义）</p><p>方法：通过模拟业务生产运行的业务压力量和使用场景组合，测试系统的性能是否满足生产性能的要求</p><p>目的：验证系统是否具有系统宣称的能力</p></li><li><p>负载测试</p><p>方法：通过在被测系统上不断加压，直到性能指标达到极限</p><p>目的：找到系统处理能力的极限</p></li><li><p>压力测试（强度测试）</p><p>方法：测试系统在一定饱和状态下，系统能够处理的会话能力，以及系统是否会出现错误</p><p>目的：检查系统处于压力性能下时，应用的表现</p></li><li><p>并发测试</p><p>方法：通过模拟用户并发访问，测试多用户并发访问同一个应用、模块或者数据记录时是否存在死锁或其他性能问题</p><p>目的：发现系统中可能隐藏的并发访问时的问题</p></li><li><p>配置测试</p><p>方法：通过对被测系统的软硬件环境进行调整，了解不同软硬件环境对系统的性能的影响程度，从而找到系统各项资源的最优分配原则</p><p>目的：了解各种不同因素对系统性能的影响程度</p></li><li><p>可靠性测试（稳定性测试）</p><p>方法：在给系统加载一定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定</p><p>目的：验证系统是否支持长期稳定的运行</p></li></ul><p>系统测试的流程：</p><ol><li>测试计划阶段<ul><li>明确测试对象</li><li>定义测试目标</li><li>定义测试通过的标准</li><li>规划测试进度</li><li>规划测试参与人员（需求、开发、测试、运维和配置）</li><li>申请测试资源</li><li>风险控制</li></ul></li><li>测试设计阶段<ul><li>设计测试数据</li><li>设计测试用例</li><li>设计测试场景</li></ul></li><li>测试开发阶段<ul><li>测试环境搭建</li><li>测试过程文档定义以及配置</li><li>测试脚本开发、调试</li><li>测试数据准备</li><li>基准测试</li></ul></li><li>测试执行阶段<ul><li>执行测试模型，包括执行脚本和场景</li><li>测试过程监控，包括查看log、监控服务器资源、数据库和中间件等</li></ul></li><li>测试结果分析阶段<ul><li>根据测试结果和监控结果进行测试分析</li><li>根据性能测试目标，分析出系统存在的性能瓶颈，并给出优化建议</li></ul></li><li>测试报告阶段<ul><li>测试范围</li><li>测试执行以及参与人员</li><li>基准测试数据</li><li>测试执行的详细步骤（场景设计）</li><li>测试数据记录、监控结果</li><li>测试结果对比以及总结性评价</li></ul></li></ol><p>性能测试工具(LoadRunner、JMeter)组成：</p><blockquote><p>脚本生成器、压力生成器、压力控制器、结果分析器</p></blockquote><p>性能测试工具🔧的原理：</p><p>LoadRunner其实是一个代理，代理客户端和服务器之间的中间人。</p><p>LoadRunner通过代理截获客户端和服务器之间的交互数据流</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghjr9kftj31m40g4dip.jpg" alt="性能测试工具🔧的原理" style="zoom:30%;" /><h2 id="第3章-工具的安装和启动"><a href="#第3章-工具的安装和启动" class="headerlink" title="第3章 工具的安装和启动"></a>第3章 工具的安装和启动</h2><blockquote><p>Loadrunner的下载和安装注意事项；Web Tours服务的启动和功能介绍</p></blockquote><h3 id="3-1-Loadrunner的安装与介绍-07-04"><a href="#3-1-Loadrunner的安装与介绍-07-04" class="headerlink" title="3-1 Loadrunner的安装与介绍 (07:04)"></a>3-1 Loadrunner的安装与介绍 (07:04)</h3><p>安装LoadRunner(<strong>==Windows版==</strong>)：</p><ul><li>下载地址⏬：<a href="https://pan.baidu.com/s/1XzfbZ7r6OlV1T61IA-mGvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XzfbZ7r6OlV1T61IA-mGvQ</a> 密码:1sbr</li></ul><p>LoadRunner的组件：</p><ul><li>Virtual User Generator：录制最终用户业务流程并创建性能测试脚本</li><li>Controller：组织、驱动、管理并监控负载测试</li><li>Analysis：用于查看、剖析和比较性能结果</li></ul><p>LoadRunner的功能：</p><ul><li>轻松创建虚拟用户</li><li>创建真实的负载</li><li>分析结果以精确定位问题所在</li><li>重复测试保证系统发布的高性能</li></ul><h3 id="3-2-HP-Web-Tours使用-05-01"><a href="#3-2-HP-Web-Tours使用-05-01" class="headerlink" title="3-2 HP Web Tours使用 (05:01)"></a>3-2 HP Web Tours使用 (05:01)</h3><p>启动Web Tours服务</p><pre><code>/HP/LoadRunner/WebTours/StartServer.bat</code></pre><p>访问Web Tours</p><pre><code>http://127.0.0.1:1080/WebTours/</code></pre><p>帐号：jojo  密码：bean</p><p>Web Tours功能介绍：</p><blockquote><p>注册，登录，订票，查看历史订票记录，取消订票，退出</p></blockquote><h2 id="第4章-录制测试脚本"><a href="#第4章-录制测试脚本" class="headerlink" title="第4章 录制测试脚本"></a>第4章 录制测试脚本</h2><blockquote><p>介绍VUGen录制脚本的步骤，介绍Loadrunner的两种录制选项；录制登录、订票、查询和退出等操作流程；对录制的脚本进行参数化和关联等增强，使得脚本能回放成功；介绍参数化不同选项组合的用途</p></blockquote><h3 id="4-1-录制选项-07-39"><a href="#4-1-录制选项-07-39" class="headerlink" title="4-1 录制选项 (07:39)"></a>4-1 录制选项 (07:39)</h3><h3 id="4-2-录制脚本前概念-11-10"><a href="#4-2-录制脚本前概念-11-10" class="headerlink" title="4-2 录制脚本前概念 (11:10)"></a>4-2 录制脚本前概念 (11:10)</h3><h3 id="4-3-调试脚本-31-59"><a href="#4-3-调试脚本-31-59" class="headerlink" title="4-3 调试脚本 (31:59)"></a>4-3 调试脚本 (31:59)</h3><h2 id="第5章-创建测试场景"><a href="#第5章-创建测试场景" class="headerlink" title="第5章 创建测试场景"></a>第5章 创建测试场景</h2><blockquote><p>从脚本到创建场景，再到运行场景的流程做详细讲解</p></blockquote><h3 id="5-1-设置并执行场景-25-18"><a href="#5-1-设置并执行场景-25-18" class="headerlink" title="5-1 设置并执行场景 (25:18)"></a>5-1 设置并执行场景 (25:18)</h3><h2 id="第6章-分析测试结果"><a href="#第6章-分析测试结果" class="headerlink" title="第6章 分析测试结果"></a>第6章 分析测试结果</h2><blockquote><p>Loadrunner结果的分析和导出报告</p></blockquote><h3 id="6-1-测试结果分析-09-41"><a href="#6-1-测试结果分析-09-41" class="headerlink" title="6-1 测试结果分析 (09:41)"></a>6-1 测试结果分析 (09:41)</h3><h2 id="第7章-课程总结"><a href="#第7章-课程总结" class="headerlink" title="第7章 课程总结"></a>第7章 课程总结</h2><blockquote><p>通过本课程，我们学习和理解了使用Loadrunner做性能测试的步骤和方法。</p></blockquote><h3 id="7-1-性能测试框架基础课程总结-03-29"><a href="#7-1-性能测试框架基础课程总结-03-29" class="headerlink" title="7-1 性能测试框架基础课程总结 (03:29)"></a>7-1 性能测试框架基础课程总结 (03:29)</h3>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> LoadRunner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>735-JMeter性能测试入门篇</title>
      <link href="/imooc/735-JMeter/"/>
      <url>/imooc/735-JMeter/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/735" target="_blank" rel="noopener">https://www.imooc.com/learn/735</a></p><p>简介：本课程通过通俗易懂的讲法，非常容易理解的方式去讲解如何使用jmeter进行web应用的性能测试。</p></blockquote><p>@[TOC]</p><h2 id="第1章-jmeter基本介绍"><a href="#第1章-jmeter基本介绍" class="headerlink" title="第1章 jmeter基本介绍"></a>第1章 jmeter基本介绍</h2><blockquote><p>了解Jmeter及本课程的主要内容，知道如何下载到Jmeter；了解Jmeter的组成并了解性能测试工具的组成；了解jmeter的目录及为什么使用jmeter</p></blockquote><h3 id="1-1-Jmeter整体简介-20-20"><a href="#1-1-Jmeter整体简介-20-20" class="headerlink" title="1-1 Jmeter整体简介 (20:20)"></a>1-1 Jmeter整体简介 (20:20)</h3><p>软件架构：</p><ul><li><p>BS：browser-server</p></li><li><p>CS：client-server</p></li></ul><p>Jmeter简介：</p><ul><li><p>官网：<a href="https://jmeter.apache.org/" target="_blank" rel="noopener">https://jmeter.apache.org/</a></p></li><li><p>需要Java环境作为支撑。</p></li></ul><p>下载：<a href="http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-5.1.1.zip" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache//jmeter/binaries/apache-jmeter-5.1.1.zip</a></p><p>Jmeter组成：</p><ul><li><p>取样器</p><p>进行脚本逻辑控制（控制业务流程。什么样的请求，什么时候发出请求等）</p></li><li><p>线程组</p><p>场景设置（多少线程。多少用户访问，访问多少次等）</p></li><li><p>监视器</p><p>监控我们的脚本运行，取得性能指标（电量等）</p></li></ul><p>任何一款性能测试工具都应该是由这三部分组成</p><p>Jmeter操作：</p><ol><li><p>添加线程组(Thread Group)：[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p><p>Thread Properties（线程属性）</p><ul><li>Numbers of Threads(users)：控制多少用户进行并发</li></ul></li></ol><ul><li>Ramp-UpPeriod(in seconds)：在多少秒之内进行并发。加压策略<ul><li>Loop Count：循环次数</li></ul></li></ul><ol start="2"><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加监听器(Listener)</p><ul><li><p>查看结果树(View Results Tree)：[Thread Group]-[Add]-[Listener]-[View Results Tree]</p><p>【查看结果树(View Results Tree)】辅助进行脚本调试</p></li><li><p>聚合报告(Aggregate Report)：[Thread Group]-[Add]-[Listener]-[Aggregate Report]</p><p>统计访问了多少次，访问时间，错误率</p></li></ul></li><li><p>逻辑控制器(Logic Controller)</p></li><li><p>配置元件(Congif Element)</p><p>如果在压测过程中出现no cookies信息，就添加HTTP Header Manager、HTTP Cookie Manager</p></li><li><p>定时器(Timer)</p></li><li><p>前置处理器(Pre Processors)</p><p>在做取样器(Sampler)之前需要做些什么操作</p></li><li><p>后置处理器(Post Processors)</p></li><li><p>断言(Assertions)</p><p>在后置处理器(Post Processors)之后判断返回是否和期望值一致。</p><p>在做多并发处理时，不建议使用JMeter进行断言。在访问请求时自定义了变量，由于多个请求访问速度的影响，共享的一个变量就有可能出现数据的不准确。</p></li><li><p>测试碎片(Test Fragment)</p></li></ol><h2 id="第2章-使用badboy录制jmeter脚本"><a href="#第2章-使用badboy录制jmeter脚本" class="headerlink" title="第2章 使用badboy录制jmeter脚本"></a>第2章 使用badboy录制jmeter脚本</h2><blockquote><p>熟悉jmeter的录制方式及如何思考去制作一个脚本；了解badboy的组成；学会使用badboy录制脚本；能够使用jmeter将badboy脚本调试运行成功</p></blockquote><h3 id="2-1-Jmeter录制方式和思路及badboy简介-10-10"><a href="#2-1-Jmeter录制方式和思路及badboy简介-10-10" class="headerlink" title="2-1 Jmeter录制方式和思路及badboy简介 (10:10)"></a>2-1 Jmeter录制方式和思路及badboy简介 (10:10)</h3><p>JMeter脚本的两种录制方式：</p><ul><li><p>使用badboy进行录制</p><p>badboy(也是一款软件)能够进行浏览器的操作行为的录制，并且能够导出JMeter脚本。</p></li><li><p>使用代理方式进行录制</p><p>代理方式是指不借助第三方软件，然后进行浏览器中的一些设置。监听端口号捕捉在浏览器上的网络请求，然后进行录制</p><p>类似于抓包工具Fiddler。抓包工具：Fiddler、Charles、Wireshark</p></li></ul><p>脚本录制的流程与思路</p><blockquote><p>业务流程=&gt;录制工具=&gt;脚本制作=&gt;性能测试</p></blockquote><p>Badboy：<a href="http://www.badboy.com.au" target="_blank" rel="noopener">http://www.badboy.com.au</a></p><p>注：目前(2019-09-14)访问不了官网，Badboy似乎也没有Mac版。</p><p>Badboy组成：</p><blockquote><p>工具区、地址栏、脚本区、视图区</p></blockquote><p>Badboy介绍与演示</p><ol><li>地址栏输入地址</li><li>视图区进行操作</li><li>脚本区自动记录生成相应操作</li><li>点击工具栏小红点完成录制</li></ol><h3 id="2-2-使用badboy进行jmeter脚本录制-07-30"><a href="#2-2-使用badboy进行jmeter脚本录制-07-30" class="headerlink" title="2-2 使用badboy进行jmeter脚本录制 (07:30)"></a>2-2 使用badboy进行jmeter脚本录制 (07:30)</h3><p>BugFree：Bug管理系统。目前已由禅道代替。</p><p>Badboy进行JMeter脚本录制：</p><ol><li>地址栏输入地址</li><li>视图区进行录制步骤操作</li><li>脚本区自动记录生成相应操作</li><li>点击工具栏小红点完成录制</li><li>点击File=&gt;Export to JMeter=&gt;保存*.jmx文件</li></ol><p>.jmx后缀名就是JMeter可执行文件</p><h3 id="2-3-Jmeter运行badboy脚本-17-57"><a href="#2-3-Jmeter运行badboy脚本-17-57" class="headerlink" title="2-3 Jmeter运行badboy脚本 (17:57)"></a>2-3 Jmeter运行badboy脚本 (17:57)</h3><ol><li>点击File=&gt;Open(command+O)=&gt;选择*.jmx文件=&gt;Open</li><li>Thread Group出现了相应步骤</li><li>Thread Group=&gt;Add=&gt;Listener=&gt;View Results Tree</li><li>点击Start(工具栏上的绿色三角形)回放所有步骤</li></ol><p>【查看结果树】中的请求为绿色并不代表请求成功，而只是代表网络是否联通。通过HTML模式查看相应结果发现所有的返回页面都是登录界面</p><p>Redirect Automatically(自动重定向)</p><p>Follow Redirects(跟重定向)</p><p>Use KeepAlive(保持长链接)</p><p>Use multipart/form-data</p><p>Browser-compatible headers</p><p>第三方录制下来的脚本可能存在的出错点：</p><ol><li><p>检查是否登录系统</p></li><li><p>录制产生的URL与实际不同</p><p>根据网页路径修改</p></li><li><p>选择为[跟踪重定向]</p></li><li><p>录制后的脚本参数出现乱码</p><p>修改字符编码格式[Content encoding]为UTF8</p></li></ol><p>自动重定向与跟随重定向的区别：</p><ul><li><p>自动重定向：HttpClient接收到请求后，如果请求中包含重定向请求，HttpClient是可以自动跳转的，但是只针对GET和Head请求。勾选此项则“跟随重定向”失效。</p><p>自动重定向可以自动转向到最终目标页面，但是JMeter是不记录重定向过程内容的，比如在[查看结果树]中是无法找到重定向过程内容的。如果此时你想做关联，那就比较遗憾了，你无法关联到。</p><p>例如：A重定向到B，此时只记录B的内容不记录A的内容，A的响应内容我们暂时且叫过程内容</p></li><li><p>跟随重定向：Http Request取样器的默认选项，但响应Code是3XX时（比如301是重定向），自动跳转至目标地址。与自动重定向不同，JMeter会记录重定向过程中的所有请求响应，在查看结果树时可以看到服务器返回的内容，所以你可以对响应的内容做关联。</p><p>比如你要测试登录，你把POST请求改为跟随重定向就可以了</p></li></ul><h2 id="第3章-jmeter代理录制及运行"><a href="#第3章-jmeter代理录制及运行" class="headerlink" title="第3章 jmeter代理录制及运行"></a>第3章 jmeter代理录制及运行</h2><blockquote><p>了解jmeter代理录制的设置方式；能够把代理录制设置完成；可以使用代理录制方式录制完成脚本；能够使用jmeter将代理录制的脚本调试运行成功</p></blockquote><h3 id="3-1-JMeter性能测试入门篇-代理录制及脚本运行-23-35"><a href="#3-1-JMeter性能测试入门篇-代理录制及脚本运行-23-35" class="headerlink" title="3-1 JMeter性能测试入门篇-代理录制及脚本运行 (23:35)"></a>3-1 JMeter性能测试入门篇-代理录制及脚本运行 (23:35)</h3><p>JMeter代理录制：</p><ul><li><p>HTTP请求默认值</p><p>输入被测试的URL地址(域名/IP+端口号)</p></li><li><p>HTTP代理服务器</p><p>HTTP代理服务器和国外翻墙代理服务器的工作原理差不多</p></li><li><p>浏览器设置</p><p>局域网设置的端口号需要与代理服务器的端口号保持一致。然后在浏览器的操作就会被代理服务器捕捉到，从而形成系统测试的脚本。</p></li></ul><ol><li><p>创建HTTP代理服务器：Test Plan=&gt;Add=&gt;Non-Test Elements=&gt;HTTP(S) Test Script Recorder</p></li><li><p>在[Global Settings]-[Port]设置端口</p></li><li><p>在[Test Plan Creation]-[Test Plan content]-[Target Controller]选择。<strong>必须设置</strong>。</p></li><li><p>浏览器设置：</p><ul><li>IE浏览器：[工具]-[Internet选项]-[连接]-[局域网设置]-[代理服务器]-[地址+端口]</li><li>Chrome：[工具]-[设置]-[高级]-[打开代理设置]-[网页代理(HTTP)/安全网页代理(HTTPS)]–[地址+端口]</li></ul><p>地址、端口为JMeter代理服务器的相应设置。</p></li><li><p>在浏览器进行相应业务操作，JMeter会自动记录操作及资源文件</p></li><li><p>使用包含模式、排除模式，保留或过滤不需要的资源文件。</p><p>[Requests Filtering]-[URL Patterns to Exclude]-[Add suggested excludes]，或者点击[Add]自定义正则匹配</p></li></ol><p>Web应用程序需添加HTTP Cookie Manager(HTTP Cookie管理器)和HTTP Cache Manager</p><blockquote><p>[Test Plan]-[Add]-[Config Element]-[HTTP Cookie Manager]</p><p>[Test Plan]-[Add]-[Config Element]-[HTTP Cache Manager]</p></blockquote><p><strong>注</strong>：必须添加【查看结果树(View Results Tree)】和【聚合报告(Aggregate Report)】通过直观数据判断脚本是否出现问题。</p><h2 id="第4章-jmeter脚本制作"><a href="#第4章-jmeter脚本制作" class="headerlink" title="第4章 jmeter脚本制作"></a>第4章 jmeter脚本制作</h2><blockquote><p>能够自定义变量，实现值的统一化管理；可以自主使用函数助手进行参数化；可以使用csv文件进行参数化配置，达成参数化的目的</p></blockquote><h3 id="4-1-JMeter性能测试入门篇-用户自定义变量-07-33"><a href="#4-1-JMeter性能测试入门篇-用户自定义变量-07-33" class="headerlink" title="4-1 JMeter性能测试入门篇-用户自定义变量 (07:33)"></a>4-1 JMeter性能测试入门篇-用户自定义变量 (07:33)</h3><p>用户自定义变量作用：</p><blockquote><p>把IP地址、端口号、应用上下文等字段用一个变量去代替，测试环境变化时改变一下变量值即可。</p></blockquote><p>添加用户变量：[Thread Group]-[Add]-[Config Element]-[User Defined Variables]</p><p>使用用户变量：<code>${variable_name}</code></p><h3 id="4-2-JMeter性能测试入门篇-CsvReader函数参数化-07-11"><a href="#4-2-JMeter性能测试入门篇-CsvReader函数参数化-07-11" class="headerlink" title="4-2 JMeter性能测试入门篇-CsvReader函数参数化 (07:11)"></a>4-2 JMeter性能测试入门篇-CsvReader函数参数化 (07:11)</h3><p>文件参数化方式：</p><blockquote><ol><li>函数助手</li><li>csv data set config</li></ol></blockquote><p>函数助手：</p><blockquote><p>[Tools]-[Function Helper Dialog(Shift+Command+F1)]-[Choose a function]-[_CSVRead]-[填写文件名称+列号]-[Generate &amp; Copy to clipboard]-[粘贴到对应属性值框]</p></blockquote><p>如：<code>${_CSVRead(D:\csv.txt,column_idx)}</code></p><p>注：</p><ol><li>文件可以是*.txt，但必须以<code>,</code>隔开。</li><li>列号从<code>0</code>开始</li><li>更改线程数(Number of Threads)，_CSVRead会自动遍历(行号递增)csv.txt</li></ol><h3 id="4-3-JMeter性能测试入门篇-CsvDataSetConfig参数化-09-03"><a href="#4-3-JMeter性能测试入门篇-CsvDataSetConfig参数化-09-03" class="headerlink" title="4-3 JMeter性能测试入门篇-CsvDataSetConfig参数化 (09:03)"></a>4-3 JMeter性能测试入门篇-CsvDataSetConfig参数化 (09:03)</h3><p>csv data set config：</p><blockquote><p>[Thread Group]-[Add]-[Config Element]-[CSV Data Set Config]</p></blockquote><ol><li><p>Variable Names(comma-delimited)：设置变量名称，<code>title,build</code></p><ul><li>引用声明的变量：<code>${title}</code>、<code>${build}</code></li></ul></li><li><p>Delimiter：分隔符</p></li><li><p>Allow quoted data：是否允许带引号</p></li><li><p>Recycle on EOF：遇到文件结束符再次循环</p></li><li><p>Stop thread on EOF：遇到文件结束符停止线程</p></li><li><p>Sharing mode：线程共享模式</p><ul><li>All threads：测试计划中所有线程，假如说有线程1到线程n (n&gt;1)，线程1取了一次值后，线程2取值时，取到的是csv文件中的下一行，即与线程1取的不是同一行。</li><li>Current thread group：当前线程组，假设有线程组A、线程组B，A组内有线程A1到线程An，线程组B内有线程B1到线程Bn。取之情况是：线程A1取到了第1行，线程A2取第2行，现在B1取第1行，线程B2取第2行。</li><li>Current thread：当前线程。假设测试计划内有线程1到线程n (n&gt;1)，则线程1取了第1行，线程2也取第1行。</li></ul></li></ol><h2 id="第5章-关联的使用及总结"><a href="#第5章-关联的使用及总结" class="headerlink" title="第5章 关联的使用及总结"></a>第5章 关联的使用及总结</h2><blockquote><p>通过关联的学习，可以准确的进行关联，排查脚本错误，完成性能测试脚本，学到这里，可以完成整个脚本的制作，独立进行基本的性能测试</p></blockquote><h3 id="5-1-JMeter性能测试入门篇-关联的使用及总结-26-40"><a href="#5-1-JMeter性能测试入门篇-关联的使用及总结-26-40" class="headerlink" title="5-1 JMeter性能测试入门篇-关联的使用及总结 (26:40)"></a>5-1 JMeter性能测试入门篇-关联的使用及总结 (26:40)</h3><p>关联：</p><blockquote><p>当上文中的有一些变量的值在下文中被使用。</p></blockquote><p>添加正则表达式提取器：[HTTP Request]-[Add]-[Post Processors]-[Regular Expression Extractor]</p><ol><li><p>引用名称(Name of created variable)：<code>bugId</code></p></li><li><p>正则表达式(Regular Expression)：<code>左边界(.+?)右边界</code></p><p><code>.</code>匹配任意字符(除了斜杠)，<code>+</code>一次或多次，<code>?</code>0次或多次</p></li><li><p>模版(Template)：<code>$1$</code>。指的是匹配第一个结果</p></li><li><p>匹配数字(0代表随机)(Match No.(0 for Random))：<code>0</code></p></li><li><p>引用上文变量名称：${bugId}</p></li></ol><p>注：在调试测试脚本时，多注意编码。</p><p>:star: <strong>解决中文乱码</strong>：</p><ol><li><p>[Content encoding]设置为UTF-8，同时勾选参数后的[编码?]</p></li><li><p>vim ~/bin/jmeter.properties</p><p>sampleresult.default.encoding=UTF-8</p></li></ol><p>loadrunner与JMeter关联的不同之处：</p><ol><li><p>在loadrunner中，关联函数是写在要获取变量值的页面的前面；</p><p>在JMeter中，关联函数是写在要获取变量值的页面的后面。</p></li><li><p>在loadrunner中，关联函数是注册函数；</p><p>在JMeter中，使用正则表达式提取器进行关联</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>719-JMeter之HTTP协议接口性能测试</title>
      <link href="/imooc/791-JMeterHTTP/"/>
      <url>/imooc/791-JMeterHTTP/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/791" target="_blank" rel="noopener">https://www.imooc.com/learn/791</a></p><p>简介：接口的测试，并不仅仅是掌握某一种工具。工具是死的，并且是多种多样的，本课程通过层层剖析的方式来帮助同学们了解http协议，让学习的同学并不仅仅会做接口的功能和性能测试，并且能够了解什么是真正的接口，消除歧义。 慕课网测试交流群 559506833</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程大纲介绍及接口理解"><a href="#第1章-课程大纲介绍及接口理解" class="headerlink" title="第1章 课程大纲介绍及接口理解"></a>第1章 课程大纲介绍及接口理解</h2><blockquote><p>了解本次课程的基本内容；掌握测试与开发对接口的不同理解</p></blockquote><h3 id="1-1-课程内容介绍-04-28"><a href="#1-1-课程内容介绍-04-28" class="headerlink" title="1-1 课程内容介绍 (04:28)"></a>1-1 课程内容介绍 (04:28)</h3><ol><li>不同角色眼中的接口（开发、测试）</li><li>常见的接口协议（如HTTP等）</li><li>HTTP协议栈中的位置（HTTP协议的底层原理）</li><li>HTTP协议响应码（2XX、4XX、5XX）</li><li>HTTP协议响应模型（一次请求的生命周期）</li><li>常见HTTP协议的请求方式（GET、POST等）</li><li>JMeter的功能介绍</li><li>GET请求与POST请求（实战-如何测试）</li></ol><h3 id="1-2-不同角色眼中的接口-04-50"><a href="#1-2-不同角色眼中的接口-04-50" class="headerlink" title="1-2 不同角色眼中的接口 (04:50)"></a>1-2 不同角色眼中的接口 (04:50)</h3><ul><li><p>开发眼中的接口：模块与模块之间的对接方式定义</p><p>创建一个接口，创建一个接口的实现类，必须实现这个接口里的所有方法。</p></li><li><p>测试眼中的接口：可以独立部署成服务的协议接口</p><p>协议接口（HTTP、FTP等）。利用中间件实现某个功能需求</p></li></ul><h2 id="第2章-HTTP协议基本介绍了解"><a href="#第2章-HTTP协议基本介绍了解" class="headerlink" title="第2章 HTTP协议基本介绍了解"></a>第2章 HTTP协议基本介绍了解</h2><blockquote><p>掌握常见接口的协议；理解http协议栈的位置；掌握响应码并能够根据响应码去定位错误；掌握一次请求的生命周期并掌握一次请求的数据流；掌握常用请求方式，并能够区别不同的请求的表现形式</p></blockquote><h3 id="2-1-常见的接口协议-03-30"><a href="#2-1-常见的接口协议-03-30" class="headerlink" title="2-1 常见的接口协议 (03:30)"></a>2-1 常见的接口协议 (03:30)</h3><table><thead><tr><th>协议</th><th>中文名称</th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议</td></tr><tr><td>HTTPS</td><td>安全超文本传输协议</td></tr><tr><td>FTP</td><td>文件传输协议</td></tr><tr><td>TCP</td><td>网络控制协议</td></tr><tr><td>IP</td><td>互联网协议</td></tr><tr><td>UDP</td><td>用户数据协议</td></tr></tbody></table><h3 id="2-2-HTTP协议栈中的位置-02-03"><a href="#2-2-HTTP协议栈中的位置-02-03" class="headerlink" title="2-2 HTTP协议栈中的位置 (02:03)"></a>2-2 HTTP协议栈中的位置 (02:03)</h3><p>HTTP协议栈中的位置：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghioyetnj314g0qitb4.jpg" alt="HTTP协议栈中的位置" style="zoom:30%;" /><p>注：</p><ul><li>SSL：安全套接层协议</li><li>TLS：传输层安全性协议</li></ul><p>HTTP与HTTPS网络层区别：</p><ul><li><p>HTTPS是构建在SSL（安全套接层协议）之上的，</p><p>也有构建在TLS（传输层安全性协议）之上；</p></li><li><p>HTTP是构建在TCP（网络控制协议）之上的；</p></li></ul><h3 id="2-3-HTTP协议响应码-08-50"><a href="#2-3-HTTP协议响应码-08-50" class="headerlink" title="2-3 HTTP协议响应码 (08:50)"></a>2-3 HTTP协议响应码 (08:50)</h3><blockquote><p>每一个响应码都代表了服务端反馈的一种响应状态，也标识了本次请求是否成功</p></blockquote><p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">HTTP状态码|菜鸟教程</a></p><ol><li><p>1XX：信息响应类，表示接受到请求并且继续处理（中间状态）</p></li><li><p>2XX：处理成功响应类，表示动作被成功接收、理解和接受</p></li><li><p>3XX：重定向响应类，为了完成指定的动作，必须接受进一步处理</p></li><li><p>4XX：客户端错误，客户请求包含语法错误或者是不能正确执行</p><p>检查请求URL是否正确</p></li><li><p>5XX：服务端错误，服务器不能正确执行一个正确的请求</p><p>必须在测试时解决此类型错误。查看服务器端日志，重启服务</p></li></ol><h3 id="2-4-HTTP协议请求响应模型-16-23"><a href="#2-4-HTTP协议请求响应模型-16-23" class="headerlink" title="2-4 HTTP协议请求响应模型 (16:23)"></a>2-4 HTTP协议请求响应模型 (16:23)</h3><p>HTTP协议请求响应模型：（一次请求的生命周期，最简单的软件分层）</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ghipxi3nj30l40kqdgm.jpg" alt="HTTP协议请求响应模型" style="zoom:45%;" /><p>场景：登录</p><ol><li><p>客户端发起请求到API接口层</p><ul><li>用户在客户端填写用户名和密码，点击登录，发送请求</li></ul></li><li><p>API接收到客户端发起的用户请求</p><ul><li><p>API对业务逻辑进行验证</p><p>验证用户名和密码是否合法（例如：用户名要求必须为真实的手机号码。如果验证失败，即用户名不合法，那么需要给客户端返回(自定义)响应码，比如码值为1.2.3，1代表用户名格式错误，2代表用户名或密码错误，3代表密码格式错误）</p></li></ul></li><li><p>API会将用户输入的数据发给DB层（数据库）</p><p>CRUD：Create、Read、Update、Delete</p><ul><li>数据库查询成功返回1，失败返回0</li></ul></li><li><p>DB会将查询数据库的条目数返回给API</p></li><li><p>API返回成功或失败的状态码给客户端</p></li><li><p>客户端将返回信息提示给用户</p></li></ol><p>简单的软件分层：</p><ol><li><p>客户端</p><p>功能测试、性能测试、自动化测试</p></li><li><p>接口层</p><p>接口测试，功能测试、性能测试、自动化测试(更好维护脚本，不涉及页面元素的改变，最多只是接口,数据格式,传输数据内容的改变)</p></li><li><p>数据库层</p><p>可以将开发人员使用到的SQL语句单独拿出来进行性能测试</p></li></ol><h3 id="2-5-常用HTTP请求方式-08-52"><a href="#2-5-常用HTTP请求方式-08-52" class="headerlink" title="2-5 常用HTTP请求方式 (08:52)"></a>2-5 常用HTTP请求方式 (08:52)</h3><p>最常用的HTTP请求方式：</p><ol><li><p>GET请求</p><p>URL：</p><pre><code>http://127.0.0.1:8080?username=zhangsan&amp;password=123456</code></pre></li><li><p>POST请求</p><p>URL：</p><pre><code class="json">http://127.0.0.1:8080</code></pre><p>请求体：</p><pre><code class="json">{  [      &quot;username&quot;: &quot;zhangsan&quot;,      &quot;password&quot;: &quot;123456&quot;  ]}</code></pre></li></ol><p>HTTP请求的方法：</p><blockquote><p>HTTP/1.1协议中共定义了八种请求方法（有时也叫做“动作”），来表明Request-URL指定的资源不同的操作方式</p></blockquote><ol><li><p>OPTIONS</p><p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向Web服务器发送“*”的请求来测试服务器的功能性</p></li><li><p>HEAD</p><p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。</p><p>这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息</p></li><li><p><strong>:star: GET</strong></p><p>向特定的资源发出请求。</p><p>注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。</p></li><li><p><strong>:star: POST</strong></p><p>向指定资源提交数据进行处理请求（例如，提交表单或者上传文件）</p><p>数据被包含在请求体中。</p><p>POST请求可能会导致新资源的建立和/或已有资源的修改</p></li><li><p>PUT</p><p>向指定资源位置上传其最新内容</p></li><li><p>DELETE</p><p>请求服务器删除Request-URL所标识的资源</p></li><li><p>TRACE</p><p>回显服务器所收到的请求，主要用于测试或诊断</p></li><li><p>CONNECT</p><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</p></li></ol><p><strong>注意：</strong></p><ol><li><p>方法名称是区分大小写的。</p><p>当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405(Method Not Allowed)；当服务器不认识或者不支持对应的请求方法时，应返回状态码501(Not Implemented)。</p></li><li><p>HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法</p></li></ol><h2 id="第3章-JMeter的get请求介绍及使用"><a href="#第3章-JMeter的get请求介绍及使用" class="headerlink" title="第3章 JMeter的get请求介绍及使用"></a>第3章 JMeter的get请求介绍及使用</h2><blockquote><p>了解jmeter能够做什么；了解get接口运行原理；能够自主开发get请求脚本并且解决乱码问题；能够掌握函数助手的参数化方式；能够掌握线程组中各个选项的意义并能够进行符合业务逻辑的场景设置</p></blockquote><h3 id="3-1-JMeter功能介绍-06-21"><a href="#3-1-JMeter功能介绍-06-21" class="headerlink" title="3-1 JMeter功能介绍 (06:21)"></a>3-1 JMeter功能介绍 (06:21)</h3><p>万能的JMeter</p><ol><li>BS(Browser-Server)架构应用性能(分三层：1.浏览器性能；2.API性能；3.数据库性能测试)</li><li>HTTP协议接口功能与性能</li><li>FTP协议接口功能与性能</li><li>MySQL数据库性能(增删改查脚本测试)</li><li>MongoDB数据库性能(数据量大，较重要的读写功能性能)</li><li><strong>:star: 支持自定义Java组件开发</strong>(JMeter工具的组件不满足是可以开发新的组件，Java代码脚本方便管理)</li></ol><h3 id="3-2-get接口代码开发及原理讲解-11-51"><a href="#3-2-get接口代码开发及原理讲解-11-51" class="headerlink" title="3-2 get接口代码开发及原理讲解 (11:51)"></a>3-2 get接口代码开发及原理讲解 (11:51)</h3><ol><li><p><a href="https://jmeter.apache.org/" target="_blank" rel="noopener">JMeter</a>下载：<a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">https://jmeter.apache.org/download_jmeter.cgi</a></p><p>Windows系统：运行jmeter.bat</p><p>Linux、Mac系统：运行jmeter.sh</p></li><li><p>SpringBoot接口开发</p><p>DemoApplication.java</p><pre><code class="java">@SpringBootApplicationpublic class DemoApplication {    public static void main(String[] args) {        ConfigurableApplicationContext context = SpringApplication.run(DemoApplication.class,args);        for (String str : context.getEnvironment().getActiveProfiles()) {            System.out.println(str);        }    }}</code></pre><p>DemoAPI.java</p><pre><code class="java">@RestController@RequestMapping(&quot;/demoAPI&quot;)public class DemoAPI {    // http://127.0.0.1:8080/demoAPI/getDemo/zhangsan    @RequestMapping(value = &quot;/getDemo/{userName}&quot;,method = RequestMethod.GET)    public String getDemo(@PathVariable String userName){        String s = &quot; is pig&quot;;        userName = userName + s;        return &quot;您输入的数据是：&quot; + userName;    }}</code></pre></li></ol><h3 id="3-3-get接口测试及常见乱码问题-24-50"><a href="#3-3-get接口测试及常见乱码问题-24-50" class="headerlink" title="3-3 get接口测试及常见乱码问题 (24:50)"></a>3-3 get接口测试及常见乱码问题 (24:50)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：GET</li><li>Path：/demoAPI/getDemo/zhangsan</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加查看结果树(View Results Tree)：[Thread Group]-[Add]-[Listener]-[View Results Tree]</p></li><li><p>点击绿色小箭头运行访问</p></li><li><p>聚合报告(Aggregate Report)：[Thread Group]-[Add]-[Listener]-[Aggregate Report]</p><p>反应整个测试结果快慢、并发量</p><p>关注指标：Average(平均值)、Error%(错误率)、Throughput(吞吐量)、</p><p>Received KB/sec(接收)、Sent KB/sec(发送)、90%Line(90%百分位)</p></li></ol><p><strong>注</strong>：在真正做测试时应该把[查看结果树(View Result Tree)]去掉，打印日志记录会消耗大量IO、CPU等资源</p><p>:star: 测试并解决请求响应数据乱码：</p><pre><code>http://www.weather.com.cn/data/sk/101010100.htmlhttp://www.weather.com.cn/data/cityinfo/101010100.html</code></pre><ol><li>在Content encoding中设置UTF-8。无效</li><li>打开/bin/jmeter.properties搜索<code>sampleresult.default.encoding=ISO-8859-1</code>，设置为UTF-8。有效</li><li>[Thread Group]-[Add]-[Post Processors]-[BeanShell PostProcessor]-[Script]：<code>prev.setDataEncoding(&quot;UTF-8&quot;)</code>。有效</li></ol><h3 id="3-4-参数化－函数助手-06-12"><a href="#3-4-参数化－函数助手-06-12" class="headerlink" title="3-4 参数化－函数助手 (06:12)"></a>3-4 参数化－函数助手 (06:12)</h3><blockquote><p>意义：数据的多变。</p></blockquote><p>[Tools]-[Function Helper Dialog]-[Choose a function(__CSVRead)]-[Generate &amp; Copy to Clipboard]</p><ul><li><p>输入参数：</p><p>CSV file to get values from | *alias：文件路径</p><p>Column number of CSV file | next | *alias：文件列号，0</p></li><li><p>点击生成：代表某个数值</p><pre><code>${__CSVRead(文件路径, 0)}</code></pre></li><li><p>复制到链接🔗：</p><pre><code>/demoAPI/getDemo/${__CSVRead(文件路径, 0)}</code></pre></li></ul><h3 id="3-5-场景设置（get请求）-06-56"><a href="#3-5-场景设置（get请求）-06-56" class="headerlink" title="3-5 场景设置（get请求） (06:56)"></a>3-5 场景设置（get请求） (06:56)</h3><blockquote><p>场景设置即配置线程组</p></blockquote><p>Thread Properties：</p><ul><li>Number of Threads：线程数</li><li>Ramp-Up Period(in seconds)：每秒当中有多少用户进行访问(加压策略)</li><li>Loop Count：循环次数</li></ul><p>复杂场景需要使用多个线程组</p><h2 id="第4章-JMeter的post请求介绍及使用"><a href="#第4章-JMeter的post请求介绍及使用" class="headerlink" title="第4章 JMeter的post请求介绍及使用"></a>第4章 JMeter的post请求介绍及使用</h2><blockquote><p>学习能够了解post接口开发的原理；能够掌握post接口中map格式的数据传递的访问方式；能够了解json格式传递数据传递的原理；能够掌握post接口中json格式的数据传递的访问方式</p></blockquote><h3 id="4-1-post接口代码开发及原理-07-52"><a href="#4-1-post接口代码开发及原理-07-52" class="headerlink" title="4-1 post接口代码开发及原理 (07:52)"></a>4-1 post接口代码开发及原理 (07:52)</h3><pre><code class="java">// http://127.0.0.1:8080/demoAPI/postDemo/*{  &quot;userName&quot;: &quot;zhangsan&quot;}*/public static int count = 0;@RequestMapping(value = &quot;/postDemo&quot;, method = RequestMethod.POST)public String postDemo(@RequestParam String userName){  count++;  String result = &quot;接口是第&quot; + count + &quot;次被调用,您的用户名是&quot; + userName;  return result;}</code></pre><p>使用POSTMAN工具🔧调用测试接口。</p><h3 id="4-2-接口测试实战－map参数格式-04-55"><a href="#4-2-接口测试实战－map参数格式-04-55" class="headerlink" title="4-2 接口测试实战－map参数格式 (04:55)"></a>4-2 接口测试实战－map参数格式 (04:55)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：POST</li><li>Path：/demoAPI/postDemo</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加参数：[Parameters]-[Add]</p><ul><li>userName：zhangsan</li></ul><p>使用函数助手__CSVRead <code>${CSVRead(文件路径, 0)}</code> 动态获取CSV的数据</p></li><li><p>点击绿色小箭头运行访问</p></li></ol><h3 id="4-3-json格式数据传递接口原理及开发-06-31"><a href="#4-3-json格式数据传递接口原理及开发-06-31" class="headerlink" title="4-3 json格式数据传递接口原理及开发 (06:31)"></a>4-3 json格式数据传递接口原理及开发 (06:31)</h3><pre><code class="java">// http://127.0.0.1:8080/demoAPI/postJson/*{  &quot;name&quot;: &quot;zhangsan&quot;,  &quot;clazz&quot;: &quot;一年一班&quot;}*/public static int count = 0;@ResponseBody@RequestMapping(value = &quot;/postJson&quot;, method = RequestMethod.POST)public String postDemo(@RequestBody Student student){  Student stu = new Student();  stu.setName(student.getName());  stu.setClazz(student.getClazz());  return stu;}</code></pre><pre><code class="java">@Datapublic class Student {  private String name;  private String clazz;}</code></pre><pre><code>Content-Type: application/json</code></pre><h3 id="4-4-json格式post请求实战-05-03"><a href="#4-4-json格式post请求实战-05-03" class="headerlink" title="4-4 json格式post请求实战 (05:03)"></a>4-4 json格式post请求实战 (05:03)</h3><ol><li><p>添加线程组(Thread Group)</p><p>[Test Plan]-[Add]-[Threads(Users)]-[Thread Group]</p></li><li><p>添加取样器(Sampler)：[Thread Group]-[Add]-[Sampler]-[HTTP Request]</p></li><li><p>添加服务器信息(Web Server)</p><ul><li>Protocol[http]：http</li><li>Server Name OR IP：127.0.0.1</li><li>Port Number：8080</li></ul></li><li><p>添加HTTP请求信息(HTTP Request)</p><ul><li>Method：POST</li><li>Path：/demoAPI/postJson</li><li>Content encoding：UTF-8</li><li>跟随重定向(Follow Redirects)、使用Keep Alive(Use Keep Alive)</li></ul></li><li><p>添加参数：[Body Data]</p><pre><code class="json">{  &quot;name&quot;: &quot;zhangsan&quot;,  &quot;clazz&quot;: &quot;一年一班&quot;}</code></pre><p>使用函数助手__CSVRead <code>${CSVRead(文件路径, 0)}</code> 动态获取CSV的数据</p></li><li><p>添加HTTP信息头管理器：[Thread Group]-[Add]-[Config Element]-[HTTP Header Manager]-[Add]</p><ul><li>Content-Type：application/json</li></ul></li><li><p>点击绿色小箭头运行访问</p></li></ol><h2 id="第5章-JMeter之接口性能测试-课程总结"><a href="#第5章-JMeter之接口性能测试-课程总结" class="headerlink" title="第5章 JMeter之接口性能测试-课程总结"></a>第5章 JMeter之接口性能测试-课程总结</h2><blockquote><p>掌握本次课程的所有重点内容，能够独立进行接口测试</p></blockquote><h3 id="5-1-课程总结-03-31"><a href="#5-1-课程总结-03-31" class="headerlink" title="5-1 课程总结 (03:31)"></a>5-1 课程总结 (03:31)</h3><ol><li>常见的接口协议（HTTP协议、FTP协议）</li><li>HTTP协议响应码</li><li>HTTP协议响应模型（HTTP生命周期）</li><li>GET请求的开发与测试</li><li>POST请求的开发与测试</li><li>场景设置（配置线程组信息）</li><li>参数化（函数助手参数化、外部文件参数化）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能测试 </tag>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>889-ElasticSearch入门</title>
      <link href="/imooc/889-ElasticSearch/"/>
      <url>/imooc/889-ElasticSearch/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/889" target="_blank" rel="noopener">https://www.imooc.com/learn/889</a></p><p>简介：ElasticSearch是一个分布式、可扩展、实时的搜索与数据分析引擎，它能从项目一开始就赋予你的数据以搜索、分析和探索的能力。通过本课程的学习，你可以了解到，ElasticSearch在互联网行业里的火热程度，也可以了解到它的实际应用场景。本课程会通过理论与实践相结合的方式，带领你一步一步走进ElasticSearch的世界，使你轻松掌握ElasticSearch的基本概念，学习ElasticSearch的服务搭建，了解ElasticSearch的常用技巧，并通过案例项目让你拥有实际的应用能力。 老师实战课程已经上线：<a href="http://coding.imooc.com/class/167.html" target="_blank" rel="noopener">http://coding.imooc.com/class/167.html</a> ElasticSearch+MySQL+Kafka强力组合，更有ES结合百度地图，Nginx等高级应用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>介绍Elastic Search的由来，应用场景，课程需要的前置知识，环境要求，介绍课程安排</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title=" 1-1 课程介绍"></a><a href="https://www.imooc.com/video/15762" target="_blank" rel="noopener"> 1-1 课程介绍</a></h3><p>什么是ElasticSearch？</p><ul><li><p>基于Apache Lucene构建的开源搜索引擎</p><p>Lucene相对复杂，需要深厚的搜索理论知识，难以集成</p></li><li><p>采用Java编写，提供简单易用的RESTFul API</p></li><li><p>轻松的横向扩展，可支持PB级的结构化或非结构化 数据处理</p></li></ul><p>应用场景：</p><ul><li>海量数据分析引擎</li><li>站内搜索引擎</li><li>数据仓库</li></ul><p>一线公司实际应用场景：</p><ul><li>英国卫报-实时分析公众对文章的回应</li><li>维基百科、Github-站内实时搜索</li><li>百度-实时日志监控平台</li><li>阿里巴巴、Google、京东等等</li></ul><p>前置知识</p><ul><li>熟悉用Maven构建项目</li><li>了解Spring Boot的基本使用</li></ul><p>环境要求：</p><ul><li>IDE工具：Intellij IDEA、Eclipse等常用IDE即可</li><li>Java：JDK1.8</li><li>其他依赖：Maven、NodeJS(6.0以上)</li></ul><p>课程简介：</p><ul><li>安装=》基础概念=》基本用法=》高级查询=》实战演练=》课程总结</li></ul><h2 id="第2章-安装"><a href="#第2章-安装" class="headerlink" title="第2章 安装"></a>第2章 安装</h2><blockquote><p>先从单个节点的安装讲起，然后把插件安装流程走一遍，并说一下插件的主要作用，最后把分布式安装简单的介绍一下</p></blockquote><h3 id="2-1-ES版本历史和选择"><a href="#2-1-ES版本历史和选择" class="headerlink" title=" 2-1 ES版本历史和选择"></a><a href="https://www.imooc.com/video/15763" target="_blank" rel="noopener"> 2-1 ES版本历史和选择</a></h3><ul><li>版本历史 1.x -&gt; 2.x -&gt; 5.x</li><li>版本选择 5.x以上</li></ul><p>安装</p><ul><li>单实例安装</li><li>实用插件Head安装</li><li>分布式安装</li></ul><h3 id="2-2-单实例安装"><a href="#2-2-单实例安装" class="headerlink" title=" 2-2 单实例安装"></a><a href="https://www.imooc.com/video/15764" target="_blank" rel="noopener"> 2-2 单实例安装</a></h3><blockquote><p><a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">ElasticSearch官网首页</a> </p></blockquote><pre><code class="shell"># 下载wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.3.1-linux-x86_64.tar.gz# 解压tar -zvxf elasticsearch-7.3.1-linux-x86_64.tar.gz# 进入HOME目录cd elasticsearch-7.3.1-linux-x86_64# 运行ElasticSearch程序sh ./bin/elasticsearch# 获取ElasticSearch服务信息curl http://localhost:9200/</code></pre><h3 id="2-3-插件安装"><a href="#2-3-插件安装" class="headerlink" title=" 2-3 插件安装"></a><a href="https://www.imooc.com/video/15765" target="_blank" rel="noopener"> 2-3 插件安装</a></h3><blockquote><p><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">Github主页</a></p></blockquote><pre><code class="shell"># 下载wget https://github.com/mobz/elasticsearch-head/archive/master.zip# 解压unzip master.zip# 进入HOME目录cd elasticsearch-head-master# 编译源码npm install# 运行程序npm run start# 访问服务地址open http://localhost:9100/</code></pre><ul><li><p>修改ElasticSearch配置</p><pre><code class="shell">vim config/elasticsearch.yml</code></pre><pre><code class="yaml">http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p>重启ElasticSearch、Head</p></li></ul><h3 id="2-4-分布式安装"><a href="#2-4-分布式安装" class="headerlink" title=" 2-4 分布式安装"></a><a href="https://www.imooc.com/video/15766" target="_blank" rel="noopener"> 2-4 分布式安装</a></h3><p>修改ElasticSearch配置</p><ul><li><p>主节点：</p><pre><code class="shell">vim config/elasticsearch.yml# -import ~~master~~# 查看进程ps -ef | grep `pwd`# 后台启动ElasticSearch./bin/elasticsearch -d</code></pre><pre><code class="yaml"># ~~master~~cluster.name: walinode.name: masternode.master: truenetwork.host: 127.0.0.1</code></pre></li><li><p>从节点</p><pre><code class="shell"># 创建子节点目录mkdir es_slave# 拷贝ElasticSearchcp elasticsearch-7.3.1-linux-x86_64.tar.gz es_slave# 解压tar -zvxf elasticsearch-7.3.1-linux-x86_64.tar.gz# 复制两份子节点程序cp -r elasticsearch-7.3.1-linux-x86_64 es_slave1cp -r elasticsearch-7.3.1-linux-x86_64 es_slave2cd es_slave1vi config/elasticsearch.yml# -import ~~es_slave1~~# 后台启动ElasticSearch./bin/elasticsearch -dcd es_slave2vi config/elasticsearch.yml# -import ~~es_slave2~~# 后台启动ElasticSearch./bin/elasticsearch -d</code></pre><pre><code class="yaml"># ~~es_slave1~~cluster.name: walinode.name: slave1network.host: 127.0.0.1http.port: 8001</code></pre><pre><code class="yaml"># ~~es_slave2~~cluster.name: walinode.name: slave2network.host: 127.0.0.1http.port: 8002</code></pre></li></ul><h2 id="第3章-基础概念"><a href="#第3章-基础概念" class="headerlink" title="第3章 基础概念"></a>第3章 基础概念</h2><blockquote><p>结合Head插件，简单的讲解集群、节点的概念，重点讲解索引及其重要性，分片和备份属于索引的附属概念，一笔带过，类型、文档简单讲解下，并将索引、类型、文档三者的关系讲解清楚</p></blockquote><h3 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title=" 3-1 基础概念"></a><a href="https://www.imooc.com/video/15767" target="_blank" rel="noopener"> 3-1 基础概念</a></h3><p>集群和节点：</p><ul><li>节点1+节点2+…+…+节点N ==》集群</li></ul><p>基础概念</p><ul><li><p>索引：含有相同属性的文档集合</p></li><li><p>类型：索引可以定义一个或多个类型，文档必须属于一个类型</p></li><li><p>文档：文档是可以被索引的基本数据单位</p></li><li><p>分片：每个索引都有多个分片，每个分片是一个Lucene索引</p></li><li><p>备份：拷贝一份分片就可以完成了分片的备份</p></li></ul><h2 id="第4章-基本用法"><a href="#第4章-基本用法" class="headerlink" title="第4章 基本用法"></a>第4章 基本用法</h2><blockquote><p>本章节主要带领学生一起学习ElasticSearch的基本使用方法，并了解常用的REST API，讲解过程中要将命令行与head插件相结合以演示相应操作。</p></blockquote><h3 id="4-1-索引创建"><a href="#4-1-索引创建" class="headerlink" title=" 4-1 索引创建"></a><a href="https://www.imooc.com/video/15768" target="_blank" rel="noopener"> 4-1 索引创建</a></h3><blockquote><ul><li>非结构化创建</li><li>结构化创建</li></ul></blockquote><p>RESTFul API：</p><ul><li><p>API基本格式</p><pre><code>http://&lt;ip&gt;:&lt;port&gt;/&lt;索引&gt;/&lt;类型&gt;/&lt;文档ID&gt;</code></pre></li><li><p>常用HTTP动词：GET/PUT/POST/DELETE</p></li></ul><p>Head插件创建索引（非结构化）：</p><ol><li><p>访问Head服务地址：<a href="http://127.0.0.1:9100" target="_blank" rel="noopener">http://127.0.0.1:9100</a></p></li><li><p>索引-新建索引</p></li><li><p>概览</p><p>粗线框为主分片，旁边细线框为分片备份</p></li></ol><p>Head插件创建索引（结构化）：</p><ol><li><p>复合查询-查询</p></li><li><p>参数信息</p><pre><code>http://127.0.0.1:9200/book/novel/_mappings POST</code></pre><pre><code class="json">{    &quot;novel&quot;: {        &quot;properties&quot;: {            &quot;title&quot;:{                &quot;type&quot;: &quot;text&quot;            }        }    }}</code></pre></li><li><p>验证JSON-提交请求</p></li><li><p>概览-刷新-信息-索引信息-mappings</p></li></ol><p>Postman创建索引</p><ol><li><pre><code>PUT http://127.0.0.1:9200/people</code></pre></li><li><pre><code>{    &quot;settings&quot;: {        &quot;number_of_shards&quot;: 3,        &quot;number_of_replicas&quot;: 1    },    &quot;mappings&quot;: {        &quot;man&quot;: {            &quot;properties&quot;: {                &quot;name&quot;: {&quot;type&quot;: &quot;text&quot;},                &quot;country&quot;: {&quot;type&quot;: &quot;keyword&quot;},                &quot;age&quot;: {                    &quot;type&quot;: &quot;integer&quot;                },                &quot;date&quot;: {                    &quot;type&quot;: &quot;date&quot;,                    &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;                }            }        },        &quot;woman&quot;: {        }    }}</code></pre></li></ol><h3 id="4-2-插入"><a href="#4-2-插入" class="headerlink" title=" 4-2 插入"></a><a href="https://www.imooc.com/video/15769" target="_blank" rel="noopener"> 4-2 插入</a></h3><blockquote><ul><li>指定文档ID插入</li><li>自动产生文档ID插入</li></ul></blockquote><p>文档ID：唯一索引值，指向文档数据</p><p>指定文档ID插入：</p><ol><li><pre><code>PUT http://127.0.0.1:9200/people/man/1</code></pre></li><li><pre><code class="json">{    &quot;name&quot;: &quot;瓦力&quot;, &quot;country&quot;: &quot;China&quot;,    &quot;age&quot;: 30,    &quot;date&quot;: &quot;1987-03-07&quot;}</code></pre></li><li><p>概览-docs：索引下所有文档的数量值</p></li><li><p>数据浏览</p></li></ol><p>自动产生文档ID插入：</p><ol><li><pre><code>POST http://127.0.0.1:9200/people/man</code></pre></li><li><pre><code class="json">{    &quot;name&quot;: &quot;瓦力&quot;,    &quot;country&quot;: &quot;China&quot;,    &quot;age&quot;: 30,    &quot;date&quot;: &quot;1987-03-07&quot;}</code></pre></li></ol><h3 id="4-3-修改"><a href="#4-3-修改" class="headerlink" title=" 4-3 修改"></a><a href="https://www.imooc.com/video/15770" target="_blank" rel="noopener"> 4-3 修改</a></h3><blockquote><ul><li>直接修改文档</li><li>脚本修改文档</li></ul></blockquote><p>直接修改文档</p><ol><li><pre><code>POST http://127.0.0.1:9200/people/man/1/_update</code></pre></li><li><pre><code class="json">{    &quot;doc&quot;: {        &quot;name&quot;: &quot;谁是瓦力&quot;    }}</code></pre></li></ol><p>脚本修改文档</p><ol><li><pre><code>POST http://127.0.0.1:9200/people/man/1/_update</code></pre></li><li><pre><code class="json">{    &quot;script&quot;: {        &quot;lang&quot;: &quot;painless&quot;,        &quot;inline&quot;: &quot;ctx._source.age += 10&quot;    }}</code></pre><pre><code class="json">{    &quot;script&quot;: {        &quot;lang&quot;: &quot;painless&quot;,        &quot;inline&quot;: &quot;ctx._source.age += params.age&quot;,        &quot;params&quot;: {            &quot;age&quot;: 100        }    }}</code></pre></li></ol><h3 id="4-4-删除"><a href="#4-4-删除" class="headerlink" title=" 4-4 删除"></a><a href="https://www.imooc.com/video/15771" target="_blank" rel="noopener"> 4-4 删除</a></h3><blockquote><ul><li>删除文档</li><li>删除索引</li></ul></blockquote><p>删除文档</p><pre><code>DELETE http://127.0.0.1:9200/people/man/1</code></pre><p>删除索引</p><ul><li><p>Head插件删除</p><p>概览-动作-删除-输入删除-确定</p></li><li><p>Postman删除</p><pre><code>DELETE http://127.0.0.1:9200/people</code></pre></li></ul><p>删除索引是一个非常危险的操作。</p><h3 id="4-5-查询"><a href="#4-5-查询" class="headerlink" title=" 4-5 查询"></a><a href="https://www.imooc.com/video/15772" target="_blank" rel="noopener"> 4-5 查询</a></h3><blockquote><ul><li>简单查询</li><li>条件查询</li><li>聚合查询</li></ul></blockquote><p>事先创建索引book：</p><pre><code>PUT http://127.0.0.1:9200/book</code></pre><pre><code class="json">{    &quot;settings&quot;: {        &quot;number_of_shards&quot;: 3,        &quot;number_of_replicas&quot;: 1    },    &quot;mappings&quot;: {        &quot;novel&quot;: {            &quot;properties&quot;: {                &quot;word_count&quot;: {                    &quot;type&quot;: &quot;integer&quot;                },                &quot;author&quot;: {                    &quot;type&quot;: &quot;keyword&quot;                },                &quot;title&quot;: {                    &quot;type&quot;: &quot;text&quot;                },                &quot;publish_date&quot;: {                    &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;,                    &quot;type&quot;: &quot;date&quot;                }            }        }    }}</code></pre><p>插入数据：</p><pre><code>PUT http://127.0.0.1:9200/book/novel/1</code></pre><pre><code class="json">{    &quot;word_count&quot;: &quot;5000&quot;,    &quot;author&quot;: &quot;王五&quot;,    &quot;title&quot;: &quot;菜谱&quot;,    &quot;publish_date&quot;: &quot;2002-10-01&quot;}</code></pre><p>book novel 5  1 王五 菜谱                    5000  2002-10-01<br>book novel 8  1 瓦力 ElasticSearch入门       3000  2017-08-20<br>book novel 9  1 很胖的瓦力 ElasticSearch精通 3000  2017-08-15<br>book novel 10 1 牛魔王 芭蕉扇                1000  2000-10-01<br>book novel 2  1 李三 Java入门                2000  2010-10-01<br>book novel 4  1 李四 ElasticSearch大法好     1000  2017-08-01<br>book novel 6  1 赵六 剑谱                    10000 1997-01-01<br>book novel 1  1 张三 移魂大法                1000  2000-10-01<br>book novel 7  1 张三丰 太极拳                1000  1997-01-01<br>book novel 3  1 张四 Python入门              2000  2005-10-01<br>book novel 11 1 孙悟空 七十二变              1000  2000-10-01</p><p>简单查询：</p><pre><code>GET http://127.0.0.1:9200/book/novel/1</code></pre><p>条件查询：</p><ul><li><p>查询所有</p><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;match_all&quot;: {}    },    &quot;form&quot;: 1,    &quot;size&quot;: 1}</code></pre><p>关键词查询</p><pre><code class="json">{    &quot;query&quot;: {        &quot;match&quot;: {            &quot;title&quot;: &quot;ElasticSearch&quot;        }    },    &quot;sort&quot;: [        {&quot;publish_date&quot;: {&quot;order&quot;: &quot;desc&quot;}}    ]}</code></pre></li><li><p>条件查询</p><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;aggs&quot;: {        &quot;group_by_word_count&quot;: {            &quot;terms&quot;: {                &quot;field&quot;: &quot;word_count&quot;            }        },        &quot;group_by_publish_date&quot;: {            &quot;terms&quot;: {                &quot;field&quot;: &quot;publish_date&quot;            }        }    }}</code></pre></li><li><p>聚合查询</p><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;aggs&quot;: {        &quot;grades_word_count&quot;: {            &quot;stats&quot;: {                &quot;field&quot;: word_count            }        }    }}</code></pre><pre><code class="json">{    &quot;aggs&quot;: {        &quot;grades_word_count&quot;: {            &quot;min&quot;: {                &quot;field&quot;: word_count            }        }    }}</code></pre></li></ul><h2 id="第5章-高级查询"><a href="#第5章-高级查询" class="headerlink" title="第5章 高级查询"></a>第5章 高级查询</h2><blockquote><p>将query与filter分开讲解，并把相应的关键词列举一些，结合实例操作，最后将query与filter组合起来，讲解实例</p></blockquote><h3 id="5-1-query"><a href="#5-1-query" class="headerlink" title=" 5-1 query"></a><a href="https://www.imooc.com/video/15759" target="_blank" rel="noopener"> 5-1 query</a></h3><p>高级查询：</p><ul><li>子条件查询：特定字段查询所指特定值</li><li>复合条件查询：以一定的逻辑组合子条件查询</li></ul><p>子条件查询</p><ul><li>Query context</li><li>Filter context</li></ul><p>Query Context</p><blockquote><p>在查询过程中，除了判断文档是否满足查询条件外，ES还会计算一个_score来标识匹配的程度，旨在判断目标文档和查询条件匹配的有多好。</p></blockquote><p>常用查询：</p><ul><li>全文本查询：针对文本类型数据</li><li>字段级别查询：针对结构化数据，如数字、日期等</li></ul><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><ul><li><p>模糊匹配(匹配：ElasticSearch+入门)</p><pre><code class="json">{    &quot;query&quot;: {        &quot;match&quot;: {            &quot;title&quot;: &quot;ElasticSearch入门&quot;        }    }}</code></pre></li><li><p>习语匹配(匹配：ElasticSearch入门)</p><pre><code class="json">{    &quot;query&quot;: {        &quot;match_phrase&quot;: {            &quot;title&quot;: &quot;ElasticSearch入门&quot;        }    }}</code></pre></li><li><p>多字段模糊匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;multi_match&quot;: {            &quot;query&quot;: &quot;瓦力&quot;,            &quot;fields&quot;: [&quot;author&quot;, &quot;title&quot;]        }    }}</code></pre></li><li><p>语法匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;query_string&quot;: {            &quot;query&quot;: &quot;ElasticSearch AND 大法&quot;        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;query_string&quot;: {            &quot;query&quot;: &quot;(ElasticSearch AND 大法) OR Python&quot;        }    }}</code></pre></li><li><p>多字段语法匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;query_string&quot;: {            &quot;query&quot;: &quot;瓦力 OR ElasticSearch&quot;,            &quot;fields&quot;: [&quot;title&quot;, &quot;author&quot;]        }    }}</code></pre></li><li><p>字段匹配</p><pre><code class="json">{    &quot;query&quot;: {        &quot;term&quot;: {            &quot;word_count&quot;: 1000        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;term&quot;: {            &quot;author&quot;: &quot;瓦力&quot;        }    }}</code></pre></li><li><p>范围匹配（数字、日期）</p><pre><code class="json">{    &quot;query&quot;: {        &quot;range&quot;: {            &quot;word_count&quot;: {                &quot;gte&quot;: 1000,                &quot;lte&quot;: 2000            }        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;range&quot;: {            &quot;publish_date&quot;: {                &quot;gt&quot;: &quot;2019-08-29&quot;,                &quot;lte&quot;: &quot;now&quot;            }        }    }}</code></pre><p>now：代表当前时间</p></li></ul><h3 id="5-2-filter"><a href="#5-2-filter" class="headerlink" title=" 5-2 filter"></a><a href="https://www.imooc.com/video/15760" target="_blank" rel="noopener"> 5-2 filter</a></h3><p>Filter Context</p><blockquote><p>在查询过程中，只判断该文档是否满足条件，只有Yes或者No</p></blockquote><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;filter&quot;: {                &quot;term&quot;: {                    &quot;word_count&quot;: 1000                }            }        }    }}</code></pre><p>filter做数据过滤的，并且会对查询结果进行缓存，所以filter比query要快一些。</p><h3 id="5-3-复合查询"><a href="#5-3-复合查询" class="headerlink" title=" 5-3 复合查询"></a><a href="https://www.imooc.com/video/15761" target="_blank" rel="noopener"> 5-3 复合查询</a></h3><p>常用查询：</p><ul><li>固定分数查询</li><li>布尔查询</li></ul><pre><code>POST http://127.0.0.1:9200/book/_search</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;match&quot;: {            &quot;title&quot;: &quot;ElasticSearch&quot;        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;constant_score&quot;: {            &quot;filter&quot;: {                &quot;match&quot;: {                    &quot;title&quot;: &quot;ElasticSearch&quot;                }            },            &quot;boost&quot;: 2        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;should&quot;: [                {                    &quot;match&quot;: {                        &quot;author&quot;: &quot;瓦力&quot;                    }                },                {                    &quot;match&quot;: {                        &quot;title&quot;: &quot;ElasticSearch&quot;                    }                }            ]        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;must&quot;: [                {                    &quot;match&quot;: {                        &quot;author&quot;: &quot;瓦力&quot;                    }                },                {                    &quot;match&quot;: {                        &quot;title&quot;: &quot;ElasticSearch&quot;                    }                }            ],            &quot;filter&quot;: [                {                    &quot;term&quot;: {                        &quot;word_count&quot;: 1000                    }                }            ]        }    }}</code></pre><pre><code class="json">{    &quot;query&quot;: {        &quot;bool&quot;: {            &quot;must_not&quot;: {                &quot;term&quot;: {                    &quot;author&quot;: &quot;瓦力&quot;                }            }        }    }}</code></pre><p>固定分数查询不支持match，只支持filter</p><h2 id="第6章-Spring-Boot集成ES"><a href="#第6章-Spring-Boot集成ES" class="headerlink" title="第6章 Spring Boot集成ES"></a>第6章 Spring Boot集成ES</h2><blockquote><p>直接演示SpringBoot集成ES，做接口开发</p><p>以下使用ElasticSearch7.3.1做演示</p></blockquote><h3 id="6-1-SpringBoot集成ElasticSearch"><a href="#6-1-SpringBoot集成ElasticSearch" class="headerlink" title=" 6-1 SpringBoot集成ElasticSearch"></a><a href="https://www.imooc.com/video/15758" target="_blank" rel="noopener"> 6-1 SpringBoot集成ElasticSearch</a></h3><p>实战演练：</p><ul><li>Spring Boot集成ES</li><li>图书信息管理接口开发</li></ul><p>Pom.xml</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch-rest-client&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;  &lt;artifactId&gt;elasticsearch-rest-client-sniffer&lt;/artifactId&gt;  &lt;version&gt;${elasticsearch.version}&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>配置Spring Bean</p><pre><code class="java">@Configurationpublic class ESConfig {    @Bean    public RestHighLevelClient client() throws UnknownHostException {        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(                        new HttpHost(&quot;127.0.0.1&quot;, 9200, &quot;http&quot;)));        return client;    }}</code></pre><p>ESController</p><pre><code class="java">@RestController@RequestMapping(&quot;/novel&quot;)public class ESController {  @Autowired  private RestHighLevelClient client;  // todo }</code></pre><p>运行</p><pre><code class="shell">mvn spring-boot:run</code></pre><h3 id="6-2-查询接口开发"><a href="#6-2-查询接口开发" class="headerlink" title=" 6-2 查询接口开发"></a><a href="https://www.imooc.com/video/15773" target="_blank" rel="noopener"> 6-2 查询接口开发</a></h3><p>接口开发：</p><ul><li>新增图书信息功能开发</li><li>修改图书信息功能开发</li><li>删除功能开发</li><li>综合查询接口开发</li></ul><pre><code class="java">@GetMapping(&quot;/{id}&quot;)public ResponseEntity get(@PathVariable(name = &quot;id&quot;) String id) {  if (id.isEmpty()) {    return new ResponseEntity(HttpStatus.NOT_FOUND);  }  GetRequest novelRequest = new GetRequest(&quot;novel&quot;, id);  try {    GetResponse novelResponse = this.client.get(novelRequest, RequestOptions.DEFAULT);    if (novelResponse.isExists()) {      System.out.println(novelResponse);      return new ResponseEntity(novelResponse.getSource(), HttpStatus.OK);    }  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }  return new ResponseEntity(HttpStatus.NOT_FOUND);}</code></pre><p>运行：</p><pre><code class="shell">mvn spring-boot:runGET http://127.0.0.1:8080/novel/1</code></pre><h3 id="6-3-增加接口开发"><a href="#6-3-增加接口开发" class="headerlink" title=" 6-3 增加接口开发"></a><a href="https://www.imooc.com/video/15775" target="_blank" rel="noopener"> 6-3 增加接口开发</a></h3><pre><code class="java">@PostMapping(&quot;&quot;)public ResponseEntity add(@RequestBody Novel novel) {  try {    Gson gson = new Gson();    Map novelMap = gson.fromJson(gson.toJson(novel), Map.class);    IndexRequest novelRequest = new IndexRequest(&quot;novel&quot;).id(UUID.randomUUID().toString()).source(novelMap);    IndexResponse novelResponse = this.client.index(novelRequest, RequestOptions.DEFAULT);    System.out.println(novelResponse);    return new ResponseEntity(novelResponse.getId(), HttpStatus.OK);  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }}</code></pre><pre><code class="java">@Datapublic class Novel {    private String title;    private String author;    @JsonProperty(value = &quot;word_count&quot;)    private String wordCount;    @JsonProperty(value = &quot;publish_date&quot;)    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)    private Date publishDate;}</code></pre><p>运行</p><pre><code>POST http://127.0.0.1:8080/novel</code></pre><pre><code class="json">{    &quot;title&quot;: &quot;大话西游&quot;,    &quot;author&quot;: &quot;刘镇伟&quot;,    &quot;word_count&quot;: &quot;1008&quot;,    &quot;publish_date&quot;: &quot;2019-09-08&quot;}</code></pre><h3 id="6-4-删除接口开发"><a href="#6-4-删除接口开发" class="headerlink" title=" 6-4 删除接口开发"></a><a href="https://www.imooc.com/video/15774" target="_blank" rel="noopener"> 6-4 删除接口开发</a></h3><pre><code class="java">@DeleteMapping(&quot;/{id}&quot;)public ResponseEntity delete(@PathVariable(name = &quot;id&quot;) String id) {  DeleteRequest novelRequest = new DeleteRequest(&quot;novel&quot;, id);  try {    DeleteResponse novelResponse = this.client.delete(novelRequest, RequestOptions.DEFAULT);    System.out.println(novelResponse);    return new ResponseEntity(novelResponse.getResult().toString(),HttpStatus.OK);  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }}</code></pre><p>运行</p><pre><code>DELETE http://127.0.0.1:8080/novel/1</code></pre><h3 id="6-5-更新接口开发"><a href="#6-5-更新接口开发" class="headerlink" title=" 6-5 更新接口开发"></a><a href="https://www.imooc.com/video/15776" target="_blank" rel="noopener"> 6-5 更新接口开发</a></h3><pre><code class="java">@PutMapping(&quot;/{id}&quot;)public ResponseEntity update(@PathVariable(name = &quot;id&quot;) String id, @RequestBody Novel novel) {  try {    Gson gson = new Gson();    Map map = gson.fromJson(gson.toJson(novel), Map.class);    UpdateRequest novelRequest = new UpdateRequest(&quot;novel&quot;, id).doc(map);    UpdateResponse novelResponse = this.client.update(novelRequest, RequestOptions.DEFAULT);    System.out.println(novelResponse);    return new ResponseEntity(novelResponse.getResult().toString(), HttpStatus.OK);  } catch (IOException e) {    e.printStackTrace();    return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);  }}</code></pre><p>运行</p><pre><code>PUT http://127.0.0.1:8080/novel/1</code></pre><pre><code class="json">{    &quot;title&quot;: &quot;大话西游&quot;,    &quot;author&quot;: &quot;刘镇伟&quot;,    &quot;word_count&quot;: &quot;1008&quot;,    &quot;publish_date&quot;: &quot;2019-09-08&quot;}</code></pre><h3 id="6-6-复合查询接口开发"><a href="#6-6-复合查询接口开发" class="headerlink" title=" 6-6 复合查询接口开发"></a><a href="https://www.imooc.com/video/15777" target="_blank" rel="noopener"> 6-6 复合查询接口开发</a></h3><pre><code class="java">@GetMapping(&quot;&quot;)public ResponseEntity query(@RequestParam(value = &quot;author&quot;, required = false) String author,                            @RequestParam(value = &quot;title&quot;, required = false) String title,                            @RequestParam(value = &quot;gt_word_count&quot;, defaultValue = &quot;0&quot;) Integer gtWordCount,                            @RequestParam(value = &quot;lt_word_count&quot;, required = false) Integer ltWordCount) {    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();    if (author != null) {        boolQueryBuilder.must(QueryBuilders.matchQuery(&quot;author&quot;, author));    }    if (title != null) {        boolQueryBuilder.must(QueryBuilders.matchQuery(&quot;title&quot;, title));    }    RangeQueryBuilder wordCountRangeQuery = QueryBuilders.rangeQuery(&quot;word_count&quot;)            .from(gtWordCount);    if (ltWordCount != null &amp;&amp; 0 &lt; ltWordCount) {        wordCountRangeQuery.to(ltWordCount);    }    boolQueryBuilder.filter(wordCountRangeQuery);    SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()            .query(boolQueryBuilder)            .from(0)            .size(10);    SearchRequest novelSearchRequest = new SearchRequest(&quot;novel&quot;)            .source(searchSourceBuilder)            .searchType(SearchType.DFS_QUERY_THEN_FETCH);    System.out.println(novelSearchRequest.source());    try {        SearchResponse novelSearchResponse = this.client.search(novelSearchRequest, RequestOptions.DEFAULT);        System.out.println(novelSearchResponse);        ArrayList&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;&gt;();        novelSearchResponse.getHits().forEach(e -&gt; {            result.add(e.getSourceAsMap());        });        return new ResponseEntity(result, HttpStatus.OK);    } catch (IOException e) {        e.printStackTrace();        return new ResponseEntity(HttpStatus.INTERNAL_SERVER_ERROR);    }}</code></pre><h2 id="第7章-课程总结"><a href="#第7章-课程总结" class="headerlink" title="第7章 课程总结"></a>第7章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="7-1-课程总结"><a href="#7-1-课程总结" class="headerlink" title=" 7-1 课程总结"></a><a href="https://www.imooc.com/video/15757" target="_blank" rel="noopener"> 7-1 课程总结</a></h3><ol><li><p>ES简介</p><p>ES使用场景例子</p><p>ES的火热程度-重要性</p></li><li><p>安装</p><p>ES使用插件HEAD</p><p>ES分布式安装，实现了ES的横向扩容</p></li><li><p>基础概念</p></li><li><p>基本用法</p><p>增删查改功能</p></li><li><p>高级查询</p></li><li><p>实战演练</p><p>将ES集成到SpringBoot</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>951-MyCAT入门及应用</title>
      <link href="/imooc/951-MyCat/"/>
      <url>/imooc/951-MyCat/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/951" target="_blank" rel="noopener">https://www.imooc.com/learn/951</a></p><p>简介：本课程从实际生产环境应用MyCAT入手，讲解MyCAT的基础知识和MyCAT的基本应用操作，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>本章节主要介绍课程结构</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>学习目的：</p><ul><li>掌握在数据库负载增大时的处理方法</li><li>理解MyCat的基础概念（分库、分表、逻辑库、逻辑表）</li><li>掌握MyCat的基础配置和监控方法</li></ul><h2 id="第2章-MyCAT介绍"><a href="#第2章-MyCAT介绍" class="headerlink" title="第2章 MyCAT介绍"></a>第2章 MyCAT介绍</h2><blockquote><p>本章节主要介绍MyCAT的主要应用场景和优势，用来帮助大家了解MyCAT具体应用在什么样的生产环境中。</p></blockquote><h3 id="2-1-MyCAT前世今生"><a href="#2-1-MyCAT前世今生" class="headerlink" title="2-1 MyCAT前世今生"></a>2-1 MyCAT前世今生</h3><p>阿里开源数据库中间件产品：</p><ul><li><p>2008年：Amoeba。</p><p>阿里使用多台MySQL数据库来替代Oracle数据库</p><p>充当MySQL分布式数据库中间层，主要应用在访问层，充当应用程序与数据库之间的代理</p><p>具有负载均衡、高可用、SQL过滤，支持对后端数据库的读写分离</p></li><li><p>2012年：Cobar</p><p>应用3000+台服务器的集群规模</p><p>明天可处理超过10亿的数据库访问</p></li><li><p>2013年：MyCat</p><p>解决了Cobar在高并发的情况下假死</p><p>前后端的……并不是统一的</p></li></ul><h3 id="2-2-MyCAT的主要功能"><a href="#2-2-MyCAT的主要功能" class="headerlink" title="2-2 MyCAT的主要功能"></a>2-2 MyCAT的主要功能</h3><p>MyCat的主要作用：</p><ul><li><p>实现了MySQL通信协议的<strong>分布式数据库系统中间层</strong></p><p>数据库中间层：在架构中的位置，位于前端应用和后端数据库之间的一个应用软件</p><p>数据库中间层：作用，读写分离、负载均衡、数据库连接池（统一控制数据库的连接数量）、屏蔽后端数据库的变更、连接多种类型数据库（如MSSQL、MongoDB等<strong>包括非关系型数据库</strong>）</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gief3798j30hm07cq3l.jpg"  width="350" alt="分布式数据库系统中间层"/></li><li><p>实现数据库的读写分离</p><p>MySQL主从复制集群（写操作在主数据库中执行、读操作在从数据库中执行）</p><p>主从复制实现原理</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gieg9chlj307x09x3yo.jpg"  width="200" alt="数据库的读写分离"/><p>MyCat支持读数据库的负载均衡</p><p>这种情况多出现在一主多从的架构上，将读负载在多个服务器上进行负载均衡</p></li></ul><p>  MyCat支持后端MySQL高可用</p><p>  此处的高可用不同于通过MHA和3M方式复制架构来实现的高可用。在MHA和3M架构中，当主节点宕机之后是可以自动从多个从节点中选择一个新的主节点，并且将其他从节点对这个新的主节点重新进行同步。</p><p>  MyCat对后端数据库的高可用是指，在配置的时候，除了主节点之外，可以指定从节点，实现写操作。当主节点宕机之后，MyCat会把写的SQL路由到配置的写从节点上，并且不支持把其他的从节点对新节点进行主从同步。</p><ul><li><p>数据库垂直拆分</p><p>垂直切蛋糕…</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giegt6poj30jy08h0tk.jpg"  width="400" alt="数据库垂直拆分"/></li><li><p>数据库水平拆分（分库、分表）</p><p>水平切蛋糕…</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giefdedqj30ml08g75d.jpg"  width="430" alt="数据库水平拆分"/><p>将一个数据库通过一定规则进行切分成多个数据库。比如，对userId取模来进行切分，将user表均匀的分到三个数据库中（三个库的表结构是完全一致的）。</p><p>前端应用通过MyCat以及切分规则来对切分后的数据库进行访问。</p><p>MyCat统一实现了切分逻辑，而不同在前端应用中实现切分逻辑。</p></li></ul><h3 id="2-3-MyCAT的主要功能"><a href="#2-3-MyCAT的主要功能" class="headerlink" title="2-3 MyCAT的主要功能"></a>2-3 MyCAT的主要功能</h3><p>见【2-2 MyCAT的主要功能】</p><h3 id="2-4-MyCAT的主要功能"><a href="#2-4-MyCAT的主要功能" class="headerlink" title="2-4 MyCAT的主要功能"></a>2-4 MyCAT的主要功能</h3><p>见【2-2 MyCAT的主要功能】</p><h3 id="2-5-MyCAT的应用场景"><a href="#2-5-MyCAT的应用场景" class="headerlink" title="2-5 MyCAT的应用场景"></a>2-5 MyCAT的应用场景</h3><ul><li><p>需要进行读写分离的场景</p><p>在一台数据库服务器上进行读写混合操作时，数据库读写性能大幅下降，并且读负载明显高于写负载</p><p>MyCat支持多种后端MySQL集群方案来进行读写分离，如一主一从、一主多从、主主复制、PXC集群等等</p></li><li><p>需要进行分库分表的场景（切分）</p><p>最大支持单表1000亿的操作</p></li><li><p>多租户场景（软件架构）</p><p>在多用户的环境下，使用共同的数据库系统的组件，并且可以确保各个 用户之间具有数据隔离性。如云服务。</p></li><li><p>数据统计系统</p></li><li><p>HBASE的一种替代方案</p><p>HBASE是基于Hadoop的一种分布式列存储数据库</p><p>MySQL关系型数据库为行存储</p></li><li><p>需要使用同样的方式查询多种数据库的场景</p><p>MyCat可以同时支持多种数据库，如关系型数据库和NoSQL非关系型数据库。MyCat只向应用提供一个IP访问地址，而数据库存储方式的实现则可以使用各种方案。</p></li></ul><h3 id="2-6-MyCAT的优势"><a href="#2-6-MyCAT的优势" class="headerlink" title="2-6 MyCAT的优势"></a>2-6 MyCAT的优势</h3><ul><li>基于阿里的Cobar系统开发</li><li>开发社区活跃</li><li>完全开源可以自定义开发</li><li>支持多种关系型及NoSQL数据库</li><li>使用JAVA开发，可以部署在多种系统上。建议部署在Linux</li><li>具有在多种行业和项目中应用的成功案例</li></ul><h2 id="第3章-MyCAT基础"><a href="#第3章-MyCAT基础" class="headerlink" title="第3章 MyCAT基础"></a>第3章 MyCAT基础</h2><blockquote><p>本章节主要讲解MyCAT的基础知识，包括MyCAT的安装，启动配置和应用等。通过老师逻辑清晰的讲解，让大家理解并掌握MyCAT在实战中的基本应用。</p></blockquote><h3 id="3-1-MyCAT的基本概念"><a href="#3-1-MyCAT的基本概念" class="headerlink" title="3-1 MyCAT的基本概念"></a>3-1 MyCAT的基本概念</h3><ul><li><p>MYCAT中的数据库一逻辑库</p><p>user_db是逻辑数据库；db01、db02、db03是物理数据库</p><p>MyCat中只保存逻辑库的定义，不保存数据，具体的数据存储在物理数据库中</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gieftwvlj30j908k0tq.jpg"  width="430" alt="MYCAT中的数据库一逻辑库"/></li><li><p>MYCAT中的数据库一逻辑表</p><p>可以用数据库中视图的概念理解</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8giehbahcj30fo07paam.jpg"  width="430" alt="MYCAT中的数据库一逻辑表"/></li></ul><h3 id="3-2-MyCAT的关键特性"><a href="#3-2-MyCAT的关键特性" class="headerlink" title="3-2 MyCAT的关键特性"></a>3-2 MyCAT的关键特性</h3><ul><li><p>支持<strong>SQL92标准</strong></p></li><li><p>支持MySQL集群</p></li><li><p>支持JDBC连接数据库</p></li><li><p>支持NOSQL数据库</p></li><li><p>支持<strong>自动故障切换</strong>，高可用性</p></li><li><p>支持<strong>读写分离</strong></p></li><li><p>支持全局表</p><p>将较少变动的数据统一存储起来</p></li><li><p>支持独有的基于ER关系的分片策略</p><p>根据实体关系ER模型，将相关的表存储在一个分片上，避免调用时跨分片</p></li><li><p>支持一致性HASH分片</p></li><li><p>多平台支持，部署简单方便</p></li><li><p>支持<strong>全局序列号</strong></p><p>将多个数据库表的自增ID统一起来，不出现重复ID</p></li></ul><h3 id="3-3-安装MyCAT"><a href="#3-3-安装MyCAT" class="headerlink" title="3-3 安装MyCAT"></a>3-3 安装MyCAT</h3><ol><li><p>安装Java环境</p></li><li><p>下载MyCat</p></li><li><p>新建MyCat用户</p><p>在Linux系统环境下，最好为每一款软件都独立的建立一个运行账号。既安全又可以对账号进行资源的限制</p></li><li><p>解压MyCat</p></li><li><p>配置环境变量</p><p>Java的HOME目录</p><p>Java的CLASSPATH目录</p><p>MyCat的HOME目录</p></li><li><p>启动MyCat</p></li></ol><h3 id="3-4-MyCAT安装"><a href="#3-4-MyCAT安装" class="headerlink" title="3-4 MyCAT安装"></a>3-4 MyCAT安装</h3><pre><code class="shell">java -versionyum install java-1.7.0-openjdkwget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gzadduser mycat # 建立mycat用户tar -xzvf Mycat-server-1.6.7.1-release-20190627191042-linux.tar.gz # 解压MyCat安装文件mv mycat /usr/local/ # 移动MyCat安装文件到/usr/local/chown mycat:mycat -R mycat # #改变当前文件夹属主和属组vi /etc/profile # 配置环境变量export JAVA_HOME=/usrexport MYCAT_HOME=/usr/local/mycat</code></pre><p>Linux系统安装任何一种软件最好都要新建一个独立用户，不要用root运行，不然会产生不安全的因素</p><h3 id="3-5-MyCAT启动-03-48"><a href="#3-5-MyCAT启动-03-48" class="headerlink" title="3-5 MyCAT启动 (03:48)"></a>3-5 MyCAT启动 (03:48)</h3><p>MyCat两种启动方式：</p><ol><li><p>基于脚本的启动方式</p><p>启动脚本：</p><pre><code class="shell">$MYCAT_HOME/bin/startup_nowrap.sh==&gt;/usr/local/mycat/bin/startup_nowrap.sh</code></pre><p>脚本参数：</p><p>当运行MyCat时，报内存不足或者是内存溢出异常</p><pre><code class="shell">JAVA_OPTS=&quot;-server -Xms1G -Xmx2G -XX:MaxPermSize=64M -XX:+AggressiveOpts -XX:MaxDirectMemorySize=2G&quot;</code></pre><pre><code class="shell"># 切换到mycat用户su - mycatcd /usr/local/mycat# 通过脚本启动MyCatbin/startup_nowrap.sh# 查看进程信息ps -ef# 查看日志cd /usr/local/mycat/logsmore mycat.log</code></pre></li><li><p>bin下已打包的mycat</p></li></ol><h3 id="3-6-MyCAT配置文件"><a href="#3-6-MyCAT配置文件" class="headerlink" title="3-6 MyCAT配置文件"></a>3-6 MyCAT配置文件</h3><ul><li>schema.xml用于配置逻辑库表及数据节点，数据源</li><li>rule.xml用于配置表的分片规则</li><li>server.xml用于配置服务器权限</li></ul><p>schema.xml文件</p><ul><li><p>定义逻辑库表</p><p>逻辑表是要依赖于逻辑库存在的。</p><p>如果数据库不需要进行分片，只进行读写分离，此时不用配置<table>标签，而只保留<schema>标签</p><pre><code class="xml">&lt;schema&gt;    &lt;table&gt;    &lt;/table&gt;&lt;/schema&gt;</code></pre></li><li><p>定义数据节点</p><p>定义MyCat的分片节点，一个数据节点就代表着一个独立的分片。其内容包括数据库节点的名字、数据源真实物理数据库的名称</p><pre><code class="xml">&lt;dataNode&gt;&lt;/dataNode&gt;</code></pre></li><li><p>定义数据节点的物理数据源</p><p>定义了一组主机节点，是真实物理数据库的实例。</p><p>一个<dataHost>标签所指定的主机就是一组真实的MySQL数据库集群</p><p>读写分离配置、心跳检测。。。</p><pre><code class="xml">&lt;dataHost&gt;&lt;/dataHost&gt;</code></pre></li></ul><p>rule.xml文件</p><ul><li><p>定义表使用的分片规则</p><pre><code class="xml">&lt;tableRule name=&quot;&quot;&gt;&lt;/tableRule&gt;</code></pre></li><li><p>定义分片算法</p><pre><code class="xml">&lt;function name=&quot;&quot;&gt;&lt;/function&gt;</code></pre></li></ul><p>server.xml文件</p><ul><li><p>用于定义系统配置</p><p>系统端口号、系统使用内存大小、timeout时间</p><pre><code class="xml">&lt;system&gt;    &lt;property name=&quot;&quot;&gt;    &lt;/property&gt;&lt;/system&gt;</code></pre></li><li><p>用于定义连接MyCat的用户信息</p><p>用户名字、密码</p><p>只有在server.xml中存在的用户才可以通过MyCat连接到后端数据库</p><pre><code class="xml">&lt;user&gt;&lt;/user&gt;</code></pre></li></ul><h3 id="3-7-MyCAT读写分离"><a href="#3-7-MyCAT读写分离" class="headerlink" title="3-7 MyCAT读写分离"></a>3-7 MyCAT读写分离</h3><p>三台服务器：MyCat服务器（node1）、两台MySQL服务器（Master-node2、Slave-node3）</p><p>显示xml文件：</p><pre><code class="shell">ls -lh *xml</code></pre><p>MyCat实现数据库读写分离只需配置两个文件：schema.xml、server.xml</p><pre><code class="xml">&lt;!-- /usr/local/mycat/conf/schema.xml --&gt;&lt;mycat:schema&gt;    &lt;!-- 配置逻辑库USERDB --&gt;    &lt;schema name=&quot;USERDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn1&quot;&gt;&lt;/schema&gt;    &lt;!-- 定义数据节点node1 --&gt;    &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;node1&quot; database=&quot;user_db&quot; /&gt;    &lt;!-- 定义数据库集群 --&gt;    &lt;dataHost name=&quot;node1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; blance=&quot;1&quot; writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt;        &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;        &lt;writeHost host=&quot;10.102.13.3&quot; url=&quot;10.102.13.3:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot;&gt;            &lt;readHost host=&quot;10.102.13.4&quot; url=&quot;10.102.13.4:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot; /&gt;        &lt;/writeHost&gt;        &lt;writeHost host=&quot;10.102.13.4&quot; url=&quot;10.102.13.4:3306&quot; user=&quot;im_user&quot; password=&quot;123456&quot; /&gt;    &lt;/dataHost&gt;&lt;/mycat:schema&gt;</code></pre><p>注：</p><ul><li><p><code>sqlMaxLimit=&quot;100&quot;</code>每一条SQL只返回100行记录</p><p>如果数据库进行了分片操作，查询数据会从所有分片中查询。此时会对系统造成负载</p></li><li><p><code>dataNode=&quot;dn1&quot;</code>定义了数据节点dn1</p></li><li><p><code>blance=&quot;1&quot;</code>定义了是否对后端多个从数据库进行负载均衡。1是0否</p></li><li><p><code>&lt;heartbeat&gt;</code>定义了如何监测后端数据库是否健康</p></li><li><p><code>user=&quot;im_user&quot; password=&quot;123456&quot;</code>定义了后端物理数据库的用户名和密码</p></li></ul><pre><code class="xml">&lt;!-- /usr/local/mycat/conf/server.xml --&gt;&lt;mycat:server&gt;    &lt;system&gt;        &lt;property name=&quot;serverPort&quot;&gt;3306&lt;/property&gt;        &lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;        &lt;property name=&quot;nonePasswordLogin&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useHandshakeV10&quot;&gt;1&lt;/property&gt;        &lt;property name=&quot;useSqlStat&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useGTob]eTablecheck&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;sequnceHandlerType&quot;&gt;2&lt;/property&gt;        &lt;property name=&quot;subqueryRelationshipcheck&quot;&gt; fal se&lt;/property&gt;        &lt;property name=&quot;processorBufferPoolType&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;handlepistributedTransactions&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;useoffHeapForMerge&quot;&gt;1&lt;/property&gt;        &lt;property name=&quot;memoryPageSize&quot;&gt;64k&lt;/property&gt;        &lt;property name=&quot;spi11sFileBuffersize&quot;&gt;1k&lt;/property&gt;        &lt;property name=&quot;usestreamoutput&quot;&gt;0&lt;/property&gt;        &lt;property name=&quot;systemReserveMemorysize&quot;&gt;384m&lt;/property&gt;        &lt;property name=&quot;usezkSwitch&quot;&gt;false&lt;/property&gt;    &lt;/system&gt;    &lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;        &lt;property name=&quot;schemas&quot;&gt;USERDB&lt;/property&gt;    &lt;/user&gt;    &lt;user name=&quot;mc_user&quot;&gt;        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;        &lt;property name=&quot;schemas&quot;&gt;USERDB&lt;/property&gt;        &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;    &lt;/user&gt;&lt;/mycat:server&gt;</code></pre><p>注：</p><ul><li><code>&lt;user&gt;</code>定义的用户在后端数据库中实际并不存在</li></ul><p>重启MyCat：</p><pre><code class="shell"># /usr/local/mycatbin/mycat stopbin/mycat start</code></pre><p>通过MyCat写数据，然后再读取：</p><pre><code class="python"># /root/script/init_data.pyimport MySQLdbfrom faker import Fakertry:    conn = MysQLdb.connect(host=&#39;127.0.0.1&#39;, user=&#39;root&#39;,passwd=&#39;123456&#39;, db=&#39;USERDB&#39;, charset=&quot;utf8&quot;)    cursor=conn. cursor(MySQLdb.cursors.Dictcursor)except MysQLdb.Error, e:    print &quot;Error %d: %s \n&quot; % (e.args[0],e. args[1])try:    faker=Faker()    # write data    for i in range(0, 10):        InSQL=&quot;&quot;&quot;            insert into customer_login(login_name, password, user_stats) VALUES(&#39;%s&#39;, md5(&#39;%s&#39;), 1)        &quot;&quot;&quot;%(faker.name(), faker.ean13())        print InSQL        cursor.execute(InSQL)        cursor.execute(&#39;commit&#39;)    # read data    for i in range(0, 10):        sQLstr=&quot;&quot;&quot;            select login_name from customer_login where customer_id = %d;        &quot;&quot;&quot;%(i)        cursor.execute(SQLstr)        resuit = cursor. fetchall()        print resultexcept MysQLdb.Error,e:    print &quot;Error %d: %s \n&quot; % (e.args[0], e.args[1])finally    cursor.close()    conn.close()</code></pre><p>执行程序：</p><pre><code class="shell"># /root/scriptpython init_data.py</code></pre><p>查看MyCat日志：</p><pre><code class="shell">more /usr/local/mycay/logs/mycat.log</code></pre><p>跟踪日志文件：</p><pre><code class="shell">tailf /usr/local/mycay/logs/mycat.log</code></pre><h3 id="3-8-MyCAT读写分离总结"><a href="#3-8-MyCAT读写分离总结" class="headerlink" title="3-8 MyCAT读写分离总结"></a>3-8 MyCAT读写分离总结</h3><p>步骤：</p><ol><li><p>修改schema.xml文件（/usr/local/mycat/conf/schema.xml）</p><p>对后端数据库的逻辑库、数据节点、数据主机节点进行配置</p><p>由于未进行分片操作，只需配置<schema>标签，无需配置<table>标签</p></li><li><p>修改server.xml文件（/usr/local/mycat/conf/server.xml）</p><p>MyCat向应用程序提供的服务端口、MyCat用户</p></li></ol><h3 id="3-9-MyCAT管理"><a href="#3-9-MyCAT管理" class="headerlink" title="3-9 MyCAT管理"></a>3-9 MyCAT管理</h3><p>使用MySQL客户端管理MyCat</p><ul><li>管理端口：<code>&lt;property name=&quot;managerPort&quot;&gt;9066&lt;/property&gt;</code></li><li>命令：<code>mysql -uroot -p123456 -h127.0.0.1 -P9066</code></li><li>查看管理命令：<code>show @@help</code></li></ul><p>常用管理命令</p><ul><li><p>动态加载配置文件：<code>reload @@config</code></p><p>动态加载MyCat配置文件，但是并不是所有的配置文件都能够通过该命令加载的，某些还需要对MyCat进行重启，后期还会有MyCat高可用方案避免重启对应用程序的影响。</p></li><li><p>查看数据节点：<code>show @@datanode</code></p><p>查看MyCat中配置的节点详情</p></li><li><p>查看后端数据库：<code>show @@datasource</code></p><p>查看MyCat后端的物理数据库的详情</p></li><li><p>查看后端数据库连接：<code>show @@backend</code></p><p>查看MyCat后端的数据库的连接情况</p></li></ul><h2 id="第4章-MyCAT日志分析"><a href="#第4章-MyCAT日志分析" class="headerlink" title="第4章 MyCAT日志分析"></a>第4章 MyCAT日志分析</h2><blockquote><p>通过学习MyCAT日志，掌握MyCAT运行时的相关信息以及应用日志对MyCAT运行时的错误进行跟踪处理。</p></blockquote><h3 id="4-1-MyCAT日志"><a href="#4-1-MyCAT日志" class="headerlink" title="4-1 MyCAT日志"></a>4-1 MyCAT日志</h3><p>配置MyCat日志：</p><ul><li><p>MyCat使用Apache log4j项目管理日志</p></li><li><p>MyCat配置文件：conf/log4j2.xml</p></li></ul><p>log4j2.xml作用</p><ul><li><p>配置日志格式</p><pre><code class="xml">&lt;PatternLayout&gt;    &lt;Pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %5p [%t] - %m%n&lt;/Pattern&gt;&lt;/PatternLayout&gt;</code></pre><pre><code class="log">2019-07-07 15:22:02.485 DEBUG [Timer1] - con query sql:select user() to con:MySQLConnection</code></pre><p>注：</p><ul><li>%d：定义时间。如：2019-07-07 15:22:02.485</li><li>%5p：日志级别。如：DEBUG</li><li>%t：线程信息。如：[Timer1]</li><li>%m：代码提示信息。如：con query sql:select user() to con:MySQLConnection</li><li>%n：回车符</li></ul></li><li><p>配置日志级别</p><ul><li><p><code>&lt;asyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot; /&gt;</code></p></li><li><p>ALL &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF</p></li><li><p>注：</p><ul><li>一般设置Debug模式，最强也就是Info类型</li></ul></li></ul></li></ul><h3 id="4-2-MyCAT日志"><a href="#4-2-MyCAT日志" class="headerlink" title="4-2 MyCAT日志"></a>4-2 MyCAT日志</h3><ol><li><p>MyCat启动过程中输出的日志</p><pre><code class="log">10:45:06.377 INFO [ WrapperSimpleAppMain]-total resouces of dataHost nodel is:310:45:06.389 INFO [ WrapperSimpleAppMain]-create layer cache pool TableID2DataNodeCache of type encache, default cache size 10000, default expire seconds1800010:45:06.391 INFO [ WrapperSimpleAppMain]-create child Cache: TESTDB_ORDERS for layered cache TableID2DataNodeCache, size 50000, expire seconds 1800010:45:06.523 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from ehcache. xml found in the classpath: file:/usr/1ocal/mycat/conf/ehcache. xml10:45:06.525 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from URL: file:/usr/1ocal/mycat/conf/ehcache. xmll10:45:06.525 DEBUG [ WrappersimpleAppMain]-Configuring ehcache from InputStream10:45:06.652 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xmlns: mycat10:45:06.653 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xmlns: xsi10:45:06.653 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute maxEntriesLocalHeap10:45:06.656 DEBUG [ WrapperSimpleAppMain]-Ignoring ehcache attribute xsi: noNamespaceSchemalocation10:45:06.689 DEBUG [ WrappersimpleAppMain]-Creating new CacheManager with default config10:45:06.723 DEBUG [ WrapperSimpleAppMain]-propertiesstring is null.10:45:06.812 DEBUG[ WrapperSimpleAppMain]-Cacheuriter factory not configured. Skipping...10:45:06.812 DEBUG [ WrappersimpleAppMain]-Initialized net. sf. ehcache. store. NotifyingMemoryStore for SQLRouteCache10:45:06.813 DEBUG [ WrappersimpleAppMain]-Initialised cache: SQLRouteCache10:45:06.828 INFO [ WrappersimpleAppMain]-dyna class load from./catlet, and auto check for class file modified every 60 seconds10:45:06.830 DEBUG [ WrappersimpleAppMain]-baseDir./tmlogs/10:45:06.830 DEBUG[ WrappersimpleAppMain]-baseName tmlog</code></pre><p>注：</p><ul><li>total resouces of dataHost nodel is:3。3个主机节点</li></ul></li><li><p>MyCat线程数</p><pre><code class="log">10:45:06.875 INFO[ WrapperslimpleAppMain]-MyCat is ready to startup.….10:45:06.875 INFO [ WrappersimpleAppMain]-Startup processors..., total processors:48, aio thread pool size:96each process allocated socket buffer pool bytes,a page size:2097152 a page&#39;s chunk number(Pagesize/Chunksize) is:512buffer page&#39;s number is:960</code></pre><p>注：</p><ul><li>total processors:48。线程数为48，默认为线程数等于CPU核数。</li><li>aio thread pool size:96。aio进程池数量为CPU核数的两倍</li></ul></li><li><p>server.xml中配置MyCat的启动参数</p><pre><code class="log">10:45:06.875 INFO[ WrapperSimpleAppMain]-sysconfig params: Systemconfig[processorBufferLocalPercent=100,frontSocketSoRcvbuf=1048576,frontSocketSoSndbuf=4194304,backSocketSoRcvbuf=4194384,backSocketSosndbuf=1048576,frontSocketNoDelay=1,backSocketNoDelay=1,maxStringLiteralLength=65535,frontwriteQueueSize=2048,bindIp=0.0.0.0,serverPort=3306,managerPort=9066,charset=utf8,processors=48,processorExecutor=96,timerExecutor=2,managerExecutor=2,idleTimeout=1800000,catletC1assCheckSeconds=60,sqlExecuteTimeout=300,processorCheckPeriod=1000,dataNodeIdleCheckPeriod=300000,dataNodeHeartbeatPeriod=10000,clusterHeartbeatUser=HEARTBEAT_USER_,clusterHeartbeatPass=_HEARTBEAT_PASS_,clusterHeartbeatPeriod=5000,clusterHeartbeatTimeout=10000,clusterHeartbeatRetry=10,txIsolation=3,parserCommentVersion=50148,sq1RecordCount=10,bufferPoolPageSize=2097152,bufferPoolChunkSize=4096,bufferPoolPageNumber=960,maxResultSet=524288,bigResultsizesqlCount=10,bufferUsagePercent=80,flowControlRejectStrategy=0,clearBigSqLResultSetMapMS=600000,defaultMaxLimit=100,sequnceHandlerType=2,mutiNodeLimitType=e,mutiNodePatchSize=100,defaultSqlParser=druidparser,usingArO=0,packetHeaderSize=4,maxPacketsize=16777216,mycatNodeId=1]</code></pre><p>注：</p><ul><li>serverPort=3306。MyCat对外提供服务的端口号</li><li>managerPort=9066。MyCat管理端口</li><li>charset=utf8。MyCat默认字符集</li><li>processors=48。MyCay进程数</li><li>processorExecutor=96。MyCay进程池大小</li><li>idleTimeout=1800000。应用程序与MyCat连接超时时间</li><li>defaultMaxLimit=100。MyCat默认返回结果集行数</li><li>maxPacketsize=16777216。最大包大小，一定不能大于在MySQL中配置的大小。</li></ul></li><li><p>MyCat监听端口的启动</p><pre><code class="log">10:45:08.158 INFO [WrapperSimpleAppMain]-using nio network handler10:45:08.224 INFO [WrapperSimpleAppMain]-$ MyCatManager is started and listening on 906610:45:08.224 INFO[WrappersimpleAppMain]-$_MyCatserver is started and listening on 3306</code></pre></li><li><p>MyCat对后端连接池的初始化</p><pre><code class="log">10:45:08.224 INFO[WrapperSimpleAppMain]-============================10:45:08.224 INFO[WrapperSimpleAppMain]-Initialize dataHost...10:45:08.224 INFO[WrappersimpleAppMain]-init datahost:nodel to use datasource index:110:45:08.225 INFO[WrappersimpleAppMain]-init backend myqsl source，create connections total 10 for 192.168.13.4 index:110:45:08.226 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.227 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.228 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.229 INFO[WrappersimpleAppMain]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db10:45:08.271 INFO[$_NIOREACTOR-1-RW]-connected successfuly MysQLConnection[id=1, 1astTime=1520217908270, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233481, harset=utf8, txIsolat ion=3, autocommit=true, attachment=nul1, respHandler=null, host=192.168.13.4, port=3306, statussync=null, uriteQueue=e, modifiedSQLExecuted=false]10:45:08.271 INFO[$_NIOREACTOR-5-RW]-connected successfuly MysQLConnection[id=5, 1astTime=152021790827e, er=imuser, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233482, harset=utf8, txIsolat ion=3, autocommit=true, attachment=nul1, respHandler=nul1, host=192.168.13.4, port=3306, statussync=null, writeQueue=0, modifiedSQLExecuted=false]</code></pre></li><li><p>MyCat初始化完成之后的输出</p><pre><code class="log">10:45:08.334 INFO [WrapperSimpleAppMain]-init result :finished 10 success 10 target count:1010:45:08.334 INFO [WrappersimpleAppMain]-nodel index:1 init success</code></pre></li><li><p>MyCat对后端数据库进行心跳检测</p><pre><code class="log">10:45:08.347 INFO [ Timer1]-no ilde connection in pool, create new connection for 192.168.13.3 of schema user db10:45:08.348DEBUG[ Timer1]-con query sql: select user() to con: MysQLConnection [ id=2, 1astTime=1520217908348, iser=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=2233483, charset=utf8, txIsol ation=3, autocommit=true, attachment=nul1, respHandler=nul1, host=192.168.13.4, port=3306, statussync=null, writeQueue=0,m odifiedSQLExecuted=false]10:45:08.348 INFO[$_NIOREACTOR-11-RW]-connectionAcquired MySQLConnection [ id=11,1astTime=1520217908348, er=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=true, threadId=2233490, charset=utf8, txIsolatio1=3, autocommit=true, attachment=nul1, respHandler=null, host=192.168,13.4, port=3306, statussync=nul1, writeQueue=e, modif iedSQLExecuted=false]10:45:08.373 INFO [ Timer1]-no ilde connection in pool, create new connection for 192.168.13.4 of schema user_db18:45:08.377 DEBUG[$_NTOREACTOR-12-RW]-con query sql: select user() to con: MysQLconnection [ id=12, lastTime=1520217908377, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=false, threadId=908148, charset=utf8, txIsolation=3, autocommit=true, attachment=nul1, respHandler=nu11, host=192.168.13.3, port=3306, statusSync=nul1, wri teQueue=e, modifiedSQLExecuted=false]</code></pre></li><li><p>应用程序登录到MyCat输出的信息</p><pre><code class="log">14:16:48.257 INFO[$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB]&#39;root&#39; login success14:16:48.259 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show databases14:16:48.260 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show tables14:16:48.260 DEBUG[$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] show tables, route={    1-&gt;dnl{ show tables}} rrs</code></pre></li><li><p>向MyCat发送一条SQL语句输出的日志</p><pre><code class="log">14:16:48.262 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] select * from customer_login where login_name=&#39; John Miller14:16:48.263 DEBUG[$_NIOREACTOR-7-RW]-SQLRouteCache miss cache, key: USERDB select * from customer_1ogin where login_name=&#39;John Miller&#39;14:16:48.263 DEBUG [$_NIOREACTOR-7-RW]-ServerConnection [ id=6, schema=USERDB, host=127.0.0.1, user=root, txIsolation=3, autocommit=true, schema=USERDB] select * from customer_login where 1ogin_name=&#39; John Miller&#39;, route={    1-&gt; dnl{ select * from customer_login where login_name=&#39; John Miller}} rrs</code></pre></li><li><p>具体SQL执行过程</p><pre><code class="log">14:16:48.263 DEBUG [$_NIOREACTOR-7-RW]-select read source 192.168.13.4 for dataHost: nodel14:16:48.265 DEBUG[$_NIOREACTOR-13-RW]-release connection MySQLConnection [ id=13,1astTime=1520230608256, user=im_user, schema=user_db, old shema=user_db, borrowed=true, fromslaveDB=true, threadId=2233491, charset=utf8, txIsolation=3, autocommit=true, attachment=dnl{ select * from customer_login where login_name=&#39; John Miller&#39;}, respHandler=SingleNodeHandler [ node=dn1{ select * from customer_login where login_name=&#39;John Miller&#39;}, packetId=8], host=192.168.13.4, port=3306, statussync=null, writeQueue=0, modifiedSQLExecuted=false]</code></pre></li></ol><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>本章节主要对课程中涉及到的全部知识点进行知识总结。并介绍进一步学习MyCAT的学习途径。</p></blockquote><h3 id="5-1-总结"><a href="#5-1-总结" class="headerlink" title="5-1 总结"></a>5-1 总结</h3><p>已学内容：</p><ul><li>MyCat起源</li><li>MyCat基本概念</li><li>如何安装、启动、配置MyCat</li><li>利用MyCat实现对后端数据库的读写分离</li><li>MyCat主要功能和应用场景</li></ul><p>未讲内容：</p><ul><li>如何利用MyCat对后端数据库进行分片</li><li>如何对分片集群进行备份</li><li>分片集群中宕机一台服务器会有什么影响</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mycat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>945-SpringBoot+MyBatis搭建迷你小程序</title>
      <link href="/imooc/945-mini-app/"/>
      <url>/imooc/945-mini-app/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/945" target="_blank" rel="noopener">https://www.imooc.com/learn/945</a></p><p>简介：用Spring Boot框架大大简化了新Spring应用的初始搭建以及开发过程，在开发人员中越来越受到欢迎。微信小程序作为目前炙手可热的应用，很有可能在未来占据轻应用的市场。本门课程的主要目的是将两者结合起来，同时希望作为入门翔仔之前实战课的一个更低门槛的课程进行讲解。本课分为三大部分：第一部分带领大家明确需求，从零开始进行SpringBoot+MyBatis的框架搭建；第二部分咱们将依据业务模块配合UT实现后端完整的增删改查功能；最后我们将来到微信小程序开发部分，帮大家入门微信小程序开发，并教会大家前后联调。老师相关实战课程：<a href="http://coding.imooc.com/class/144.html" target="_blank" rel="noopener">http://coding.imooc.com/class/144.html</a> 老师的面试课程： <a href="https://coding.imooc.com/class/303.html" target="_blank" rel="noopener">https://coding.imooc.com/class/303.html</a></p></blockquote><p><a href="https://gitee.com/xiangze/areadisplay" target="_blank" rel="noopener">讲师源码-前端</a><br><a href="https://gitee.com/xiangze/demo" target="_blank" rel="noopener">讲师源码-后端</a></p><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>本章节讲解本门课程的主旨，便于同学掌握课程的来龙去脉。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>学习本门课程的作用：</p><ul><li>学会从0搭建后端的SpringBoot + MyBatis框架</li><li>微信小程序入门</li><li>规范的代码编写</li></ul><p>本门课程的框架：</p><ul><li>从0搭建后端的springboot + mybatis框架</li><li>实现后端的业务功能</li><li>实现本地微信小程序的前端开发</li><li>前端与后端的联调</li></ul><p>技术储备要求：</p><ul><li>基本的Java知识</li><li>基本的前端开发知识(简单了解HTML,JS等)</li><li>Spring , Mybatis基础知识(不会也没关系)</li></ul><h3 id="1-2-最终效果展示"><a href="#1-2-最终效果展示" class="headerlink" title="1-2 最终效果展示"></a>1-2 最终效果展示</h3><p>登录、区域信息的增删改查</p><h2 id="第2章-项目设计及框架搭建"><a href="#第2章-项目设计及框架搭建" class="headerlink" title="第2章 项目设计及框架搭建"></a>第2章 项目设计及框架搭建</h2><blockquote><p>本章节讲解项目的需求分析、数据库设计以及后端SpringBoot + Mybatis框架的搭建</p></blockquote><h3 id="2-1-SpringBoot的搭建与启动上"><a href="#2-1-SpringBoot的搭建与启动上" class="headerlink" title="2-1 SpringBoot的搭建与启动上"></a>2-1 SpringBoot的搭建与启动上</h3><p><a href="https://spring.io/" target="_blank" rel="noopener">Spring官网</a></p><pre><code class="yaml">server.context-path=/demo //设置上下文路径  server.port=8888 //设置端口号</code></pre><h3 id="2-3-功能点的明确"><a href="#2-3-功能点的明确" class="headerlink" title="2-3 功能点的明确"></a>2-3 功能点的明确</h3><p>区域信息的增删改查</p><h3 id="2-4-表设计与实体类的创建"><a href="#2-4-表设计与实体类的创建" class="headerlink" title="2-4 表设计与实体类的创建"></a>2-4 表设计与实体类的创建</h3><ul><li><p>表设计</p><pre><code class="sql">CREATE DATABASE IF NOT EXISTS `imooc_945_mini_app`;USE `imooc_945_mini_app`;SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for tb_area-- ----------------------------DROP TABLE IF EXISTS `tb_area`;CREATE TABLE `tb_area` (  `area_id`        INT(2)      NOT NULL AUTO_INCREMENT  COMMENT &#39;主键ID&#39;,  `area_name`      VARCHAR(200) CHARACTER SET utf8  COLLATE utf8_general_ci      NOT NULL  COMMENT &#39;名称&#39;,  `priority`       INT(2)      NOT NULL DEFAULT 0  COMMENT &#39;权重，越大越排前显示&#39;,  `create_time`    DATETIME(0) NULL     DEFAULT NULL  COMMENT &#39;创建时间&#39;,  `last_edit_time` DATETIME(0) NULL     DEFAULT NULL  COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`area_id`) USING BTREE,  UNIQUE INDEX `UK_AREA`(`area_name`) USING BTREE)  ENGINE = InnoDB  AUTO_INCREMENT = 1  CHARACTER SET = utf8  COLLATE = utf8_general_ci  COMMENT = &#39;区域信息&#39;  ROW_FORMAT = DYNAMIC;SET FOREIGN_KEY_CHECKS = 1;</code></pre></li><li><p>实体类</p><pre><code class="java">// 区域信息public class Area {    // 主键ID    private Integer areaId;    // 名称    private String areaName;    // 权重，越大越排前显示    private Integer priority;    // 创建时间    private Date createTime;    // 更新时间    private Date lastEditTime;}</code></pre></li></ul><h2 id="第3章-项目开发"><a href="#第3章-项目开发" class="headerlink" title="第3章 项目开发"></a>第3章 项目开发</h2><blockquote><p>本章节带领大家从零开始从Dao到Controller开发一个完整的带单元测试增删改查后端。</p></blockquote><ul><li>配置</li><li>接口</li><li>mapper</li><li>ut，即单元测试</li></ul><h3 id="3-1-pom的配置"><a href="#3-1-pom的配置" class="headerlink" title="3-1 pom的配置"></a>3-1 pom的配置</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--数据库--&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--连接池--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.mchange&lt;/groupId&gt;    &lt;artifactId&gt;c3p0&lt;/artifactId&gt;    &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="3-2-mybatis-config的配置"><a href="#3-2-mybatis-config的配置" class="headerlink" title="3-2 mybatis-config的配置"></a>3-2 mybatis-config的配置</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置全局属性--&gt;    &lt;settings&gt;        &lt;!--使用JDBC的getGeneratedKeys获取数据库自增主键值--&gt;        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;        &lt;!--使用列标签替换列别名 默认：true--&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;        &lt;!--开启驼峰命名转换：Table{create_time} -&gt; Entity{createTime}--&gt;        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;&lt;/configuration&gt;</code></pre><h3 id="3-3-datasource和sessionfactorybean的配置"><a href="#3-3-datasource和sessionfactorybean的配置" class="headerlink" title="3-3 datasource和sessionfactorybean的配置"></a>3-3 datasource和sessionfactorybean的配置</h3><ul><li><p>配置datasource到ioc容器里面</p><pre><code class="java">@Configuration// 配置mybatis mapper的扫描路径@MapperScan(&quot;com.tuyrk.dao&quot;)public class DataSourceConfiguration {    @Value(&quot;${jdbc.driver}&quot;)    private String jdbcDriver;    @Value((&quot;${jdbc.url}&quot;))    private String jdbcUrl;    @Value(&quot;${jdbc.username}&quot;)    private String jdbcUsername;    @Value(&quot;${jdbc.password}&quot;)    private String jdbcPassword;    // 生成与spring-dao.xml对应的bean dataSource    @Bean(name = &quot;dataSource&quot;)    public ComboPooledDataSource createDataSource() throws PropertyVetoException {        // 生成datasource实例        ComboPooledDataSource dataSource = new ComboPooledDataSource();        // 跟配置文件一样设置以下信息        // 驱动        dataSource.setDriverClass(jdbcDriver);        // 数据库连接URL        dataSource.setJdbcUrl(jdbcUrl);        // 设置用户名        dataSource.setUser(jdbcUsername);        // 设置用户密码        dataSource.setPassword(jdbcPassword);        // 配置c3p0连接池的私有属性        // 连接池最大线程数        dataSource.setMaxPoolSize(30);        // 连接池最小线程数        dataSource.setMinPoolSize(10);        //关闭连接后不自动commit        dataSource.setAutoCommitOnClose(false);        // 连接超时时间        dataSource.setCheckoutTimeout(10000);        // 连接失败重试次数        dataSource.setAcquireRetryAttempts(2);        return dataSource;    }}</code></pre></li><li><p>创建sqlSessionFactoryBean实例</p><pre><code class="java">@Configurationpublic class SessionFactoryConfiguration {    // mybatis-config.xml配置文件的路径    @Value(&quot;${mybatis_config_file}&quot;)    private String mybatisConfigFilePath;    // mybatis mapper文件所在的路径    @Value(&quot;${mapper_path}&quot;)    private String mapperPath;    // 实体类所在的Package    @Value(&quot;${entity_package}&quot;)    private String entityPackage;    @Autowired    @Qualifier(&quot;dataSource&quot;)    private DataSource dataSource;    // 创建sqlSessionFactoryBean实例 并且设置configtion 设置mapper映射路径 设置datasource数据源    @Bean(name = &quot;sqlSessionFactory&quot;)    public SqlSessionFactoryBean createSqlSessionFactoryBean() throws IOException {        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        // 设置mybatis configuration 扫描路径        sqlSessionFactoryBean.setConfigLocation(new ClassPathResource(mybatisConfigFilePath));        // 添加mapper 扫描路径        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();        String packageSearchPath = PathMatchingResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + mapperPath;        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(packageSearchPath));        // 设置dataSource        sqlSessionFactoryBean.setDataSource(dataSource);        // 设置typeAlias 包扫描路径        sqlSessionFactoryBean.setTypeAliasesPackage(entityPackage);        return sqlSessionFactoryBean;    }}</code></pre></li></ul><h3 id="3-4-dao的创建"><a href="#3-4-dao的创建" class="headerlink" title="3-4 dao的创建"></a>3-4 dao的创建</h3><pre><code class="java">public interface AreaDao {    // 列出区域列表    List&lt;Area&gt; queryArea();    // 根据Id列出具体区域    Area queryAreaById(Integer areaId);    // 插入区域信息    Integer insertArea(Area area);    // 更新区域信息    Integer updateArea(Area area);    // 删除区域信息    Integer deleteArea(Integer areaId);}</code></pre><h3 id="3-5-mapper的编写"><a href="#3-5-mapper的编写" class="headerlink" title="3-5 mapper的编写"></a>3-5 mapper的编写</h3><p>自动化生成mapper工具：</p><ul><li><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper      PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;      &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.tuyrk.dao.AreaDao&quot;&gt;  &lt;!-- 查询区域信息列表 --&gt;  &lt;select id=&quot;queryArea&quot; resultType=&quot;com.tuyrk.entity.Area&quot;&gt;      SELECT          area_id,          area_name,          priority,          create_time,          last_edit_time      FROM tb_area      ORDER BY priority DESC;  &lt;/select&gt;  &lt;!-- 根据区域ID，查询区域信息 --&gt;  &lt;select id=&quot;queryAreaById&quot; resultType=&quot;com.tuyrk.entity.Area&quot;&gt;      SELECT          area_id,          area_name,          priority,          create_time,          last_edit_time      FROM tb_area      WHERE area_id = #{areaId}  &lt;/select&gt;  &lt;!-- 新增区域信息 --&gt;  &lt;insert id=&quot;insertArea&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;areaId&quot; keyColumn=&quot;area_id&quot;          parameterType=&quot;com.tuyrk.entity.Area&quot;&gt;      INSERT INTO tb_area (area_name, priority, create_time, last_edit_time)      VALUES (#{areaName}, #{priority}, #{createTime}, #{lastEditTime});  &lt;/insert&gt;  &lt;!-- 更新区域信息 --&gt;  &lt;update id=&quot;updateArea&quot; parameterType=&quot;com.tuyrk.entity.Area&quot;&gt;      update tb_area      &lt;set&gt;          &lt;if test=&quot;areaName != null&quot;&gt;area_name = #{areaName},&lt;/if&gt;          &lt;if test=&quot;priority != null&quot;&gt;priority = #{priority},&lt;/if&gt;          &lt;if test=&quot;lastEditTime != null&quot;&gt;last_edit_time = #{lastEditTime}&lt;/if&gt;      &lt;/set&gt;      where area_id = #{areaId};  &lt;/update&gt;  &lt;!-- 根据区域ID，删除区域信息 --&gt;  &lt;delete id=&quot;deleteArea&quot;&gt;      DELETE FROM tb_area      WHERE area_id = #{areaId};  &lt;/delete&gt;&lt;/mapper&gt;</code></pre><h3 id="3-6-dao层开发"><a href="#3-6-dao层开发" class="headerlink" title="3-6 dao层开发"></a>3-6 dao层开发</h3><pre><code class="java">@Autowiredprivate AreaDao areaDao;</code></pre></li></ul><p><strong>areaDao红线报错解决方案</strong>：</p><ul><li>【File】==&gt;【settings】==&gt;【Inspections】==&gt;【Spring】==&gt;【Spring Core】==&gt;【Code】==&gt;【Autowiring for Bean Class】==&gt;【Warning】</li></ul><p>UT单元测试：</p><ul><li><p>AreaDaoTest.java的编写</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class AreaDaoTest {    //通过spring容器注入Dao的实现类    @Autowired    private AreaDao areaDao;    @Test    public void queryArea() {        List&lt;Area&gt; areaList = areaDao.queryArea();        // 验证预期值和实际值是否相符        assertEquals(2, areaList.size());    }    // ...}</code></pre></li></ul><p><strong>如此繁多的框架应该学习哪一个</strong>？</p><ul><li><p>答：Spring。多看Spring源码，学习框架设计。</p><h3 id="3-7-service层的实现"><a href="#3-7-service层的实现" class="headerlink" title="3-7 service层的实现"></a>3-7 service层的实现</h3></li><li><p>配置<br>对标spring-service里面的transactionManager<br>继承TransactionManagementConfiguration是因为开启annotation-driven</p><pre><code class="java">@Configuration// 首先使用注解 @EnableTransactionManagement 开启事务支持后// 在Service方法上添加注解 @Transactional 便可@EnableTransactionManagement// 开启事务的管理public class TransactionManagementConfiguration implements TransactionManagementConfigurer {    @Autowired    // 注入DataSourceConfiguration里边的DataSource，通过createDataSource()获取    private DataSource dataSource;     // 关于事务管理，需要返回PlatformTransactionManager的实现    @Override    public PlatformTransactionManager annotationDrivenTransactionManager() {        return new DataSourceTransactionManager(dataSource);    }}</code></pre></li><li><p>接口</p><pre><code class="java">public interface AreaService {    // 获取区域列表    List&lt;Area&gt; getAreaList();    // 通过区域Id获取区域信息    Area getAreaById(int areaId);    // 增加区域信息    boolean addArea(Area area);    // 修改区域信息    boolean modifyArea(Area area);    // 删除区域信息    boolean deleteArea(int areaId);}</code></pre></li><li><p>实现类</p><h3 id="3-8-业务controller方法的实现"><a href="#3-8-业务controller方法的实现" class="headerlink" title="3-8 业务controller方法的实现"></a>3-8 业务controller方法的实现</h3></li><li><p>业务Controller方法的实现</p></li><li><p>统一异常处理</p></li></ul><p>浏览器JSON格式化查看插件：JsonView</p><h3 id="3-9-统一异常处理功能的实现"><a href="#3-9-统一异常处理功能的实现" class="headerlink" title="3-9 统一异常处理功能的实现"></a>3-9 统一异常处理功能的实现</h3><pre><code class="java">@ControllerAdvicepublic class GlobalExceptionHandler {    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Map&lt;String, Object&gt; handlerException(HttpServletRequest request, Exception e) {        Map&lt;String, Object&gt; modelMap = new HashMap&lt;&gt;();        modelMap.put(&quot;success&quot;, false);        modelMap.put(&quot;errMsg&quot;, e.getMessage());        return modelMap;    }}</code></pre><h2 id="第4章-微信小程序的入门及前后联调"><a href="#第4章-微信小程序的入门及前后联调" class="headerlink" title="第4章 微信小程序的入门及前后联调"></a>第4章 微信小程序的入门及前后联调</h2><blockquote><p>本章节将带领大家入门微信小程序，并实现本项目的前端功能，同时进行前后端联调。</p></blockquote><h3 id="4-1-微信小程序简介"><a href="#4-1-微信小程序简介" class="headerlink" title="4-1 微信小程序简介"></a>4-1 微信小程序简介</h3><p><a href="https://developers.weixin.qq.com/miniprogram/dev/index.html" target="_blank" rel="noopener">小程序开发文档</a></p><p>小程序代码构成：</p><ol><li>JSON配置</li><li>WXML模板</li><li>WXSS样式</li><li>JS逻辑交互<h3 id="4-2-微信开发者工具简介"><a href="#4-2-微信开发者工具简介" class="headerlink" title="4-2 微信开发者工具简介"></a>4-2 微信开发者工具简介</h3><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">下载</a></li></ol><p>模拟器、编辑器、调试器</p><h3 id="4-3-创建新的小程序"><a href="#4-3-创建新的小程序" class="headerlink" title="4-3 创建新的小程序"></a>4-3 创建新的小程序</h3><p>【项目目录】==&gt;【APPID（测试号）】==&gt;【项目名称】==&gt;【建立普通快速启动模板】</p><h3 id="4-4-列表页开发"><a href="#4-4-列表页开发" class="headerlink" title="4-4 列表页开发"></a>4-4 列表页开发</h3><p>修改标题：</p><ul><li>在*.json中添加<code>&quot;navigationBarTitleText&quot;: &quot;区域信息列表&quot;</code></li></ul><p>组件：</p><ul><li>view：类似于html的div</li><li>scroll-view：可滚动试图区域</li><li>text：文本</li></ul><pre><code class="html">&lt;!--pages/list/list.wxml--&gt;&lt;view class=&#39;container&#39;&gt;  &lt;!-- 表头 --&gt;  &lt;view class=&#39;widget&#39;&gt;    &lt;text class=&#39;column&#39;&gt;ID&lt;/text&gt;    &lt;text class=&#39;column&#39;&gt;区域名&lt;/text&gt;    &lt;text class=&#39;column&#39;&gt;优先级&lt;/text&gt;    &lt;text class=&#39;link-column&#39;&gt;操作&lt;/text&gt;  &lt;/view&gt;  &lt;!-- 数据展示区域 --&gt;  &lt;scroll-view scroll-y=&quot;true&quot;&gt;    &lt;view&gt;      &lt;block wx:for=&quot;{{list}}&quot;&gt;        &lt;view class=&quot;widget&quot;&gt;          &lt;text class=&#39;column&#39;&gt;{{item.areaId}}&lt;/text&gt;          &lt;text class=&#39;column&#39;&gt;{{item.areaName}}&lt;/text&gt;          &lt;text class=&#39;column&#39;&gt;{{item.priority}}&lt;/text&gt;          &lt;view class=&#39;link-column&#39;&gt;            &lt;navigator class=&#39;link&#39; url=&#39;../operation/operation?areaId={{item.areaId}}&#39;&gt;编辑&lt;/navigator&gt;|            &lt;text class=&#39;link&#39; bindtap=&#39;deleteArea&#39; data-areaid=&#39;{{item.areaId}}&#39; data-areaname=&#39;{{item.areaName}}&#39; data-index=&#39;{{index}}&#39;&gt;删除&lt;/text&gt;          &lt;/view&gt;        &lt;/view&gt;      &lt;/block&gt;    &lt;/view&gt;  &lt;/scroll-view&gt;  &lt;!-- 按钮 --&gt;  &lt;button type=&#39;primary&#39; bindtap=&#39;addArea&#39;&gt;添加区域信息&lt;/button&gt;&lt;/view&gt;</code></pre><ul><li><p>列表展示</p><pre><code class="javascript">onShow: function() {  var that = this;  wx.request({    url: &#39;http://127.0.0.1:8888/demo/superadmin/listarea&#39;,    data: {},    method: &#39;GET&#39;,    success: function(res) {      var list = res.data.areaList;      console.log(res);      if (list == null) {        var toastText = &#39;获取数据失败&#39; + res.data.errMsg;        wx.showToast({          title: toastText,          icon: &#39;&#39;,          duration: 2000        })      } else {        that.setData({          list: list        });      }    }  })}</code></pre></li><li><p>删除功能</p><pre><code class="javascript">deleteArea: function(e) {  var that = this;  // 0. 询问用户是否删除该信息  wx.showModal({    title: &#39;提示&#39;,    content: &#39;确定要删除[&#39; + e.target.dataset.areaname + &#39;]吗？&#39;,    success: function(sm) {      // 如果点击确认，      if (sm.confirm) {        // 1. 获取areaId，将其传递给后台做删除操作        wx.request({          url: &#39;http://127.0.0.1:8888/demo/superadmin/removearea&#39;,          data: {            &quot;areaId&quot;: e.target.dataset.areaid          },          method: &#39;GET&#39;,          success: function(res) {            var result = res.data.success;            var toastText = &quot;删除成功！&quot;;            if (result != true) {              toastText = &quot;刪除失敗！&quot;;            } else {              // 2. 更新list值              that.data.list.splice(e.target.dataset.index, 1);              that.setData({                list: that.data.list              })            }            // 彈出提示            wx.showToast({              title: toastText,              icon: &#39;&#39;,              duration: 2000            })          }        })      }    }  })}</code></pre></li><li><p>跳转到添加区域信息</p><pre><code class="javascript">addArea: function() {  wx.navigateTo({    url: &#39;../operation/operation&#39;  });}</code></pre></li></ul><h3 id="4-7-列表页前后端联调"><a href="#4-7-列表页前后端联调" class="headerlink" title="4-7 列表页前后端联调"></a>4-7 列表页前后端联调</h3><h3 id="4-8-区域信息编辑页的开发"><a href="#4-8-区域信息编辑页的开发" class="headerlink" title="4-8 区域信息编辑页的开发"></a>4-8 区域信息编辑页的开发</h3><pre><code class="html">&lt;!--pages/operation/operation.wxml--&gt;&lt;view class=&quot;container&quot;&gt;  &lt;form bindsubmit=&#39;formSubmit&#39; bindreset=&#39;formReset&#39;&gt;    &lt;!-- 输入框  --&gt;    &lt;view class=&#39;row&#39;&gt;      &lt;text&gt;区域名：&lt;/text&gt;      &lt;input type=&#39;text&#39; name=&#39;areaName&#39; placeholder=&#39;请输入区域名&#39; value=&#39;{{areaName}}&#39;/&gt;    &lt;/view&gt;    &lt;view class=&#39;row&#39;&gt;      &lt;text&gt;优先级：&lt;/text&gt;      &lt;input type=&#39;number&#39; name=&#39;priority&#39; placeholder=&#39;数值越大越靠前&#39; value=&#39;{{priority}}&#39;/&gt;    &lt;/view&gt;    &lt;!-- 按钮  --&gt;    &lt;view class=&#39;row&#39;&gt;      &lt;button type=&#39;primary&#39; form-type=&#39;submit&#39;&gt;提交&lt;/button&gt;      &lt;button type=&#39;primary&#39; form-type=&#39;reset&#39;&gt;清空&lt;/button&gt;    &lt;/view&gt;  &lt;/form&gt;&lt;/view&gt;</code></pre><ul><li>区域信息添加</li><li>区域信息更新</li></ul><ul><li><p>页面的初始数据</p><pre><code class="javascript">data: {  areaId: undefined,  areaName: &#39;&#39;,  priority: &#39;&#39;,  addUrl: &#39;http://127.0.0.1:8888/demo/superadmin/addarea&#39;,  modifyUrl: &#39;http://127.0.0.1:8888/demo/superadmin/modifyarea&#39;}</code></pre></li><li><p>编辑页获取区域信息</p><pre><code class="javascript">onLoad: function(options) {  var that = this;  // 页面初始化 options为页面跳转所带来的参数  this.setData({    areaId: options.areaId  });  if (options.areaId == undefined) {    return;  }  // 向后端发送请求，获取areaId的区域信息  wx.request({    url: &#39;http://127.0.0.1:8888/demo/superadmin/getareabyid&#39;,    data: {      &quot;areaId&quot;: options.areaId    },    method: &#39;GET&#39;,    success: function(res) {      var area = res.data.area;      if (area == undefined) {        var toastText = &quot;获取数据失败&quot; + res.data.errMsg;        wx.showToast({          title: toastText,          icon: &#39;&#39;,          duration: 2000        });      } else {        that.setData({          areaName: area.areaName,          priority: area.priority        });      }    }  })}</code></pre></li><li><p>提交区域信息表单</p><pre><code class="javascript">formSubmit: function (e) {  var that = this;  // 默认为新增操作  var formData = e.detail.value;  var url = that.data.addUrl;  // 如果areaId不为空，则为更新操作  if (that.data.areaId != undefined) {    formData.areaId = that.data.areaId;    url = that.data.modifyUrl;  }  wx.request({    url: url,    data: JSON.stringify(formData),    method: &#39;POST&#39;,    header: {      &#39;Content-Type&#39;: &#39;application/json&#39;    },    success: function(res) {      var result = res.data.success;      var toastText = &quot;操作成功&quot;;      if (result != true) {        toastText = &quot;操作失败&quot; + res.data.errMsg;      }      wx.showToast({        title: toastText,        icon: &#39;&#39;,        duration: 2000      });      if (that.data.areaId == undefined) {        wx.redirectTo({          url: &#39;../list/list&#39;        })      }    }  });}</code></pre></li></ul><h3 id="4-9-区域信息编辑页的联调"><a href="#4-9-区域信息编辑页的联调" class="headerlink" title="4-9 区域信息编辑页的联调"></a>4-9 区域信息编辑页的联调</h3><h2 id="第5章-课程总结与展望"><a href="#第5章-课程总结与展望" class="headerlink" title="第5章 课程总结与展望"></a>第5章 课程总结与展望</h2><blockquote><p>从整体上复习下本门课程的知识点</p></blockquote><ol><li>HelloWorld Controller</li><li>表设计和实体类的创建</li><li>dao层配置：mybatis-config，</li><li>service层配置：事务，接口及实现类</li><li>Controller层：增删改查</li><li>微信小程序，微信开发者工具</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>993-MySQL集群（PXC）入门</title>
      <link href="/imooc/993-MySQL-PXC/"/>
      <url>/imooc/993-MySQL-PXC/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/993" target="_blank" rel="noopener">https://www.imooc.com/learn/993</a></p><p>简介：本课程以项目演示为例，讲解PXC集群原理、PXC数据同步与Replication同步的区别、PXC的多节点并发写入、Docker虚拟机部署MySQL集群，并以案例验证Replication方案的数据不一致性、PXC方案数据一致性</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p> 本章总体介绍本课程学习的目标和学到的知识。</p></blockquote><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1-1 引言"></a>1-1 引言</h3><p>引言：</p><ul><li><p>伴随互联网经济的兴起，越来越多的领域需要相应的技术方案</p></li><li><p>行业：打车软件、电商平台、直播平台、电子支付、媒体社交</p></li><li><p>案例：滴滴出行、淘宝/京东、斗鱼直播、支付宝/微信、QQ</p></li></ul><p>单机单节点数据库没有冗余设计，如果数据库节点挂掉（断电、断网），则全部不能使用（网站不能访问）</p><p>使用冗余设计，即数据库节点集群在一起，性能翻倍。数据库集群。</p><p><strong><em>向BAT高标准看齐。</em></strong></p><h3 id="1-2-天猫双十一案例"><a href="#1-2-天猫双十一案例" class="headerlink" title="1-2 天猫双十一案例"></a>1-2 天猫双十一案例</h3><p>天猫双十一：</p><ul><li>2017年天猫双11交易额1682亿元，3分钟破百亿，9小时破干亿</li><li>交易峰值32.5万/秒，支付峰值25.6万/秒，数据库峰值4200万/秒</li><li>云服务器、负载均衡、RDS云数据库等技术</li></ul><p>淘宝/天猫使用3000+台数据库</p><h3 id="1-3-微信红包案例"><a href="#1-3-微信红包案例" class="headerlink" title="1-3 微信红包案例"></a>1-3 微信红包案例</h3><p>微信红包：</p><ul><li>2017年除夕当天，全国人民总共收发142亿个红包，峰值42万/秒</li><li>央视春晚微信摇一摇互动总量达110亿次，峰值8.1亿/秒</li><li>请求排队串行化、双维度分库表等设计</li></ul><h3 id="1-4-技术学习的目标和方式"><a href="#1-4-技术学习的目标和方式" class="headerlink" title="1-4 技术学习的目标和方式"></a>1-4 技术学习的目标和方式</h3><p>技术学习的目标和方式</p><ul><li>向大型互联网应用看齐，学习架构设计和业务处理</li><li>由浅入深，循序渐进；案例由小到大，逐步扩展</li><li>“视频学习”优于“看书学习”</li></ul><h3 id="1-5-课程学习目标"><a href="#1-5-课程学习目标" class="headerlink" title="1-5 课程学习目标"></a>1-5 课程学习目标</h3><p>本门课程学习目标</p><ul><li><p>掌握PXC集群MySQL方案的原理</p></li><li><p>掌握PXC集群的强一致性</p></li><li><p>掌握PXC集群的高可用方案</p></li></ul><h3 id="1-6-硬件环境介绍"><a href="#1-6-硬件环境介绍" class="headerlink" title="1-6 硬件环境介绍"></a>1-6 硬件环境介绍</h3><p>硬件环境需求</p><ul><li>Win10×64专业版或企业版/Linux/MacOS</li><li>Docker虚拟机</li><li>内存8GB以上</li></ul><pre><code class="shell">docker ps -apxc * 3 + haproxy * 1</code></pre><h2 id="第2章-PXC原理"><a href="#第2章-PXC原理" class="headerlink" title="第2章 PXC原理"></a>第2章 PXC原理</h2><blockquote><p>本章介绍数据库集群的必要性，以项目演示在数据库集群、Tomcat集群、Redis集群、Nginx负载均衡的部署环境下，后台程序遇到各种宕机，但是后台程序仍然高可用，最后介绍PXC数据同步的原理。</p></blockquote><h3 id="2-1-单节点数据库的介绍"><a href="#2-1-单节点数据库的介绍" class="headerlink" title="2-1 单节点数据库的介绍"></a>2-1 单节点数据库的介绍</h3><p>数据库集群的必要性</p><p>单节点数据库的弊病：<br>情况说明</p><ul><li>大型互联网程序用户群体庞大，所以架构必须要特殊设计</li><li>单节点的数据库无法满足性能上的要求</li><li>单节点的数据库没有冗余设计，无法满足高可用</li></ul><p>单节点数据库压力测试：</p><ul><li><p>测试案例</p><pre><code class="mysql">mysqlslap -hlocalhost -uroot -p123456 -P3306# 并发量5000连接--concurrency=5000 --iterations=1 --auto-generate-sql--auto-generate-sql-load-type=mixed--auto-generate-sql-add-autoincrement--engine=innodb# 共测试5000条SQL语句--number-of-queries=5000--debug-info</code></pre></li><li><p>测试结果</p><pre><code class="bash">Benchmark    Running for engine innodb    Average number of seconds to run all queries: 0.234 seconds    Minimum number of seconds to run all queries:0.234 seconds    Maximum number of seconds to run all queries:0.234 seconds    Number of clients running queries:100    Average number of queries per client50Benchmark    Running for engine innodb    Average number of seconds to run all queries: 1.656 seconds    Minimum number of seconds to run all queries:1.656 seconds    Maximum number of seconds to run all queries:1.656 seconds    Number of clients running queries:500    Average number of queries per clien:10Benchmark    Running for engine innodb    Average number of seconds to run all queries: 2.187 seconds    Minimum number of seconds to run all queries:2.187 seconds    Maximum number of seconds to run all queries:2.187 seconds    Number of clients running queries:1000    Average number of queries per client:5</code></pre><p>并发100、500和1000个连接，执行5000次查询，单节点数据还可以正常应对，没有太大的问题。</p><p>当并发10000个连接执行10000次查询，数据库则会拒绝一部分请求，仅完成另一部分接收的请求。</p></li></ul><h3 id="2-2-PXC集群方案"><a href="#2-2-PXC集群方案" class="headerlink" title="2-2 PXC集群方案"></a>2-2 PXC集群方案</h3><p>单节点数据库的高可用测试：</p><p>测试案例</p><ul><li><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifkl2e6j30jl08qwes.jpg"  width="350" alt="单节点数据库的高可用测试"/></li></ul><p>MySQL高性能高可用集群方案：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifm5x9cj31do0lo0wr.jpg"  width="600" alt="MySQL高性能高可用集群方案"/><p>MySQL单表数据量不能超过2000万条。性能极速下降。 </p><p>Mycat：国内主流数据切分中间件，阿里巴巴开源、Java编写、跨平台。</p><p>分片：利用Mycat切分后，一组集群就叫一个分片。</p><p>切分算法</p><ul><li><p>按照日期の（年份/月份/天）进行切分切分</p></li><li><p>按照某一列的固定值（主键ID，对分片数2求余）切分</p></li></ul><p>PXC–&gt;HA–&gt;Mycat</p><p>PXC数据读写是强一致性，但是牺牲了性能</p><h3 id="2-3-Replication集群方案"><a href="#2-3-Replication集群方案" class="headerlink" title="2-3 Replication集群方案"></a>2-3 Replication集群方案</h3><p>协同过滤算法：</p><ul><li>浏览记录会产生日志数据，将日志数据保存到数据库中。大数据算法根据日志数据分析当前用户行为，找出与之相同兴趣的用户，然后向当前用户推荐其他用户的喜好的商品、新闻。</li></ul><p>单条日志数据没有太大意义，而大量日志数据才有使用价值。此时便可以使用Replication集群。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifpe3gvj30u00by0tx.jpg"  width="600" alt="MySQL高性能高可用集群方案"/><p>应用软件数据架构：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifn0csaj30ff08mq37.jpg"  width="400" alt="应用软件数据架构"/><h3 id="2-4-系统架构方案介绍"><a href="#2-4-系统架构方案介绍" class="headerlink" title="2-4 系统架构方案介绍"></a>2-4 系统架构方案介绍</h3><p>互联网大型应用架构分析：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi4w17xoj31000jcjz7.jpg" alt="系统架构方案"></p><p>互联网大型应用技术分析：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gi4xg1xfj30vk0k0k16.jpg" alt="系统架构方案"></p><h3 id="2-5-APP项目介绍"><a href="#2-5-APP项目介绍" class="headerlink" title="2-5 APP项目介绍"></a>2-5 APP项目介绍</h3><p>APP项目截图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifo5e3lj310e0h2q5l.jpg"  width="600" alt="APP项目截图"/><p>【登录界面】-【欢迎界面】-【人才招聘界面】</p><p>APP项目架构设计：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifjbscbj30s608y0tk.jpg"  width="600" alt="APP项目架构设计"/><p>服务器端微服务之间的调用实现：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifowc6lj30p708xwf7.jpg"  width="600" alt="服务器端微服务之间的调用实现"/><p>消息队列实现业务的解耦。</p><p>生产者不知道谁来接收这个消息，消费者也不知道是哪个生产者发来的消息。</p><p>消息队列的两个功能：</p><ol><li>异步消息发送。</li><li>利用异步消息发送，进行业务功能的解耦。即把不是强依赖，不是实时返回的功能做成消息队列，这样不管是调用方还是被调用方的改动，对另一方的依赖就会减小甚至消除。</li></ol><h3 id="2-6-Docker虚拟机部署MySQL集群"><a href="#2-6-Docker虚拟机部署MySQL集群" class="headerlink" title="2-6 Docker虚拟机部署MySQL集群"></a>2-6 Docker虚拟机部署MySQL集群</h3><p>查看正在运行的容器：</p><pre><code class="shell">docker ps -a</code></pre><h3 id="2-7-APP项目演示"><a href="#2-7-APP项目演示" class="headerlink" title="2-7 APP项目演示"></a>2-7 APP项目演示</h3><p>如果PXC集群中的主机挂掉的数目超过一半，则其它也不能提供服务</p><p>大学所储备知识做出的项目：</p><ol><li><p>性能不足</p></li><li><p>故障抵御能力不足</p></li></ol><h3 id="2-8-PXC简介"><a href="#2-8-PXC简介" class="headerlink" title="2-8 PXC简介"></a>2-8 PXC简介</h3><p>Percona XtraDB Cluster</p><ul><li>PXC通过Galera将不同的MySQL实例连接起来，实现多主机群</li><li>PXC基于Percona Server（性能较MySQL有显著提升）</li><li>PXC是众多MySQL集群方案的一种</li></ul><p>PXC方案与Replication方案对比：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gikqijyej30pt0g0my1.jpg"  width="400" alt="PXC方案"/><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gikprxo8j30hu0bvglz.jpg"  width="350" alt="Replication方案"/><h3 id="2-9-PXC测试案例"><a href="#2-9-PXC测试案例" class="headerlink" title="2-9 PXC测试案例"></a>2-9 PXC测试案例</h3><pre><code class="shell">docker pa -a</code></pre><p>PXC方案：</p><pre><code class="mysql"># node1CREATE DATABASE test;USE test;# node5CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);# node4INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;), (2, &quot;Jack&quot;);</code></pre><p>Replication方案：</p><pre><code class="mysql"># masterCREATE DATABASE test;USE test;CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student    SET id = 1, name = &quot;Scott&quot;;# slaveINSERT INTO student    SET id = 2, name = &quot;Jack&quot;;</code></pre><p>PXC集群的节点之间是双向同步，没有主从之分。</p><p>Replication是单向同步，只能由主节点同步到从节点，从节点也可以写入数据，但不会同步数据到主节点。</p><p>PXC双向同步从演示的耗时看比Replication慢6倍，一个insert约80多毫秒，replication只要10多毫秒。</p><h3 id="2-10-PXC集群工作原理"><a href="#2-10-PXC集群工作原理" class="headerlink" title="2-10 PXC集群工作原理"></a>2-10 PXC集群工作原理</h3><p>PXC集群工作原理：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifqb2j3j31b80rw76u.jpg"  width="800" alt="PXC集群工作原理"/><p>数据的同步是由PXC完成的。</p><p>数据库事务，指的是逻辑上的一组操作，组成这组事务的操作，要么全部不成功，要么全部成功。</p><p>一个事务若有多个操作，则需要手动开启事务。且要手动提交事务，才能将操作持久化到数据库。</p><h2 id="第3章-PXC数据强一致性"><a href="#第3章-PXC数据强一致性" class="headerlink" title="第3章 PXC数据强一致性"></a>第3章 PXC数据强一致性</h2><blockquote><p>本章介绍PXC和Replication两种集群方案在数据同步上的区别。</p></blockquote><h3 id="3-1-PXC与Replication方案优劣介绍"><a href="#3-1-PXC与Replication方案优劣介绍" class="headerlink" title="3-1 PXC与Replication方案优劣介绍"></a>3-1 PXC与Replication方案优劣介绍</h3><p>PXC的数据强一致性：</p><ul><li>同步复制，事务在所有集群节点要么同时提交，要么不提交</li><li>Replication采用异步复制，无法保证数据的一致性</li></ul><p>PXC和Replication方案优劣：</p><ul><li><p>Replication写入速度快，但是不能保证数据的一致性</p><p>异步复制，分为master节点和slave节点。</p><p>master节点写入数据提交事务后，即返回结果给客户端，不管slave节点的数据是否一致。</p></li><li><p>PXC可以保证数据的一致性，但是写入速康慢</p><p>PXC的数据强一致性牺牲了速度为代价。</p><p>节点间同步复制数据，将事务执行结果返回给客户端。</p></li><li><p>PXC和Replication只实现了数据的同步，没有数据切分功能</p></li></ul><p>PXC与Replication两种方案结合：</p><ol><li>重要数据保存在PXC集群。</li><li>非重要数据（操作的记录）保存在Replication集群</li></ol><p>当MySQL单表数据量超过2000万条时，性能会急剧下降，所以需要进行数据切分，即利用两个甚至多个集群来存储不同的数据</p><p>阿里巴巴开源中间件MyCat可以将两个集群做数据切分</p><h3 id="3-2-PXC与Replication方案性能对比"><a href="#3-2-PXC与Replication方案性能对比" class="headerlink" title="3-2 PXC与Replication方案性能对比"></a>3-2 PXC与Replication方案性能对比</h3><p>PXC和Replication方案性能对比：</p><ul><li>2016年春节，微信红包支付峰值15.8万次/秒，创下世界纪录</li><li>2017天猫双11，数据库峰值4200万次/秒，支付峰值25.6万次/秒</li></ul><p>PXC集群注意：</p><ol><li><p>PXC集群规模不能太大</p></li><li><p>PXC集群性能瓶颈不在于性能最好的节点，而在于性能最差的节点</p><p>尽量保证节点的配置一致</p></li></ol><p>PXC和Replication组合方案：</p><ul><li><p>PXC方案存储高价值数据，如：账户、订单、交易等等</p></li><li><p>Replication方案存储低价值数据，如：权限、通知、日志等等</p></li><li><p>用MyCat或JDBC-Sharding切分数据管理集群</p><p>按照主键ID值、年月日、某一字段等等进行切分</p></li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifk38zsj30h505iq32.jpg"  width="400" alt="PXC集群工作原理"/><p>MyCat本身也需要高可用、需冗余设计。</p><p>搭建两个MyCat，再用Linux的虚拟IP技术虚拟一个IP供客户端程序访问，再由两个MyCat去争抢这个虚拟IP，如果哪个MyCat挂了，另一个MyCat就会接收到这个IP继续提供服务。</p><h3 id="3-3-案例验证Replication方案的数据不一致性"><a href="#3-3-案例验证Replication方案的数据不一致性" class="headerlink" title="3-3 案例验证Replication方案的数据不一致性"></a>3-3 案例验证Replication方案的数据不一致性</h3><p>案例介绍：</p><ul><li><p>搭建一组两节点的Replication集群</p></li><li><p>使用MyCat实现Master和Slave节点的读写分离</p></li><li><p>设置防火墙网络规则，Master和Slave之间禁止访问，断开同步</p><p>注：</p><ul><li>MyCat默认端口8066</li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifj5gsbj30s608y0tk.jpg"  width="400" alt="Replication方案案例介绍"/></li></ul><p>步骤：</p><ol><li><p>在Master创建数据库、数据表，同时插入两条数据：</p><pre><code class="mysql"># masterCREATE DATABASE test;USE test;CREATE TABLE student(    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;), (2, &quot;Jack&quot;);</code></pre><p>MyCat配置文件介绍：</p><pre><code class="xml">&lt;!-- schema.xml --&gt;&lt;dataHost describe=&quot;配置数据库连接&quot;&gt;    &lt;heartbeat describe=&quot;心跳检测，实时检测MySQL节点是否有效。如果MySQL节点挂掉，则向冗余节点发送请求&quot;&gt;    &lt;/heartbeat&gt;    &lt;writeHost describe=&quot;写节点。Master&quot;&gt;        &lt;readHost describe=&quot;读节点。Slave&quot;&gt;&lt;/readHost&gt;    &lt;/writeHost&gt;&lt;/dataHost&gt;</code></pre></li><li><p>在MyCat查询数据表可以查看到两条数据：</p><pre><code class="mysql"># MyCatSELECT * FROM student;</code></pre></li><li><p>关闭Master与Slave之间的同步设置：</p><p>同步操作是在Slave节点配置的。</p><pre><code class="mysql"># slaveSHOW SLAVE STATUS;# Salve_IO_Running Slave_SQL_Running# YES               YESSTOP SLAVE;# Salve_IO_Running Slave_SQL_Running# NO               NO</code></pre></li><li><p>在MyCat插入一条数据：</p><pre><code class="mysql"># MyCatINSERT INTO student(id, name)VALUES(3, &quot;admin&quot;);</code></pre></li><li><p>在MyCat查询数据表可以查看到只有两条数据，无步骤4中插入的数据</p><pre><code class="mysql"># MyCatSELECT * FROM student;</code></pre></li></ol><h3 id="3-4-案例验证PXC方案数据一致性"><a href="#3-4-案例验证PXC方案数据一致性" class="headerlink" title="3-4 案例验证PXC方案数据一致性"></a>3-4 案例验证PXC方案数据一致性</h3><p>案例介绍：</p><ul><li><p>搭建一组三节点的PXC集群</p></li><li><p>使用MyCat实现PXC节点的读写分离</p></li><li><p>设置防火墙网络规则，PXC之间禁止访问，断开同步</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifnems7j30f50863yn.jpg"  width="400" alt="Replication方案案例介绍"/></li></ul><pre><code class="shell"># 查看正在运行的容器docker ps -a# 进入node1数据库节点docker exec -it node1 bashiptables -A INPUT -p tcp --dport 4444 -j DROPiptables -A OUTPUT -p tcp --dport 4444 -j DROPiptables -A INPUT -p tcp --dport 4567 -j DROPiptables -A OUTPUT -p tcp --dport 4567 -j DROPiptables -A INPUT -p tcp --dport 4568 -j DROPiptables -A OUTPUT -p tcp --dport 4568 -j DROP# 进入node2数据库节点...# 进入node3数据库节点...</code></pre><h2 id="第4章-PXC的多节点并发写入"><a href="#第4章-PXC的多节点并发写入" class="headerlink" title="第4章 PXC的多节点并发写入"></a>第4章 PXC的多节点并发写入</h2><blockquote><p>本章介绍并演示PXC多节点并发写入和HaProxy高可用方案</p></blockquote><h3 id="4-1-PXC多节点并发写入"><a href="#4-1-PXC多节点并发写入" class="headerlink" title="4-1 PXC多节点并发写入"></a>4-1 PXC多节点并发写入</h3><p>多节点并发写入：</p><ul><li>PXC集群没有主从节点之分，任何节点都是可读可写的</li><li>Replication集群的主节点（写节点）宕机，从节点不能自动升级为主节点</li><li>Replication集群必须为主节点设置冗余节点，而PXC不必这样</li></ul><p>案例测试：</p><ul><li>利用Java程序向三节点的PXC集群每个节点同时写入数据</li><li>程序执行结束之后，查看每个节点的数据是否同步正确</li><li>得出PXC多节点并发写入的结论</li></ul><p>Java线程：</p><pre><code class="java">// MyThread.java@Dataclass MyThread extends Thread {    String url;    String username;    String pas sword;    String threadName;    override run() {        var con = DriverManager.getConnection(url, username, password);        var pst = con.prepareStatement(&quot;INSERT INTO student(name) VALUES (?)&quot;);        for(i : 1 ... 50) {            pst.setobject(1, threadName);            pst.execute;            Thread.sleep(5000);        }        con.close();        println(&quot;线程执行结束&quot;);    }}</code></pre><pre><code class="java">// Test.javaclass Test {    def static void main(String[] args) {        var t1=new MyThread(&quot;jdbc: mysq1://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        var t2=new MyThread(&quot;jdbc: mysql://127.0.0.1:3307/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        var t3=new MyThread(&quot;jdbc: mysql://127.0.0.1:3308/test?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;, &quot;C线程&quot;);        t1. start();        t2. start();        t3. start();    }}</code></pre><p>Java语法严谨、但啰嗦。</p><p>IBM开发了Xtend、SUN发开了Groovy、Kotlin等都扩展简化Java语法</p><h3 id="4-2-PXC多节点并发写入案例"><a href="#4-2-PXC多节点并发写入案例" class="headerlink" title="4-2 PXC多节点并发写入案例"></a>4-2 PXC多节点并发写入案例</h3><p>在已设置ID主键自增的情况下，为何PXC多节点并发写入的主键值不连续？</p><ul><li>多个节点并发写入时同时生成了相同的ID主键值，此时去同步其他数据库节点会因为ID值被占用而驳回同步，需要重新生成一个ID主键值后再发起同步请求。如：A节点用了主键2，B节点也 用了主键2，这个时候同步就不能进行，然后B节点就用了主键3，A节点就用了主键4。</li></ul><p>如何避免主键值不连续？</p><ul><li>将主键生成任务从数据库本地移交给数据库集群中间件，如MyCat。从而避免冲突，不连续</li></ul><p>验证PXC多节点并发写入数据库节点的数据是否同步成功：</p><pre><code class="mysql"># node1/node2/node3use test;SELECT COUNT(*) FROM student;</code></pre><p>同时多节点并发（三线程）写入50条记录，最终有150条记录。</p><p>PXC集群多节点并发写入验证数据的强一致性。</p><h3 id="4-3-Haproxy高可用方案介绍"><a href="#4-3-Haproxy高可用方案介绍" class="headerlink" title="4-3 Haproxy高可用方案介绍"></a>4-3 Haproxy高可用方案介绍</h3><p>Haproxy高可用方案：</p><ul><li><p>PXC节点可读可写，应该采用负载均衡技术管理这些节点</p></li><li><p>程序设计中，数据源接口应该单一，对接负载均衡中间件</p></li><li><p>Haproxy是著名的负载均衡中间件，很适合负载均衡PXC集群</p><p>注：</p><ul><li>NGINX可实现Tomcat的负载均衡，是基于HTTP协议的。最近新版NGINX才支持TCP/IP协议，产品还不够成熟。</li><li>故使用Haproxy做数据库集群的负载均衡。</li></ul></li></ul><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gifqpcfyj30ho0ajq3e.jpg"  width="400" alt="Haproxy高可用方案"/><p>PXC集群最好是奇数数量（最少要三个节点），PXC集群可能出现脑裂的情况</p><h3 id="4-4-Haproxy高可用案例1"><a href="#4-4-Haproxy高可用案例1" class="headerlink" title="4-4 Haproxy高可用案例1"></a>4-4 Haproxy高可用案例1</h3><pre><code class="shell"># 查看正在运行的容器实例docker ps -a</code></pre><pre><code class="cfg"># haproxy.cfg# 配置管理画面listen admin_stats  # 管理信息的名字。可随意        bind 0.0.0.0:8888  # 管理画面的IP与端口，任何IP地址均可访问。        mode http  # 网络协议使用HTTP        stats uri /dbs  # 访问URI        stats realm Global\ statistics        stats auth admin:admin  # 管理画面的登录账号密码# 负载均衡listen proxy-mysql  # 负载均衡的名字。可随意        bind 0.0.0.0:3306  # 负载均衡的入口IP与端口，任何IP地址均可访问。        mode tcp  # 网络协议使用TCP。MySQL默认为TCP协议，不能为HTTP协议        balance roundrobin  # 使用轮询的方式去分发请求（分发权重）        option tcplog  # 记录日志        option mysql-check user haproxy  # 定期发送心跳检测，‘haproxy’为Haproxy容器的用户名        server MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000        server MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000        server MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000        option tcpka</code></pre><h3 id="4-5-Haproxy高可用案例2"><a href="#4-5-Haproxy高可用案例2" class="headerlink" title="4-5 Haproxy高可用案例2"></a>4-5 Haproxy高可用案例2</h3><pre><code class="mysql"># haproxyCREATE DATABASE test;USE test;CREATE TABLE student (    id INT PRIMARY KEY,    name VARCHAR(200) NOT NULL);INSERT INTO student(id, name)VALUES (1, &quot;Scott&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>867-Docker入门</title>
      <link href="/imooc/867-Docker/"/>
      <url>/imooc/867-Docker/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/867" target="_blank" rel="noopener">https://www.imooc.com/learn/867</a></p><p>简介：本课程从最基础的安装开始，通过大量的实际操作循序渐进地介绍Docker基本知识。从最基本的镜像、容器开始，学习Dockerfile编写，容器操作，到完成一个多容器的应用。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程简介"><a href="#第1章-课程简介" class="headerlink" title="第1章 课程简介"></a>第1章 课程简介</h2><blockquote><p>介绍Docker以及安装方式</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>Docker简介：</p><blockquote><p>Docker是容器技术的代表。<br>容器技术本质上是<strong>将程序隔离、打包的一个技术</strong>。</p></blockquote><p>解决问题：</p><blockquote><p><strong>解决软件包安装的问题</strong><br>理顺了开发与运维环境的差异，使开发和运维可以使用同一种语言进行沟通</p></blockquote><p>Docker入门教程</p><blockquote><p>Docker简介：什么是Docker<br>镜像与容器<br>容器存储<br>Registry<br>多容器app</p></blockquote><p>面向用户</p><blockquote><p>对docker感兴趣的。开发、测试、运维</p></blockquote><p>预备知识</p><blockquote><p>linux命令行<br>bash shell脚本</p></blockquote><h3 id="1-2-Docker介绍"><a href="#1-2-Docker介绍" class="headerlink" title="1-2 Docker介绍"></a>1-2 Docker介绍</h3><p>什么是Docker</p><blockquote><p>Docker: an open source project to pack, ship and run any application as a lightweight container.<br>是一个开源的项目，可以使任何应用以轻量级的形式打包、发布和运行</p><p>Node. js: allows to package an application with all of its dependencies into a standardized unit.<br>允许一个应用程序及其所有依赖以一种标准的单位来进行打包</p></blockquote><blockquote><p>Docker 是一个开源的应用容器引擎，开发者可以打包他们的应用以及依赖包到一个可移植的容器中，<br>然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>与现有技术进行类比</p><blockquote><p>可以粗糙地理解为轻量级的虚拟机<br>开挂的chroot（chroot：对应用程序作了文件系统的分离）</p></blockquote><p>Docker与虚拟机：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif4j6saj30mq0dbdgu.jpg"  width="450" alt="Docker与虚拟机"/><p>注：</p><ul><li>左边为虚拟机，右边为Docker</li><li>Hypervisor层：虚拟出硬件</li><li>Guest OS：硬件上安装完全独立的Guest OS</li><li>Docker Engine：利用Namespace、Control Group将应用程序分离</li><li>Docker没有Hypervisor虚拟层，会轻量很多</li></ul><h3 id="1-3-docker-mac安装"><a href="#1-3-docker-mac安装" class="headerlink" title="1-3 docker mac安装"></a>1-3 docker mac安装</h3><ul><li><p>下载</p><blockquote><p>官网地址：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>下载安装包：<a href="https://www.docker.com/docker-windows" target="_blank" rel="noopener">https://www.docker.com/docker-windows</a></p></blockquote></li><li><p>安装</p><blockquote><p>打开docker<br>open Docker.dmg或双击Docker.dmg<br>将Docker拖到Applications里面</p><p>验证安装：docker info</p></blockquote></li><li><p>配置</p><blockquote><p>镜像加速：</p><p>【Preferences…】=&gt;【Advanced】=&gt;【Registry mirrors】</p></blockquote></li></ul><h3 id="1-4-docker-linux安装"><a href="#1-4-docker-linux安装" class="headerlink" title="1-4 docker linux安装"></a>1-4 docker linux安装</h3><pre><code class="shell">## Ubuntu# 安装docker本身sudo wget -qO- https://get.docker.com | sh# 允许非root用户运行dockersudo usermod -aG docker tyk# 验证安装docker info</code></pre><p>注：</p><ul><li>-q：标识输出要简单</li><li>O-：标识标准输出，而不是输出到文件</li></ul><pre><code class="shell">## CentOS7# 系统 CentOS-Extras 库中已带 Docker，可以直接安装：sudo yum install docker# 安装之后启动Docker服务，并让它随系统启动自动加载。sudo service docker startsudo chkconfig docker on</code></pre><h3 id="1-5-docker-windows安装"><a href="#1-5-docker-windows安装" class="headerlink" title="1-5 docker windows安装"></a>1-5 docker windows安装</h3><ul><li><p>下载</p><blockquote><p>官网地址：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a><br>下载安装包：<a href="https://www.docker.com/docker-windows" target="_blank" rel="noopener">https://www.docker.com/docker-windows</a></p></blockquote></li><li><p>安装</p><blockquote><p>执行安装包：Docker for Windows Installer.exe</p><p>验证安装：docker info</p></blockquote></li><li><p>配置</p><blockquote><p>镜像加速：</p><p>【settings】=&gt;【Daemon】=&gt;【Registry mirrors】</p></blockquote></li></ul><h2 id="第2章-实践第一步"><a href="#第2章-实践第一步" class="headerlink" title="第2章 实践第一步"></a>第2章 实践第一步</h2><blockquote><p>创建第一个Hello world</p></blockquote><h3 id="2-1-docker架构介绍与实战"><a href="#2-1-docker架构介绍与实战" class="headerlink" title="2-1 docker架构介绍与实战"></a>2-1 docker架构介绍与实战</h3><p>Docker架构：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif53qczj30mm0cowfg.jpg"  width="600" alt="Docker架构"/><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gif5kicqj30ha0b63yu.jpg"  width="400" alt="Docker架构"/><p> 使用ubuntu镜像，在里面运行了echo hello docker这个命令，输出就是hello docker</p><pre><code class="shell">docker run ubuntu echo hello docker    </code></pre><p>运行NGINX服务器：</p><pre><code class="shell">docker run nginx</code></pre><p>查看本地镜像：</p><pre><code class="shell">docker images</code></pre><p>运行daocloud.io/nginx镜像：</p><pre><code class="shell">docker run -d -p 8080:80 daocloud.io/nginx</code></pre><p>注：</p><ul><li>-d：使用守护进程启动</li><li>-p：端口映射，将nginx的80端口映射到本地的8080端口</li></ul><p>查看当前正在运行的容器：</p><pre><code class="shell">docker ps</code></pre><p>显示Docker相关信息的页面：</p><pre><code class="shell"># 将文件拷贝到Docker容器。# 将index.html文件拷贝到容器ID为17asdasdasa容器内部，路径为//usr/share/nginx/html# docker cp 文件 容器ID:容器内部文件路径docker cp index.html 17add7bbc58c://usr/share/nginx/html</code></pre><p>停止指定容器：</p><pre><code class="shell">docker stop 容器ID</code></pre><p><a href="https://www.runoob.com/docker/docker-commit-command.html" target="_blank" rel="noopener"><strong>保存容器为镜像</strong></a>：</p><blockquote><p>Docker在容器内的改动都是暂时的，没有被保存</p></blockquote><pre><code class="shell"># # 保存容器为镜像，镜像名为nginx-fundocker commit -m &#39;fun&#39; 容器ID nginx-fun</code></pre><p>删除指定镜像：</p><pre><code class="shell">docker rmi 镜像ID</code></pre><p>查看所有容器（正在运行和停止运行）：</p><pre><code class="shell">docker ps -a</code></pre><p>删除指定容器：</p><pre><code class="shell">docker rm 容器ID</code></pre><p>命令小结：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>docker pull</td><td>获取image</td></tr><tr><td>docker build</td><td>创建image</td></tr><tr><td>docker images</td><td>列出image</td></tr><tr><td>docker run</td><td>运行container</td></tr><tr><td>docker ps</td><td>列出正在运行的container</td></tr><tr><td>docker rm</td><td>删除container</td></tr><tr><td>docker rmi</td><td>删除image</td></tr><tr><td>docker cp</td><td>在host和container之间拷贝文件</td></tr><tr><td>docker commit</td><td>保存改动为新的image</td></tr></tbody></table><h2 id="第3章-Dockerfile介绍"><a href="#第3章-Dockerfile介绍" class="headerlink" title="第3章 Dockerfile介绍"></a>第3章 Dockerfile介绍</h2><blockquote><p>编写dockerfile</p></blockquote><h3 id="3-1-dockerfile介绍"><a href="#3-1-dockerfile介绍" class="headerlink" title="3-1 dockerfile介绍"></a>3-1 dockerfile介绍</h3><blockquote><p>通过编写简单的文件自创docker镜像</p></blockquote><p>第一个Dockerfile：</p><pre><code class="dockerfile">FROM alpine:latestMAINTAINER tyk 766564616@qq.comCMD echo &#39;hello docker&#39;</code></pre><p>注：</p><ul><li>依赖于基础镜像alpine:latest</li><li>标识镜像信息</li><li>需要运行的命令</li></ul><pre><code class="shell">mkdir dockerfile1cd dockerfile1# 产生一个Dockerfile文件touch Dockerfile# 编辑Dockerfile文件vim Dockerfile# 构建docker镜像docker build -t hello_docker .# 查看已安装Docker镜像docker images hello_docker# 运行Docker镜像docker run hello_docker</code></pre><p>注：</p><ul><li>-t：参数指定镜像名称</li><li>最后面的点（.）表示构建镜像文件的路径</li></ul><h3 id="3-2-dockerfile实战"><a href="#3-2-dockerfile实战" class="headerlink" title="3-2 dockerfile实战"></a>3-2 dockerfile实战</h3><p>第二个Dockerfile：</p><pre><code class="dockerfile"># 依赖于基础镜像ubuntuFROM ubuntu# 标识镜像信息MAINTAINER tyk 766564616@qq.com# 运行ubuntu命令，新增一个软件仓库镜像地址RUN sed -i &#39;s/archive.ubuntu.com/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list# 运行ubuntu命令，更新软件RUN apt-get update# 运行ubuntu命令，安装nginx。-y：默认yes不询问RUN apt-get install -y nginx# 拷贝本地文件到镜像内部COPY index.html /var/www/html# 将NGINX在前台启动ENTRYPOINT [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]# 镜像暴露服务的端口EXPOSE 80</code></pre><pre><code class="shell">mkdir dockerfile2cd dockerfile2touch Dockerfilevim Dockerfiletouch index.htmlvim index.htmldocker build -t 766564616/hello-nginx .docker run -d -p 80:80 766564616/hello-nginx使用curl进行测试curl http://localhost</code></pre><p>Dockerfile语法：</p><table><thead><tr><th>命令</th><th>用途</th><th>说明</th><th>是否必填</th></tr></thead><tbody><tr><td>FROM</td><td>base_image</td><td>指明基础镜像名称。</td><td>必填</td></tr><tr><td>RUN</td><td>执行命令</td><td>用于执行命令，当RUN执行完毕后，将产生一个新的文件层。</td><td>可选</td></tr><tr><td>ADD</td><td>添加文件</td><td>向镜像添加文件。可以添加远程文件</td><td>可选</td></tr><tr><td>COPY</td><td>拷贝文件</td><td>从主机向镜像复制文件。</td><td>可选</td></tr><tr><td>CMD</td><td>执行命令</td><td>指定此镜像启动时默认执行命令。容器执行入口</td><td>可选</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>用于指定需要暴露的网络端口号。</td><td>可选</td></tr><tr><td>WORKDIR</td><td>指定路径</td><td>设定此镜像后续操作的默认工作目录。</td><td>可选</td></tr><tr><td>MAINTAINER</td><td>维护者</td><td>可用于提供作者、版本及气他备注信息。</td><td>可选</td></tr><tr><td>ENV</td><td>设定环境变量</td><td>用于在镜像中添加环境变量。</td><td>可选</td></tr><tr><td>ENTRYPOINT</td><td>容器入口</td><td>在镜像中设定默认执行的二进制程序。容器执行入口</td><td>可选</td></tr><tr><td>USER</td><td>指定用户</td><td>在镜像构建过程中，生成或者切换到另一个用户。</td><td>可选</td></tr><tr><td>VOLUME</td><td>mount point</td><td>向镜像中挂载一个卷组。</td><td>可选</td></tr></tbody></table><h3 id="3-3-镜像分层"><a href="#3-3-镜像分层" class="headerlink" title="3-3 镜像分层"></a>3-3 镜像分层</h3><blockquote><p>Dockerfile中的每一行都产生一个新层</p></blockquote><pre><code class="dockerfile">FROM alpine:latest        4dffsd5454wqMAINTAINER tyk766564616   fbdfasdfasfd554CMD echo &#39;hello docker&#39;   3df545dfad4a</code></pre><p>每个命令都是单独保存的一层。只有容器层是RW，镜像中的各层都是RO</p><p>分层的好处：假如有很多container或者很多的Image，相同的镜像层会复用共享。一定程度上减小了储存空间的使用，运行起来方便。</p><h2 id="第4章-存储"><a href="#第4章-存储" class="headerlink" title="第4章 存储"></a>第4章 存储</h2><blockquote><p>对volume进行介绍</p></blockquote><h3 id="4-1-volume介绍"><a href="#4-1-volume介绍" class="headerlink" title="4-1 volume介绍"></a>4-1 volume介绍</h3><blockquote><p>提供独立于容器之外的持久化存储</p></blockquote><p>应用场景：</p><blockquote><p>比如数据库，可以将数据存储在容器外的分卷。</p><p>可以提供容器跟容器之间的数据共享。</p></blockquote><h3 id="4-2-volume操作"><a href="#4-2-volume操作" class="headerlink" title="4-2 volume操作"></a>4-2 volume操作</h3><p>第一种形式：</p><blockquote><p>Docker虚拟路径挂载到容器里面的路径</p></blockquote><pre><code class="shell">docker run -v 容器内部地址 镜像名称</code></pre><pre><code class="shell"># 运行nginx容器，通过-v挂载一个卷组docker run -d --name nginx -v /usr/share/nginx/html nginx# 查看指定容器信息# docker inspect 容器名称docker inspect nginx# 查看Mounts节点下的Sources节点和Destination节点信息# 该容器把宿主机的Sources对应目录挂载到容器内部的Destination的目录地址cd Sources对应的目录路径# 修改index.html文件echo &quot;it&#39;s 2016&quot; &gt; index.html# 进入到容器内部# docker exec -it 容器名称 /bin/bashdocker exec -it nginx /bin/bash# cd Destination对应的路径路径# 查看index.html文件cat index.html# 打印出刚刚修改后的内容，即挂载成功，映射关系正确</code></pre><p>第二种形式：</p><blockquote><p>本地目录挂载到容器里面的路径</p></blockquote><pre><code class="shell">docker run -v $PWD/code:/var/www/html nginx</code></pre><pre><code class="shell">docker run -d -p 80:80 -v $PWD/html:/usr/share/nginx/html nginx# 查看本地文件的内容cat html/index.html# 进入到容器内部docker exec -it 容器名称 /bin/bash# 发现其内容和本地文件的内容一致，即映射关系正确cat /usr/share/nginx/html/index.html</code></pre><p>第三种形式</p><blockquote><p>创建数据卷容器，将其挂载到其他容器</p></blockquote><pre><code class="shell">docker run --volumes-from 卷容器ID</code></pre><p>好处：</p><blockquote><p>可以多个容器挂载一个数据容器，实现数据共享</p></blockquote><pre><code class="shell">mkdir data# 产生一个仅有数据的容器docker create -v $PWD/data:/var/mydata --name data_container ubuntu# 从另外一个容器挂载， 运行并直接进入容器内部docker run -it --volumes-from data_container ubuntu /bin/basemounttouch /var/mydatawhatever.txtexit# 查看本地data目录下是否有whatever.txt文件ls data</code></pre><h2 id="第5章-镜像仓库"><a href="#第5章-镜像仓库" class="headerlink" title="第5章 镜像仓库"></a>第5章 镜像仓库</h2><blockquote><p>registry介绍与实战</p></blockquote><h3 id="5-1-registry介绍"><a href="#5-1-registry介绍" class="headerlink" title="5-1 registry介绍"></a>5-1 registry介绍</h3><p>Docker相关术语：</p><table><thead><tr><th>English</th><th>中文</th></tr></thead><tbody><tr><td>host</td><td>宿主机</td></tr><tr><td>image</td><td>镜像</td></tr><tr><td>container</td><td>容器</td></tr><tr><td>registry</td><td>镜像仓库</td></tr><tr><td>daemon</td><td>守护程序</td></tr><tr><td>client</td><td>客户端</td></tr></tbody></table><p>Registry相关命令：</p><pre><code class="shell"># 从镜像仓库中搜索指定镜像docker search image_name# 从镜像仓库中拉取指定镜像docker pull image_name# 将本地镜像推送到镜像仓库docker push image_name</code></pre><p>国内的一些镜像仓库：</p><blockquote><p>daocloud<br>时速云<br>阿里云</p></blockquote><h3 id="5-2-registry实战"><a href="#5-2-registry实战" class="headerlink" title="5-2 registry实战"></a>5-2 registry实战</h3><pre><code class="shell"># 在镜像仓库中搜索whalesaydocker search whalesay# 从镜像仓库中拉取镜像docker/whalesay到本地docker pull docker/whalesay# 查看本地镜像信息docker images# 运行docker/whalesay镜像，并指定参数docker run docker/whalesay cowsay Docker so fun# 在push之前，需要登录。默认登录到docker hubdocker login# 依赖docker/whalesay镜像产生新的766564616/whalesay镜像（类似复制）docker tag docker/whalesay 766564616/whalesay# 将镜像766564616/whalesay推送到镜像仓库docker push 766564616/whalesay# 到dockerhub官方地址，查看到自己push的镜像# https://hub.docker.com/</code></pre><h2 id="第6章-多容器app"><a href="#第6章-多容器app" class="headerlink" title="第6章 多容器app"></a>第6章 多容器app</h2><blockquote><p>介绍多容器app与实例</p></blockquote><h3 id="6-1-compose介绍"><a href="#6-1-compose介绍" class="headerlink" title="6-1 compose介绍"></a>6-1 compose介绍</h3><p>多容器app</p><blockquote><p>编写文本文件，文件描述多容器APP的结构然后通过工具docker-compose把它拉起来</p></blockquote><blockquote><p>docker-compose是独立的软件</p></blockquote><p>docker-compose安装：</p><blockquote><p>Mac/Windows：自带</p><p>Linux：curl <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p></blockquote><h3 id="6-2-compose-install-linux"><a href="#6-2-compose-install-linux" class="headerlink" title="6-2 compose-install-linux"></a>6-2 compose-install-linux</h3><p><a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">https://github.com/docker/compose/releases</a></p><pre><code class="shell"># 下载docker-compose包到/usr/local/bin/docker-composecurl -L https://github.com/docker/compose/releases/download/1.24.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/docker-compose# 给/usr/local/bin/docker-compose授可执行权限chmod +x /usr/local/docker-compose    # 验证安装docker-compose --version</code></pre><pre><code class="shell">uname -s# Linux$ uname -m# x86_64</code></pre><h3 id="6-3-compose实战"><a href="#6-3-compose实战" class="headerlink" title="6-3 compose实战"></a>6-3 compose实战</h3><p>实战案例介绍</p><blockquote><p>app名称：ghost<br>是一个博客平台程序，安装之后，可自己写文章或别人发布<br>架构：nginx、ghost app、mysql<br>分别分为三个容器</p></blockquote><p>docker-compose.yml文件</p><pre><code class="yaml">ghost-app:   build: ghost  depends_on:     - db  ports:     - &quot;2368:2368&quot;nginx:   build: nginx  ports:     - &quot;80:80&quot;  depends_on:     - ghost-appdb:   images: &quot;mysql:5.7.15&quot;</code></pre><p>实战操作：</p><pre><code class="shell"># ghost根路径mkdir ghostcd ghost# 存放Dockerfile和配置文件用来构建镜像mkdir ghostmkdir nginx# 存放博客的数据mkdir data</code></pre><ol><li><p>ghost镜像构建</p><pre><code class="shell"># /ghost# ghost镜像构建cd ghosttouch Dockerfilevim Dockerfile...touch config.jsvim config.js...</code></pre><pre><code class="dockerfile">### Dockerfile #### 依赖ghost官方镜像FROM ghost# 拷贝本地配置文件到镜像中COPY ./config.js /var/lib/ghost/config.js# 声明暴露服务的端口EXPOSE 2368# 执行启动命令。ghost为node.js程序，所以使用npm命令CMD [&quot;npm&quot;,&quot;start&quot;,&quot;--production&quot;]</code></pre><pre><code class="javascript">&lt;!-- config.js --&gt;var path = require(&#39;path&#39;),config;config = {    production: {        url:&#39;http://mytestblog.com&#39;,        mail: {},        database: {            client: &#39;mysql&#39;,            connection: {                host: &#39;db&#39;,                user: &#39;ghost&#39;,                password: &#39;ghost&#39;,                database: &#39;ghost&#39;,                port: &#39;3306&#39;,                charset: &#39;utf8&#39;            },            debug: false        },        paths: {            contentPath: path.join(process.env.GHOST_CONTENT,&#39;/&#39;)        },        server: {            host: &#39;0.0.0.0&#39;,            port: &#39;2368&#39;        }    }};module.exports = config;</code></pre></li><li><p>NGINX镜像构建</p><pre><code class="shell"># /ghostcd nginxtouch Dockerfilevim Dockerfile...touch nginx.confvim nginx.conf...</code></pre><pre><code class="dockerfile">### Dockerfile #### 依赖nginx官方镜像FROM nginx# 拷贝本地配置文件到镜像中COPY nginx.conf /etc/nginx/nginx.conf# 声明暴露服务的端口EXPOSE 80</code></pre><pre><code class="nginx">### nginx.conf ###worker_processes 4;events {worker_connections 1024;}http {    server {        listen 80;        location / {            proxy_pass http://ghost-app:2368;        }    }}</code></pre></li><li><p>准备compose文件，用于描述整个系统的架构</p><pre><code class="shell"># /ghosttouch docker-compose.ymlvim docker-compose.yml</code></pre><pre><code class="yaml">### docker-compose.yml ###version: &#39;2&#39;networks:     ghost: services:     ghost-app:         build: ghost        networks:             - ghost        depends_on:             - db        ports:             - &quot;2368:2368&quot;    nginx:         build: nginx        networks:             - ghost        depends_on:             - ghost-app        ports:             - &quot;80:80&quot;    db:         image: &quot;mysql:5.7.15&quot;        networks:             - ghost        environment:             MYSQL_ROOT_PASSWORD: 123456            MYSQL_USER: ghost            MYSQL_PASSWORD: ghost        volumes:             - $PWD/data:/var/lib/mysql        ports:             - &quot;3306:3306&quot;</code></pre></li><li><p>拉起系统</p><pre><code class="shell"># /ghost# 启动docker-compose up -d# 关闭docker-compose stop# 删除docker-compose rm# 构建docker-compose build</code></pre></li><li><p>访问<a href="http://localhost、http://localhost/ghost" target="_blank" rel="noopener">http://localhost、http://localhost/ghost</a></p></li></ol><h3 id="6-4-章节回顾"><a href="#6-4-章节回顾" class="headerlink" title="6-4 章节回顾"></a>6-4 章节回顾</h3><p>docker-compose.yml常用命令：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>build</td><td>本地创建镜像</td></tr><tr><td>command</td><td>覆盖缺省命令</td></tr><tr><td>depends_on</td><td>连接容器，服务依赖</td></tr><tr><td>ports</td><td>暴露端口</td></tr><tr><td>volumes</td><td>挂载卷组</td></tr><tr><td>image</td><td>拉取镜像</td></tr></tbody></table><p>docker-compose命令：</p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>up</td><td>启动服务</td></tr><tr><td>stop</td><td>停止服务</td></tr><tr><td>rm</td><td>删除服务中的各个容器</td></tr><tr><td>logs</td><td>观察各个容器中的日志</td></tr><tr><td>ps</td><td>列出服务相关的容器</td></tr></tbody></table><h2 id="第7章-总结"><a href="#第7章-总结" class="headerlink" title="第7章 总结"></a>第7章 总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="7-1-课程总结"><a href="#7-1-课程总结" class="headerlink" title="7-1 课程总结"></a>7-1 课程总结</h3><blockquote><p>Docker介绍：容器、镜像<br>如何制作镜像<br>如何分享镜像<br>如何持久化容器数据<br>如何编排一个多容器的应用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>824-第一个docker化的java应用</title>
      <link href="/imooc/824-docker-java/"/>
      <url>/imooc/824-docker-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/824" target="_blank" rel="noopener">https://www.imooc.com/learn/824</a></p><p>简介：Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。Docker的发展速度和火爆程度着实令人惊叹，一发不可收拾，形成了席卷整个IT界的新浪潮。学完本课程你将了解到什么是docker，docker的思想以及诸如镜像，仓库，容器等核心概念。你将学会怎样运行一个容器，如何搭建私有仓库，怎么写dockerfile以及怎样把自己的应用放到容器中运行。docker将会是你的IT路上一笔不小的财富。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>对docker有个简单的印象，了解课程的安排。</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>docker解决企业大部分痛点：</p><blockquote><ol><li>快速的持续集成</li><li>服务的弹性伸缩 </li><li>部署简单，解放了运维 </li><li>为企业节省了机器资源</li></ol></blockquote><p>课程内容：</p><ul><li><p>什么是Docker?</p><p>对Docker的认识，Docker的历史，初步介绍</p></li><li><p>理解Docker</p><p>Docker的核心理论、思想，解决了什么实际问题</p></li><li><p>走进Docker</p><p>Docker的具体技术</p></li><li><p>HelloWorld</p></li><li><p>Nginx服务</p><p>Docker命令、Docker网络</p></li><li><p>Docker化的Java Web</p></li></ul><h3 id="1-2-什么是docker"><a href="#1-2-什么是docker" class="headerlink" title="1-2 什么是docker"></a>1-2 什么是docker</h3><p>Docker历史</p><ul><li>2010 dotCloud PAAS</li><li>2013 docker开源</li><li>2014.6 Docker 1.0</li><li>2014.7 C轮 $4000万</li><li>2015.4 D轮 $9500万</li><li>至今Docker 1.13</li></ul><p><a href="http://docker.com" target="_blank" rel="noopener">Docker官网</a></p><p>什么是Docker</p><blockquote><p>Docker是一个用来装应用的容器，就像被子可以装水，笔筒可以放笔，书包可以放书一样，可以把Hello World放在Docker里，可以把网站放在Docker里，可以把程序放在Docker里。</p></blockquote><ul><li>docker是世界领先的软件容器化平台（Docker is the world’s leading software containerization<br>platform）</li><li>docker公司开发，开源，托管在github上</li><li>跨平台，支持Windows、Macos、Linux</li></ul><h2 id="第2章-了解docker"><a href="#第2章-了解docker" class="headerlink" title="第2章 了解docker"></a>第2章 了解docker</h2><blockquote><p>用形象的类比说明docker的集装箱、标准化、隔离的思想。在用几个工作学习中碰到的问题说明docker解决了哪些问题。</p></blockquote><h3 id="2-1-docker思想"><a href="#2-1-docker思想" class="headerlink" title="2-1 docker思想"></a>2-1 docker思想</h3><ul><li><p>集装箱：容器</p><p>保证我们的程序放在任何地方都不会缺少东西</p></li><li><p>标准化</p><ul><li><p>运输方式</p><p>Docker运输程序有一个超级码头。A B两台电脑，A执行Docker命令把鲸鱼派过来把A的程序送到超级码头，在由B执行Docker命令由鲸鱼把程序从超级码头送过来</p></li><li><p>存储方式</p><p>不需要再关系拷贝过来的应用存在哪里 只需要在Docker 执行命令</p></li><li><p>API接口</p><p>Docker提供了一系列的RESTFUL API接口，包含了对Docker也就是对应用的控制，其中包括停止 查看 删除等等</p><p>只需要在Docker执行同样的命令 就可以控制所有的应用</p></li></ul></li><li><p>隔离：轻量级容器虚拟机技术</p><p>利用Linux内核LXC技术，能够非常快速地创建docker容器</p><p>最底层的技术实际上是一种Linux的一种内核的限制机制（LXC，Linux Container）。LXC是一种轻量级的容器虚拟化技术，最大效率的隔离了进程和资源，通过CGroup 、Namespace等限制隔离进程组所使用的物理资源，如CPU 、I/O 、Memory等等。</p><p>容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求</p></li></ul><h3 id="2-2-docker解决了什么问题"><a href="#2-2-docker解决了什么问题" class="headerlink" title="2-2 docker解决了什么问题"></a>2-2 docker解决了什么问题</h3><ol><li><p>我本地运行没问题啊。</p><p>一个Java Web程序要启动起来需要依赖什么？</p><ol><li><p>操作系统</p><p>调用了操作系统不一致的系统命令</p></li><li><p>JDK</p><p>JDK版本，如：JDK1.7编译的class文件在JDK1.6上运行</p></li><li><p>Tomcat</p><p>Tomcat版本，旧版本配置可能在新版本中不再支持</p></li><li><p>代码</p><p>比如代码引用了磁盘上（C盘）的一个文件，系统环境编码</p></li><li><p>配置文件</p><p>可能少了某些配置文件</p></li></ol><p>docker解决了运行环境不一致带来的问题。</p></li><li><p>系统好卡，哪个哥们又写死循环了。</p><p>docker的隔离性，使自己运行的程序不受其他程序的影响。</p></li><li><p>双11来了，服务器撑不住啦。</p><p>docker的标准化让快速扩展，弹性伸缩变得简单。</p></li></ol><h2 id="第3章-走进docker"><a href="#第3章-走进docker" class="headerlink" title="第3章 走进docker"></a>第3章 走进docker</h2><blockquote><p>结合上面的类比引出docker的核心技术：镜像、仓库和容器的概念，并分别深入讲解技术、原理。</p></blockquote><h3 id="3-1-docker核心技术"><a href="#3-1-docker核心技术" class="headerlink" title="3-1 docker核心技术"></a>3-1 docker核心技术</h3><p>核心概念</p><ul><li>镜像：集装箱</li><li>仓库：超级码头</li><li>容器：运行程序的地方</li></ul><p>docker运行程序的过程</p><ul><li>去仓库把镜像运到本地，用命令把镜像运行起来变成容器。</li></ul><p>分别讲解核心概念</p><ul><li>Build：构建镜像</li><li>Ship：运输镜像，从仓库和主机上运输</li><li>Run：运行的镜像，就是容器</li></ul><h3 id="3-2-docker镜像"><a href="#3-2-docker镜像" class="headerlink" title="3-2 docker镜像"></a>3-2 docker镜像</h3><ol><li><p>docker镜像就是image。从本质上来说镜像就是一系列的文件（包括应用程序的文件，也包括应用环境的文件）。镜像以联合文件系统分层的形式保存到本地；</p></li><li><p>docker镜像：（docker中的文件系统都是只读的）</p></li></ol><p>Docker文件保存存储格式？</p><blockquote><p>联合文件系统（Union FS），联合文件系统是一种分层的文件系统，它可以将不同的目录挂到同一个虚拟的文件系统下面。</p><p>联合文件系统可以通过这种方式实现文件的分层，比如test1可以看做是第一层，test2可以看做是第二层，每一层有每一层自己的文件，Docker镜像就是利用了这种分层的概念来实现了镜像存储。</p></blockquote><p>docker镜像的存储方式</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigviqm7j30eh0awaap.jpg" width="350" alt="Docker镜像"/><ul><li>最底层：操作系统的引导</li><li>上面一层：具体的Linux操作系统</li><li>上面一层：具体的软件，比如说JDK、Tomcat</li><li>上面一层：我们自己的应用代码</li><li>最上面一层：容器层</li></ul><h3 id="3-3-docker容器"><a href="#3-3-docker容器" class="headerlink" title="3-3 docker容器"></a>3-3 docker容器</h3><ol><li>docker的容器可理解为一个进程（可以将容器想象为一个虚拟机）</li><li>docker容器中除了Container层可写外，其他层都是只读的</li><li>镜像的各层都是可读的，如果想对可读层进行修改操作，那么本层内容会传到可写层，然后再进行修改操作；</li><li>当我们的应用进行文件查找是会从最顶层可写层查找（因为可读层内容都传到可写层），如果可写层没有相应数据才会去可读层查找</li><li>容器中Container层可以修改（即可写），但是在镜像中Container层是不可以修改的，这样也就保证了同一个镜像可以生成多个容器独立运行，而他们之间没有任何的干扰。</li></ol><h3 id="3-4-docker仓库"><a href="#3-4-docker仓库" class="headerlink" title="3-4 docker仓库"></a>3-4 docker仓库</h3><p>构建镜像的目的</p><blockquote><p>是为了在其机器上运行镜像程序。</p></blockquote><p>仓库的作用</p><blockquote><p>为了在其他地方运行，我们就需要将构建的镜像传递到目的地才可以，仓库可以起到传输传递作用。</p></blockquote><p>传输过程</p><blockquote><p>先将构建的镜像传到docker仓库中，再由目的地去docker仓库将我们的镜像拉过去，这样就完成了传输过程。</p></blockquote><p>docker仓库</p><ul><li>hub.docker.com（国际）</li><li>c.163.com（国内）</li></ul><h2 id="第4章-docker安装"><a href="#第4章-docker安装" class="headerlink" title="第4章 docker安装"></a>第4章 docker安装</h2><blockquote><p>分别在三中平台上讲解docker的安装。同学可以选择自己的平台观看。</p></blockquote><h3 id="4-1-window安装docker"><a href="#4-1-window安装docker" class="headerlink" title="4-1 window安装docker"></a>4-1 window安装docker</h3><p><a href="https://hub.docker.com/?overlay=onboarding" target="_blank" rel="noopener">https://hub.docker.com/?overlay=onboarding</a></p><p>查看Docker版本：</p><pre><code class="shell">docker version</code></pre><h3 id="4-2-macos安装docker"><a href="#4-2-macos安装docker" class="headerlink" title="4-2 macos安装docker"></a>4-2 macos安装docker</h3><p><a href="https://hub.docker.com/?overlay=onboarding" target="_blank" rel="noopener">https://hub.docker.com/?overlay=onboarding</a></p><h3 id="4-3-linux安装docker"><a href="#4-3-linux安装docker" class="headerlink" title="4-3 linux安装docker"></a>4-3 linux安装docker</h3><ul><li><p>Redhat&amp;CentOS：<br>系统要求：64-bit OS and version 3.10</p></li><li><p>Ubuntu</p><p>系统要求：64-bit OS and version 3.10</p></li></ul><blockquote><p>docker是在Linux的Ubuntu系统开发的，所以在Ubuntu系统是docker的最理想运行系统。</p></blockquote><p>Redhat&amp;CentOS：</p><pre><code class="shell"># 检查内核版本uname -r# 切换到root用户sudo# 保证系统为最新版本yum update# 卸载旧版本yum remove docker docker-common docker-selinux docker-engine# 安装Dockeryum install -y docker# 查看是否安装成功yum list installed | grep docker# 启动docker服务systemclt start docker# 查看是否启动成功systemclt status docker</code></pre><p>Ubuntu：</p><pre><code class="shell"># 检查内核版本uname -r# 切换到root用户su# 保证系统为最新版本apt-get update# 安装Dockerapt-get install -y docker.io# 安装Docker最新版本curl -s https://get.docker.com|sh# 是否安装成功(Client、Server)docker version# 启动Docker俯卧撑service docker start</code></pre><h2 id="第5章-docker初体验"><a href="#第5章-docker初体验" class="headerlink" title="第5章 docker初体验"></a>第5章 docker初体验</h2><blockquote><p>第一个实例：用helloworld镜像带入，熟悉docker最基本的两个命令，拉取镜像和运行容器，并讲解背后运行逻辑。</p></blockquote><h3 id="5-1-第一个docker镜像"><a href="#5-1-第一个docker镜像" class="headerlink" title="5-1 第一个docker镜像"></a>5-1 第一个docker镜像</h3><ol><li><p>从docker远程的仓库拉取镜像到本地</p><pre><code class="shell">docker pull [OPTIONS] NAME [:TAG]</code></pre><p>注：</p><ul><li>NAME项是必填，代表需要拉取的镜像名称</li><li>[:TAG]是可选的，代表镜像的版本</li><li>[OPTIONS]代表拉取的镜像参数</li></ul><p>例如：拉取hello-world镜像命令：</p><pre><code class="shell">docker pull hello-world</code></pre></li><li><p>查看我们本机都有哪些镜像，也可以验证我们的pull是否执行成功</p><pre><code class="shell">docker images [OPTIONS] [REPOSITORY[:TAG]]</code></pre><p>注：</p><ul><li>[OPTIONS]是镜像的参数</li><li>[REPOSITORY[:TAG]]是镜像的名称和版本</li></ul></li></ol><h3 id="5-2-第一个docker容器"><a href="#5-2-第一个docker容器" class="headerlink" title="5-2 第一个docker容器"></a>5-2 第一个docker容器</h3><p>运行docker镜像命令</p><pre><code class="shell">docker run [OPTIONS] IMAGE[:TAG][COMMAND] [ARG…]</code></pre><p>注：</p><ul><li>NAME项是必填，代表运行的镜像名称</li><li>[COMMAND]代表镜像运行的时候需要执行什么命令</li><li>[ARG…]代表命令所依赖的参数</li><li>[OPTIONS]代表运行的时候选项</li></ul><p>例如：运行hello-world镜像命令：</p><pre><code class="shell">docker run hello-world</code></pre><p>docker client 执行一条命令，然后根据命令内容发送相应的请求到 docker host，docker host 解析该请求，会首先查询本地镜像仓库是否有对应的资源，假如没有，则向远程镜像中心拉取镜像放回本地，接着在执行该镜像，初始化为一个容器。</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigws3xnj30mi0bvmy6.jpg"  width="500" alt="Docker初体验"/><ol><li><p>Client ：本机的docker执行命令的客户端</p></li><li><p>DOCKER_HOST：本机docker服务</p></li><li><p>Registry：docker远程仓库</p></li></ol><p>docker pull 流程：</p><ul><li>在Client主机发出docker pull执行命令到DOCKER_HOST主机docker服务的Docker daemon中，Docker daemon会先在本机中寻找是否有相应的镜像，如果存在不进行任何操作，否则会从docker的远程仓库Registry中将相应的镜像拉取到本地服务</li></ul><p>docker run 流程：</p><ul><li>在Client主机发出docker run执行命令到DOCKER_HOST主机docker服务的Docker daemon中，Docker daemon会先在本机中寻找是否有相应的镜像，如果不存在则会从docker的远程仓库Registry中将相应的镜像拉取到本地服务，然后通过一定方式将镜像运行起来变成docker的容器。</li></ul><h2 id="第6章-docker运行nginx静态网站"><a href="#第6章-docker运行nginx静态网站" class="headerlink" title="第6章 docker运行nginx静态网站"></a>第6章 docker运行nginx静态网站</h2><blockquote><p>第二个实例：从运行nginx镜像引出docker网络概念和docker的端口映射，最后运行nginx容器。</p></blockquote><h3 id="6-1-运行nginx镜像"><a href="#6-1-运行nginx镜像" class="headerlink" title="6-1 运行nginx镜像"></a>6-1 运行nginx镜像</h3><p>运行NGINX：</p><ul><li>持久运行的容器</li><li>前台挂机 &amp; 后台运行</li><li>进入容器内部</li></ul><p>常用命令：</p><pre><code class="shell"># 查找Docker的nginx镜像docker search nginx# 获取Docker的nginx镜像docker pull nginx# 查看run的帮助信息docker run --help# 以后台运行方式运行docker镜像docker run -d nginx# 查看正在运行的容器docker ps# 查看运行容器的内部信息docker exec# 查看容器指定容器ID（CONTAINER_ID）的信息docker exec -it CONTAINER_ID bash# 停止容器docker stop CONTAINER_ID</code></pre><h3 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6-2 docker网络"></a>6-2 docker网络</h3><blockquote><p>Docker使用了Linux的namespace技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Docker容器一般会分配一个独立的Network Namespace。</p></blockquote><p>docker网络：</p><ul><li><p>网络类型</p><ol><li><p>Bridge（桥接）：</p><p>docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。</p></li><li><p>Host（主机）：</p><p>容器不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p></li><li><p>None（无网络）：</p><p>Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。docker将不会和外界的任何网络进行通讯。</p></li><li><p>container模式：</p><p>新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p></li></ol></li><li><p>端口映射</p><p>Bridge网络模式需要使用独立的Namespace，就需要容器内的端口可以在主机上访问，这就是端口映射。</p><p>Docker可以指定容器内的某个端口与容器所在主机的某个端口进行映射，此时访问主机的端口就是访问容器内的端口</p></li></ul><p>docker网络示意图：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigwe5jlj30ll0arwfn.jpg"  width="350" alt="Docker网络"/><p>运行nginx镜像，并指定主机的端口：</p><pre><code class="shell">docker run -d -p 8080:80 nginx</code></pre><p>注：</p><ul><li>使用 –p 参数，冒号前面为主机端口，后面为容器端口。</li></ul><p>docker开放所有随机端口映射到容器上：</p><pre><code class="shell">Docker run -d -P nginx</code></pre><p>查看网络端口信息：</p><pre><code class="shell">netstart -na | grep 8080</code></pre><h2 id="第7章-第一个java-web应用"><a href="#第7章-第一个java-web应用" class="headerlink" title="第7章 第一个java web应用"></a>第7章 第一个java web应用</h2><blockquote><p>最后一个实例：创建自己的镜像，引出dockerfile，讲解基本的dockerfile语法。然后讲解私有仓库的搭建。最后分别在两台机器上演示docker的跨平台运行我们的java web项目。</p></blockquote><h3 id="7-1-制作自己的镜像"><a href="#7-1-制作自己的镜像" class="headerlink" title="7-1 制作自己的镜像"></a>7-1 制作自己的镜像</h3><p><a href="https://segmentfault.com/a/1190000009237581" target="_blank" rel="noopener">Linux_基于Docker快速搭建个人博客网站</a></p><p>制作自己的镜像：</p><ul><li><p>dockerfile</p><p>是由一系列命令和参数构成的脚本。这些命令应用于基础镜像并最终创建一个新的镜像，简化了从头到尾的流程并极大的简化了部署工作。</p></li><li><p>docker build</p><p>用于使用Dockerfile创建镜像。</p></li><li><p>Jpress: <a href="http://jpress.io/" target="_blank" rel="noopener">http://jpress.io/</a></p><p>开源的java web应用。</p></li></ul><p>制作 JAVA WEB应用：</p><blockquote><p>dockerFile是docker镜像的创建脚本文件，告诉docker按照文件里的流程去创建镜像</p></blockquote><ul><li><p>创建Dockerfile文件</p><pre><code class="dockerfile"># 创建的镜像继承自指定的tomcatfrom tomcat# 创建镜像人的信息，可不写MAINTAINER tyk 766564616@qq.com# COPY  [本地war包]  [指定的tomcat/webapps/下]COPY jpress.war /usr/local/tomcat/webapps</code></pre></li><li><p>构建镜像，并把镜像命名为jpress</p><pre><code class="shell"># 执行这个Dokerfile脚本文件docker build -t jpress:latest .</code></pre><p>注：</p><ul><li>-t：构建镜像的名字</li><li>.：dockerfile文件的目录，.代表当前目录下</li></ul></li></ul><h3 id="7-2-运行自己的容器"><a href="#7-2-运行自己的容器" class="headerlink" title="7-2 运行自己的容器"></a>7-2 运行自己的容器</h3><p>启动构建好的镜像：</p><pre><code class="shell">docker run -d -p 8888:8080 jpress</code></pre><p>查看端口是否被占用：</p><pre><code>netstat -na|grep 8888</code></pre><p>安装mysql：</p><pre><code>docker pull mysql</code></pre><p>创建数据库并启动mysql：</p><pre><code>docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=jpress mysql</code></pre><p>配置jpress：</p><p>查看本机实际IP地址：</p><pre><code>ifconfig</code></pre><p>上传至dockerhub</p><pre><code class="shell"># 登录docker login -u 用户名 -p 密码# docker push [用户名]/[镜像名]:[版本]docker push 766564616/jpress:latest# 登出docker logout</code></pre><h2 id="第8章-课程总结"><a href="#第8章-课程总结" class="headerlink" title="第8章 课程总结"></a>第8章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="8-1-课程总结"><a href="#8-1-课程总结" class="headerlink" title="8-1 课程总结"></a>8-1 课程总结</h3><ul><li><p>思想：集装箱、标准化，隔离</p></li><li><p>镜像（BUILD）、容器（SHIP）、仓库（RUN）</p></li><li><p>docker命令pull，build，run，stop，restart，exec…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>821-轻松愉快之玩转SpringData</title>
      <link href="/imooc/821-SpringData/"/>
      <url>/imooc/821-SpringData/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/821" target="_blank" rel="noopener">https://www.imooc.com/learn/821</a></p><p>简介：在企业级JavaEE应用开发中，对数据库的访问和操作是必须的。Spring Data作为SpringSource的其中一个子项目，旨在统一和简化对各类型持久化存储和访问，而不拘泥于是关系型数据库还是NoSQL数据存储，使得对数据库的访问变得方便快捷，并支持MapReduce框架及云计算服务；对于拥有海量数据的项目，可以用Spring Data来简化项目的开发，就如Spring Framework对JDBC、ORM的支持一样，Spring Data会让数据的访问变得更加方便，极大提高开发效率、提升程序员的幸福指数！</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>课程介绍</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><p>什么是Spring Data</p><blockquote><p>主旨：provide a familiar and consistent，Spring-based programming model for data access<br>​            提供一个熟悉的、一致的，基于Spring框架的数据访问框架。</p><p>简化数据库的访问。<br>历史：2010年提出，作者Rod Johnso，Spring Source项目<br>网址：<a href="http://projects.spring.io/spring-data/#quick-start" target="_blank" rel="noopener">http://projects.spring.io/spring-data/#quick-start</a></p></blockquote><p>Spring Data概览</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gig4qf3wj30h40c70tv.jpg" width="500" alt="Spring Data概览"/><p>Spring Data包含多个子项目</p><blockquote><ul><li><p>Spring Data JPA<br>减少数据访问层的开发量</p></li><li><p>Spring Data Mongo DB<br>基于分布于存储的数据库</p></li><li><p>Spring Data Redis<br>开源、C语言开发、支持网络内存、可持久化的Key-Value的数据库</p></li><li><p>Spring Data Solr<br>Solr是高性能的、Java语言开发、基于Lucence的全文搜索服务器</p></li></ul></blockquote><p>课程安排</p><blockquote><ul><li>传统方式访问数据库<br>原生JDBC、Spring JdbcTemplate</li><li>Spring Data快速起步</li><li>Spring Data JPA进阶<ul><li>Spring Data JPA高级</li></ul></li></ul></blockquote><h2 id="第2章-使用传统方式访问数据库"><a href="#第2章-使用传统方式访问数据库" class="headerlink" title="第2章 使用传统方式访问数据库"></a>第2章 使用传统方式访问数据库</h2><blockquote><p>先使用传统的JDBC方法操作数据库，进而再使用Spring JdbcTemplate方式操作数据库，并对比现存操作方式的优缺点</p></blockquote><h3 id="2-1-使用传统方式访问数据库"><a href="#2-1-使用传统方式访问数据库" class="headerlink" title="2-1 使用传统方式访问数据库"></a>2-1 使用传统方式访问数据库</h3><blockquote><ul><li>JDBC</li><li>Spring JdbcTemplate</li><li>弊端分析</li></ul></blockquote><h3 id="2-2-准备工作"><a href="#2-2-准备工作" class="headerlink" title="2-2 准备工作"></a>2-2 准备工作</h3><p>JDBC</p><blockquote><p>Connection<br>Statement<br>ResultSet<br>Test Case</p></blockquote><p>搭建开发环境</p><ul><li><p>创建maven项目<br>Maven工程的目录结构</p></li><li><p>添加数据库驱动和单元测试依赖</p><pre><code class="xml">&lt;!-- mysql --&gt;&lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.38&lt;/version&gt;&lt;/dependency&gt;&lt;!-- junit --&gt;&lt;dependency&gt;   &lt;groupId&gt;junit&lt;/groupId&gt;   &lt;artifactId&gt;junit&lt;/artifactId&gt;   &lt;version&gt;4.10&lt;/version&gt;   &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre></li><li><p>数据库表的准备，使用mysql数据库</p><pre><code class="mysql"># 创建数据库create database spring_data;# 创建数据表create table student(    id int not null auto_increment,    name varchar(20)not null,    age int not null,    primary key(id));# 查看表结构desc student;# 插入数据insert into student(name,age)values(&quot;zhangsan&quot;, 20);insert into student(name,age)values(&quot;lisi&quot;, 21);insert into student(name,age)values(&quot;wangwu&quot;, 22);# 查询数据select * from student;</code></pre></li></ul><h3 id="2-3-JDBCUtil开发"><a href="#2-3-JDBCUtil开发" class="headerlink" title="2-3 JDBCUtil开发"></a>2-3 JDBCUtil开发</h3><p>开发JDBCUtil工具类：</p><blockquote><p>获取Connection，关闭Connection、Statement、ResultSet<br>注意事项：配置的属性放置配置文件中，然后通过代码的方式将配置文件中的数据加载进来即可。</p></blockquote><p>代码示例：</p><pre><code class="java">package com.myimooc.springdata.jdbc.util;import java.io.InputStream;import java.sql.*;import java.util.Properties;/** * JDBC工具类： * 1）获取Connection * 2）释放资源 */public class JDBCUtils {    /**     * 获取Connection     * @return 所获得到的JDBC的Connection     */    public static Connection getConnection() throws Exception {        /**         * 不建议大家把配置硬编码到代码中         * 最佳实践：配置性的建议写到配置文件中         * *///        String url = &quot;jdbc:mysql:///spring_data&quot;;//        String username = &quot;root&quot;;//        String password = &quot;root&quot;;//        String dirverClass = &quot;com.mysql.jdbc.Driver&quot;;        InputStream inputStream =  JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);        Properties properties = new Properties();        properties.load(inputStream);        String url = properties.getProperty(&quot;jdbc.url&quot;);        String username = properties.getProperty(&quot;jdbc.username&quot;);        String password = properties.getProperty(&quot;jdbc.password&quot;);        String driverClass = properties.getProperty(&quot;jdbc.driverClass&quot;);        Class.forName(driverClass);        return DriverManager.getConnection(url,username,password);    }    /**     * 释放DB相关资源     */    public static void release(ResultSet resultSet, Statement statement, Connection connection) throws Exception {        if(resultSet != null ){            resultSet.close();        }        if(statement != null ){            statement.close();        }        if(connection != null ){            connection.close();        }    }}</code></pre><p>数据库连接配置文件：</p><pre><code class="properties"># db.propertiesjdbc.url = jdbc:mysql:///spring_datajdbc.user = rootjdbc.password = rootjdbc.driverClass = com.mysql.jdbc.Driver</code></pre><p>注：</p><ul><li>配置的属性放在配置文件中，然后通过代码的方式将配置文件中的数据加载进来即可。</li></ul><p>单元测试：</p><pre><code class="java">@Testpublic void testGetConnection() throws Exception {    Connection connection = JDBCUtil.getConnection();    Assert.assertNotNull(connection);}</code></pre><h3 id="2-4-Dao开发"><a href="#2-4-Dao开发" class="headerlink" title="2-4 Dao开发"></a>2-4 Dao开发</h3><p>建立对象模型及DAO层开发。</p><p>代码演示：</p><ol><li><p>对象模型</p><pre><code class="java">package com.myimooc.springdata.jdbc.domain;/** * Student实体类 */@Datapublic class Student {    /** 主键ID */    private Integer id;    /** 姓名 */    private String name;    /** 年龄 */    private int age;}</code></pre></li><li><p>DAO接口</p><pre><code class="java">package com.myimooc.springdata.jdbc.dao;import com.myimooc.springdata.jdbc.domain.Student;import java.util.List;/** * Student DAO访问接口 */public interface StudentDao {    /**     * 获取所有学生     * @return 所有学生     */    List&lt;Student&gt; listStudent();    /**     * 添加一个学生     * @param student 待添加的学生     */    void saveStudent(Student student);}</code></pre></li><li><p>DAO实现</p><pre><code class="java">package com.myimooc.springdata.jdbc.dao.impl;import com.myimooc.springdata.jdbc.dao.StudentDao;import com.myimooc.springdata.jdbc.domain.Student;import com.myimooc.springdata.jdbc.util.JDBCUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import java.util.List;/** * Student DAO访问接口实现类：通过最原始的JDBC的方式操作 */public class StudentDaoImpl implements StudentDao {    public List&lt;Student&gt; listStudent() {        List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();        String sql = &quot;select id,name,age from student&quot;;        try (Connection connection = JDBCUtils.getConnection();             PreparedStatement preparedStatement = connection.prepareStatement(sql);             ResultSet resultSet = preparedStatement.executeQuery();) {            while(resultSet.next()) {                Student student = new Student();                student.setId(resultSet.getInt(&quot;id&quot;));                student.setName(resultSet.getString(&quot;name&quot;));                student.setAge(resultSet.getInt(&quot;age&quot;));                studentList.add(student);            }        } catch (Exception e) {            e.printStackTrace();        } finally {            JDBCUtils.release(resultSet, preparedStatement, connection);        }        return studentList;    }    public void saveStudent(Student student) {        String sql = &quot;insert into student(name,age) values(?, ?)&quot;;        try (Connection connection = JDBCUtils.getConnection();             PreparedStatement preparedStatement = connection.prepareStatement(sql);) {            preparedStatement.setString(1, student.getName());            preparedStatement.setInt(2, student.getAge());            preparedStatement.executeUpdate();        } catch (Exception e) {            e.printStackTrace();        } finally {            JDBCUtils.release(resultSet,preparedStatement,connection);        }    }}</code></pre></li><li><p>单元测试</p><pre><code class="java">@Testpublic void listStudentTest(){    StudentDao studentDao = new StudentDaoImpl();    List&lt;Student&gt;  studentList = studentDao.listStudent();    for(Student student : studentList){        System.out.println(student);    }}@Testpublic void saveStudentTest(){    StudentDao studentDao = new StudentDaoImpl();    Student student = new Student(&quot;test&quot;, 30);    studentDao.saveStudent(student);}</code></pre></li></ol><h3 id="2-5-使用JdbcTemplate"><a href="#2-5-使用JdbcTemplate" class="headerlink" title="2-5 使用JdbcTemplate"></a>2-5 使用JdbcTemplate</h3><p>Spring JdbcTemplate</p><ul><li><p>添加maven依赖</p><pre><code class="xml">&lt;!--spring--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;4.3.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>DataSource &amp; JdbcTemplate注入</p><p>Spring配置文件</p><pre><code class="xml">&lt;!-- beans.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///spring_data&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;studentDAO&quot; class=&quot;com.imooc.dao.StudentDAOSpringJdbcImpl&quot;&gt;        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre></li><li><p>Test Case</p><pre><code class="java">public class DataSourceTest {    private ApplicationContext ctx = null;    @Before    public void setup(){        System.out.println(&quot;setup&quot;);        ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    }    @After    public void tearDown(){        System.out.println(&quot;tearDown&quot;);        ctx = null;    }    @Test    public void testDataSource(){        System.out.println(&quot;testDataSource&quot;);        DataSource dataSource = (DataSource)ctx.getBean(&quot;dataSource&quot;);        Assert.notNull(dataSource);    }    @Test    public void testJdbcTemplate(){        System.out.println(&quot;testJdbcTemplate&quot;);        JdbcTemplate jdbcTemplate = (JdbcTemplate)ctx.getBean(&quot;jdbcTemplate&quot;);        Assert.notNull(jdbcTemplate);    }}</code></pre></li><li><p>Dao实现</p><pre><code class="java">package com.imooc.dao;import com.imooc.domain.Student;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowCallbackHandler;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * StudentDAO访问接口实现类：通过Spring jdbc的方式操作 */@Datapublic class StudentDAOSpringJdbcImpl implements StudentDAO {    @Autowired    private JdbcTemplate jdbcTemplate;    @Override    public List&lt;Student&gt; query() {        final List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();        String sql = &quot;SELECT id, name, age FROM student&quot;;        jdbcTemplate.query(sql, new RowCallbackHandler() {            @Override            public void processRow(ResultSet rs) throws SQLException {                Student student = new Student();                student.setId(rs.getInt(&quot;id&quot;));                student.setName(rs.getString(&quot;name&quot;));                student.setAge(rs.getInt(&quot;age&quot;));                students.add(student);            }        });        return students;    }    @Override    public void save(Student student) {        String sql = &quot;INSERT INTO student(name, age) VALUES(?, ?)&quot;;        jdbcTemplate.update(sql, student.getName(), student.getAge());    }}</code></pre></li><li><p>单元测试</p><pre><code class="java">public class StudentDAOSpringJdbcImplTest {    private ApplicationContext ctx = null;    private StudentDAO studentDAO = null;    @Before    public void setup(){        System.out.println(&quot;setup&quot;);        ctx = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        studentDAO = (StudentDAO)ctx.getBean(&quot;studentDAO&quot;);    }    @After    public void tearDown(){        System.out.println(&quot;tearDown&quot;);        ctx = null;    }    @Test    public void testQuery() {        List&lt;Student&gt; students = studentDAO.query();        for (Student student : students) {            System.out.println(&quot;student:&quot; + student);        }    }    @Test    public void testSave() {        Student student = new Student(&quot;test-spring-jdbc&quot;, 40);        studentDAO.save(student);    }}</code></pre><p>END</p></li></ul><p>代码演示：</p><ol><li><p>创建DB配置文件</p><pre><code class="properties">jdbc.url = jdbc:mysql:///springdatajdbc.username = rootjdbc.password = rootjdbc.driverClass = com.mysql.jdbc.Driver</code></pre></li><li><p>创建配置文件类</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.ImportResource;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;/** * 配置参数类 */@Data@PropertySource(value=&quot;classpath:db.properties&quot;)@Componentpublic class Properties {    @Value(&quot;${jdbc.driverClass}&quot;)    private String jdbcDriverClass;    @Value(&quot;${jdbc.url}&quot;)    private String jdbcUrl;    @Value(&quot;${jdbc.username}&quot;)    private String jdbcUser;    @Value(&quot;${jdbc.password}&quot;)    private String jdbcPassword;}</code></pre></li><li><p>配置DataSource、JdbcTemplate和Spring注解扫描</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;@Configuration@ComponentScan(&quot;com.myimooc.springdata.jdbctemplate&quot;)public class SpringConfig {    @Autowired    private Properties properties;    @Bean    DriverManagerDataSource getDriverManagerDataSource(){        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();        driverManagerDataSource.setDriverClassName(properties.getJdbcDriverClass());        driverManagerDataSource.setUrl(properties.getJdbcUrl());        driverManagerDataSource.setUsername(properties.getJdbcUser());        driverManagerDataSource.setPassword(properties.getJdbcPassword());        return driverManagerDataSource;    }    @Bean    JdbcTemplate getJdbcTemplate(){        JdbcTemplate jdbcTemplate = new JdbcTemplate();        jdbcTemplate.setDataSource(getDriverManagerDataSource());        return jdbcTemplate;    }}</code></pre></li><li><p>编写实体类</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.domain;/** * Student实体类 */@Datapublic class Student {    /** 主键ID */    private Integer id;    /** 姓名 */    private String name;    /** 年龄 */    private int age;}</code></pre></li><li><p>DAO接口</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.dao;import com.myimooc.springdata.jdbctemplate.domain.Student;import java.util.List;/** * StudentDAO访问接口 */public interface StudentDao {    /**     * 获取所有学生     * @return 所有学生     */    List&lt;Student&gt; listStudent();    /**     * 添加一个学生     * @param student 待添加的学生     */    void saveStudent(Student student);}</code></pre></li><li><p>DAO实现</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate.dao.impl;import com.myimooc.springdata.jdbctemplate.dao.StudentDao;import com.myimooc.springdata.jdbctemplate.domain.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * StudentDAO访问接口实现类：通过 JdbcTemplate 的方式操作 */@Repositorypublic class StudentDaoImpl implements StudentDao {    @Autowired    private JdbcTemplate jdbcTemplate;    public List&lt;Student&gt; listStudent() {        List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;();        String sql = &quot;select id, name, age from student&quot;;        List&lt;Map&lt;String,Object&gt;&gt;  mapList = jdbcTemplate.queryForList(sql);        for (Map&lt;String,Object&gt; mapTemp : mapList) {            Integer id = Integer.parseInt(mapTemp.get(&quot;id&quot;).toString());            String name = mapTemp.get(&quot;name&quot;).toString();            Integer age = Integer.parseInt(mapTemp.get(&quot;age&quot;).toString());            Student student = new Student();            student.setId(id);            student.setName(name);            student.setAge(age);            studentList.add(student);        }        return studentList;    }    public void saveStudent(Student student) {        String sql = &quot;insert into student(name, age) value(?,?)&quot;;        jdbcTemplate.update(sql,student.getName(),student.getAge());    }}</code></pre></li><li><p>单元测试类</p><pre><code class="java">package com.myimooc.springdata.jdbctemplate;import com.myimooc.springdata.jdbctemplate.config.SpringConfig;import com.myimooc.springdata.jdbctemplate.dao.StudentDao;import com.myimooc.springdata.jdbctemplate.domain.Student;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import javax.sql.DataSource;import java.util.List;/** *  使用 JdbcTemplate 实现 StudentDao 单元测试类 */public class StudentDaoTest {    private ApplicationContext ctx = null;    private StudentDao studentDao;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        studentDao = ctx.getBean(StudentDao.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void listStudentTest(){        List&lt;Student&gt; studentList = studentDao.listStudent();        for (Student student : studentList){            System.out.println(student.toString());        }    }    @Test    public void saveTest(){        Student student = new Student(&quot;test-spring-jdbcTemplate&quot;, 25);        studentDao.saveStudent(student);    }}</code></pre></li></ol><h3 id="2-6-弊端分析"><a href="#2-6-弊端分析" class="headerlink" title="2-6 弊端分析"></a>2-6 弊端分析</h3><blockquote><ul><li>DAO里面代码量太多</li><li>DAO的实现有很多重复代码</li><li>开发分页和其它功能，需要重新进行封装</li></ul></blockquote><h2 id="第3章-Spring-Data快速入门"><a href="#第3章-Spring-Data快速入门" class="headerlink" title="第3章 Spring Data快速入门"></a>第3章 Spring Data快速入门</h2><blockquote><p>完成该框架的开发环境搭建及单元测试，本课我们将使用IDEA开发并使用Maven构建项目；</p></blockquote><h3 id="3-1-开发环境搭建"><a href="#3-1-开发环境搭建" class="headerlink" title="3-1 开发环境搭建"></a>3-1 开发环境搭建</h3><p>Spring Data JPA快速起步</p><blockquote><ol><li>开发环境搭建</li><li>Spring Data JPA HelloWorld开发</li></ol></blockquote><ul><li><p>添加maven依赖：</p><pre><code class="xml">&lt;!--spring data jpa--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;    &lt;version&gt;1.8.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;    &lt;version&gt;4.3.6.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>DataSource &amp; JdbcTemplate注入</p><p><strong>Spring配置文件</strong>：</p><pre><code class="xml">&lt;!-- beans-new.xml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa-1.3.xsd        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt;    &lt;!-- Spring扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.imooc&quot;/&gt;&lt;/beans&gt;</code></pre><ol><li><p>配置数据源</p><pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///spring_data&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>配置EntityManagerFactory</p><pre><code class="xml">&lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;property name=&quot;jpaVendorAdapter&quot;&gt;        &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;/&gt;    &lt;/property&gt;    &lt;property name=&quot;packagesToScan&quot; value=&quot;com.imooc&quot;/&gt;    &lt;property name=&quot;jpaProperties&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;hibernate.ejb.naming_strategy&quot;&gt;org.hibernate.cfg.ImprovedNamingStrategy&lt;/prop&gt;            &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/prop&gt;            &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;            &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt;            &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre></li><li><p>配置事务管理器</p><pre><code class="xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;    &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;&lt;/bean&gt;</code></pre></li><li><p>配置支持注解的事务</p><pre><code class="xml">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></pre></li><li><p>配置spring data</p><pre><code class="xml">&lt;jpa:repositories base-package=&quot;com.imooc&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot;/&gt;</code></pre></li></ol></li><li><p>创建实体类</p><pre><code class="java">/** * 雇员:  先开发实体类===&gt;自动生成数据表 */@Data@Entitypublic class Employee {    @Id    @GeneratedValue    private Integer id;    @Column(length = 20, nullable = false)    private String name;    private Integer age;}</code></pre></li><li><p>单元测试</p><pre><code class="java">public class SpringDataTest {    private ApplicationContext ctx = null;    @Before    public void setup(){        System.out.println(&quot;setup&quot;);        ctx = new ClassPathXmlApplicationContext(&quot;beans-new.xml&quot;);    }    @After    public void tearDown(){        System.out.println(&quot;tearDown&quot;);        ctx = null;    }    @Test    public void testEntityManagerFactory(){        // 运行单元测试，检查是否有生成一张数据表。有则成功，无则失败。    }}</code></pre><p>END</p></li></ul><p>代码演示：</p><ol><li><p>创建DB配置文件</p><pre><code class="properties">jdbc.url = jdbc:mysql:///springdatajdbc.username = rootjdbc.password = rootjdbc.driverClass = com.mysql.jdbc.Driver</code></pre></li><li><p>创建配置文件类</p><pre><code class="java">package com.myimooc.springdata.jpa.config;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Data@Component@PropertySource(value=&quot;classpath:db.properties&quot;)public class PropertiesConfig {    @Value(&quot;${jdbc.driverClass}&quot;)    private String jdbcDriverClass;    @Value(&quot;${jdbc.url}&quot;)    private String jdbcUrl;    @Value(&quot;${jdbc.username}&quot;)    private String jdbcUser;    @Value(&quot;${jdbc.password}&quot;)    private String jdbcPassword;}</code></pre></li><li><p>配置TransactionManager、EntityManagerFactory和Spring自动扫描注入</p><pre><code class="java">package com.myimooc.springdata.jpa.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.jdbc.datasource.DriverManagerDataSource;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.Database;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import java.util.Properties;/** * Spring配置类 */// 声明为配置类@Configuration// 启用事务管理@EnableTransactionManagement// 启用自动扫描继承 JpaRepository 接口的类。// 注意，此注解需要配置 entityManagerFactory 和 transactionManager// 方式一：定义获取Bean方法名为 entityManagerFactory 和 transactionManager// 方式二：配置 @EnableJpaRepositories注解的 entityManagerFactoryRef 属性 为自定义获取Bean的方法名。@EnableJpaRepositories(basePackages = &quot;com.myimooc.springdata.jpa&quot;)// 启用自动扫描 @Component 注解的Bean@ComponentScan(basePackages = &quot;com.myimooc.springdata.jpa&quot;)public class SpringConfig {    @Autowired    private PropertiesConfig propertiesConfig;    /**     * 配置数据源     * @return     */    @Bean    public DriverManagerDataSource dataSource(){        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();        driverManagerDataSource.setDriverClassName(propertiesConfig.getJdbcDriverClass());        driverManagerDataSource.setUrl(propertiesConfig.getJdbcUrl());        driverManagerDataSource.setUsername(propertiesConfig.getJdbcUser());        driverManagerDataSource.setPassword(propertiesConfig.getJdbcPassword());        return driverManagerDataSource;    }    /**     * 配置事务管理器 JpaTransactionManager     * @return     */    @Bean(name=&quot;transactionManager&quot;)    public PlatformTransactionManager transactionManager(){        JpaTransactionManager transactionManager = new JpaTransactionManager();        transactionManager.setDataSource(this.dataSource());        transactionManager.setEntityManagerFactory(this.entityManagerFactory().getObject());        return transactionManager;//        return new DataSourceTransactionManager(this.dataSource());//        return new JpaTransactionManager(this.entityManagerFactory().getObject());    }    /**     * 配置JPA的 EntityManagerFactory     * @return     */    @Bean    public LocalContainerEntityManagerFactoryBean entityManagerFactory(){        LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();        entityManagerFactory.setDataSource(dataSource());        HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();        jpaVendorAdapter.setGenerateDdl(true);        jpaVendorAdapter.setDatabase(Database.MYSQL);        entityManagerFactory.setJpaVendorAdapter(jpaVendorAdapter);        entityManagerFactory.setPackagesToScan(&quot;com.myimooc.springdata.jpa&quot;);        Properties jpaProperties = new Properties();//        jpaProperties.setProperty(&quot;hibernate.ejb.naming_strategy&quot;,&quot;org.hibernate.cfg.ImprovedNamingStrategy&quot;);        jpaProperties.setProperty(&quot;hibernate.dialect&quot;,&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;);        jpaProperties.setProperty(&quot;hibernate.show_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.format_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.hbm2ddl.auto&quot;,&quot;update&quot;);        entityManagerFactory.setJpaProperties(jpaProperties);        return entityManagerFactory;    }}</code></pre></li><li><p>编写实体类：Employee</p><pre><code class="java">package com.myimooc.springdata.jpa.domain;import javax.persistence.*;/** * 雇员：先开发实体类，然后自动生成实体表 */@Data@Entity@Table(name = &quot;test_employee&quot;)public class Employee {    @Id    @GeneratedValue    private Integer id;    @Column(length = 20)    private String name;    private Integer age;}</code></pre></li></ol><h3 id="3-2-起步程序开发"><a href="#3-2-起步程序开发" class="headerlink" title="3-2 起步程序开发"></a>3-2 起步程序开发</h3><ol><li><p>编写EmployeeRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.repository.Repository;/** * 使用 Repository 接口 */// 方式二：使用 @RepositoryDefinition 注解//  @RepositoryDefinition(domainClass = Employee.class,idClass = Integer.class)public interface EmployeeRepository extends Repository&lt;Employee,Integer&gt; { //方式一：继承 Repository 接口    /**     * 获取雇员对象通过名称     */    Employee findByName(String name);}</code></pre></li><li><p>编写单元测试类：EmployeeRepositoryTest</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeeRepository;import com.myimooc.springdata.jpa.service.EmployeeService;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import java.util.ArrayList;import java.util.List;/** * EmployeeRepository单元测试类 */public class EmployeeRepositoryTest {    private ApplicationContext ctx = null;    private EmployeeRepository employeeRepository = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeRepository = ctx.getBean(EmployeeRepository.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void findByNameTest(){        // org.springframework.data.ipa.repository.support.SimpleJpaRepository@566        System.out.println(employeeRepository);        Employee employee = employeeRepository.findByName(&quot;cc&quot;);        System.out.println(employee.toString());    }}</code></pre></li></ol><p>Repository</p><blockquote><p>Repository：Spring Data核心类<br>RepositoryDefinition：使用该注解进行配置<br>Repository Query Specification：查询时，方法命名不能乱写<br>Query Annotation：使用该注解，可以实现原生SQL查询<br>Update/Delete/Transaction：更新、删除操作，支持事务</p></blockquote><p>Repository Hierarchy：层次结构</p><blockquote><p>CrudRepository：内置了新增、更新、删除、查询方法<br>PagingAndSortingRespository：分页和排序<br>JpaRepository：<br>JpaSpecificationExcutor</p></blockquote><h2 id="第4章-Spring-Data-JPA进阶"><a href="#第4章-Spring-Data-JPA进阶" class="headerlink" title="第4章 Spring Data JPA进阶"></a>第4章 Spring Data JPA进阶</h2><blockquote><p>使用Spring Data JPA完成CRUD操作</p></blockquote><h3 id="4-1-关于Repository接口"><a href="#4-1-关于Repository接口" class="headerlink" title="4-1 关于Repository接口"></a>4-1 关于Repository接口</h3><p>Repository接口详解</p><blockquote><p>Repository接口是Spring Data的核心接口，不提供任何方法<br>public interface Repository&lt;T, ID extends Serializable&gt;{}</p><p>@RepositoryDefinition注解的使用<br>@RepositoryDefinition(domainClass = Employee.class, idClass = Integer.class)</p></blockquote><p>Repository类的定义：</p><blockquote><ul><li><p>Repository是一个空接口，标记接口。没有包含方法声明的接口</p></li><li><p>如果我们定义的接口EmployeeRepository extends Repository，会被Spring管理。<br>如果我们自己的接口没有extends Repository，运行时会报错，没有这个Bean：</p><pre><code class="java">org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &#39;com.imooc.repository.EmployeeRepository&#39; available</code></pre></li><li><p>添加RepositoryDefinition注解能到达到不用extends Repository的功能</p></li></ul></blockquote><h3 id="4-2-Repository子接口详解"><a href="#4-2-Repository子接口详解" class="headerlink" title="4-2 Repository子接口详解"></a>4-2 Repository子接口详解</h3><p>Repository子接口详解</p><blockquote><p>CrudRepository：继承Repository，实现了CRUD相关的方法<br>PagingAndSortingRepository：继承CrudRepository，实现了分页排序相关的方法<br>JpaRepository：继承PagingAndSortingRepositor，实现JPA规范相关的方法</p></blockquote><h3 id="4-3-查询方法定义规则和使用"><a href="#4-3-查询方法定义规则和使用" class="headerlink" title="4-3 查询方法定义规则和使用"></a>4-3 查询方法定义规则和使用</h3><p>Repository中查询方法定义规则和使用</p><blockquote><p>了解Spring Data中查询方法名称的定义规则<br>使用Spring Data完成复杂查询方法名称的命名</p></blockquote><p>查询方法定义规则</p><table><thead><tr><th>Keyword</th><th>Sample</th><th>JPQL snippet</th></tr></thead><tbody><tr><td>And</td><td>findByLastnameAndFirstname</td><td>where x.lastname=?1 and x.firstname=?2</td></tr><tr><td>Or</td><td>findByLastnameOrFirstname</td><td>where x.lastname=?1 or x.firstname=?2</td></tr><tr><td>Between</td><td>findByStartDateBetween</td><td>where x.startDate between 1? and ?2</td></tr><tr><td>LessThan</td><td>findByAgeLessThan</td><td>where x.age&lt;?1</td></tr><tr><td>GreaterThan</td><td>findByAgeGreaterThan</td><td>where x.age&gt;?1</td></tr><tr><td>After</td><td>findByStartDateAfter</td><td>where x.startDate&gt;?1</td></tr><tr><td>Before</td><td>findByStartDateBefore</td><td>where x.startDate&lt;?1</td></tr><tr><td>IsNull</td><td>findByAgelsNull</td><td>where x.age is null</td></tr><tr><td>IsNotNul, NotNull</td><td>findByAge(Is)NotNull</td><td>where x.age not null</td></tr><tr><td>Like</td><td>findByFirstnameLike</td><td>where x.firstname like ?1</td></tr><tr><td>Notlike</td><td>findByFirstnameNotlike</td><td>where x. firstname not like ?1</td></tr><tr><td>StartingWith</td><td>findByFirstnameStartingWith</td><td>where x.firstname like ?1(parameter bound with appended %)</td></tr><tr><td>EndingWith</td><td>findByFirstnameEndingWith</td><td>where x.firstname like ?1(parameter bound with prepended %)</td></tr><tr><td>Containing</td><td>findByFirstnameContaining</td><td>where x.firstname like ?1(parameter bound wrapped in %)</td></tr><tr><td>OrderBy</td><td>findByAgeOrderByLastnameDesc</td><td>where x.age=?1 order by x.lastname desc</td></tr><tr><td>Not</td><td>findByLastnameNot</td><td>where x.lastname&lt;&gt;?1</td></tr><tr><td>In</td><td>findByAgeln(Collection<Age> ages)</td><td>where x.age in ?1</td></tr><tr><td>Notln</td><td>findByAgeNotin(Collection<Age> age)</td><td>where x.age not in ?1</td></tr><tr><td>TRUE</td><td>findByActiveTrue</td><td>where x.active=true</td></tr><tr><td>FALSE</td><td>findByActiveFalse</td><td>where x.active=false</td></tr></tbody></table><p>代码演示：</p><pre><code class="sql">-- 测试数据insert into employee (name, age) values (&quot;test1&quot;,20);insert into employee (name, age) values (&quot;test2&quot;,21);insert into employee (name, age) values (&quot;test3&quot;,22);insert into employee (name, age) values (&quot;test4&quot;,20);insert into employee (name, age) values (&quot;test5&quot;,21);insert into employee (name, age) values (&quot;test6&quot;,22);insert into employee (name, age) values (&quot;test16&quot;,22);</code></pre><ol><li><p>在EmployeeRepository接口编写以下代码</p><pre><code class="java">// --- 使用JPA规范查询 ---// where name like ?% and age &lt; ?List&lt;Employee&gt; findByNameStartingWithAndAgeLessThan(String name,Integer age);// where name like %? and age &lt; ?List&lt;Employee&gt; findByNameEndingWithAndAgeLessThan(String name,Integer age);// where name in (?, ?...) or age &lt; ?List&lt;Employee&gt; findByNameInOrAgeLessThan(List&lt;String&gt; name,Integer age);// where name in (?, ?...) and age &lt; ?List&lt;Employee&gt; findByNameInAndAgeLessThan(List&lt;String&gt; name,Integer age);</code></pre></li><li><p>在EmployeeRepositoryTest单元测试类进行测试</p><pre><code class="java">@Testpublic void findByNameStartingWithAndAgeLessThanTest(){    List&lt;Employee&gt; employees = employeeRepository.findByNameStartingWithAndAgeLessThan(&quot;test&quot;,22);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}@Testpublic void findByNameEndingWithAndAgeLessThanTest(){    List&lt;Employee&gt; employees = employeeRepository.findByNameEndingWithAndAgeLessThan(&quot;6&quot;,23);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}@Testpublic void findByNameInOrAgeLessThanTest(){    List&lt;String&gt; names = new ArrayList&lt;String&gt;();    names.add(&quot;test1&quot;);    names.add(&quot;test2&quot;);    names.add(&quot;test3&quot;);    List&lt;Employee&gt; employees = employeeRepository.findByNameInOrAgeLessThan(names,22);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}@Testpublic void findByNameInAndAgeLessThanTest(){    List&lt;String&gt; names = new ArrayList&lt;String&gt;();    names.add(&quot;test1&quot;);    names.add(&quot;test2&quot;);    names.add(&quot;test3&quot;);    List&lt;Employee&gt; employees = employeeRepository.findByNameInAndAgeLessThan(names,22);    for (Employee employee : employees) {        System.out.println(employee.toString());    }}</code></pre></li></ol><p>对于按照方法命名规则来使用的话，有弊端：</p><blockquote><p>1）方法名比较长：约定大于配置<br>2）对于一些复杂的查询，是很难实现。</p></blockquote><p>使用@Query注解来解决以上弊端。</p><h3 id="4-4-Query注解使用"><a href="#4-4-Query注解使用" class="headerlink" title="4-4 Query注解使用"></a>4-4 Query注解使用</h3><p>Query注解使用</p><blockquote><ul><li>在Respository方法中使用，不需要遵循查询方法命令规则</li><li>只需要将@Query定义在Respository中的方法之上即可</li><li>命名参数及索引参数的使用</li><li>本地查询</li></ul></blockquote><ol><li><p>在EmployeeRepository接口编写以下代码</p><pre><code class="java">// --- 使用@Query注解查询 ---// 自定义查询SQL。Employee为类名，不是表名@Query(&quot;select o from Employee o where id=(select max(id) from Employee t1)&quot;)Employee getEmployeeByMaxId();// 使用占位符进行参数绑定@Query(&quot;select o from Employee o where o.name=?1 and o.age=?2&quot;)List&lt;Employee&gt; listEmployeeByNameAndAge(String name, Integer age);// 使用命名参数进行参数绑定@Query(&quot;select o from Employee o where o.name=:name and o.age=:age&quot;)List&lt;Employee&gt; listEmployeeByNameAndAge2(@Param(&quot;name&quot;) String name, @Param(&quot;age&quot;)Integer age);// 自定义查询SQL，like,占位符进行参数绑定@Query(&quot;select o from Employee o where o.name like %?1%&quot;)List&lt;Employee&gt; listEmployeeByLikeName(String name);// 自定义查询SQL，like,命名参数进行参数绑定@Query(&quot;select o from Employee o where o.name like %:name%&quot;)List&lt;Employee&gt; listEmployeeByLikeName2(@Param(&quot;name&quot;) String name);// 使用原生态SQL查询。employee为表名@Query(nativeQuery = true,value = &quot;select count(1) from employee&quot;)long getCount();</code></pre></li><li><p>在EmployeeRepositoryTest单元测试类进行测试</p><pre><code class="java">//  使用 @Query 注解查询@Testpublic void getEmployeeByMaxIdTest(){    Employee employee = employeeRepository.getEmployeeByMaxId();    System.out.println(employee);}@Testpublic void listEmployeeByNameAndAgeTest(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByNameAndAge(&quot;zhangsan&quot;,20);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void listEmployeeByNameAndAge2Test(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByNameAndAge2(&quot;zhangsan&quot;,20);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void listEmployeeByLikeNameTest(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByLikeName(&quot;test1&quot;);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void listEmployeeByLikeName2Test(){    List&lt;Employee&gt; employees = employeeRepository.listEmployeeByLikeName2(&quot;test&quot;);    for (Employee employee : employees) {        System.out.println(employee);    }}@Testpublic void getCountTest(){    long count = employeeRepository.getCount();    System.out.println(count);}</code></pre></li></ol><h3 id="4-5-更新操作整合事务使用"><a href="#4-5-更新操作整合事务使用" class="headerlink" title="4-5 更新操作整合事务使用"></a>4-5 更新操作整合事务使用</h3><p>更新及删除操作整合事务的使用</p><blockquote><ul><li>@Modifying注解使用</li><li>@Modifying结合@Query注解执行更新操作</li><li>@Transaction在Spring Data中的使用</li></ul></blockquote><ol><li><p>基于javaconfig在SpringConfig类进行事务配置</p><pre><code class="java">package com.myimooc.springdata.jpa.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.jdbc.datasource.DriverManagerDataSource;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.orm.jpa.vendor.Database;import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import java.util.Properties;/** * Spring配置类 */// 声明为配置类@Configuration// 启用事务管理@EnableTransactionManagement// 启用自动扫描继承 JpaRepository 接口的类。// 注意，此注解需要配置 entityManagerFactory 和 transactionManager// 方式一：定义获取Bean方法名为 entityManagerFactory 和 transactionManager// 方式二：配置 @EnableJpaRepositories注解的 entityManagerFactoryRef 属性 为自定义获取Bean的方法名。@EnableJpaRepositories(basePackages = &quot;com.myimooc.springdata.jpa&quot;)// 启用自动扫描 @Component 注解的Bean@ComponentScan(basePackages = &quot;com.myimooc.springdata.jpa&quot;)public class SpringConfig{    @Autowired    private PropertiesConfig propertiesConfig;    // 配置数据源    @Bean    public DriverManagerDataSource dataSource(){        DriverManagerDataSource driverManagerDataSource = new DriverManagerDataSource();        driverManagerDataSource.setDriverClassName(propertiesConfig.getJdbcDriverClass());        driverManagerDataSource.setUrl(propertiesConfig.getJdbcUrl());        driverManagerDataSource.setUsername(propertiesConfig.getJdbcUser());        driverManagerDataSource.setPassword(propertiesConfig.getJdbcPassword());        return driverManagerDataSource;    }    // 配置事务管理器 JpaTransactionManager    @Bean(name=&quot;transactionManager&quot;)    public PlatformTransactionManager transactionManager(){        JpaTransactionManager transactionManager = new JpaTransactionManager();        transactionManager.setDataSource(this.dataSource());        transactionManager.setEntityManagerFactory(this.entityManagerFactory().getObject());        return transactionManager;//        return new DataSourceTransactionManager(this.dataSource());//        return new JpaTransactionManager(this.entityManagerFactory().getObject());    }    // 配置JPA的 EntityManagerFactory    @Bean    public LocalContainerEntityManagerFactoryBean entityManagerFactory(){        LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();        entityManagerFactory.setDataSource(dataSource());        HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter();        jpaVendorAdapter.setGenerateDdl(true);        jpaVendorAdapter.setDatabase(Database.MYSQL);        entityManagerFactory.setJpaVendorAdapter(jpaVendorAdapter);        entityManagerFactory.setPackagesToScan(&quot;com.myimooc.springdata.jpa&quot;);        Properties jpaProperties = new Properties();//        jpaProperties.setProperty(&quot;hibernate.ejb.naming_strategy&quot;,&quot;org.hibernate.cfg.ImprovedNamingStrategy&quot;);        jpaProperties.setProperty(&quot;hibernate.dialect&quot;,&quot;org.hibernate.dialect.MySQL5InnoDBDialect&quot;);        jpaProperties.setProperty(&quot;hibernate.show_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.format_sql&quot;,&quot;true&quot;);        jpaProperties.setProperty(&quot;hibernate.hbm2ddl.auto&quot;,&quot;update&quot;);        entityManagerFactory.setJpaProperties(jpaProperties);        return entityManagerFactory;    }}</code></pre></li><li><p>在EmployeeRepository接口编写以下代码</p><pre><code class="java">// 更新数据，需添加@Modifying、@Transactional@Modifying@Query(&quot;update Employee o set o.age = :age where o.id = :id&quot;)void updateAgeById(@Param(&quot;id&quot;)Integer id,@Param(&quot;age&quot;)Integer age);</code></pre></li><li><p>定义Service层，实际开发中，需要定义接口，这里为了演示方便，直接使用类。</p><pre><code class="java">package com.myimooc.springdata.jpa.service;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeeCrudRepository;import com.myimooc.springdata.jpa.repository.EmployeeRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Servicepublic class EmployeeService {    @Autowired    private EmployeeRepository employeeRepository;    @Autowired    private EmployeeCrudRepository employeeCrudRepository;    @Transactional    public void updateAgeById(Integer id, Integer age){        this.employeeRepository.updateAgeById(id,age);    };    @Transactional    public void save(List&lt;Employee&gt; employees){        this.employeeCrudRepository.save(employees);    }}</code></pre></li><li><p>编写EmployeeService单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.service;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.repository.EmployeeRepository;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.transaction.PlatformTransactionManager;/** * EmployeeService单元测试类 */public class EmployeeServiceTest {    private ApplicationContext ctx = null;    private EmployeeService employeeService = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeService = ctx.getBean(EmployeeService.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void transactionManagerTest(){        PlatformTransactionManager transactionManager = (PlatformTransactionManager)ctx.getBean(PlatformTransactionManager.class);        Assert.assertNotNull(transactionManager);    }    // 更新操作    @Test    public void updateAgeByIdTest(){        employeeService.updateAgeById(1,55);    }}</code></pre></li></ol><p>事务在Spring data中的使用：</p><blockquote><ol><li>事务一般是在Service层</li><li>@Query、@Modifying、@Transaction的综合使用</li></ol></blockquote><h2 id="第5章-Spring-Data-JPA高级"><a href="#第5章-Spring-Data-JPA高级" class="headerlink" title="第5章 Spring Data JPA高级"></a>第5章 Spring Data JPA高级</h2><blockquote><p>详解Spring Data JPA的Repository核心接口的各种子类的使用</p></blockquote><h3 id="5-1-CrudRepository接口使用详解"><a href="#5-1-CrudRepository接口使用详解" class="headerlink" title="5-1 CrudRepository接口使用详解"></a>5-1 CrudRepository接口使用详解</h3><p>CrudRepository接口使用详解</p><blockquote><p>save(entity)：保存一个实体<br>save(entities)：保存多个实体<br>findOne(id)：找到一个对象<br>exists(id)：根据ID判断对象是否存在<br>findAll()：找到所有实体对象<br>delete(id)：根据ID删除实体对象<br>delete(entity)：根据实体对象删除实体对象<br>delete(entities)：删除多个实体对象<br>deleteAll()：删除所有实体对象</p></blockquote><ol><li><p>编写EmployeeCrudRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.repository.CrudRepository;/** * 使用 CrudRepository 接口 */public interface EmployeeCrudRepository extends CrudRepository&lt;Employee,Integer&gt;{}</code></pre></li><li><p>编写EmployeeCrudRepositoryTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import java.util.ArrayList;import java.util.List;/** * EmployeeRepository单元测试类 */public class EmployeeCrudRepositoryTest {    private ApplicationContext ctx = null;    private EmployeeService employeeService = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeCrudRepository = ctx.getBean(EmployeeService.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void saveTest(){        List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();        Employee employee = null;        for(int i=0;i&lt;100;i++){            employee = new Employee();            employee.setName(&quot;test&quot;+i);            employee.setAge(100 - i);            employees.add(employee);        }        employeeService.save(employees);    }}</code></pre></li></ol><h3 id="5-2-PagingAndSortingRespsitory接口使用详解-14-48"><a href="#5-2-PagingAndSortingRespsitory接口使用详解-14-48" class="headerlink" title="5-2 PagingAndSortingRespsitory接口使用详解 (14:48)"></a>5-2 PagingAndSortingRespsitory接口使用详解 (14:48)</h3><p>PagingAndSortingRespository接口使用详解</p><blockquote><ul><li>该接口包含分页和排序的功能</li><li>带排序的查询：findAll(Sort sort)</li><li>带排序的分页查询：findAll(Pageable pageable)</li></ul></blockquote><ol><li><p>编写EmployeePagingAndSortingRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.repository.PagingAndSortingRepository;/** * 使用 PagingAndSortingRepository 实现分页和排序功能 */public interface EmployeePagingAndSortingRepository extends PagingAndSortingRepository&lt;Employee,Integer&gt; {}</code></pre></li><li><p>编写EmployeePagingAndSortingRepositoryTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeePagingAndSortingRepository;import com.myimooc.springdata.jpa.service.EmployeeService;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.repository.PagingAndSortingRepository;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import java.util.ArrayList;import java.util.List;/** * PagingAndSortingRepository 单元测试类 */public class EmployeePagingAndSortingRepositoryTest {    private ApplicationContext ctx = null;    private EmployeePagingAndSortingRepository employeePagingAndSortingRepository = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeePagingAndSortingRepository = ctx.getBean(EmployeePagingAndSortingRepository.class);    }    @After    public void destroy(){        ctx = null;    }    /**     * 分页功能测试     */    @Test    public void pageTest(){        // page: index是从0开始的，不是从1开始的        Pageable pageable = new PageRequest(0,9);// page,size        Page&lt;Employee&gt; employeePage = employeePagingAndSortingRepository.findAll(pageable);        System.out.println(&quot;查询的总页数：&quot;+employeePage.getTotalPages());        System.out.println(&quot;查询的总记录数：&quot;+employeePage.getTotalElements());        System.out.println(&quot;查询的当前第几页：&quot;+(employeePage.getNumber() + 1));        System.out.println(&quot;查询的当前页面的集合：&quot;+employeePage.getContent());        System.out.println(&quot;查询的当前页面的记录数：&quot;+employeePage.getNumberOfElements());    }    /**     * 分页和排序功能测试     */    @Test    public void pageAndSort(){        Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;);// 升/降序,规则字段        Sort sort = new Sort(order);        // page: index是从0开始的，不是从1开始的        Pageable pageable = new PageRequest(0,5,sort);// 先排序，再分页        Page&lt;Employee&gt; employeePage = employeePagingAndSortingRepository.findAll(pageable);        System.out.println(&quot;查询的总页数：&quot;+employeePage.getTotalPages());        System.out.println(&quot;查询的总记录数：&quot;+employeePage.getTotalElements());        System.out.println(&quot;查询的当前第几页：&quot;+(employeePage.getNumber() + 1));        System.out.println(&quot;查询的当前页面的集合：&quot;+employeePage.getContent());        System.out.println(&quot;查询的当前页面的记录数：&quot;+employeePage.getNumberOfElements());    }}</code></pre></li></ol><h3 id="5-3-JpaRepository接口使用详解"><a href="#5-3-JpaRepository接口使用详解" class="headerlink" title="5-3 JpaRepository接口使用详解"></a>5-3 JpaRepository接口使用详解</h3><p>JpaRepository接口使用详解</p><blockquote><p>finaAll：查询所有记录<br>findAll(Sort sort)：查询所有记录并排序<br>save(entities)：保存多个实体对象<br>fiush：<br>deleteInBatch(entities)：一个批次里面删除那些实体</p></blockquote><ol><li><p>编写EmployeeJpaRepository接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.PagingAndSortingRepository;/** * 使用 JpaRepository 接口 */public interface EmployeeJpaRepository extends JpaRepository&lt;Employee,Integer&gt; {}</code></pre></li><li><p>编写EmployeeJpaRepositoryTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import com.myimooc.springdata.jpa.repository.EmployeeJpaRepository;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.PagingAndSortingRepository;/** * EmployeeJpaRepository 单元测试类 */public class EmployeeJpaRepositoryTest {    private ApplicationContext ctx = null;    private EmployeeJpaRepository employeeJpaRepository = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeJpaRepository = ctx.getBean(EmployeeJpaRepository.class);    }    @After    public void destroy(){        ctx = null;    }    @Test    public void findTest(){        Employee employee = employeeJpaRepository.findOne(99);        System.out.println(&quot;employee&quot; + employee);        System.out.println(&quot;employee(10)&quot; + employeeJpaRepository.exists(10));// true        System.out.println(&quot;employee(102)&quot; + employeeJpaRepository.exists(102));// false    }}</code></pre></li></ol><h3 id="5-4-JpaSpecificationExecutor接口使用详解"><a href="#5-4-JpaSpecificationExecutor接口使用详解" class="headerlink" title="5-4 JpaSpecificationExecutor接口使用详解"></a>5-4 JpaSpecificationExecutor接口使用详解</h3><p>JpaSpecificationExecutor接口使用详解（JPA规范执行者）</p><blockquote><p>Specification封装了JPA Criteria(JAP标准)查询条件</p><p>Repository接口体系无法携带一些查询条件</p></blockquote><p>代码演示：</p><ol><li><p>编写EmployeeJpaSpecificationExecutor接口</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.domain.Employee;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;/** * 使用 JpaSpecificationExecutor 接口 */public interface EmployeeJpaSpecificationExecutor extends JpaRepository&lt;Employee,Integer&gt; , JpaSpecificationExecutor&lt;Employee&gt;{}</code></pre></li><li><p>编写EmployeeJpaSpecificationExecutorTest单元测试类</p><pre><code class="java">package com.myimooc.springdata.jpa.repository;import com.myimooc.springdata.jpa.config.SpringConfig;import com.myimooc.springdata.jpa.domain.Employee;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.data.jpa.domain.Specification;import javax.persistence.criteria.*;/** * EmployeeJpaSpecificationExecutor 单元测试类 */public class EmployeeJpaSpecificationExecutorTest {    private ApplicationContext ctx = null;    private EmployeeJpaSpecificationExecutor employeeJpaSpecificationExecutor = null;    @Before    public void init(){        ctx = new AnnotationConfigApplicationContext(SpringConfig.class);        employeeJpaSpecificationExecutor = ctx.getBean(EmployeeJpaSpecificationExecutor.class);    }    @After    public void destroy(){        ctx = null;    }    /**     * 1、分页     * 2、排序     * 3、查询条件:age &gt; 50     */    @Test    public void queryTest(){        Sort.Order order = new Sort.Order(Sort.Direction.DESC,&quot;id&quot;);        Sort sort = new Sort(order);        // page: index是从0开始的，不是从1开始的        Pageable pageable = new PageRequest(0,5,sort);        /**         * root : 就是我们要查询的类型 (Employee)         * query : 添加查询条件         * cb : 构建 Predicate         */        Specification&lt;Employee&gt; specification = new Specification&lt;Employee&gt;() {            // 查询条件            public Predicate toPredicate(Root&lt;Employee&gt; root,                                         CriteriaQuery&lt;?&gt; query,                                         CriteriaBuilder cb)             {                // root (employee (age))                Path path = root.get(&quot;age&quot;);                return cb.gt(path,50);            }        };        Page&lt;Employee&gt; employeePage = employeeJpaSpecificationExecutor.findAll(specification,pageable);        System.out.println(&quot;查询的总页数：&quot; + employeePage.getTotalPages());        System.out.println(&quot;查询的总记录数：&quot; + employeePage.getTotalElements());        System.out.println(&quot;查询的当前第几页：&quot; + (employeePage.getNumber() + 1));        System.out.println(&quot;查询的当前页面的集合：&quot; + employeePage.getContent());        System.out.println(&quot;查询的当前页面的记录数：&quot; + employeePage.getNumberOfElements());    }}</code></pre></li></ol><h2 id="第6章-课程总结"><a href="#第6章-课程总结" class="headerlink" title="第6章 课程总结"></a>第6章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="6-1-课程总结"><a href="#6-1-课程总结" class="headerlink" title="6-1 课程总结"></a>6-1 课程总结</h3><blockquote><p>Spring Data概览<br>传统方式访问数据库<br>Spring Data快速起步<br>Spring Data JPA进阶<br>Spring Data JAP高级</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>810-Spring Boot进阶之Web进阶</title>
      <link href="/imooc/810-SpringBoot-Web/"/>
      <url>/imooc/810-SpringBoot-Web/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/810" target="_blank" rel="noopener">https://www.imooc.com/learn/810</a></p><p>简介：《2小时学习Spring Boot》后续进阶课程，主要讲述了Spring Boot针对Web方面的相关技巧 讲师实战课程《Spring Boot微信点餐系统》 <a href="http://coding.imooc.com/class/117.html" target="_blank" rel="noopener">http://coding.imooc.com/class/117.html</a> 《Spring Cloud微服务实战》 <a href="http://coding.imooc.com/class/187.html" target="_blank" rel="noopener">http://coding.imooc.com/class/187.html</a> 均已上线</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>课程介绍</p></blockquote><h3 id="1-1-课程介绍"><a href="#1-1-课程介绍" class="headerlink" title="1-1 课程介绍"></a>1-1 课程介绍</h3><blockquote><p>本课程紧接着《<a href="https://www.imooc.com/learn/767" target="_blank" rel="noopener">2小时学会SpringBoot</a>》课程，请先看入门课。</p></blockquote><ol><li>使用@Valid表单验证</li><li>使用AOP处理请求</li><li>统一异常处理</li><li>单元测试</li></ol><h2 id="第2章-Web进阶"><a href="#第2章-Web进阶" class="headerlink" title="第2章 Web进阶"></a>第2章 Web进阶</h2><blockquote><p>SpringBoot进阶中web方面的内容</p></blockquote><h3 id="2-0-表单验证"><a href="#2-0-表单验证" class="headerlink" title="2-0 表单验证"></a>2-0 表单验证</h3><blockquote><p>项目源码：<a href="https://gitee.com/liaoshixiong/girl" target="_blank" rel="noopener">https://gitee.com/liaoshixiong/girl</a></p></blockquote><pre><code class="shell"># 克隆项目代码git clone git@gitee.com:liaoshixiong/girl.git# 切换分支git checkout -b web-2 web-2</code></pre><p>当Girl的参数特别多的时候，可以使用Java实体类接收参数。</p><pre><code class="java">/** * 添加一个女生 */@PostMapping(value = &quot;/girls&quot;)public Girl girlAdd(Girl girl) {    return girlRepository.save(girl);}</code></pre><p>表单验证：</p><ol><li><p>在实体Bean里需要校验的字段上面添加注解</p><pre><code class="java">@Min(value = 18, message = &quot;未成年少女禁止入内&quot;)private Integer age;@NotNull(message = &quot;金额必传&quot;)private Integer money;</code></pre></li><li><p>在接收参数时，使用@Valid注解进行校验</p><pre><code class="java">@PostMapping(value = &quot;/girls&quot;)public Result&lt;Girl&gt; girlAdd(@Valid Girl girl, BindingResult bindingResult){    if(bindingResult.hasErrors()){        return ResultUtil.error(ResultUtil.RESPCODE_ERROR_PARAM,bindingResult.getFieldError().getDefaultMessage());    }    // ...}</code></pre></li></ol><h3 id="2-1-使用AOP处理请求-上）"><a href="#2-1-使用AOP处理请求-上）" class="headerlink" title="2-1 使用AOP处理请求(上）"></a>2-1 使用AOP处理请求(上）</h3><p>AOP统一处理请求日志</p><ol><li><p>AOP是一种编程方式</p><ul><li>与语言无关，是一种程序设计思想</li><li>面向切面（AOP）Aspect Oriented Programming</li><li>面向对象（OOP）Object Oriented Programming</li><li>面向过程（POP）Procedure Oriented Programming</li></ul></li><li><p>面向过程到面向对象</p><ul><li>面向过程：假如下雨了，我打开了雨伞</li><li>面向对象：天气-&gt;下雨，我-&gt;打伞</li></ul></li><li><p>换个角度看世界，换个姿势处理问题</p><ul><li><p>面向对象：将需求功能垂直划分为不同的并且相对独立的，封装为良好的类并且让其有自己的行为</p></li><li><p>面向切面：利用横切技术将面向对象的庞大体系进行水平切割，并且将影响到多个类的公共行为进行封装成一个可重用的模块（切面）</p></li></ul></li><li><p>将通用逻辑从业务逻辑中分离出来</p></li></ol><p>AOP示例：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigqdsvwj30nc0fwwg3.jpg" width="350" alt="面向对象处理流程"/><p>提取执行相同的代码为一个切面</p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gigpelibj30sn0gjjty.jpg" width="350" alt="面向切面处理流程"/><p>登录授权访问</p><p>使用AOP流程：</p><ol><li><p>添加POM文件</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>建立处理文件</p><pre><code class="java">@Aspect@Componentpublic class HttpAspect {    @Before(&quot;execution(public * com.imooc.controller.GirlController.girlList(...))&quot;)    public void log() {        System.out.println(11111);    }}</code></pre></li></ol><h3 id="2-2-使用AOP处理请求-中）"><a href="#2-2-使用AOP处理请求-中）" class="headerlink" title="2-2 使用AOP处理请求(中）"></a>2-2 使用AOP处理请求(中）</h3><p>编写切面通知执行方法</p><pre><code class="java">@Aspect@Componentpublic class HttpAspect {    /** 日志 */    private final static Logger LOGGER = LoggerFactory.getLogger(HttpAspect.class);    /** 定义切点 */    @Pointcut(&quot;execution(public * com.myimooc.boot.web.controller.GirlController.*(..))&quot;)    public void log(){}    /** 前置通知 */    @Before(&quot;log()&quot;)    public void doBefore(JoinPoint joinPoint){        ServletRequestAttributes attributes =  (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // url        LOGGER.info(&quot;url={}&quot;, request.getRequestURI());        // method        LOGGER.info(&quot;method={}&quot;, request.getMethod());        // ip        LOGGER.info(&quot;ip={}&quot;, request.getRemoteAddr());        // 类方法        LOGGER.info(&quot;class_method={}&quot;, joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());        // 参数        LOGGER.info(&quot;args={}&quot;, joinPoint.getArgs());    }}</code></pre><blockquote><p>@Aspect：声明当前类是一个切面处理类<br>@Component：声明当前类是一个Bean，由Spring的IOC容器进行管理<br>@Pointcut：声明需要处理的切点</p></blockquote><p>Spring AOP通知(advice)分成五类：</p><blockquote><ul><li>@Before：前置通知[Before advice]：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 </li><li>@AfterReturning：正常返回通知[After returning advice]：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 </li><li>@AfterThrowing：异常返回通知[After throwing advice]：在连接点抛出异常后执行。 </li><li>@After：返回通知[After (finally) advice]：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 </li><li>@Around：环绕通知[Around advice]：环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。</li></ul></blockquote><h3 id="2-3-使用AOP处理请求-下）"><a href="#2-3-使用AOP处理请求-下）" class="headerlink" title="2-3 使用AOP处理请求(下）"></a>2-3 使用AOP处理请求(下）</h3><pre><code class="java">/** 后置通知 */@After(&quot;log()&quot;)public void doAfter(){    LOGGER.info(&quot;方法执行之后执行&quot;);}/** 正常返回通知 */@AfterReturning(returning = &quot;object&quot;, pointcut = &quot;log()&quot;)public void doAfterReturning(Object object){    // LOGGER.info(&quot;response={}&quot;, object.toString());}</code></pre><h3 id="2-4-统一异常处理（上）"><a href="#2-4-统一异常处理（上）" class="headerlink" title="2-4 统一异常处理（上）"></a>2-4 统一异常处理（上）</h3><p>什么是异常处理？</p><blockquote><p>如果不加异常处理的话，程序出错了，用户可能不知道是啥原因。<br>加上处理后，比如加上友好信息等用户能知道错在哪。</p></blockquote><p>为什么要统一异常处理？</p><blockquote><ol><li>在框架层面封装checked exception，将其转化为unchecked exception，避免开发过程中编写繁冗的try…catch代码。 </li><li>业务层面的开发，根据程序代码职责定义不同的RuntimeException(它就是unchecked exception，一般定义为RuntimeException的子类) </li><li>通过前两个观点，系统中自定义的异常将只存在unchecked exception，系统只在于客户端交换数据的上层，设置统一异常处理机制，并将一些异常转化为用户所能理解的信息传达给用户。 </li><li>其他如业务层，数据持久层，等底层只负责将异常抛出即可，但要注意不要丢失掉异常堆栈（这一点是初学者容易犯的一个错误）。 </li></ol></blockquote><p>统一异常处理返回格式：</p><pre><code class="json">{    &quot;code&quot;: 1,    &quot;msg&quot;: &quot;金额必传&quot;,    &quot;data&quot;: null}{    &quot;code&quot;: 1,    &quot;msg&quot;: &quot;成功&quot;,    &quot;data&quot;: {        &quot;id&quot;: 20,        &quot;cupSize&quot;: &quot;B&quot;,        &quot;age&quot;: 25,        &quot;money&quot;: 1.2    }}</code></pre><p>:arrow_up_small:</p><pre><code class="java">public class Result&lt;T&gt; {    /** 响应编号 */    private Integer respCode;    /** 响应消息 */    private String respMsg;    /** 具体的内容 */    private T data;    // ...getter and setter...}</code></pre><pre><code class="java">/** * 添加一个女生 * @return */@PostMapping(value=&quot;/girls&quot;)public Result&lt;Girl&gt; girlAdd(@Valid Girl girl, BindingResult bindingResult) {    Result result = new Result();    if(bindingResult.hasErrors()) {        result.setCode(1);        result.setMsg(bindingResult.getFieldError().getDefaultMessage());        return result;    }    girl.setCupSize(girl.getCupSize());    girl.setAge(girl.getAge());    result.setCode(0);    result.setMsg(&quot;成功&quot;);    result.setData(girlRepository.save(girl));    return result;}</code></pre><p>优化：</p><pre><code class="java">/** * http请求返回的实体Bean工具类 */public class ResultUtil {    /** 成功 */    public final static Integer RESPCODE_SUCCESS = 200;    /** 请求参数错误 */    public final static Integer RESPCODE_ERROR_PARAM = 300;    /** 系统内部业务错误 */    public final static Integer RESPCODE_ERROR_SERVICE = 400;    /** 系统内部异常 */    public final static Integer RESPCODE_ERROR_EXECEPTION = 500;    /** 执行成功，返回参数 */    public  static Result success(Object object){        Result result = new Result();        result.setRespCode(ResultUtil.RESPCODE_SUCCESS);        result.setRespMsg(&quot;成功&quot;);        result.setData(object);        return result;    }    /** 执行成功，无返回参数 */    public static Result success(){        return success(null);    }    /** 执行错误 */    public static Result error(Integer code,String msg){        Result result = new Result();        result.setRespCode(code);        result.setRespMsg(msg);        return result;    }}</code></pre><pre><code class="java">// 成功返回return ResultUtil.success(girlRepository.save(girl));// 失败返回return ResultUtil.error(bindingResult.getFieldError().getDefaultMessage());</code></pre><p>例Ⅰ：</p><blockquote><p>获取某女生的年龄并判断</p><p>小于10，返回“应该在上小学”</p><p>大于10且小于16，返回“可能在上初中”</p></blockquote><p>可能比较容易想到的解决方案是：通过标识来传递信息，比如：</p><pre><code class="java">public Integer getAge1(Integer id) {    Girl girl = girlRepository.findOne(id);    Integer age = girl.getAge();    if (age &lt; 10) {        // 返回“你还在上小学吧”        return 1;    } else if (10 &lt; age &amp;&amp; age &lt; 16) {        // 返回“你可能在上初中”        return 2;    }    // 如果 &gt; 16岁，加钱    // ...    return 0;}</code></pre><h3 id="2-5-统一异常处理（中）"><a href="#2-5-统一异常处理（中）" class="headerlink" title="2-5 统一异常处理（中）"></a>2-5 统一异常处理（中）</h3><p>使用统一异常处理后，则为另一种解决方式</p><p>步骤一：自定义异常</p><pre><code class="java">public class RespException extends RuntimeException {    /** 响应编号 */    private Integer respCode;    public RespException(Integer respCode, String message) {        super(message);        this.respCode = respCode;    }    // ...getter and setter...}</code></pre><p>步骤二：全局异常统一处理类</p><pre><code class="java">@ControllerAdvicepublic class ExceptionHandle {    private final static Logger LOGGER = LoggerFactory.getLogger(ExceptionHandle.class);    /**     * 全局异常返回处理     * @param e 异常     * @return 处理后的返回结果     */    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Result handle(Exception e) {        if (e instanceof RespException) {            RespException respException = (RespException) e;            return ResultUtil.error(respException.getRespCode(), respException.getMessage());        }        LOGGER.error(&quot;【系统异常】{}&quot;, e);        return ResultUtil.error(ResultUtil.RESPCODE_ERROR_SERVICE, &quot;未知错误&quot;);    }}</code></pre><p>步骤三：使用自定义异常</p><pre><code class="java">public void getAge(Integer id) throws Exception {    Girl girl = girlRepository.findOne(id);    Integer age = girl.getAge();    if (age &lt; 10) {        // 返回“你还在上小学吧”        throw new RespException(100, &quot;你还在上小学吧&quot;);    } else if (age &gt; 10 &amp;&amp; age &lt; 16) {        // 返回“你可能在上初中”        throw new RespException(101, &quot;你可能在上初中&quot;);    }    // 如果 &gt; 16岁，价钱    // ...}</code></pre><h3 id="2-6-统一异常处理（下）"><a href="#2-6-统一异常处理（下）" class="headerlink" title="2-6 统一异常处理（下）"></a>2-6 统一异常处理（下）</h3><p>使用枚举进行优化响应编码及响应消息，便于统一维护</p><p>步骤一：定义枚举类</p><pre><code class="java">/** * http请求返回的消息响应编号 */public enum ResultResp {    SUCCESS(0, &quot;成功&quot;),    UNKONW_ERROR(-1, &quot;未知错误&quot;),    PARAM_ERROR(1, &quot;参数错误&quot;),    PRIMARY_SCHOOL(100, &quot;你可能还在上小学&quot;),    MIDDLE_SCHOOL(101, &quot;你可能在上初中&quot;);    private Integer respCode;    private String respMsg;    // ...constructor and getter and setter...}</code></pre><p>步骤二：优化自定义异常</p><pre><code class="java">public class RespException extends RuntimeException {    /** 响应编号 */    private Integer respCode;    public RespException(ResultResp resultResp) {        super(resultResp.getRespMsg());        this.respCode = resultResp.getRespCode();    }    // ...getter and setter...}</code></pre><p>步骤三：全局异常统一处理类</p><pre><code class="java">@ControllerAdvicepublic class ExceptionHandle {    private final static Logger LOGGER = LoggerFactory.getLogger(ExceptionHandle.class);    /**     * 全局异常返回处理     * @param e 异常     * @return 处理后的返回结果     */    @ExceptionHandler(value = Exception.class)    @ResponseBody    public Result handle(Exception e) {        if (e instanceof RespException) {            RespException respException = (RespException) e;            return ResultUtil.error(respException.getRespCode(), respException.getMessage());        }        LOGGER.error(&quot;【系统异常】{}&quot;, e);        return ResultUtil.error(ResultUtil.RESPCODE_ERROR_SERVICE, &quot;未知错误&quot;);    }}</code></pre><p>步骤四：使用自定义异常</p><pre><code class="java">public void getAge(Integer id) throws Exception {    Girl girl = girlRepository.findOne(id);    Integer age = girl.getAge();    int primarySchool = 10;    int middleSchool = 16;    if (age &lt; primarySchool) {        // 返回“你还在上小学吧”        throw new RespException(ResultResp.PRIMARY_SCHOOL);    } else if (age &gt; primarySchool &amp;&amp; age &lt; middleSchool) {        // 返回“你可能在上初中”        throw new RespException(ResultResp.MIDDLE_SCHOOL);    }    // 如果 &gt; 16岁，价钱    // ...}</code></pre><h3 id="2-7-单元测试"><a href="#2-7-单元测试" class="headerlink" title="2-7 单元测试"></a>2-7 单元测试</h3><blockquote><p>测试Service<br>测试API</p></blockquote><p>测试Service</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class GirlServiceImplTest {    @Autowired    private GirlService girlService;    @Test    public void findOne() throws Exception {        Girl girl = girlService.findOne(7);        Assert.assertEquals(new Integer(22), girl.getAge());    }}</code></pre><p>测试Controller</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcpublic class GirlControllerTest {    @Autowired    private MockMvc mockMvc;    @Test    public void listGirl() throws Exception {        mockMvc.perform(MockMvcRequestBuilders.get(&quot;/girls&quot;))                .andExpect(MockMvcResultMatchers.status().isOk());    }}</code></pre><pre><code class="shell"># 项目打包时自动进行单元测试mvn clean package# 项目打包时跳过单元测试mvn clean package -Dmaven.test.skip=true</code></pre><h2 id="第3章-课程总结"><a href="#第3章-课程总结" class="headerlink" title="第3章 课程总结"></a>第3章 课程总结</h2><blockquote><p>课程总结</p></blockquote><h3 id="3-1-课程总结"><a href="#3-1-课程总结" class="headerlink" title="3-1 课程总结"></a>3-1 课程总结</h3><ol><li>使用@Valid表单验证</li><li>使用AOP处理请求</li><li>统一异常处理</li><li>单元测试</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>767-2小时学会Spring Boot</title>
      <link href="/imooc/767-2Hours-SringBoot/"/>
      <url>/imooc/767-2Hours-SringBoot/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.imooc.com/learn/767" target="_blank" rel="noopener">http://www.imooc.com/learn/767</a></p><p>简介：Spring Boot是用来简化Spring应用初始搭建以及开发过程的全新框架，被认为是Spring MVC的“接班人”，和微服务紧密联系在一起。通过本门课程的学习，你将学会如何使用Spring Boot快速构建应用程序，初步领略Spring Boot的魅力！其后续课程《Spring Boot进阶之Web进阶》.此课专为IT屌丝男程序员打造，女生请慎入！ 讲师实战课程《Spring Boot微信点餐系统》 <a href="http://coding.imooc.com/class/117.html" target="_blank" rel="noopener">http://coding.imooc.com/class/117.html</a> 《Spring Cloud微服务实战》 <a href="http://coding.imooc.com/class/187.html" target="_blank" rel="noopener">http://coding.imooc.com/class/187.html</a> 均已上线</p></blockquote><blockquote><p>项目源码：<a href="https://gitee.com/liaoshixiong/girl" target="_blank" rel="noopener">https://gitee.com/liaoshixiong/girl</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-SpringBoot介绍"><a href="#第1章-SpringBoot介绍" class="headerlink" title="第1章 SpringBoot介绍"></a>第1章 SpringBoot介绍</h2><blockquote><p>1-1 SpringBoot介绍和课程安排</p></blockquote><h3 id="1-1-SpringBoot介绍"><a href="#1-1-SpringBoot介绍" class="headerlink" title="1-1 SpringBoot介绍"></a>1-1 SpringBoot介绍</h3><p>SpringBoot优点</p><blockquote><p> 编码，部署，配置，监控变得更加简单</p></blockquote><p>SpringBoot和SpringMVC的关系</p><blockquote><p>SpringBoot是SpringMVC的升级版，两者没有必然的联系</p></blockquote><p>SpringBoot的特点</p><pre><code>1. 化繁为简，简化配置2. 备受关注，是下一代框架3. 微服务的入门级微框架</code></pre><p>微服务</p><blockquote><p>SpringBoot =&gt; SpringCloud =&gt; 微服务</p></blockquote><p>课程目录</p><pre><code>1. 第一个SpringBoot程序2. 自定义属性配置3. Controller的使用4. spring-data-jpa5. 事务管理</code></pre><p><a href="http://www.imooc.com/learn/443" target="_blank" rel="noopener">《项目管理利器maven》</a><br><a href="http://www.imooc.com/learn/196" target="_blank" rel="noopener">《Spring入门篇》</a></p><p>注意</p><pre><code>1. 具备必要的前置知识    --利用maven构建项目    --Spring注解    --RESTful API2. 可以不需要先去学SpringMVC3. Java、Maven等版本保持一致</code></pre><h2 id="第2章-第一个SpringBoot应用"><a href="#第2章-第一个SpringBoot应用" class="headerlink" title="第2章 第一个SpringBoot应用"></a>第2章 第一个SpringBoot应用</h2><blockquote><p>快速构建第一个SpringBoot应用</p></blockquote><h3 id="2-1-第一个SpringBoot应用"><a href="#2-1-第一个SpringBoot应用" class="headerlink" title="2-1 第一个SpringBoot应用"></a>2-1 第一个SpringBoot应用</h3><pre><code class="shell"># 查看Java版本java -version# 查看Maven版本mvn -version</code></pre><p>下载<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IDEA Ultimate</a></p><p>阿里云Maven镜像配置：</p><pre><code class="xml">&lt;!-- settings.xml --&gt;&lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;ur1&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;</code></pre><p>启动SpringBoot项目：</p><pre><code class="shell"># /girlmvn spring-boot:run</code></pre><pre><code class="shell"># /girlmvn installjava -jar target/girl.jar</code></pre><h2 id="第3章-项目属性配置"><a href="#第3章-项目属性配置" class="headerlink" title="第3章 项目属性配置"></a>第3章 项目属性配置</h2><blockquote><p>项目属性配置的各种方法</p></blockquote><h3 id="3-1-项目属性配置"><a href="#3-1-项目属性配置" class="headerlink" title="3-1 项目属性配置"></a>3-1 项目属性配置</h3><p>属性配置</p><pre><code class="properties"># application.propertiesserver.port=8888server.context-path=/girlspring.datasource.url=jdbc:mysql://127.0.0.1:3306/spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc</code></pre><p>加载配置属性注解</p><ul><li><p>单属性</p><pre><code class="yaml">cupSize: Bage: 18content: &quot;cupSize: ${cupSize}, age: ${age}&quot;</code></pre><pre><code class="java">@Value(&quot;${cupSize}&quot;)private String cupSize;@Value(&quot;${age}&quot;)private Integer age;@Value(&quot;${content}&quot;)private String content;</code></pre></li><li><p>组属性</p><pre><code class="yaml">girl:     cupSize: B    age: 18</code></pre><pre><code class="java">@Component@ConfigurationProperties(prefix = &quot;girl&quot;)public class GirlProperties {    private String cupSize;    private Integer age;    // ...getter and setter...}</code></pre><pre><code class="java">@Autowiredprivate GrilProperties girlProperties;</code></pre></li></ul><p>多环境配置：</p><pre><code class="yaml"># application.ymlspring:    profiles:         active: dev</code></pre><pre><code class="yaml"># application-dev.yml 开发环境cupSize: B</code></pre><pre><code class="yaml"># application-prod.yml 生产环境cupSize: F</code></pre><pre><code class="shell"># 编译mvn install# 启动java -jar target/girl.jar --spring.profiles.active=prod</code></pre><h2 id="第4章-Controller的使用"><a href="#第4章-Controller的使用" class="headerlink" title="第4章 Controller的使用"></a>第4章 Controller的使用</h2><blockquote><p>介绍SpringBoot项目中Controller的使用</p></blockquote><h3 id="4-1-Controller的使用"><a href="#4-1-Controller的使用" class="headerlink" title="4-1 Controller的使用"></a>4-1 Controller的使用</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Controller</td><td>处理http请求</td></tr><tr><td>@RestController</td><td>Spring4之后新的注解，原来返回JSON需要@ResponseBody配合@Controller</td></tr><tr><td>@RequestMapping</td><td>配置url映射</td></tr></tbody></table><p>模板使用</p><pre><code class="xml">&lt;!-- pom.xml --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springf ramework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><pre><code class="html">&lt;!-- /resources/templates/index.html --&gt;&lt;hi&gt;hello Spring Boot&lt;/h1&gt;</code></pre><pre><code class="java">@RequestMapping(value=&quot;/helLo&quot;, method = RequestMethod.GET)public String say() {    return &quot;index&quot;;}</code></pre><p>处理请求中的参数</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@PathVariable</td><td>获取url中的数据</td></tr><tr><td>@RequestParam</td><td>获取请求参数的值</td></tr><tr><td>@GetMapping</td><td>组合注解</td></tr></tbody></table><ol><li><p>@RestController相当于@ResponseBody与@Controller</p></li><li><p>@RequestMapping(value={“/hi”, “/say”}, method=RequestMethod.GET)。value可以是个集合</p></li><li><p>@RequestMapping可以用@GetMapping或@PostMapping代替，省去声明方法</p></li><li><p>/luckymoney/hello/say/100</p><p>@GetMapping(value=”/{id}/say”)</p><p>@PathVariable(“id”) Integer id</p></li><li><p>/luckymoney/hello/say?id=100</p><p>@RequestParam(value=”id”, required=false, defaultValue=”0”) Integer id</p></li></ol><h2 id="第5章-数据库操作"><a href="#第5章-数据库操作" class="headerlink" title="第5章 数据库操作"></a>第5章 数据库操作</h2><blockquote><p>SpringBoot中使用spring-data-jpa</p></blockquote><h3 id="5-1-数据库操作（上）"><a href="#5-1-数据库操作（上）" class="headerlink" title="5-1 数据库操作（上）"></a>5-1 数据库操作（上）</h3><p>数据库操作</p><blockquote><p>Spring-Data-Jpa -&gt; MySQL</p></blockquote><p>Spring-Data-JPA</p><blockquote><p>JPA(Java Persistence API)定义了一系列对象持久化的标准，目前实现这一规范的产品有Hibernate、TopLink等。</p><p>Spring-Data-JPA就是对Hibernate的整合</p></blockquote><p>RESTful API设计：</p><table><thead><tr><th>请求类型</th><th>请求路径</th><th>功能</th></tr></thead><tbody><tr><td>GET</td><td>/girls</td><td>获取女生列表</td></tr><tr><td>POST</td><td>/girls</td><td>创建一个女生</td></tr><tr><td>GET</td><td>/girls/id</td><td>通过id查询一个女生</td></tr><tr><td>PUT</td><td>/girls/id clipbogu</td><td>通过id更新一个女生</td></tr><tr><td>DELETE</td><td>/girls/id</td><td>通过id删除一个女生</td></tr></tbody></table><p>步骤：</p><ol><li><p>添加POM依赖</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springf ramework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置数据库信息和Spring-Data-JPA信息</p><pre><code class="yaml">spring:     datasource:         driver-class-name: com.mysql.jdbc.Driver        ur1: jdbc:mysql://127.0.0.1:3306/dbgirl        username: root        password: 123456    jpa:         hibernate:             ddl-auto: create        show-sql: true</code></pre><p>ddl-auto参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>create</td><td>运行时自动创建表。每次程序运行都会创建空表，如果已存在则会先删除表</td></tr><tr><td>create-drop</td><td>应用停下来的时候就会把表删除</td></tr><tr><td>none</td><td>不做任何操作。</td></tr><tr><td>update</td><td>运行时自动创建表。当已存在表则不会操作</td></tr><tr><td>validate</td><td>验证实体属性是否和表结构一致，不一致则会报错。</td></tr></tbody></table></li><li><p>创建实体类</p><pre><code class="java">@Entitypublic class Girl {    @Id    @GenerateValue    private Integer id;    private String cupSize;    private Integer age;    // 无参构造函数。必须要有，否则报错    // ...getter and setter...}</code></pre></li><li><p>运行程序</p></li></ol><h3 id="5-2-数据库操作（下）"><a href="#5-2-数据库操作（下）" class="headerlink" title="5-2 数据库操作（下）"></a>5-2 数据库操作（下）</h3><ol><li><p>Dao</p><pre><code class="java">public interface GirlRepository extends JpaRepository&lt;Girl, Integer&gt; {    /**     * 通过年龄查询     */    public List&lt;Girl&gt; findByAge(Integer age);}</code></pre></li><li><p>Controller</p><pre><code class="java">@RestControllerpublic class GirlController {    @Autowired    private GirlRepository girlRepository;    /**     * 查询所有女生列表     */     @GetMapping(value = &quot;/girls&quot;)    public List&lt;Girl&gt; girlList() {        return girlRepository.findALL();    }    /**     * 添加一个女生     */     @PostMapping(value = &quot;/girls&quot;)    public Girl girlAdd(@RequestParam(&quot;cupSize&quot;) String cupSize,                        @RequestParam(&quot;age&quot;) Integer age) {        Girl girl=new Girl();        girl.setCupSize(cupSize);        girl.setAge(age);        return girlRepository.save(girl);    }    /**     * 查询一个女生     */     @GetMapping(value = &quot;/girls/{id}&quot;)    public Girl girlFindOne(@PathVariable(&quot;id&quot;) Integer id) {        return girlRepository.findOne(id);    }    /**     * 更新一个女生     */     @PutMapping(value = &quot;/girls/{id}&quot;)    public Girl girlUpdate(@PathVariable(&quot;id&quot;) Integer id,                            @RequestParam(&quot;cupSize&quot;) String cupSize,                            @RequestParam(&quot;age&quot;) Integer age) {        Girl girl = new Girl();        girl.setId(id);        girl.setCupSize(cupSize);        girl.setAge(age);        return girlRepository.save(girl);    }    /**     * 删除一个女生     */     @DeleteMapping(value = &quot;/girls/{id}&quot;)    public void girlDelete(@PathVariable(&quot;id&quot;) Integer id) {        girlRepository.delete(id);    }    /**     * 通过年龄查询女生列表     */    @GetMapping(value = &quot;/girls/age/{age}&quot;)    public List&lt;Girl&gt; girlListByAge(@PathVariable(&quot;age&quot;) Integer age) {        return girlRepository.findByAge(age);    }}</code></pre></li></ol><p>注：</p><ul><li><p><strong>Post使用form-data</strong></p></li><li><p><strong>Put使用x-www-form-urlencoded</strong></p></li></ul><h2 id="第6章-事务管理"><a href="#第6章-事务管理" class="headerlink" title="第6章 事务管理"></a>第6章 事务管理</h2><blockquote><p>演示了SpringBoot中使用事务的简单例子</p></blockquote><h3 id="6-1-事务管理"><a href="#6-1-事务管理" class="headerlink" title="6-1 事务管理"></a>6-1 事务管理</h3><pre><code class="java">@Servicepublic class GirlService {    @Autowired    private GirlRepository girlRepository;    /**     * 保存两个女生信息     */    @Transactional(rollbackFor = Exception.class)    public void saveTwo() {        Girl girlA = new Girl();        girlA.setCupSize(&quot;A&quot;);        girlA.setAge(18);        girlRepository.save(girlA);        Girl girlB = new Girl();        girlB.setAge(19);        girlB.setCupSize(&quot;B&quot;);        girlRepository.save(girlB);    }}</code></pre><pre><code class="java">@Autowiredprivate GirlService girlService;@PostMapping(value=&quot;/girls/two&quot;)public void saveGirlTwo(){    girlService.saveTwo();}</code></pre><blockquote><p>只有查询的时候不加事务，其它任何操作都要加事务。</p><p>进行添加操作的时候，如果要求，要么全部添加成功，要么全部失败</p><p>@Transactional事务处理注解的使用方法，在serive进行事务处理</p></blockquote><p>事务失败原因：数据库默认为MyISAM不支持事物回滚，需要设置为InnoDB</p><p>解决方法： 改为INNODB</p><p>更改语句：</p><pre><code class="mysql">ALTER TABLE girl ENGINE=INNODB;</code></pre><p>事务失败原因：SpringBoot2.*实体的默认引擎为MyISAM不支持事务，需要配置引擎为为innoDB<br>解决方法：在application.yml添加配置</p><pre><code class="yaml">spring:     jpa:         database-platform: org.hibernate.dialect.MySQL5InnoDBDialect</code></pre><h2 id="第7章-课程回顾"><a href="#第7章-课程回顾" class="headerlink" title="第7章 课程回顾"></a>第7章 课程回顾</h2><blockquote><p>回顾课程内容</p></blockquote><h3 id="7-1-课程回顾"><a href="#7-1-课程回顾" class="headerlink" title="7-1 课程回顾"></a>7-1 课程回顾</h3><ol><li>SpringBoot介绍</li><li>安装IDEA、Maven并初始化SpringBoot工程</li><li>配置文件、注入属性</li><li>Controller的使用及注解</li><li>数据库增删改查</li></ol><p>下门课程介绍：</p><ol><li>@Valid表单验证</li><li>AOP统一异常处理</li><li>spring-data-jpa8.用缓存应对高并发</li><li>Jdbc Template</li><li>Mybatis</li><li>Redis</li><li>MongoDB</li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1086-Java高并发之魂：synchronized深度解析</title>
      <link href="/imooc/1086-synchronized/"/>
      <url>/imooc/1086-synchronized/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/1086" target="_blank" rel="noopener">https://www.imooc.com/learn/1086</a></p><p>简介：高并发问题向来是Java程序员进阶的重点，也是面试的难点。想要打通高并发的奇经八脉，synchronized是你不得不趟过的坑，本课程从synchronized，从使用方法到底层原理源码，娓娓道来。还对常见面试题和更深层扩展方面的思考，做出了讲解。本课程由浅入深，适合各阶段工程师观看。悟空老师的实战课【Java并发核心知识精讲+Java内存模型+死锁】已经上线啦，传送门如下 <a href="https://coding.imooc.com/class/362.html" target="_blank" rel="noopener">https://coding.imooc.com/class/362.html</a></p></blockquote><p>@[TOC]</p><h2 id="第1章-课程介绍"><a href="#第1章-课程介绍" class="headerlink" title="第1章 课程介绍"></a>第1章 课程介绍</h2><blockquote><p>介绍了课程结构、要点、前置知识和开发环境。</p></blockquote><h3 id="1-1-课程介绍-07-58"><a href="#1-1-课程介绍-07-58" class="headerlink" title="1-1 课程介绍 (07:58)"></a>1-1 课程介绍 (07:58)</h3><p>前置知识</p><ul><li>了解Java基本语法</li><li>了解多线程基本知识</li></ul><p>章节介绍</p><ol><li>Synchronized<strong>简介</strong>：作用、地位、不控制并发的后果</li><li>两种用法：<strong>对象锁</strong>和<strong>类锁</strong></li><li>多线程访问同步方法的<strong>7种</strong>情况：是否static、Synchronized方法等</li><li>Synchronized的<strong>性质</strong>：可重入、不可中断</li><li><strong>原理</strong>：加解锁原理、可重入原理、可见性原理</li><li>Synchronized的<strong>缺陷</strong>：效率低、不够灵活、无法预判是否成功获取到锁</li><li>常见<strong>面试</strong>问题：使用注意点、如何选择Lock或Synchronized等</li><li><strong>思考题</strong>：如何提高性能、JVM如何决定哪个线程获取锁等</li><li>总结</li></ol><p>开发环境</p><ul><li>JDK1.8</li><li>IDEA 2018.2</li></ul><p>学习路径：</p><ul><li><p>实战课：Java并发核心知识体系精讲</p><p><a href="https://coding.imooc.com/class/362.html" target="_blank" rel="noopener">https://coding.imooc.com/class/362.html</a></p></li></ul><h2 id="第2章-Synchronized简介"><a href="#第2章-Synchronized简介" class="headerlink" title="第2章 Synchronized简介"></a>第2章 Synchronized简介</h2><blockquote><p>让同学们对Synchronized关键字有整理概念，从官网解释引出通俗解释，便于理解。从Synchronized关键字的地位说明该关键字的重要性。代码演示不用并发手段会带来的问题，吸引同学们带着疑问继续学习。分享IDEA的调试技巧，便于同学们实际操作。</p></blockquote><ul><li>作用：官方解释、通俗易懂的解释</li><li>地位</li><li>不使用并发手段的后果</li></ul><h3 id="2-1-synchronized的作用-03-11"><a href="#2-1-synchronized的作用-03-11" class="headerlink" title="2-1 synchronized的作用 (03:11)"></a>2-1 synchronized的作用 (03:11)</h3><p>官方解释</p><blockquote><p>Synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visable to more than one thread, all reads or wirtes or that object’s variables are done through synchronized methods </p></blockquote><p>翻译</p><blockquote><p>同步方法支持一种简单的策略来防止线程干扰和内存一致性错误：如果一个对象对多个线程可见，则对该对象变量的所有读取或写入都是通过同步方法完成的</p></blockquote><p>一句话说出Synchronized的作用</p><blockquote><p>能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果</p></blockquote><h3 id="2-2-synchronized的地位-00-51"><a href="#2-2-synchronized的地位-00-51" class="headerlink" title="2-2 synchronized的地位 (00:51)"></a>2-2 synchronized的地位 (00:51)</h3><ul><li>Synchronized是Java的关键字，被Java语言原生支持</li><li>Synchronized是最基本的同步互斥手段</li><li>Synchronized是并发编程中的元老级角色，是并发编程的必学内容</li></ul><h3 id="2-3-不用并发手段的后果预警-01-06"><a href="#2-3-不用并发手段的后果预警-01-06" class="headerlink" title="2-3 不用并发手段的后果预警 (01:06)"></a>2-3 不用并发手段的后果预警 (01:06)</h3><p>代码实战：两个线程同时<code>a++</code>，最后结果会比预计的少。</p><h3 id="2-4-后果的代码演示和原因分析-07-23"><a href="#2-4-后果的代码演示和原因分析-07-23" class="headerlink" title="2-4 后果的代码演示和原因分析 (07:23)"></a>2-4 后果的代码演示和原因分析 (07:23)</h3><pre><code class="java">public class DisappearRequest1 implements Runnable {    private static DisappearRequest1 instance = new DisappearRequest1();    private static int a = 0;    public static void main(String[] args) throws InterruptedException {        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();t2.start();        t1.join();t2.join();        System.out.println(&quot;a = &quot; + a);    }    @Override    public void run() {        for (int i = 0; i &lt; 100000; i++) {            a++;        }    }}</code></pre><p>原因：</p><blockquote><p><code>count++</code>，它看上去只是一个操作，实际上包含了三个动作（非原子操作）：</p><ol><li>读取count</li><li>将count加1</li><li>将count的值写入到内存中</li></ol><p>非原子操作还有：<code>a--</code>、<code>a+=1</code>、<code>a-=1</code>等</p></blockquote><h2 id="第3章-Synchronized的两种用法（对象锁和类锁）"><a href="#第3章-Synchronized的两种用法（对象锁和类锁）" class="headerlink" title="第3章 Synchronized的两种用法（对象锁和类锁）"></a>第3章 Synchronized的两种用法（对象锁和类锁）</h2><blockquote><p>对使用方法进行系统分类。涵盖了所有该关键字会用到的情况。</p></blockquote><h3 id="3-1-Synchronized的两种用法介绍-02-11"><a href="#3-1-Synchronized的两种用法介绍-02-11" class="headerlink" title="3-1 Synchronized的两种用法介绍 (02:11)"></a>3-1 Synchronized的两种用法介绍 (02:11)</h3><ol><li><p>对象锁：3-2</p><blockquote><p>包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）</p></blockquote></li><li><p>类锁：3-7</p><blockquote><p>指synchronized修饰静态的方法或指定锁为class对象</p></blockquote></li></ol><h3 id="3-2-对象锁的形式1-同步代码块-13-07"><a href="#3-2-对象锁的形式1-同步代码块-13-07" class="headerlink" title="3-2 对象锁的形式1-同步代码块 (13:07)"></a>3-2 对象锁的形式1-同步代码块 (13:07)</h3><p>第一个用法：对象锁</p><ul><li>代码块形式：手动指定锁对象</li><li>方法锁形式：synchronized修饰普通方法，锁对象默认为this</li></ul><blockquote><p>代码块形式：手动指定锁对象</p></blockquote><pre><code class="java">private Object lock1 = new Object();private Object lock2 = new Object();@Overridepublic void run() {    synchronized (lock1) {        System.out.println(&quot;我是对象锁的代码块形式-lock1。我叫&quot; + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;，lock1-运行结束。&quot;);    }    synchronized (lock2) {        System.out.println(&quot;我是对象锁的代码块形式-lock2。我叫&quot; + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;，lock2-运行结束。&quot;);    }}</code></pre><p>结论：当有多个synchronized同步代码块时，如果使用this为锁对象（即同一个锁对象）则只能运行其中的一个同步代码块，不能与其他同步代码块并行运行。</p><p>注：当业务复杂时，锁对象也会变得非常复杂。JDK提供了相应非常完善的工具类，例如：JUC包下的<code>CountDownLatch</code>倒计时,门闩、<code>CyclicBarrier</code>、<code>Semaphore</code>信号量。</p><h3 id="3-3-调试技巧-看线程生命周期-03-28"><a href="#3-3-调试技巧-看线程生命周期-03-28" class="headerlink" title="3-3 调试技巧-看线程生命周期 (03:28)"></a>3-3 调试技巧-看线程生命周期 (03:28)</h3><p>在调试时查看当前线程的状态：</p><p>打好断点=&gt;使用Debug启动程序=&gt;当运行到断点时,右击断点出现图1</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8pl2tiw58j30nk0aiq3q.jpg" alt="image-20191107170337910" style="zoom:40%;" alt="图1" /><p><code>All</code>：暂停所有线程，包括JVM</p><p><code>Thread</code>：暂停当前线程</p><p>Debug=&gt;Debugger=&gt;Frames=&gt;Thread-0=&gt;run,Thread=&gt;Evaluate Expression</p><p>执行：<code>this.getState()</code></p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8plcqxdrij30hy0jymz1.jpg" style="zoom:33%;" alt="图2"/><h3 id="3-4-对象锁的形式2-普通方法锁-03-58"><a href="#3-4-对象锁的形式2-普通方法锁-03-58" class="headerlink" title="3-4 对象锁的形式2-普通方法锁 (03:58)"></a>3-4 对象锁的形式2-普通方法锁 (03:58)</h3><blockquote><p>方法锁形式：synchronized修饰普通方法，锁对象默认为this</p></blockquote><pre><code class="java">public synchronized void method() throws InterruptedException {    System.out.println(&quot;我是对象锁的方法修饰符形式，我叫&quot; + Thread.currentThread().getName());    Thread.sleep(3000);    System.out.println(Thread.currentThread().getName() + &quot;，运行结束&quot;);}</code></pre><h3 id="3-5-类锁的概念-04-54"><a href="#3-5-类锁的概念-04-54" class="headerlink" title="3-5 类锁的概念 (04:54)"></a>3-5 类锁的概念 (04:54)</h3><p>第二个用法：类锁</p><ul><li>概念（★重要）：Java类可能有很多个对象，但是只有一个Class对象</li><li>形式1：synchronized加载static静态方法上</li><li>形式2：<code>synchronized(*.class)</code>代码块</li></ul><p>概念：</p><ul><li>只有一个Class对象：Java类可能会有很多个对象，但是只有1个Class对象。特殊的对象。</li><li>本质：所谓的类锁，不过是Class对象的锁而已。</li><li>用法和效果：类锁只能在同一时刻被一个对象拥有。</li></ul><p>类锁就是使用特殊对象锁（Class对象）作为同步互斥锁，因为其只有一个，所以不同的实例会互斥，在同一时刻只有一个线程可以访问该类实例中被类锁锁住的方法。</p><h3 id="3-6-类锁的形式1-静态方法锁-03-52"><a href="#3-6-类锁的形式1-静态方法锁-03-52" class="headerlink" title="3-6 类锁的形式1-静态方法锁 (03:52)"></a>3-6 类锁的形式1-静态方法锁 (03:52)</h3><blockquote><p>形式1：synchronized加载static静态方法上</p></blockquote><p>两个线程为不同的实例：</p><pre><code class="java">Thread t1 = new Thread(instance1);Thread t2 = new Thread(instance2);</code></pre><pre><code class="java">public static synchronized void method() throws InterruptedException {    System.out.println(&quot;我是类锁的静态方法形式，我叫&quot; + Thread.currentThread().getName());    Thread.sleep(3000);    System.out.println(Thread.currentThread().getName() + &quot;，运行结束&quot;);}</code></pre><h3 id="3-7-类锁的形式2–-class-05-08"><a href="#3-7-类锁的形式2–-class-05-08" class="headerlink" title="3-7 类锁的形式2–.class (05:08)"></a>3-7 类锁的形式2–.class (05:08)</h3><blockquote><p>形式2：<code>synchronized(*.class)</code>代码块</p></blockquote><p>两个线程为不同的实例：</p><pre><code class="java">Thread t1 = new Thread(instance1);Thread t2 = new Thread(instance2);</code></pre><pre><code class="java">public void method() throws InterruptedException {    synchronized (SynchronizedClassClass5.class) {        System.out.println(&quot;我是类锁的 synchronized(*.class) 形式，我叫&quot; + Thread.currentThread().getName());        Thread.sleep(3000);        System.out.println(Thread.currentThread().getName() + &quot;，运行结束&quot;);    }}</code></pre><h3 id="3-8-消失的请求解决方案-04-25"><a href="#3-8-消失的请求解决方案-04-25" class="headerlink" title="3-8 消失的请求解决方案 (04:25)"></a>3-8 消失的请求解决方案 (04:25)</h3><p>解决方案1：对象锁-普通方法形式</p><pre><code class="java">@Overridepublic synchronized void run() {    for (int i = 0; i &lt; 100000; i++) {        a++;    }}</code></pre><p>解决方案2：对象锁-同步代码块形式</p><pre><code class="java">@Overridepublic void run() {    for (int i = 0; i &lt; 100000; i++) {        synchronized (this) {            a++;        }    }}</code></pre><p>解决方案3：类锁-*.class形式</p><pre><code class="java">@Overridepublic void run() {    for (int i = 0; i &lt; 100000; i++) {        synchronized (DisappearRequest1.class) {            a++;        }    }}</code></pre><p>解决方案4：类锁-静态方案形式</p><pre><code class="java">@Overridepublic void run() {    method();}public static synchronized void method() {    for (int i = 0; i &lt; 100000; i++) {        a++;    }}</code></pre><h2 id="第4章-多线程访问同步方法的7种具体情况"><a href="#第4章-多线程访问同步方法的7种具体情况" class="headerlink" title="第4章 多线程访问同步方法的7种具体情况"></a>第4章 多线程访问同步方法的7种具体情况</h2><blockquote><p>★面试常考</p><p>除了普通用法外，对各种情况进行讲解，让同学们有整体思维，并且理解原理。</p></blockquote><h3 id="4-1-七种常见情况之123-06-38"><a href="#4-1-七种常见情况之123-06-38" class="headerlink" title="4-1 七种常见情况之123 (06:38)"></a>4-1 七种常见情况之123 (06:38)</h3><p>多线程访问同步方法的7种情况：</p><ol><li>两个线程同时访问一个对象的同步方法</li><li>两个线程访问的是两个对象的同步方法</li><li>两个线程访问的是synchronized的静态方法</li><li>同时访问同步和非同步方法</li><li>访问同一个对象的不同的普通同步方法</li><li>同时访问静态synchronized个非静态synchronized方法</li><li>方法抛出异常后，会释放锁</li></ol><ol><li><p>两个线程同时访问一个对象的同步方法</p><p>线程同步。<code>SynchronizedObjectMethod3</code></p><p>对象锁的普通方法形式。this锁</p></li><li><p>两个线程访问的是两个对象的同步方法</p><p>线程异步。</p></li><li><p>两个线程访问的是synchronized的静态方法</p><p>线程同步。<code>SynchronizedClassStatic4</code></p></li></ol><h3 id="4-2-七种常见情况之4和5-08-21"><a href="#4-2-七种常见情况之4和5-08-21" class="headerlink" title="4-2 七种常见情况之4和5 (08:21)"></a>4-2 七种常见情况之4和5 (08:21)</h3><ol start="4"><li><p>同时访问同步和非同步方法</p><p>线程异步。<code>SynchronizedYesAndNo6</code></p><p>非同步方法不受到影响</p></li><li><p>访问同一个对象的不同的普通同步方法</p><p>线程同步。<code>SynchronizedDifferentMethod7</code></p></li></ol><h3 id="4-3-七种常见情况之6和7-11-25"><a href="#4-3-七种常见情况之6和7-11-25" class="headerlink" title="4-3 七种常见情况之6和7 (11:25)"></a>4-3 七种常见情况之6和7 (11:25)</h3><ol start="6"><li><p>同时访问静态synchronized个非静态synchronized方法</p><p>线程异步。<code>SynchronizedStaticAndNormal8</code></p><p><code>this锁</code>与<code>*.class锁</code>不是同一把锁</p></li><li><p>方法抛出异常后，会释放锁</p><p><code>SynchronizedException9</code></p><p>synchronized与Lock接口：</p><ul><li>在Lock接口中，只要是没有显式手动释放锁，即便抛出异常Lock也是不会释放锁的。</li><li>synchronized一旦抛出异常会自动释放锁。</li></ul></li></ol><h3 id="4-4-7种情况总结-03-00"><a href="#4-4-7种情况总结-03-00" class="headerlink" title="4-4 7种情况总结 (03:00)"></a>4-4 7种情况总结 (03:00)</h3><p>3点核心思想：</p><ol><li><p>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应第1、5种情况）</p></li><li><p>每个实例都对应有自己的一把锁(即this锁)，不同实例之间互不影响；（对应第2、4、6种情况）</p><p>例外：锁对象是*.class以及synchronized修饰的事static方法的时候，所有对象公用同一把锁(即类锁)（对应第3种情况）</p></li><li><p>无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应第7种情况）</p></li></ol><p>补充：</p><ul><li><p>synchronized方法调用非synchronized方法，此时是线程安全的么？</p><p>答：不是的。一旦出了synchronized方法，由于另一个方法未被synchronized修饰，所以这个方法是可以被多个线程同时访问的。</p></li></ul><h2 id="第5章-Synchronized的性质"><a href="#第5章-Synchronized的性质" class="headerlink" title="第5章 Synchronized的性质"></a>第5章 Synchronized的性质</h2><blockquote><p>重点对可重入性作深入讲解，对粒度进行代码展示。</p></blockquote><ul><li>可重入性质</li><li>不可中断性质</li></ul><h3 id="5-1-可重入性质-理论部分-07-54"><a href="#5-1-可重入性质-理论部分-07-54" class="headerlink" title="5-1 可重入性质-理论部分 (07:54)"></a>5-1 可重入性质-理论部分 (07:54)</h3><p>锁的种类：自选锁、互斥锁、可重入锁（递归锁）、中断锁、读写锁</p><p>可重入锁：<code>synchronized</code>、<code>ReentrantLock</code></p><p>什么是可重入：</p><blockquote><p>指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。</p></blockquote><p>好处：</p><blockquote><p>避免死锁、提升封装性</p></blockquote><ul><li><p>假设方法A和方法B都被synchronized修饰，线程执行到方法A并且获得了这把锁。此时方法A想要去调用方法B，由于方法B也被synchronized修饰，所以也需要获取锁。线程在这个时候既想要获取锁又不想释放锁，造成了永久等待，所以形成了死锁。</p></li><li><p>可重入性避免了一次一次的解锁加锁。</p></li></ul><p>粒度：</p><blockquote><p>指的是加锁的一个范围（scope）。线程而非调用（用3种情况来说明和pthread的区别）</p></blockquote><p>​    <strong>synchronized的粒度为线程</strong></p><p>​    pthread（Linux中的PROCESS线程）的粒度为调用</p><p>代码验证：</p><ol><li><p>情况1:证明同一个方法是可以重入的</p></li><li><p>情况2:证明可重入不要求是同一个方法（不同方法）</p></li><li><p>情况3:证明可重入不要求是同一个类中（不同类）</p><p>子类重写父类的synchronized方法，然后在子类中利用super调用父类的这个synchronized方法，如果不具备可重入性，则代码会产生死锁。</p></li></ol><h3 id="5-2-可重入性质-代码演示-10-32"><a href="#5-2-可重入性质-代码演示-10-32" class="headerlink" title="5-2 可重入性质-代码演示 (10:32)"></a>5-2 可重入性质-代码演示 (10:32)</h3><p>补充：</p><ul><li>递归三要素：<ol><li>一定有一种可以退出程序的情况</li><li>总是在尝试将一个问题化简到更小的规模</li><li>父问题与子问题不能有重叠的部分</li></ol></li></ul><ol><li><p>情况1:证明同一个方法是可以重入的</p><pre><code class="java">/** * 可重入粒度测试：递归调用本方法 */public class SynchronizedRecursion10 {    int a = 0;    public static void main(String[] args) {        SynchronizedRecursion10 synchronizedRecursion10 = new SynchronizedRecursion10();        synchronizedRecursion10.method1();    }    private synchronized void method1() {        System.out.println(&quot;this is method1, a = &quot; + a);        if (a == 0) {            a++;            method1();        }    }}</code></pre></li><li><p>情况2:证明可重入不要求是同一个方法（不同方法）</p><pre><code class="java">/** * 可重入粒度测试：调用类内另外的方法 */public class SynchronizedOtherMethod11 {    public static void main(String[] args) {        SynchronizedOtherMethod11 synchronizedOtherMethod11 = new SynchronizedOtherMethod11();        synchronizedOtherMethod11.method1();    }    public synchronized void method1() {        System.out.println(&quot;I&#39;m method1&quot;);        method2();    }    private synchronized void method2() {        System.out.println(&quot;I&#39;m method2&quot;);    }}</code></pre></li><li><p>情况3:证明可重入不要求是同一个类中（不同类）</p><pre><code class="java">/** * 可重入粒度测试：调用父类的方法 */public class SynchronizedSuperClass12 {    public synchronized void doSomething() {        System.out.println(&quot;我是父类方法&quot;);    }}class TestClass extends SynchronizedSuperClass12 {    public static void main(String[] args) {        TestClass t = new TestClass();        t.doSomething();    }    @Override    public synchronized void doSomething() {        System.out.println(&quot;我是子类方法&quot;);        super.doSomething();    }}</code></pre></li></ol><h3 id="5-3-不可中断性质-02-10"><a href="#5-3-不可中断性质-02-10" class="headerlink" title="5-3 不可中断性质 (02:10)"></a>5-3 不可中断性质 (02:10)</h3><p>一旦锁已经被其他线程获得，如果当前线程想要获得锁，那么当前线程只能选择等待或者阻塞，直到其他线程释放这个锁。如果其他线程永远不释放锁，那么当前线程只能永远地等待下去。</p><p>相比之下，<code>JUC包</code>下的<code>Lock</code>类，可以拥有中断的能力。第一点，如果我觉得我等的时间太长了，有权中断现在已经获取到锁的线程的执行；第二点，如果我觉得我等待的时间太长了不想等待了，也可以退出。</p><p><code>Lock类</code>相比<code>synchronized</code>更为灵活，但是需要注意更多的点，在编码中避免出错。</p><h2 id="第6章-深入原理"><a href="#第6章-深入原理" class="headerlink" title="第6章 深入原理"></a>第6章 深入原理</h2><blockquote><p>知其所以然，学习原理。学习monitor指令、可重入和可见性原理</p></blockquote><ul><li>加锁和释放锁的原理：现象、时机、深入JVM查看字节码</li><li>可重入原理：加锁次数计数器</li><li>保证可见性的原理：内存模型</li></ul><h3 id="6-1-加锁和释放锁的原理-08-55"><a href="#6-1-加锁和释放锁的原理-08-55" class="headerlink" title="6-1 加锁和释放锁的原理 (08:55)"></a>6-1 加锁和释放锁的原理 (08:55)</h3><ol><li><p>现象：每一个类的实例对应一把锁，每一个synchronized方法都必须获取调用该方法的类的实例的锁方能执行，否则线程会阻塞。方法一旦执行就会独占这把锁直到该方法返回或者抛出异常才将锁释放。释放锁之后，其他阻塞线程才有机会获取到锁，进入到可执行状态。</p></li><li><p>获取和释放锁的时机：内置锁（监视器锁，MonitorLock）</p></li><li><p>等价代码：</p><pre><code class="java">/** * synchronized锁与lock锁 */public class SynchronizedToLock13 {    public static void main(String[] args) {        SynchronizedToLock13 s = new SynchronizedToLock13();        s.method1();        s.method2();    }    Lock lock = new ReentrantLock();    public synchronized void method1() {        System.out.println(&quot;我是Synchronized形式的锁。&quot;);    }    public void method2() {        lock.lock();        try {            System.out.println(&quot;我是lock形式的锁。&quot;);        } finally {            lock.unlock();        }    }}</code></pre></li><li><p>深入JVM看字节码：反编译、monitor指令</p></li></ol><h3 id="6-2-反编译看monitor指令-12-06"><a href="#6-2-反编译看monitor指令-12-06" class="headerlink" title="6-2 反编译看monitor指令 (12:06)"></a>6-2 反编译看monitor指令 (12:06)</h3><p>概况：synchronized使用的锁是在Java对象头里的一个字段，表明是否被锁住。</p><p>synchronized的实现原理：进入锁和释放锁是基于monitor对象来实现同步方法和同步代码块的</p><p>monitor对象最主要是两个指令：</p><ul><li><p>monitorenter：插入到同步代码块开始的位置</p></li><li><p>monitorexit：插入到方法结束和退出的时候</p><p>monitorenter个数 &lt;= monitorexit个数</p></li></ul><p>补充：</p><ul><li>Java对象头</li><li>class类文件的结构</li></ul><p>如何反编译：</p><ol><li><p>编写Java代码</p><pre><code class="java">/** * 反编译字节码 */public class Decompilation14 {    private final Object object = new Object();    public void insert(Thread thread) {        synchronized (object) {        }    }}</code></pre></li><li><p>编译为字节码文件</p><pre><code class="shell">javac Decompilation14.java</code></pre></li><li><p>反编译/反汇编</p><pre><code class="shell">javap -verbose Decompilation14</code></pre><p><code>-verbose</code>：打印所有信息</p></li></ol><p>Monitorenter和Monitorexit指令</p><ul><li>monitorenter和monitorexit在执行的时候会让对象的锁计数器加一或减一，和操作系统的PV操作非常类似。</li><li>每一个对象都与一个monitor相关联，一个monitor的lock锁在同一时间只能被一个线程获取</li><li>一个线程在尝试获得与这个对象相关联的monitor的所有权时，会发生三种情况：<ol><li>如果monitor计数器为0，意味着目前还没有被获得，线程会立刻获得锁，然后把计数器加1</li><li>如果monitor已经拿到锁的所有权，然后又重入，会导致锁计数器累加</li><li>如果monitor已经被其他线程持有，此时线程进入阻塞状态，直到monitor计数器变为0才会再次去尝试获取锁</li></ol></li><li>monitorexit：释放对于monitor的所有权（前提是已经拥有锁的所有权）。释放所有权就是将monitor计数器减一，如果为0则当前线程不再拥有monitor的所有权，同时阻塞的线程会再次尝试获取锁；如果不为0则说明上一步为重入，当前线程依然持有monitor的所有权</li></ul><h3 id="6-3-可重入原理-01-50"><a href="#6-3-可重入原理-01-50" class="headerlink" title="6-3 可重入原理 (01:50)"></a>6-3 可重入原理 (01:50)</h3><p>加锁次数计数器</p><ul><li>JVM负责跟踪对象被加锁的次数</li><li>线程第一次给对象加锁的时候，计数器变为1；每当这个<strong>相同的线程</strong>在此对象上再次获得锁时，计数器会递增</li><li>每当任务离开时，计数器递减，当计数器为0的时候，锁被完全释放</li></ul><h3 id="6-4-可见性原理-03-34"><a href="#6-4-可见性原理-03-34" class="headerlink" title="6-4 可见性原理 (03:34)"></a>6-4 可见性原理 (03:34)</h3><ul><li><p>Java内存模型：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8qrch253bj30um0qcjzl.jpg" alt="Java内存模型" style="zoom:35%;"/><p>线程使用的内存速度要比主存所使用的内存要快。</p></li><li><p>线程A向线程B发送数据的步骤：</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8qre9xvtwj30xe0pon3m.jpg" alt="线程之间的通信" style="zoom:35%;"/></li></ul><h2 id="第7章-Synchronized的缺陷"><a href="#第7章-Synchronized的缺陷" class="headerlink" title="第7章 Synchronized的缺陷"></a>第7章 Synchronized的缺陷</h2><blockquote><p>对Synchronized关键字的缺陷进行梳理</p></blockquote><h3 id="7-1-Synchronized缺陷-09-02"><a href="#7-1-Synchronized缺陷-09-02" class="headerlink" title="7-1 Synchronized缺陷 (09:02)"></a>7-1 Synchronized缺陷 (09:02)</h3><ol><li><p>效率低：锁的释放情况少、试图获得锁时不能设定超时、不能中断一个正在试图获得锁的线程</p><p>在IO操作、sleep()等不会主动释放锁</p><p>永久等待别的线程释放锁，再获取锁。不到南墙不回头，不到黄河心不死</p><p>解决方案：使用Lock锁</p></li><li><p>不够灵活：加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象），可能是不够的。</p><p>读写锁在读操作时不会加锁，在写操作的时候才会加锁</p><p>解决方案：使用读写锁</p></li><li><p>无法知道是否成功获取到锁</p><p>Lock锁可以做尝试加锁。分成功、失败的情况</p></li></ol><pre><code class="java">/** * 展示Lock的方法 */public class LockExample15 {    public static void main(String[] args) throws InterruptedException {        Lock lock = new ReentrantLock();        lock.lock();        lock.unlock();        boolean tryLock1 = lock.tryLock();        boolean tryLock2 = lock.tryLock(10, TimeUnit.SECONDS);        Condition condition = lock.newCondition();    }}</code></pre><h2 id="第8章-常见面试题"><a href="#第8章-常见面试题" class="headerlink" title="第8章 常见面试题"></a>第8章 常见面试题</h2><blockquote><p>对常见面试题进行总结</p></blockquote><h3 id="8-1-常见面试问题-07-01"><a href="#8-1-常见面试问题-07-01" class="headerlink" title="8-1 常见面试问题 (07:01)"></a>8-1 常见面试问题 (07:01)</h3><ol><li><p>使用注意点：锁对象不能为空、作用域不宜过大、避免死锁</p><ul><li><p>锁对象不能为空：锁对象必须是一个实例对象，不能是一个空对象，需由new或者其他方法创建。锁的信息都保存在对象头中的。</p></li><li><p>作用域不宜过大：作用域即synchronized所包裹的范围，范围过大会降低程序运行速度。</p></li><li><p>避免死锁：</p><pre><code class="java">synchronized (instnace1) {    synchronized (instnace2) {}}synchronized (instnace2) {    synchronized (instnace1) {}}</code></pre></li></ul></li><li><p>如何选择Lock和synchronized关键字？</p><ul><li>如果可以，尽量都不使用。而是使用<code>java.util.concurrent</code>包下的原子类</li><li>如果synchronized适用，就优先使用synchronized。减少代码量。</li><li>特别需要才使用Lock、Condition</li></ul></li><li><p>多线程访问同步方法的各种具体情况</p><p>第四章。7种具体情况</p></li></ol><h2 id="第9章-思考题"><a href="#第9章-思考题" class="headerlink" title="第9章 思考题"></a>第9章 思考题</h2><blockquote><p>由点到面，进一步引发同学们的深入思考</p></blockquote><h3 id="9-1-思考题-05-47"><a href="#9-1-思考题-05-47" class="headerlink" title="9-1 思考题 (05:47)"></a>9-1 思考题 (05:47)</h3><ol><li><p>多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的是哪一个线程？用的是什么算法呢？</p><p>涉及到内部锁调度机制。可能是运行时间最短的，也有可能是等待时间最长的，甚至是随机的。这和不同JVM的版本和具体实现都有关系，所以不能依赖具体算法。只能判定为随机的、不可控制的。</p></li><li><p>synchronized使得同时只有一个线程可以运行，性能较差，有什么办法可以提升性能？</p><ul><li>优化使用范围，不宜范围过大。临界区在符合要求的情况下尽可能的小。</li><li>使用其他类型的锁，比如说读写锁</li></ul></li><li><p>我想更灵活地控制锁的获取和释放（现在释放锁的时机都被规定死了），怎们办？</p><p>可以自己实现一个Lock接口。参考已有的优秀的锁。</p></li><li><p>什么是锁的升级、降级？什么是JVM里的偏斜锁、轻量级锁、重量级锁？</p><p>随JVM版本的提高，synchronized关键字的性能得到了显著提升</p></li></ol><h2 id="第10章-课程总结"><a href="#第10章-课程总结" class="headerlink" title="第10章 课程总结"></a>第10章 课程总结</h2><blockquote><p>对课程进行总结梳理，展望。</p></blockquote><h3 id="10-1-课程总结和展望-13-35"><a href="#10-1-课程总结和展望-13-35" class="headerlink" title="10-1 课程总结和展望 (13:35)"></a>10-1 课程总结和展望 (13:35)</h3><p>一句话介绍synchronized</p><blockquote><p>JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以同时执行指定代码，从而保证了线程安全，同时具有可重入和不可中断的性质。</p></blockquote><p>思维导图：（百度脑图,别登录否则没有权限）</p><p><a href="https://naotu.baidu.com/file/12e7658471786e71e69cf57c9316a3de" target="_blank" rel="noopener">https://naotu.baidu.com/file/12e7658471786e71e69cf57c9316a3de</a></p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8rzca8dncj31lx0u01kx.jpg" alt="Synchronized关键字" style="zoom:100%;" /><p><strong>实战课：Java并发核心知识体系精讲</strong></p><blockquote><p><a href="https://coding.imooc.com/class/362.html" target="_blank" rel="noopener">https://coding.imooc.com/class/362.html</a></p></blockquote><ul><li>实现多线程的方式到底是1种、2种还是4种？：本质只有1种方式，实现执行内容有2种方式，而包装后的外在表现形式有多种形式</li><li>启动线程的正确和错误的方式：包含<code>start()</code>和<code>run()</code>的源码分析、对比</li><li>停止线程的正确方式：包含为什么广为流传的volatile boolean是错误的？如何做到3方配合，完美实现线程的停止？</li><li>线程的6个状态、线程的生命周期：一图说清线程的整个生命周期、究竟什么叫“线程阻塞”？</li><li>并发重要方法详解：包含<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>、<code>sleep()</code>、<code>join()</code>、<code>yield()</code>、<code>Thread.currentThread()</code>等</li><li>线程重要属性：包含守护线程和普通线程的区别？为什么不应该利用线程优先级设计程序？</li><li>线程的未捕获异常UncaughtException应该如何处理？有哪些解决方案？</li><li>线程安全：包含如何找出<code>a++</code>具体是在哪里出的错？3类线程不安全的现象、4种需要额外考虑线程安全的场景</li><li>Java内存模型详解——底层原理：重排序、可见性、原子性、happens-before、volatile</li><li>死锁详解：必然死锁的例子、发生死锁的4个条件、如何用jstack命令和代码这两种方式定位死锁？修复死锁的3种方案、实际工程中如何避免死锁？</li><li>彩蛋：如何从宏观和微观两个方面来提高技术？提高技术的途径？工作中业务缠身，如何在业务开发中得到更多成长？</li><li>常见面试问题——配有文档总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>352-细说Java多线程之内存可见性</title>
      <link href="/imooc/352-volatile/"/>
      <url>/imooc/352-volatile/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/352" target="_blank" rel="noopener">https://www.imooc.com/learn/352</a></p><p>简介：本课程带领大家深层次学习Java中的内存可见性、Java内存模型、指令重排序、as-if-serial语义等多线程中偏向底层的一些知识，以及synchronized和volatile实现内存可见性的原理和方法。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课程简介"><a href="#第1章-课程简介" class="headerlink" title="第1章 课程简介"></a>第1章 课程简介</h2><blockquote><p>介绍课程目标和学习内容</p></blockquote><p>多线程-数据争用-内存可见性</p><ol><li>共享变量在线程间的可见性</li><li><code>synchronized</code>实现可见性</li><li><code>volatile</code>实现可见性<ul><li>指令重排序</li><li><code>as-if-serial</code>语义</li><li><code>volatile</code>使用注意事项</li></ul></li><li><code>synchronized</code>和<code>volatile</code>比较</li></ol><h2 id="第2章-可见性介绍"><a href="#第2章-可见性介绍" class="headerlink" title="第2章 可见性介绍"></a>第2章 可见性介绍</h2><blockquote><p>本章讲解Java内存模型，可见性的概念和可见性实现的原理</p></blockquote><h3 id="2-1-可见性介绍"><a href="#2-1-可见性介绍" class="headerlink" title="2-1 可见性介绍"></a>2-1 可见性介绍</h3><ol><li><p>可见性：一个线程对共享变量值的修改，能够及时地被其他线程看到。</p></li><li><p>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。</p></li><li><p>线程的工作内存：<code>Java</code>内存抽象出来的概念</p></li><li><p><code>Java</code>内存模型（<code>JMM</code>）</p><p> <code>Java</code>内存模型（<code>Java Memory Model</code>）描述了<code>Java</code>程序中各种变量（线程共享变量）的访问规则，以及在<code>JVM</code>中将变量存储到内存和从内存中读取出变量这样的底层细节。</p></li><li><p>所有的变量都存储在主内存中</p><p> 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）</p>  <img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ol0a8of7j30xc0eq0u0.jpg" style="zoom:50%;" /></li><li><p>共享变量使用的两条规则  </p><ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成</li></ul></li><li><p>共享变量可见性实现的原理</p><p> 线程1对共享变量的修改要想被线程2及时看到，必须经过如下2个步骤：</p><ol><li><p>把工作内存1中更新过的共享变量刷新到主内存中</p></li><li><p>将主内存中最新的共享变量的值更新到工作内存2中</p><p>线程1–&gt;工作内存1中变量<code>X</code>–&gt;更新到主内存中–&gt;工作内存2中的变量<code>X</code>得到更新–&gt;线程2</p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8ol0lto5tj309907d74z.jpg" style="zoom:100%;" /></li></ol></li></ol><h3 id="2-2-练习题"><a href="#2-2-练习题" class="headerlink" title="2-2 练习题"></a>2-2 练习题</h3><p>下面叙述错误的是：B</p><blockquote><p>A. 通过<code>synchronized</code>和<code>volatile</code>都可以实现可见性</p><p>B. 不同线程之间可以直接访问其他线程工作内存中的变量</p><p>C. 线程对共享变量的所有操作都必须在自己的工作内存中进行</p><p>D. 所有的变量都存储在主内存中</p></blockquote><h2 id="第3章-synchronized实现可见性"><a href="#第3章-synchronized实现可见性" class="headerlink" title="第3章 synchronized实现可见性"></a>第3章 <code>synchronized</code>实现可见性</h2><blockquote><p>本章讲解synchronized实现可见性的原理和方法、指令重排序、as-if-serial语义等概念，并通过具体程序进行分析。</p></blockquote><h3 id="3-1-synchronized实现可见性原理"><a href="#3-1-synchronized实现可见性原理" class="headerlink" title="3-1 synchronized实现可见性原理"></a>3-1 <code>synchronized</code>实现可见性原理</h3><blockquote><p>要实现共享变量的可见性，必须保证两点：</p><ul><li>线程修改后的共享变量值能够及时从工作内存刷新到主内存中</li><li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中</li></ul></blockquote><blockquote><p>Java语言层面支持的可见性实现方式：<code>synchronized</code>、<code>volatile</code></p></blockquote><ol><li>synchronized能够实现：原子性（同步）、可见性</li><li>JMM关于synchronized的两条规定：<ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主存中重新读取最新的值。（注意：加锁与解锁需要是同一把锁）</li></ul></li></ol><pre><code>线程解锁前对共享变量的修改在下次加锁时对其他线程可见。</code></pre><ol start="3"><li><p>线程执行互斥代码块的过程：</p><ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行锁内代码</li><li>将更改后的共享变量值刷新到主内存</li><li>释放互斥锁</li></ol></li><li><p>指令重排序  </p><ol><li><p>重排序：代码的书写顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化</p><ul><li>编译器优化的重排序（编译器优化）重新安排代码的执行顺序</li><li>指令级并行的重排序（处理器优化）双核处理器采用了指令级并行技术，可执行多条指令</li><li>内存系统的重排序（处理器优化）对读写缓存做的优化<pre><code class="java">//代码顺序：         //执行顺序：int number = 1;     int result = 0;int result = 0;     int number = 1;</code></pre></li></ul></li><li><p><code>as-if-serial</code>：无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致（<code>Java</code>编译器都会保证<code>Java</code>在单线程下遵循<code>as-if-serial</code>语义）</p></li></ol></li></ol><pre><code>注：- 重排序不会给单线程带来内存可见性问题- 多线程中程序交错执行时，重排序可能会造成内存可见性问题  </code></pre><h3 id="3-2-synchronized实现可见性代码"><a href="#3-2-synchronized实现可见性代码" class="headerlink" title="3-2 synchronized实现可见性代码"></a>3-2 <code>synchronized</code>实现可见性代码</h3><pre><code class="java">ready = false;result = 0;number = 1;// 写操作public void write() {   ready = true; // 1.1   number = 2; // 1.2}//读操作public void read() {   if (ready) { // 2.1       result = number * 3;//2.2   }   System.out.println(&quot;result的值为：&quot; + result);}</code></pre><p>执行顺序：</p><ol><li>1.1–&gt;2.1–&gt;2.2–&gt;1.2<br>result=3;</li><li>1.2–&gt;2.1–&gt;2.2–&gt;1.1<br>result=0;</li></ol><p>导致共享变量在线程间不可见的原因：</p><ol><li>线程的交叉执行</li><li>重排序结合线程交叉执行</li><li>共享变量更新后的值没有在工作内存与主内存间及时更新</li></ol><p>synchronized解决不可见的方案：</p><ol><li>原子性：由于锁的关系，线程之间不允许交叉执行；相当于给该线程（或当前运行的有且仅有一个的线程）加了一把锁，外面的线程无法进入，更别提互相交叉执行。</li><li>原子性 + <code>as-if-serial</code>语义：线程不能交叉执行，重排序对于单线程不能影响运行结果。</li><li>可见性：共享变量的更新执行。</li></ol><p>常见问题：</p><ol><li>为何不加<code>synchronized</code>关键字也会执行可见性，是主内存及时更新被获取最新值么？<br>因为当时定义说加<code>synchronized</code>一定会可见性，而不加也没说一定不会，只是有可能不会。因为现在<code>Java</code>做了一些优化：尽量实现可见性；但是不能保证每次都成功，只是成功概率比较大99%，但还是有1%的情况会失败。所以处于安全性考虑，尽量加<code>synchronized</code>关键字100%成功。</li><li>有时候不存在线程交叉情况，但是会先执行第二个线程，这是因为第一个线程把<code>CPU</code>让位出来。所以为了避免这种情况，可以在第一个线程后附上代码：<code>sleep(1000);</code>1秒之后才有机会执行线程2。</li><li><code>synchronized</code> + <code>sleep();</code>黄金搭档。<h3 id="3-5-练习题"><a href="#3-5-练习题" class="headerlink" title="3-5 练习题"></a>3-5 练习题</h3>下面说法错误的是：C<blockquote><p>A. 当两个并发线程访问同一个对象<code>object</code>中的这个<code>synchronized(this)</code>同步代码块时，一个时间内只能有一个线程得到执行。</p><p>B. 当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，另一个线程仍然可以访问该<code>object</code>中的非<code>synchronized(this)</code>同步代码块。</p><p>C. 当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，其他线程对<code>object</code>中所有其它<code>synchronized(this)</code>同步代码块的访问不会被阻塞。</p><p>D. 当一个线程访问<code>object</code>的一个<code>synchronized(this)</code>同步代码块时，它就获得了这个<code>object</code>的对象锁。结果，其它线程对该<code>object</code>对象所有同步代码块部分的访问都被暂时阻塞。</p></blockquote></li></ol><h2 id="第4章-volatile实现可见性"><a href="#第4章-volatile实现可见性" class="headerlink" title="第4章 volatile实现可见性"></a>第4章 <code>volatile</code>实现可见性</h2><blockquote><p>本章讲解volatile实现可见性的原理和方法，以及需要使用volatile时需要注意的事项，并通过具体程序进行分析。</p></blockquote><h3 id="4-1-volatile能够保证可见性"><a href="#4-1-volatile能够保证可见性" class="headerlink" title="4-1 volatile能够保证可见性"></a>4-1 <code>volatile</code>能够保证可见性</h3><ol><li><p><code>volatile</code>关键字：</p><ul><li>能够保证<code>volatile</code>变量的可见性。</li><li>不能保证<code>volatile</code>变量复合操作的原子性。</li></ul></li><li><p><code>volatile</code>如何实现内存可见性：</p><p>通过加入内存屏障和禁止重排序优化来实现的。</p></li><li><p>对<code>volatile</code>变量执行写操作时，会在写操作后加入一条<code>store</code>屏障指令。</p></li><li><p>对<code>volatile</code>变量执行读操作时，会在读操作前加入一条<code>load</code>屏障指令。</p><p> <code>Java</code>内存模型中一共定义了8条操作指令来完成主内存和工作内存的交互</p><p> <strong>★通俗地讲</strong>：<code>volatile</code>变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时候，不同的线程总能看到该变量的最新值</p></li><li><p>线程读/写<code>volatile</code>变量的过程：</p><ul><li>线程写<code>volatile</code>变量的过程：<ol><li>改变线程工作内存的中<code>volatile</code>变量副本的值。</li><li>将改变后的副本的值从工作内存刷新到主内存。</li></ol></li><li>线程读<code>volatile</code>变量的过程：<ol><li>从主内存中读取<code>volatile</code>变量的最新值到线程的工作内存中。</li><li>从工作内存中读取<code>volatile</code>变量的副本。</li></ol></li></ul></li><li><p><code>volatile</code>不能保证<code>volatile</code>变量复合操作的原子性</p><ol><li><p><code>number++;</code>的步骤：</p><ol><li>读取<code>number</code>的值</li><li>将<code>number</code>的值加1</li><li>写入最新的<code>number</code>的值<pre><code class="java">private int number = 0;number++;//不是原子操作</code></pre></li></ol></li><li><p>加入<code>synchronized</code>，变为原子操作 </p><pre><code class="java">synchronized(this){    number++;}</code></pre></li><li><p>变为<code>volatile</code>变量，无法保证原子性 </p><p><code>private volatile int number = 0;</code></p></li></ol></li></ol><h3 id="4-2-volatile不能保证原子性"><a href="#4-2-volatile不能保证原子性" class="headerlink" title="4-2 volatile不能保证原子性"></a>4-2 <code>volatile</code>不能保证原子性</h3><p>例：</p><blockquote><p><code>number = 5</code> </p></blockquote><ol><li><p>线程<code>A</code>读取<code>number</code>的值 A=5 B=N M=5</p></li><li><p>线程<code>B</code>读取<code>number</code>的值 A=5 B=5 M=5</p></li><li><p>线程<code>B</code>执行加1操作 A=5 B=6 M=5</p></li><li><p>线程<code>B</code>写入最新的<code>number</code>的值 A=5 B=6 M=6</p></li><li><p>线程<code>A</code>执行加1操作 A=6 B=6 M=6</p></li><li><p>线程<code>A</code>写入最新的<code>number</code>的值 A=6 B=6 M=6</p><p>两次<code>number++</code>只增加了1</p></li></ol><p>解决方案：</p><blockquote><p>保证<code>number</code>自增操作的原子性：</p></blockquote><ol><li><p>使用<code>synchronized</code>关键字</p><pre><code class="java"> synchronized (this) {     this.number++; }</code></pre></li><li><p>使用<code>ReentrantLock</code>(<code>java.util.concurrent.locks</code>包下)，最好使用<code>try-finally</code></p><pre><code class="java"> private Lock lock = new ReentrantLock(); lock.lock(); try {     this.number++; } finally {     lock.unlock(); }</code></pre></li><li><p>使用<code>AtomicInteger</code>(<code>java.util.concurrent.atomic</code>包下)</p><pre><code class="java"> private AtomicInteger num = new AtomicInteger(0); num.getAndAdd(1);</code></pre></li></ol><h3 id="4-5-volatile使用注意事项"><a href="#4-5-volatile使用注意事项" class="headerlink" title="4-5 volatile使用注意事项"></a>4-5 <code>volatile</code>使用注意事项</h3><p>要在多线程中安全的使用<code>volatile</code>变量，必须同时满足：</p><ol><li><p>对变量的写入操作不依赖其当前值</p><p>不满足：<code>number++</code>、<code>count=count*5</code>等<br>满足：<code>boolean</code>变量、记录温度变化的变量等</p></li><li><p>该变量没有包含在具有其他变量的不变式中</p><p>不满足：不变式<code>low&lt;up</code></p></li></ol><h3 id="4-6-synchronized与volatile比较"><a href="#4-6-synchronized与volatile比较" class="headerlink" title="4-6 synchronized与volatile比较"></a>4-6 <code>synchronized</code>与<code>volatile</code>比较</h3><ol><li><code>volatile</code>不需要加锁，比<code>synchronized</code>更轻量级，不会阻塞线程</li><li>从内存可见性角度讲：<code>volatile</code>读操作相当于加锁；<code>volatile</code>写操作相当于解锁</li><li><code>synchronized</code>既能保证可见性，又能保证原子性；而<code>volatile</code>只能保证可见性，无法保证原子性</li></ol><p>总而言之：<code>synchronized</code>稳定性高，效率低；<code>volatile</code>稳定性低，效率高。</p><h3 id="4-7-练习题"><a href="#4-7-练习题" class="headerlink" title="4-7 练习题"></a>4-7 练习题</h3><p>下列说法中错误的是：A</p><blockquote><p>A. <code>volatile</code>是保证被修饰变量的可见性，同时也保证原子操作<br>B. <code>Java</code>中没有提供检测与避免死锁的专门机制，但应用程序员可以采用某些策略防止死锁的发生<br>C. <code>JAVA</code>中对共享数据操作的并发控制是采用加锁技术<br>D. 共享数据的访问权限都必须定义为<code>private</code></p></blockquote><h2 id="第5章-课程总结"><a href="#第5章-课程总结" class="headerlink" title="第5章 课程总结"></a>第5章 课程总结</h2><blockquote><p>总结本门课程的学习内容</p></blockquote><p>总结：</p><ol><li>什么是内存可见性</li><li><code>Java</code>内存模型（<code>JMM</code>）</li><li>实现可见性的方式：<code>synchronized</code>和<code>volatile</code><ul><li><code>final</code>也可以保证内存的可见性</li></ul></li><li><code>synchronized</code>和<code>volatile</code>实现内存可见性的原理</li><li><code>synchronized</code>实现可见性<ul><li>指令重排序</li><li><code>as-if-serial</code>语义</li></ul></li><li><code>volatile</code>实现可见性<ul><li><code>volatile</code>能够保证可见性</li><li><code>volatile</code>不能保证原子性(<code>number++</code>)</li><li><code>volatile</code>使用注意事项</li></ul></li><li>synchronized和volatile比较<ul><li>volatile比synchronized更轻量级</li><li>synchronized比volatile使用更广泛</li></ul></li></ol><p>补充：  </p><ol><li><p>问：即使没有保证可见性的措施(如s<code>ynchronized</code>、<code>volatile</code>、<code>final</code>)，很多时候共享变量依然能够在主内存和工作内存见得到及时的更新？</p><p>答：一般只有在短时间内高并发的情况下才会出现变量得不到及时更新的情况，因为<code>CPU</code>在执行时会很快地刷新缓存，所以一般情况下很难看到这种问题。</p></li><li><p>对64位(<code>long</code>、<code>double</code>)变量的读写可能不是原子操作：</p><p><code>Java</code>内存模型允许<code>JVM</code>将没有被<code>volatile</code>修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行</p><p>导致问题：有可能会出现读取到“半个变量”的情况</p><p>解决方法：加<code>volatile</code>关键字</p><p><strong>注</strong>：目前几乎所有虚拟机已经把64位数据的读写做了原子操作，不需将(<code>long</code>、<code>double</code>)使用<code>volatile</code>修饰</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>312-细说多线程之Thread VS Runnable</title>
      <link href="/imooc/312-thread-runnable/"/>
      <url>/imooc/312-thread-runnable/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/312" target="_blank" rel="noopener">https://www.imooc.com/learn/312</a></p><p>简介：本课程将带领大家更加深入地学习Java多线程的机制，深入理解创建线程的两种方式Thread和Runnable之间的差异，掌握线程的生命周期和守护线程的概念，以及如何使用jstack生成线程快照。</p></blockquote><p>@[TOC]</p><h2 id="第1章-课前准备"><a href="#第1章-课前准备" class="headerlink" title="第1章 课前准备"></a>第1章 课前准备</h2><blockquote><p>了解学习本课程前的必备知识</p></blockquote><p><a href="https://www.imooc.com/learn/202" target="_blank" rel="noopener">《深入浅出Java多线程》</a></p><blockquote><p>比较Thread和Runnable这两种线程创建的方式，需要知道Thread和Runnable的基本创建方式。</p></blockquote><p>课程目标和学习内容</p><ul><li>线程创建的两种方式比较</li><li>线程的生命周期</li><li>线程的守护神：守护线程</li></ul><h2 id="第2章-Thread-VS-Runnable"><a href="#第2章-Thread-VS-Runnable" class="headerlink" title="第2章 Thread VS Runnable"></a>第2章 <code>Thread</code> VS <code>Runnable</code></h2><blockquote><p>本章首先回顾了线程创建的两种方式，而后通过一个程序案例，深入比较了这两种创建线程的方式。</p></blockquote><h3 id="2-1-回顾线程创建的两种方式"><a href="#2-1-回顾线程创建的两种方式" class="headerlink" title="2-1 回顾线程创建的两种方式"></a>2-1 回顾线程创建的两种方式</h3><ol><li><p>继承<code>Thread</code>类</p><pre><code class="java"> class MyThread extents Thread {     // ...     @Override     public void run() {         // ...     } } MyThread mt = new MyThread(); // 创建线程 mt.start(); // 启动线程</code></pre></li><li><p>实现<code>Runnable</code>接口</p><pre><code class="java"> class MyRunnable implements Runnable {     // ...     @Override     public void run() {         // ...     } } MyRunnable mr = new MyRunnable(); Thread td = new Thread(mr); // 创建线程 td.start(); // 启动线程</code></pre></li></ol><h3 id="2-2-应用Thread模拟卖票"><a href="#2-2-应用Thread模拟卖票" class="headerlink" title="2-2 应用Thread模拟卖票"></a>2-2 应用<code>Thread</code>模拟卖票</h3><p><code>Thread</code>与<code>Runnable</code>的区别：</p><ol><li><p><code>Runnable</code>方式可以避免<code>Thread</code>方式由于<code>Java</code>单继承特性带来的缺陷</p><p>单继承：Java语言中只能继承一个父类，而可以实现多个接口</p></li><li><p><code>Runnable</code>的实例对象可以被多个线程（<code>Thread</code>实例）共享，适合于多个线程处理<strong>同一资源</strong></p></li></ol><p>针对Thread和Runnable对于同一资源处理：</p><pre><code class="java">class MyThread extends Thread{}class MyRunnable implements Runnable{}public static void main(String[] args) {    // 注意：此时t1,t2,t3是堆内存中实例出的三个对象，对于它们所有属性也独立的    MyThread t1 = new MyThread();    MyThread t2 = new MyThread();    MyThread t3 = new MyThread();    // 注意：t1,t2,t3虽然是堆中的三个不同对象，但是此时的r是一个，所以三个线程引用r中的资源也是共有的    MyRunnable r = new MyRunnable();    Thread t1 = new Thread(r);    Thread t2 = new Thread(r);    Thread t3 = new Thread(r);}</code></pre><p>结论：Runnable可以实现资源共享，而Thread资源独立</p><p>注：</p><ul><li><code>a--</code>、<code>a++</code>、<code>++a</code>、<code>--a</code>、<code>a+=1</code>等为非原子操作（non-atomic operation），需要加锁</li></ul><h2 id="第3章-线程的生命周期和守护线程"><a href="#第3章-线程的生命周期和守护线程" class="headerlink" title="第3章 线程的生命周期和守护线程"></a>第3章 线程的生命周期和守护线程</h2><blockquote><p>本章归纳总结了线程的生命周期，讲解了守护线程，并演示了如何使用jstack生成线程快照</p></blockquote><h3 id="3-1-线程的生命周期"><a href="#3-1-线程的生命周期" class="headerlink" title="3-1 线程的生命周期"></a>3-1 线程的生命周期</h3><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8odd59oopj30zk0k0gmb.jpg" style="zoom:50%;" /><ol><li>创建：新建一个线程对象，如<code>Thread thd = new Thread()</code></li><li>就绪：创建了线程对象后，调用了线程的<code>start()</code>方法（注意：此时线程只是进入了线程队列，等待获取<code>CPU</code>服务，具备了运行的条件，但并不一定已经开始运行了）</li><li>运行：处于就绪状态的线程，一旦获取了<code>CPU</code>资源，便进入到运行状态，开始执行<code>run()</code>方法里面的逻辑</li><li>终止：线程的<code>run()</code>方法执行完毕，或者调用线程的<code>stop()</code>方法（该方法已经废弃），线程便进入终止状态</li><li>阻塞：一个正在执行的线程在某种情况下，由于某种原因而暂时让出了<code>CPU</code>资源，暂停了自己的执行，便进入了阻塞状态，如调用了<code>sleep()</code>、<code>wait()</code>、<code>yield()</code>等方法</li></ol><h3 id="3-2-守护线程理论知识"><a href="#3-2-守护线程理论知识" class="headerlink" title="3-2 守护线程理论知识"></a>3-2 守护线程理论知识</h3><p><code>Java</code>线程分两类：</p><ol><li><p>用户线程：运行在前台，执行具体任务</p><p>例如：程序的主线程，连接网络的子线程等</p></li><li><p>守护线程：运行在后台，为其他前台线程服务</p><p>特点：一旦所有用户线程都结束运行，守护线程会随<code>JVM</code>一起结束工作</p><p>应用：</p><ol><li>数据库连接池中的监测线程</li><li><code>JVM</code>虚拟机启动后的监测线程<ul><li>垃圾回收线程</li><li>监测内存使用的线程</li><li>监测程序锁持有的线程  </li></ul></li></ol></li></ol><p>如何设置守护线程：</p><ul><li>可以通过调用<code>Thread</code>类的<code>setDaemon(true)</code>方法来设置当前的线程为守护线程  </li></ul><p><strong>注意事项</strong>：</p><ul><li><code>setDaemon(true)</code>必须在<code>start()</code>方法之前调用，否则会抛出<code>IllegalThreadStateException</code>异常</li><li>在守护线程中产生的新线程也是守护线程</li><li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑</li></ul><h3 id="3-3-守护线程代码示例"><a href="#3-3-守护线程代码示例" class="headerlink" title="3-3 守护线程代码示例"></a>3-3 守护线程代码示例</h3><pre><code class="java">public static void main(String[] args) {    System.out.println(&quot;进入主线程&quot; + Thread.currentThread().getName());    DaemonThread daemonThread = new DaemonThread();    Thread thread = new Thread(daemonThread);    thread.setDaemon(true);//设置为守护线程    thread.start();    Scanner scanner = new Scanner(System.in);    scanner.next();    // 主线程为唯一用户线程    // thread为守护线程    // 主线程退出导致数据的不完整性    System.out.println(&quot;退出主线程&quot; + Thread.currentThread().getName());}</code></pre><p>thread线程运行完成后程序不会立刻终止，此时thread守护线程需等待main主用户线程scanner之后才会结束运行。</p><h3 id="3-4-使用jstack生成线程快照"><a href="#3-4-使用jstack生成线程快照" class="headerlink" title="3-4 使用jstack生成线程快照"></a>3-4 使用jstack生成线程快照</h3><p>位置：<code>jdk/bin/jstack.exe</code></p><table><thead><tr><th align="center">程序</th><th align="center">工具作用</th></tr></thead><tbody><tr><td align="center">jstack</td><td align="center">生成JVM线程快照</td></tr><tr><td align="center">jstat.exe</td><td align="center">监测虚拟机的运行状态</td></tr><tr><td align="center">jconsole.exe</td><td align="center">Java监视和管理控制台GUI</td></tr><tr><td align="center">jvisualvm.exe</td><td align="center">界面化工局</td></tr><tr><td align="center">jmap.exe</td><td align="center">生成堆快照</td></tr><tr><td align="center">虚拟机的运行状态：内存的使用情况、类加载情况、锁持有的情况</td><td align="center"></td></tr></tbody></table><p><code>jstack</code></p><ul><li>作用：生成<code>JVM</code>当前时刻线程的快照（<code>threaddump</code>，即当前进程中所有线程的信息）</li><li>目的：帮助定位程序问题出现的原因(查找一些程序问题)，如长时间停顿、<code>CPU</code>占用率过高、死锁、阻塞等；看出哪些是守护线程，哪些是用户线程</li><li>使用：<code>jstack -l &lt;pid&gt;</code>—-其中<code>&lt;pid&gt;</code>可以通过任务栏管理器查看<ol><li>可以通过线程名后是否有<code>daemon</code>判断是否为守护线程，有-是、无-否</li><li>查看线程的状态<code>java.lang.Thread.State</code>帮助定位程序出现的一系列问题(死锁、阻塞)</li><li><code>tid</code>、<code>nid</code>可以帮助查找<code>CPU</code>占有率很高的线程</li><li><code>prio</code>代表优先级</li></ol></li></ul><p>线程状态：  </p><ul><li><code>New</code>尚未启动的线程（创建）；</li><li><code>Runnable</code>在<code>Java</code>虚拟机中执行的线程，即将或正在运行的线程（就绪，运行）；</li><li><code>Terminated</code>已退出的线程（终止）；</li><li><code>Blocked</code>、<code>Waiting</code>、<code>Timed_Waiting</code>对应阻塞状态。<ol><li><code>Blocked</code>：等待监视器锁定的线程，如被<code>synchronized</code>阻塞的线程。</li><li><code>Waiting</code>：无限期等待另一个线程执行特定操作的线程，调用<code>join</code>方法时。</li><li><code>Timed_Waiting</code>：等待另一个线程在指定等待时间内执行操作的线程，如<code>sleep</code>方法。</li></ol></li></ul><h2 id="第4章-课程总结"><a href="#第4章-课程总结" class="headerlink" title="第4章 课程总结"></a>第4章 课程总结</h2><blockquote><p>课程总结</p></blockquote><p>建议：使用实现<code>Runnable</code>接口的方式创建线程</p><p>补充：</p><ol><li><p>程序中的同一资源指的是同一个<code>Runnable</code>对象</p><p>如果把其他类的对象也作为共享资源，则<code>Thread</code>和<code>Runnable</code>都是可以用来处理同一资源</p></li><li><p>安全的卖票程序中需要加入同步（<code>synchronized</code>）</p></li></ol><p>Thread vs Runnable，线程的生命周期，守护线程，jstack生成线程快照</p>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202-深入浅出Java多线程</title>
      <link href="/imooc/202-multi-thread/"/>
      <url>/imooc/202-multi-thread/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.imooc.com/learn/202" target="_blank" rel="noopener">https://www.imooc.com/learn/202</a></p><p>简介：多线程是日常开发中的常用知识，也是难用知识。通过本视频，你可以了解Java中多线程相关的基本概念，如何创建，启动和停止线程？什么是正确的多线程，怎样编写多线程程序。在掌握基础之后，将为你展望进阶路线，为进一步的学习提供方向。</p></blockquote><p>@[TOC]</p><h2 id="第1章-多线程背景知识介绍"><a href="#第1章-多线程背景知识介绍" class="headerlink" title="第1章 多线程背景知识介绍"></a>第1章 多线程背景知识介绍</h2><blockquote><p>本章将介绍与多线程编程相关的背景概念</p></blockquote><p>进程  </p><ol><li><p>进程是程序（任务）的执行过程，是动态性的。</p><p>放在磁盘文件中的文件并不是进程，只有在运行状态的才可称之为进程。</p></li><li><p>持有资源（共享内存，共享文件）和线程。进程是资源和线程的载体</p></li></ol><p>线程</p><ol><li>线程是系统中最小的执行单元</li><li>同一进程中有多个线程</li><li>线程共享进程的资源</li></ol><p>线程的交互：多个线程需要正确的通信才能进行工作。</p><blockquote><p>交互方式有互斥和同步两种。</p></blockquote><ul><li><p>互斥是当一个线程正在运行时其他的线程只能等待，只有在当前线程完成后才可以运行；</p></li><li><p>同步是两个或多个线程同时进行运行。</p></li></ul><h2 id="第2章-Java-线程初体验"><a href="#第2章-Java-线程初体验" class="headerlink" title="第2章 Java 线程初体验"></a>第2章 Java 线程初体验</h2><blockquote><p>Java 语言层面对线程的支持，如何创建，启动和停止线程。如何使用常用的线程方法。用隋唐演义理解线程的代码</p></blockquote><p>Java对线程的支持体现在<code>java.lang</code>的包下的class类<code>Thread</code>和interface接口<code>Runnable</code></p><p>共通的方法是<code>public void run()</code>，为我们提供线程实际工作执行的代码</p><p><strong>Thread常用方法：</strong></p><ol><li><p>线程的创建  </p><pre><code class="java"> Thread(); Thread(String name); Thread(Runnable target); Thread(Runnable target, String name);</code></pre></li><li><p>线程的方法  </p><pre><code class="java"> void start(); // 启动线程。Java虚拟机调用该线程的run()方法。 static void sleep(long millis); // 线程休眠(暂停执行) 。millis休眠的时间，单位是毫秒，可以精确到纳秒。此操作受到系统计时器和调度程序精度和准确性的影响。 static void sleep(long millis, int nanos); void join(); // 使其他线程等待当前线程终止。指明其他线程必须等待当前结束后才能运行 void join(long millis); // 参数表示其他线程最长等待的时间 void join(long millis,int nanos); static void yield(); // 当前运行线程释放处理器资源并且重新去竞争处理器资源</code></pre></li><li><p>获取线程引用  </p><pre><code class="java"> static Thread currentThread(); // 返回当前运行的线程引用（静态方法，返回Thread类型）</code></pre></li><li><p>线程的信息<br> <code>.getName()</code>：返回线程的名字</p><p> <code>.setName(String Name)</code>：改变线程的名字  </p></li></ol><p><strong><code>Thread</code>类 和 <code>Runnable</code>接口的区别与联系：</strong>  </p><ol><li><code>Runnable</code>只是一个接口，它里面只有一个<code>run()</code>方法，没有<code>start()</code>方法， 所以即使实现了<code>Runnable</code>接口，那也无法启动线程，必须依托其他类。  </li><li><code>Thread</code>类，有一个构造方法，参数是<code>Runnable</code>对象，也就是说可以通过<code>Thread</code>类来启动<code>Runnable</code>实现的多线程。  </li></ol><p>注：</p><ul><li><p>在同一时间内同一处理器或同一个核只能运行一条线程，当一条线程休眠之后，另一条线程才获得了我们处理器的时间</p></li><li><p>一个<code>.java</code>文件中可以有多个类，但是只能有一个<code>public</code>修饰的类</p></li><li><p><code>Runnable</code>接口之中没有<code>getName()</code>方法，我们可以使用<code>Thread</code>的静态方法<code>currentThreat().getName();</code>获取该对象的名字。</p></li><li><p>若实现<code>Runnable</code>接口通过<code>Thread.currentThread().getName()</code>方法获取当前线程名称，继承<code>Thread</code>类则<code>getName()</code>方法获取当前线程。</p></li></ul><h3 id="实例：隋唐演义"><a href="#实例：隋唐演义" class="headerlink" title="实例：隋唐演义"></a>实例：隋唐演义</h3><blockquote><p>历史是人民群众创建的，英雄可以推动历史的发展  </p></blockquote><p><strong>1. 演员简介：</strong></p><ul><li><p>军队 <code>ArmyRunnable</code></p></li><li><p>英雄 <code>KeyPersonThread</code></p></li><li><p>舞台 <code>Stage</code>  </p><pre><code class="java">// 隋唐演义大戏舞台public class Stage extends Thread {    @Override    public void run() {        ArmyRunnable armyTaskOfSuiDynasty = new ArmyRunnable();        ArmyRunnable armyTaskOfArmyOfRevolt = new ArmyRunnable();        //使用 Runnable 接口创建线程        Thread armyOfSuiDynasty = new Thread(armyTaskOfSuiDynasty, &quot;隋军&quot;);        Thread armyOfRevolt = new Thread(armyTaskOfarmyOfRevolt, &quot;农民起义军&quot;);    }}</code></pre></li></ul><p><strong>2. 军队：</strong>  </p><ol><li><p>加入<code>join()</code>是为了让舞台线程最后停止。</p><p> 如果不加有可能舞台线程结束，军队线程还未停止，就好比导演喊停，演员还在演！</p><p> 可以在<code>join()</code>后面加入测试语句<code>System.out.println(&quot;舞台结束!&quot;);</code>，然后去掉或者保留<code>join</code>观察效果。</p></li><li><p><code>volatile</code>关键字保证了线程可以正确地读取其他线程写入的值。</p><p> 如果不写成<code>volatile</code>，由于可见性的问题，当前线程有可能读取不到这个值 //可见性JMM（JAVA内存模型）happens-before原则、可见性原则</p><p> 用<code>volatile</code>修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的值</p></li><li><p><code>Thread.yield();</code>当前线程让出处理器时间，公平竞争  </p></li></ol><p><strong>3. 关键先生：</strong>  </p><ol><li><code>start()</code>开始线程。  </li><li><code>sleep()</code>线程休眠。  </li><li><code>yield()</code>让出当前线程的执行权限，随机选择线程执行。  </li><li><code>join()</code>优先执行该线程，其他线程(包括主线程main)都暂停。  </li></ol><h2 id="第3章-Java-线程的正确停止"><a href="#第3章-Java-线程的正确停止" class="headerlink" title="第3章 Java 线程的正确停止"></a>第3章 Java 线程的正确停止</h2><blockquote><p>本章讨论如何正确的停止一个线程，既要线程停得了，还得线程停得好。</p></blockquote><ol><li><p>错误的停止线程方法：  </p><ol><li><p><code>stop()</code>方法会导致线程戛然而止，我们不清楚线程完成了什么，没完成什么，也没有时间来完成对应的线程运行的清理工作。</p></li><li><p><code>interrupt()</code>方法只能设置<code>interrupt</code>标志位（且在线程阻塞情况下，标志位会被清除，更无法设置中断标志位），无法停止线程</p><blockquote><ol><li><code>Interrupted</code> 相当于 旗标 (isInterrupted ==&gt;true false) <ol start="2"><li>线程中使用<code>sleep</code>等方法造成线程堵塞时， 标志位被清除，<code>Interrupted</code>方式无效同时抛出<code>InterruptedException</code>（中断异常）</li><li><code>interrupt</code>方法是用来唤醒被阻塞的线程的。如果线程使用了<code>wait</code>, <code>sleep</code>, <code>join</code>方法，那么线程就会进入阻塞状态，使用<code>interrupt</code>方法会终止这种状态，此时线程的<code>sleep</code>等方法下面的<code>catch</code>语句就会接收到这个打断，从而启动线程，继续做要做的事情。如果线程在阻塞之前使用<code>interrupt</code>方法，那么在阻塞的时候，会抛出异常，并把中断标志位设置成<code>false</code>。</li></ol></li></ol></blockquote></li></ol></li><li><p>正确的停止线程方法：</p><p> 在线程执行中设置状态标识，通过控制此状态标识，来控制线程的正常完整的结束。</p><p> 另外，<code>volatile</code>关键字是保证所有其他线程里的变量的赋值都能同步到当前内存里变量的值。</p><p> 这样做的好处是：线程有机会使得一个业务步骤被完整地执行，在执行完业务步骤后有充分的时间去做代码的清理工作，使得线程代码在实际中更安全</p></li></ol><h2 id="第4章-线程交互"><a href="#第4章-线程交互" class="headerlink" title="第4章 线程交互"></a>第4章 线程交互</h2><blockquote><p>争用条件，线程的交互，及死锁的成因及预防</p></blockquote><p><strong>争用条件：</strong></p><ol><li>定义：当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（corrupted)，这种现象称为争用条件</li><li>原因：每个线程在操作数据时，会先将数据初值读【取到自己获得的内存中】，然后在内存中进行运算后，重新赋值到数据。 </li><li>争用条件：线程1在还【未重新将值赋回去时】，线程1阻塞，线程2开始访问该数据，然后进行了修改，之后被阻塞的线程1再获得资源，而将之前计算的值覆盖掉线程2所修改的值，就出现了数据丢失情况</li></ol><p><strong>互斥与同步：</strong></p><ol><li>互斥<br>同一时间，只能有一个线程访问关键数据或临界区</li><li>同步<br>是一种通信机制，一个线程操作完成后，以某种方式通知其他线程</li><li>实现方法<blockquote><ol><li>【互斥】构建锁对象<code>private final Object lockObj = new Object();</code></li><li>通过<code>synchronized(lockObj){  互斥的代码块  }</code>加锁操作。加锁操作会开销系统资源，降低效率</li><li>在某线程的条件不满足任务时，使用<code>lockObj.wait();</code>对线程进行阻挡，防止其继续竞争<code>CPU</code>资源，滞留在<code>wait set</code>中，等待唤醒，【唤醒后继续完成业务】</li><li>【同步】在某一代码正确执行完业务后，通过<code>lockObj.notifyAll()</code>唤醒所有在<code>lockObj</code>对象等待的线程</li></ol></blockquote></li></ol><ul><li><p>互斥：关键数据在一个时间被一个线程使用。</p><p>互斥的实现：<code>private final Object lockObj = new Object()</code>、<code>synchronized(intrinsic lock) {}</code>  </p></li><li><p>同步：两个线程之间的一种交互的操作（一个线程发出消息另外一个线程响应）</p><p>同步的实现：<code>wait();</code>、<code>notify();</code>、<code>notifyAll();</code>，都是属于Java中的<code>Object</code>对象的成员函数</p></li></ul><p><strong>注：</strong> 调用<code>wait();</code>和<code>notifyAll();</code>方法使线程进入等待或者唤醒不是在同一个线程的同一次操作中执行的，当操作结束，唤醒了所有的等待线程之后，线程又将有着公平的机会竞争CPU资源。  </p><p><code>wait set</code>类似于线程的休息室，访问共享数据的代码称为临界区<code>critical section</code>。<br>一个线程获取锁，然后进入临界区,发现某些条件不满足，然后调用锁对象上的<code>wait()</code>方法，然后线程释放掉锁资源，进入锁对象上的<code>wait set</code>。其他线程可以获取锁资源，然后执行，完了以后调用<code>notify()/notifyAll()</code>，通知锁对象上的等待线程。  </p><h2 id="第5章-进阶展望"><a href="#第5章-进阶展望" class="headerlink" title="第5章 进阶展望"></a>第5章 进阶展望</h2><blockquote><p>简单介绍 Java 并发相关的类，及常用的多线程编程模型</p></blockquote><p>要点回顾：</p><ol><li>线程如何创建以及线程的基本概念</li><li>可见性以及<code>volatile</code>关键字</li><li>争用条件</li><li>如何通过<code>synchronized</code>让线程的互斥</li><li>如何通过<code>wait/notify</code>、<code>notifyAll</code>让线程同步</li></ol><p><strong>展望：</strong></p><ol><li>Java Memory Mode:  <ul><li>JMM描述了java线程如何通过内存进行交互</li><li>了解happens-before</li><li>synchronized,volatile &amp; final</li></ul></li><li>Locks % Condition：<ul><li>锁机制和等待条件的高层实现</li><li>java.util.concurrent.locks</li></ul></li><li>线程安全性<ul><li>原子性与可见性</li><li>java.util.concurrent.atomic</li><li>synchronized &amp; volatile</li><li>DeadLocks(死锁)</li></ul></li><li>多线程常用的交互模型<ul><li>Producer-Consumer模型</li><li>Read-Write Lock模型</li><li>Future模型</li><li>Worker Thread模型</li><li>了解哪些类实现了这些模型可以用来直接使用</li></ul></li><li>Java5中并发编程工具：<ul><li>java.util.concurrent</li><li>线程池ExecutorService</li><li>Callable &amp; Future</li><li>BlockingQueue</li></ul></li><li>推荐书本<ul><li>CoreJava</li><li>Java Concurrency In Practice</li></ul></li></ol><p><strong>Java多线程特性：</strong></p><ol><li><p>原子性：<code>Java</code>内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过<code>synchronized</code>和<code>Lock</code>来实现。由于<code>synchronized</code>和<code>Lock</code>能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></li><li><p>可见性：对于可见性，<code>Java</code>提供了<code>volatile</code>关键字来保证可见性。当一个共享变量被<code>volatile</code>修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>另外，通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，<code>synchronized</code>和<code>Lock</code>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></li><li><p>有序性：在<code>Java</code>内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p> 在<code>Java</code>里面，可以通过<code>volatile</code>关键字来保证一定的“有序性”。另外可以通过<code>synchronized</code>和<code>Lock</code>来保证有序性，很显然，<code>synchronized</code>和<code>Lock</code>保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p> 另外，<code>Java</code>内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为<code>happens-before</code>原则。如果两个操作的执行次序无法从<code>happens-before</code>原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 慕课网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
